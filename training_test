package com . tulusha . timetracker ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . content . Context ;
import android . content . Intent ;
import android . content . pm . PackageInfo ;
import android . content . pm . PackageManager ;
import android . os . Bundle ;
import android . text . SpannableString ;
import android . text . util . Linkify ;
import android . view . View ;
import android . widget . TextView ;
import com . tulusha . timetracker . widgets . ActionBar ;
import com . tulusha . timetracker . widgets . ScrollingTextView ;
public class HomeActivity extends Activity {
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . activity_home ) ;
final ActionBar actionBar = ( ActionBar ) findViewById ( R . id . actionbar ) ;
actionBar . setTitle ( " ) ;
}
public void <unk> ( View v )
{
startActivity ( new Intent ( this , TrackerActivity . class ) ) ;
}
public void <unk> ( View v )
{
AlertDialog builder ;
String aboutTitle = " ;
final TextView message = new TextView ( this ) ;
message . setText ( " ) ;
message . setPadding ( <num> , <num> , <num> , <num> ) ;
builder = new AlertDialog . Builder ( this ) . setTitle ( aboutTitle ) . setCancelable ( true ) . setIcon ( R . drawable . icon ) . setPositiveButton (
this . getString ( android . R . string . ok ) , null ) . setView ( message ) . create ( ) ;
builder . show ( ) ;
}
public void <unk> ( View v )
{
AlertDialog builder ;
String aboutTitle = " ;
final TextView message = new TextView ( this ) ;
message . setText ( " ) ;
message . setPadding ( <num> , <num> , <num> , <num> ) ;
builder = new AlertDialog . Builder ( this ) . setTitle ( aboutTitle ) . setCancelable ( true ) . setIcon ( R . drawable . icon ) . setPositiveButton (
this . getString ( android . R . string . ok ) , null ) . setView ( message ) . create ( ) ;
builder . show ( ) ;
}
public void <unk> ( View v )
{
AlertDialog builder ;
try {
builder = AboutDialogBuilder . create ( this ) ;
builder . show ( ) ;
} catch ( PackageManager . NameNotFoundException e ) {
e . printStackTrace ( ) ;
}
}
public static Intent createIntent ( Context context )
{
Intent i = new Intent ( context , HomeActivity . class ) ;
i . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
return i ;
}
public static class AboutDialogBuilder {
public static AlertDialog create ( Context context ) throws PackageManager . NameNotFoundException {
PackageInfo pInfo = context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , PackageManager . GET_META_DATA ) ;
String versionInfo = pInfo . versionName ;
String aboutTitle = context . getString ( R . string . about , context . getString ( R . string . app_name ) ) ;
String versionString = context . getString ( R . string . version , versionInfo ) ;
String aboutText = context . getString ( R . string . about_text ) ;
final ScrollingTextView message = new ScrollingTextView ( context ) ;
final SpannableString s = new SpannableString ( aboutText ) ;
message . setPadding ( <num> , <num> , <num> , <num> ) ;
message . setText ( versionString + " + s ) ;
Linkify . addLinks ( message , Linkify . ALL ) ;
return new AlertDialog . Builder ( context ) . setTitle ( aboutTitle ) . setCancelable ( true ) . setIcon ( R . drawable . icon ) . setPositiveButton (
context . getString ( android . R . string . ok ) , null ) . setView ( message ) . create ( ) ;
}
}
package com . tulusha . timetracker ;
import android . app . Activity ;
import android . app . Notification ;
import android . app . NotificationManager ;
import android . app . PendingIntent ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . os . Bundle ;
import android . preference . PreferenceManager ;
import android . view . Menu ;
import android . view . MenuItem ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . view . animation . Animation ;
import android . view . animation . AnimationUtils ;
import android . widget . Button ;
import android . widget . TextView ;
import com . tulusha . timetracker . widgets . ActionBar ;
import com . tulusha . timetracker . widgets . ActionBar . Action ;
import java . util . Timer ;
import java . util . TimerTask ;
public class TrackerActivity extends Activity
{
final static String WORKING_STATE_KEY = " ;
final static String RESTING_STATE_KEY = " ;
final static String RESTING_TIME_KEY = " ;
final static String WORKING_TIME_KEY = " ;
static final String LAST_TIME_KEY = " ;
static final int NOTIFICATION_KEY = <num> ;
Button workButton ;
Button restButton ;
Animation workMagnify ;
Animation workShrink ;
Animation restMagnify ;
Animation restShrink ;
TextView restTime ;
TextView workTime ;
Boolean resting ;
Boolean working ;
Timer timer ;
TimerTask counter ;
long workingTime ;
long restingTime ;
long lastTime ;
SharedPreferences . Editor statistic_editor ;
OnClickListener onRestPressed = new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
if ( ! resting )
{
restTime . startAnimation ( restMagnify ) ;
resting = true ;
}
else
{
restTime . startAnimation ( restShrink ) ;
resting = false ;
}
if ( working )
{
workTime . startAnimation ( workShrink ) ;
working = false ;
}
workButton . setSelected ( working ) ;
restButton . setSelected ( resting ) ;
saveTimersState ( ) ;
}
} ;
OnClickListener onWorkPressed = new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
if ( ! working )
{
workTime . startAnimation ( workMagnify ) ;
working = true ;
}
else
{
workTime . startAnimation ( workShrink ) ;
working = false ;
}
if ( resting )
{
restTime . startAnimation ( restShrink ) ;
resting = false ;
}
workButton . setSelected ( working ) ;
restButton . setSelected ( resting ) ;
saveTimersState ( ) ;
}
} ;
@Override
public void onCreate ( Bundle savedInstanceState )
{
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . activity_tracker ) ;
statistic_editor = PreferenceManager . getDefaultSharedPreferences ( this ) . edit ( ) ;
NotificationManager manager = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ;
manager . cancel ( NOTIFICATION_KEY ) ;
SharedPreferences saved_statistic = PreferenceManager . getDefaultSharedPreferences ( this ) ;
resting = saved_statistic . getBoolean ( RESTING_STATE_KEY , false ) ;
restingTime = saved_statistic . getLong ( RESTING_TIME_KEY , <num> ) ;
working = saved_statistic . getBoolean ( WORKING_STATE_KEY , false ) ;
workingTime = saved_statistic . getLong ( WORKING_TIME_KEY , <num> ) ;
lastTime = ( System . currentTimeMillis ( )  saved_statistic . getLong ( LAST_TIME_KEY , System . currentTimeMillis ( ) ) ) / <num> ;
workButton = ( Button ) findViewById ( R . id . work ) ;
workButton . setOnClickListener ( onWorkPressed ) ;
restButton = ( Button ) findViewById ( R . id . rest ) ;
restButton . setOnClickListener ( onRestPressed ) ;
restTime = ( TextView ) findViewById ( R . id . rest_time ) ;
workTime = ( TextView ) findViewById ( R . id . work_time ) ;
restMagnify = AnimationUtils . loadAnimation ( this , R . anim . magnify_rest ) ;
restShrink = AnimationUtils . loadAnimation ( this , R . anim . shrink_rest ) ;
workMagnify = AnimationUtils . loadAnimation ( this , R . anim . magnify_work ) ;
workShrink = AnimationUtils . loadAnimation ( this , R . anim . shrink_work ) ;
counter = new TimerTask ( ) {
@Override
public void run ( ) {
if ( working )
{
workingTime ++ ;
updateWorkTimer ( ) ;
}
else if ( resting )
{
restingTime ++ ;
updateRestTimer ( ) ;
}
}
} ;
timer = new Timer ( ) ;
timer . schedule ( counter , <num> , <num> ) ;
if ( resting )
{
restTime . startAnimation ( restMagnify ) ;
restingTime += lastTime ;
}
else if ( working )
{
workTime . startAnimation ( workMagnify ) ;
workingTime += lastTime ;
}
restTime . setText ( getStringTimeFromSeconds ( restingTime ) ) ;
workTime . setText ( getStringTimeFromSeconds ( workingTime ) ) ;
final ActionBar actionBar = ( ActionBar ) findViewById ( R . id . actionbar ) ;
actionBar . setTitle ( " ) ;
actionBar . addAction ( new Action ( )
{
@Override
public void performAction ( View view ) {
startActivity ( createShareIntent ( ) ) ;
}
@Override
public int getDrawable ( ) {
return R . drawable . ic_title_share_default ;
}
} ) ;
actionBar . setHomeAction ( new ActionBar . IntentAction ( this , HomeActivity . createIntent ( this ) , R . drawable . ic_title_home_default ) ) ;
actionBar . setDisplayHomeAsUpEnabled ( true ) ;
}
@Override
protected void onStop ( ) {
super . onStop ( ) ;
saveTimersState ( ) ;
NotificationManager manager = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ;
Notification notification = null ;
PendingIntent intent = PendingIntent . getActivity ( this , <num> , new Intent ( this , TrackerActivity . class ) , PendingIntent . FLAG_UPDATE_CURRENT ) ;
if ( working )
{
notification = new Notification ( android . R . drawable . ic_menu_info_details , getResources ( ) . getString ( R . string . notification_work ) , System . currentTimeMillis ( ) ) ;
notification . setLatestEventInfo ( this , getResources ( ) . getString ( R . string . notification_work ) , getResources ( ) . getString ( R . string . show_app ) , intent ) ;
}
else if ( resting )
{
notification = new Notification ( android . R . drawable . ic_menu_info_details , getResources ( ) . getString ( R . string . notification_rest ) , System . currentTimeMillis ( ) ) ;
notification . setLatestEventInfo ( this , getResources ( ) . getString ( R . string . notification_rest ) , getResources ( ) . getString ( R . string . show_app ) , intent ) ;
}
if ( notification != null )
{
notification . flags = Notification . FLAG_AUTO_CANCEL | Notification . FLAG_ONGOING_EVENT ;
manager . notify ( NOTIFICATION_KEY , notification ) ;
}
}
@Override
protected void onResume ( ) {
super . onResume ( ) ;
NotificationManager manager = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ;
manager . cancel ( NOTIFICATION_KEY ) ;
}
private void saveTimersState ( ) {
statistic_editor . putLong ( LAST_TIME_KEY , System . currentTimeMillis ( ) ) ;
statistic_editor . putBoolean ( RESTING_STATE_KEY , resting ) ;
statistic_editor . putBoolean ( WORKING_STATE_KEY , working ) ;
statistic_editor . putLong ( RESTING_TIME_KEY , restingTime ) ;
statistic_editor . putLong ( WORKING_TIME_KEY , workingTime ) ;
statistic_editor . commit ( ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
MenuItem item = menu . add ( R . string . clear_timers ) ;
item . setIcon ( android . R . drawable . ic_menu_delete ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
@Override
public boolean onMenuItemSelected ( int featureId , MenuItem item ) {
lastTime = <num> ;
if ( working )
workTime . startAnimation ( workShrink ) ;
working = false ;
workingTime = <num> ;
workTime . setText ( " ) ;
workButton . setSelected ( resting ) ;
if ( resting )
restTime . startAnimation ( restShrink ) ;
resting = false ;
restingTime = <num> ;
restTime . setText ( " ) ;
restButton . setSelected ( resting ) ;
return super . onMenuItemSelected ( featureId , item ) ;
}
private void updateRestTimer ( )
{
final String timeString = getStringTimeFromSeconds ( restingTime ) ;
runOnUiThread ( new Runnable ( ) {
@Override
public void run ( ) {
restTime . setText ( timeString ) ;
}
} ) ;
}
private void updateWorkTimer ( )
{
final String timeString = getStringTimeFromSeconds ( workingTime ) ;
runOnUiThread ( new Runnable ( ) {
@Override
public void run ( ) {
workTime . setText ( timeString ) ;
}
} ) ;
}
private String getStringTimeFromSeconds ( long secondsTime )
{
String result = " ;
int hours = ( int ) ( secondsTime / <num> ) ;
if ( hours < <num> )
{
result += " + String . valueOf ( hours ) + " ;
}
else
{
result += String . valueOf ( hours ) + " ;
}
short minutes = ( short ) ( ( secondsTime  ( hours * <num> ) ) / <num> ) ;
if ( minutes < <num> )
{
result += " + String . valueOf ( minutes ) + " ;
}
else
{
result += String . valueOf ( minutes ) + " ;
}
short seconds = ( short ) ( secondsTime  ( hours * <num> )  ( minutes * <num> ) ) ;
if ( seconds < <num> )
{
result += " + String . valueOf ( seconds ) ;
}
else
{
result += String . valueOf ( seconds ) ;
}
return result ;
}
@Override
protected void onSaveInstanceState ( Bundle outState ) {
super . onSaveInstanceState ( outState ) ;
saveTimersState ( ) ;
}
@Override
protected void onRestoreInstanceState ( Bundle savedInstanceState ) {
super . onRestoreInstanceState ( savedInstanceState ) ;
SharedPreferences saved_statistic = PreferenceManager . getDefaultSharedPreferences ( this ) ;
resting = saved_statistic . getBoolean ( RESTING_STATE_KEY , false ) ;
working = saved_statistic . getBoolean ( WORKING_STATE_KEY , false ) ;
restingTime = saved_statistic . getLong ( RESTING_TIME_KEY , <num> ) ;
workingTime = saved_statistic . getLong ( WORKING_TIME_KEY , <num> ) ;
if ( resting )
{
long duration = restMagnify . getDuration ( ) ;
restMagnify . setDuration ( <num> ) ;
restTime . startAnimation ( restMagnify ) ;
restMagnify . setDuration ( duration ) ;
}
else if ( working )
{
long duration = workMagnify . getDuration ( ) ;
workMagnify . setDuration ( <num> ) ;
workTime . startAnimation ( workMagnify ) ;
workMagnify . setDuration ( duration ) ;
}
workButton . setSelected ( working ) ;
restButton . setSelected ( resting ) ;
}
private Intent createShareIntent ( ) {
final Intent intent = new Intent ( Intent . ACTION_SEND ) ;
intent . setType ( " ) ;
if ( working )
{
intent . putExtra ( Intent . EXTRA_TEXT , " ) ;
}
else if ( resting )
{
intent . putExtra ( Intent . EXTRA_TEXT , " ) ;
}
else
{
intent . putExtra ( Intent . EXTRA_TEXT , " ) ;
}
return Intent . createChooser ( intent , " ) ;
}
}
package com . tulusha . timetracker . widgets ;
import java . util . LinkedList ;
import com . tulusha . timetracker . R ;
import android . content . ActivityNotFoundException ;
import android . content . Context ;
import android . content . Intent ;
import android . content . res . TypedArray ;
import android . util . AttributeSet ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . ImageButton ;
import android . widget . ImageView ;
import android . widget . LinearLayout ;
import android . widget . ProgressBar ;
import android . widget . RelativeLayout ;
import android . widget . TextView ;
import android . widget . Toast ;
public class ActionBar extends RelativeLayout implements OnClickListener {
private LayoutInflater mInflater ;
private RelativeLayout mBarView ;
private ImageView mLogoView ;
private View mBackIndicator ;
private TextView mTitleView ;
private LinearLayout mActionsView ;
private ImageButton mHomeBtn ;
private RelativeLayout mHomeLayout ;
private ProgressBar mProgress ;
public ActionBar ( Context context , AttributeSet attrs ) {
super ( context , attrs ) ;
mInflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ;
mBarView = ( RelativeLayout ) mInflater . inflate ( R . layout . actionbar , null ) ;
addView ( mBarView ) ;
mLogoView = ( ImageView ) mBarView . findViewById ( R . id . actionbar_home_logo ) ;
mHomeLayout = ( RelativeLayout ) mBarView . findViewById ( R . id . actionbar_home_bg ) ;
mHomeBtn = ( ImageButton ) mBarView . findViewById ( R . id . actionbar_home_btn ) ;
mBackIndicator = mBarView . findViewById ( R . id . actionbar_home_is_back ) ;
mTitleView = ( TextView ) mBarView . findViewById ( R . id . actionbar_title ) ;
mActionsView = ( LinearLayout ) mBarView . findViewById ( R . id . actionbar_actions ) ;
mProgress = ( ProgressBar ) mBarView . findViewById ( R . id . actionbar_progress ) ;
TypedArray a = context . obtainStyledAttributes ( attrs ,
R . styleable . ActionBar ) ;
CharSequence title = a . getString ( R . styleable . ActionBar_title ) ;
if ( title != null ) {
setTitle ( title ) ;
}
a . recycle ( ) ;
}
public void setHomeAction ( Action action ) {
mHomeBtn . setOnClickListener ( this ) ;
mHomeBtn . setTag ( action ) ;
mHomeBtn . setImageResource ( action . getDrawable ( ) ) ;
mHomeLayout . setVisibility ( View . VISIBLE ) ;
}
public void <unk> ( ) {
mHomeLayout . setVisibility ( View . GONE ) ;
}
public void setHomeLogo ( int resId ) {
mLogoView . setImageResource ( resId ) ;
mLogoView . setVisibility ( View . VISIBLE ) ;
mHomeLayout . setVisibility ( View . GONE ) ;
}
public void setDisplayHomeAsUpEnabled ( boolean show ) {
mBackIndicator . setVisibility ( show ? View . VISIBLE : View . GONE ) ;
}
public void setTitle ( CharSequence title ) {
mTitleView . setText ( title ) ;
}
public void setTitle ( int resid ) {
mTitleView . setText ( resid ) ;
}
public void setProgressBarVisibility ( int visibility ) {
mProgress . setVisibility ( visibility ) ;
}
public int <unk> ( ) {
return mProgress . getVisibility ( ) ;
}
public void <unk> ( OnClickListener listener ) {
mTitleView . setOnClickListener ( listener ) ;
}
@Override
public void onClick ( View view ) {
final Object tag = view . getTag ( ) ;
if ( tag instanceof Action ) {
final Action action = ( Action ) tag ;
action . performAction ( view ) ;
}
}
public void addActions ( ActionList actionList ) {
int actions = actionList . size ( ) ;
for ( int i = <num> ; i < actions ; i ++ ) {
addAction ( actionList . get ( i ) ) ;
}
}
public void addAction ( Action action ) {
final int index = mActionsView . getChildCount ( ) ;
addAction ( action , index ) ;
}
public void addAction ( Action action , int index ) {
mActionsView . addView ( inflateAction ( action ) , index ) ;
}
public void <unk> ( ) {
mActionsView . removeAllViews ( ) ;
}
public void <unk> ( int index ) {
mActionsView . removeViewAt ( index ) ;
}
public void <unk> ( Action action ) {
int childCount = mActionsView . getChildCount ( ) ;
for ( int i = <num> ; i < childCount ; i ++ ) {
View view = mActionsView . getChildAt ( i ) ;
if ( view != null ) {
final Object tag = view . getTag ( ) ;
if ( tag instanceof Action && tag . equals ( action ) ) {
mActionsView . removeView ( view ) ;
}
}
}
}
public int <unk> ( ) {
return mActionsView . getChildCount ( ) ;
}
private View inflateAction ( Action action ) {
View view = mInflater . inflate ( R . layout . actionbar_item , mActionsView , false ) ;
ImageButton labelView =
( ImageButton ) view . findViewById ( R . id . actionbar_item ) ;
labelView . setImageResource ( action . getDrawable ( ) ) ;
view . setTag ( action ) ;
view . setOnClickListener ( this ) ;
return view ;
}
public static class ActionList extends LinkedList < Action > {
}
public interface Action {
public int getDrawable ( ) ;
public void performAction ( View view ) ;
}
public static abstract class AbstractAction implements Action {
final private int mDrawable ;
public AbstractAction ( int drawable ) {
mDrawable = drawable ;
}
@Override
public int getDrawable ( ) {
return mDrawable ;
}
}
public static class IntentAction extends AbstractAction {
private Context mContext ;
private Intent mIntent ;
public IntentAction ( Context context , Intent intent , int drawable ) {
super ( drawable ) ;
mContext = context ;
mIntent = intent ;
}
@Override
public void performAction ( View view ) {
try {
mContext . startActivity ( mIntent ) ;
} catch ( ActivityNotFoundException e ) {
Toast . makeText ( mContext ,
mContext . getText ( R . string . actionbar_activity_not_found ) ,
Toast . LENGTH_SHORT ) . show ( ) ;
}
}
}
}
package com . tulusha . timetracker ;
public final class R {
public static final class anim {
public static final int magnify_rest = <num> ;
public static final int magnify_work = <num> ;
public static final int shrink_rest = <num> ;
public static final int shrink_work = <num> ;
}
public static final class attr {
public static final int title = <num> ;
}
public static final class color {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int actionbar_title = <num> ;
public static final int <unk> = <num> ;
}
public static final class dimen {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
}
public static final class drawable {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int background = <num> ;
public static final int bg = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int home_btn_about = <num> ;
public static final int home_btn_cal = <num> ;
public static final int home_btn_charts = <num> ;
public static final int home_btn_tracker = <num> ;
public static final int <unk> = <num> ;
public static final int ic_title_home_default = <num> ;
public static final int ic_title_share_default = <num> ;
public static final int icon = <num> ;
public static final int shadow = <num> ;
}
public static final class id {
public static final int actionbar = <num> ;
public static final int actionbar_actions = <num> ;
public static final int <unk> = <num> ;
public static final int actionbar_home_bg = <num> ;
public static final int actionbar_home_btn = <num> ;
public static final int actionbar_home_is_back = <num> ;
public static final int actionbar_home_logo = <num> ;
public static final int actionbar_item = <num> ;
public static final int actionbar_progress = <num> ;
public static final int actionbar_title = <num> ;
public static final int home_btn_about = <num> ;
public static final int home_btn_cal = <num> ;
public static final int home_btn_charts = <num> ;
public static final int home_btn_tracker = <num> ;
public static final int <unk> = <num> ;
public static final int rest = <num> ;
public static final int rest_time = <num> ;
public static final int screen = <num> ;
public static final int work = <num> ;
public static final int work_time = <num> ;
}
public static final class layout {
public static final int actionbar = <num> ;
public static final int actionbar_item = <num> ;
public static final int activity_home = <num> ;
public static final int activity_tracker = <num> ;
}
public static final class string {
public static final int about = <num> ;
public static final int about_text = <num> ;
public static final int actionbar_activity_not_found = <num> ;
public static final int app_name = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int clear_timers = <num> ;
public static final int notification_rest = <num> ;
public static final int notification_work = <num> ;
public static final int rest = <num> ;
public static final int show_app = <num> ;
public static final int version = <num> ;
public static final int work = <num> ;
}
public static final class style {
public static final int ActionBar = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
}
public static final class styleable {
public static final int [ ] ActionBar = {
<num>
} ;
public static final int ActionBar_title = <num> ;
} ;
}
package com . tulusha . timetracker . widgets ;
import android . content . Context ;
import android . text . method . ScrollingMovementMethod ;
import android . util . AttributeSet ;
import android . widget . TextView ;
public class ScrollingTextView extends TextView {
public ScrollingTextView ( Context context , AttributeSet attrs ,
int defStyle ) {
super ( context , attrs , defStyle ) ;
}
public ScrollingTextView ( Context context , AttributeSet attrs ) {
super ( context , attrs ) ;
}
public ScrollingTextView ( Context context ) {
super ( context ) ;
this . setMovementMethod ( new ScrollingMovementMethod ( ) ) ;
this . setMaxLines ( <num> ) ;
}
}
package com . olivere . supahsync . diagnostics ;
import java . io . File ;
import java . io . IOException ;
import java . io . PrintStream ;
import java . io . UnsupportedEncodingException ;
import org . jaudiotagger . tag . TagField ;
public class Driver {
public static void main ( String [ ] args ) throws IOException {
File testDataDirectory = new File ( " ) ;
File outputFile = new File ( " ) ;
outputFile . createNewFile ( ) ;
System . setOut ( new PrintStream ( outputFile ) ) ;
for ( File song : testDataDirectory . listFiles ( ) ) {
printAnalysis ( new TagAnalyzer ( song ) ) ;
}
}
public static void printAnalysis ( TagAnalyzer song ) {
System . out . println ( " + song . getFormat ( ) ) ;
System . out . println ( " + song . getNumFields ( ) ) ;
for ( TagField field : song . getFields ( ) ) {
try {
System . out . println ( " + field . getRawContent ( ) . length + " + field . getId ( ) + " + field . toString ( ) ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
}
}
System . out . println ( " + song . getOwnerFormal ( ) ) ;
System . out . println ( " + song . getArtworkSize ( ) ) ;
System . out . println ( " + song . getApproximateMetadataSize ( ) ) ;
System . out . println ( ) ;
System . out . println ( " ) ;
System . out . println ( ) ;
}
}
package com . olivere . supahsync . diagnostics ;
import java . io . File ;
import java . io . IOException ;
import java . io . UnsupportedEncodingException ;
import java . nio . ByteBuffer ;
import java . util . ArrayList ;
import java . util . Iterator ;
import java . util . List ;
import org . jaudiotagger . audio . AudioFile ;
import org . jaudiotagger . audio . AudioFileIO ;
import org . jaudiotagger . audio . AudioHeader ;
import org . jaudiotagger . audio . exceptions . CannotReadException ;
import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ;
import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ;
import org . jaudiotagger . tag . InvalidTagException ;
import org . jaudiotagger . tag . Tag ;
import org . jaudiotagger . tag . TagException ;
import org . jaudiotagger . tag . TagField ;
import org . jaudiotagger . tag . <unk> . <unk> . FrameBodyPRIV ;
import org . jaudiotagger . tag . images . Artwork ;
public class TagAnalyzer {
private AudioFile audioFile ;
private String audioFormat ;
private Integer artworkSize ;
private List < Artwork > artwork ;
private List < TagField > tags ;
private boolean metadataCorrupted = false ;
private boolean fileDataCorrupted = false ;
public TagAnalyzer ( File f ) throws IOException {
try {
this . audioFile = AudioFileIO . read ( f ) ;
analyzeSong ( ) ;
} catch ( CannotReadException e ) {
throw new IOException ( e ) ;
} catch ( ReadOnlyFileException e ) {
throw new SecurityException ( e ) ;
} catch ( InvalidAudioFrameException e ) {
this . fileDataCorrupted = true ;
} catch ( TagException e ) {
this . metadataCorrupted = true ;
}
}
private void analyzeSong ( ) {
AudioHeader header = this . audioFile . getAudioHeader ( ) ;
Tag tagFields = this . audioFile . getTag ( ) ;
this . audioFormat = header . getFormat ( ) ;
this . artwork = tagFields . getArtworkList ( ) ;
Iterator < TagField > tagsIterator = tagFields . getFields ( ) ;
this . tags = new ArrayList < TagField > ( ) ;
while ( tagsIterator . hasNext ( ) ) {
this . tags . add ( tagsIterator . next ( ) ) ;
}
}
private int calculateArtworkSize ( ) {
Tag tags = audioFile . getTag ( ) ;
int sizeSum = <num> ;
for ( Artwork art : tags . getArtworkList ( ) ) {
sizeSum += art . <unk> ( ) . length ;
}
this . artworkSize = sizeSum ;
return this . artworkSize ;
}
public int getArtworkSize ( ) {
return this . artworkSize == null ? calculateArtworkSize ( ) : this . artworkSize ;
}
public int getNumFields ( ) {
return this . audioFile . getTag ( ) . <unk> ( ) ;
}
public List < TagField > getFields ( ) {
ArrayList < TagField > tags = new ArrayList < TagField > ( ) ;
Iterator < TagField > tagIterator = this . audioFile . getTag ( ) . getFields ( ) ;
while ( tagIterator . hasNext ( ) ) {
tags . add ( tagIterator . next ( ) ) ;
}
return tags ;
}
public int getApproximateMetadataSize ( ) {
int sum = <num> ;
Iterator < TagField > tags = this . audioFile . getTag ( ) . getFields ( ) ;
while ( tags . hasNext ( ) ) {
try {
sum += tags . next ( ) . getRawContent ( ) . length ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
}
}
return sum ;
}
public String getOwner ( ) {
TagField privateTag = this . audioFile . getTag ( ) . getFirstField ( " ) ;
if ( privateTag == null ) {
return null ;
}
try {
byte [ ] rawData = privateTag . getRawContent ( ) ;
int indexOfNull = <num> + <num> + <num> ;
StringBuffer owner = new StringBuffer ( ) ;
while ( rawData [ indexOfNull ] != \0' ) {
owner . append ( ( char ) rawData [ indexOfNull ++ ] ) ;
}
return owner . toString ( ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
public String getOwnerFormal ( ) {
try {
byte [ ] rawContent = this . audioFile . getTag ( ) . getFirstField ( " ) . getRawContent ( ) ;
ByteBuffer byteBuffer = ByteBuffer . wrap ( rawContent , <num> , rawContent . length  <num> ) ;
FrameBodyPRIV privateFrame = new FrameBodyPRIV ( byteBuffer , byteBuffer . remaining ( ) ) ;
return privateFrame . getIdentifier ( ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
return null ;
} catch ( InvalidTagException e ) {
e . printStackTrace ( ) ;
return null ;
} catch ( NullPointerException e ) {
return null ;
}
}
public String getFormat ( ) {
return this . audioFile . getAudioHeader ( ) . getFormat ( ) ;
}
public boolean <unk> ( ) {
return this . fileDataCorrupted || this . metadataCorrupted ;
}
public boolean <unk> ( ) {
return this . fileDataCorrupted ;
}
public boolean <unk> ( ) {
return this . metadataCorrupted ;
}
package com . modcrafting . creepyfriend ;
import java . util . ArrayList ;
import java . util . List ;
import org . bukkit . Effect ;
import org . bukkit . Location ;
import org . bukkit . configuration . file . YamlConfiguration ;
import org . bukkit . entity . Creature ;
import org . bukkit . entity . Creeper ;
import org . bukkit . entity . Entity ;
import org . bukkit . entity . LivingEntity ;
import org . bukkit . entity . Player ;
import org . bukkit . event . EventHandler ;
import org . bukkit . event . Listener ;
import org . bukkit . event . entity . EntityDamageByEntityEvent ;
import org . bukkit . event . entity . EntityDamageEvent ;
import org . bukkit . event . entity . EntityDamageEvent . DamageCause ;
import org . bukkit . event . entity . EntityTargetEvent ;
import org . bukkit . event . player . PlayerInteractEntityEvent ;
import org . bukkit . inventory . ItemStack ;
public class Friend implements Listener {
CreepyFriend plugin ;
public Friend ( CreepyFriend instance ) {
this . plugin = instance ;
}
@EventHandler
public void onEntityDamage ( EntityDamageEvent event ) {
if ( ( event . getCause ( ) == DamageCause . FIRE_TICK || event . getCause ( ) == DamageCause . FIRE ) && plugin . friendlies . contains ( event . getEntity ( ) . getEntityId ( ) ) ) {
event . setCancelled ( true ) ;
event . getEntity ( ) . setFireTicks ( <num> ) ;
} else if ( event instanceof EntityDamageByEntityEvent ) {
EntityDamageByEntityEvent e = ( EntityDamageByEntityEvent ) event ;
if ( e . getDamager ( ) instanceof LivingEntity && e . getEntity ( ) instanceof Player && plugin . friends . get ( ( ( Player ) e . getEntity ( ) ) . getName ( ) ) != null ) {
ArrayList < Integer > array = plugin . friends . get ( ( ( Player ) e . getEntity ( ) ) . getName ( ) ) ;
List < LivingEntity > livingEntities = e . getEntity ( ) . getWorld ( ) . <unk> ( ) ;
for ( LivingEntity i : livingEntities ) {
if ( i instanceof Creature && array . contains ( i . getEntityId ( ) ) ) {
( ( Creature ) i ) . setTarget ( ( LivingEntity ) e . getDamager ( ) ) ;
}
}
}
}
}
@EventHandler
public void <unk> ( EntityTargetEvent event ) {
if ( ( event . getTarget ( ) instanceof Player ) ) {
Player p = ( Player ) event . getTarget ( ) ;
if ( plugin . friendlies . contains ( event . getEntity ( ) . getEntityId ( ) ) ) {
String name = plugin . targets . get ( event . getEntity ( ) . getEntityId ( ) ) ;
if ( name == null || name . isEmpty ( ) ) {
event . setCancelled ( true ) ;
return ;
}
if ( ! ( name . equals ( p . getName ( ) ) ) ) {
event . setCancelled ( true ) ;
return ;
}
}
}
}
@EventHandler
public void <unk> ( PlayerInteractEntityEvent event ) {
YamlConfiguration config = ( YamlConfiguration ) plugin . getConfig ( ) ;
Entity creeper = event . getRightClicked ( ) ;
if ( creeper instanceof Creeper ) {
ItemStack hand = event . getPlayer ( ) . getItemInHand ( ) ;
Location hearts = creeper . getLocation ( ) ;
if ( hand . getTypeId ( ) == config . getInt ( " , <num> ) ) {
if ( hand . getAmount ( ) >= <num> ) {
event . getPlayer ( ) . playEffect ( hearts , Effect . MOBSPAWNER_FLAMES , <num> ) ;
plugin . addFriends ( event . getPlayer ( ) , ( LivingEntity ) creeper ) ;
if ( hand . getAmount ( ) == <num> ) {
event . getPlayer ( ) . setItemInHand ( null ) ;
} else {
hand . setAmount ( hand . getAmount ( )  <num> ) ;
}
return ;
}
}
}
}
}
package com . modcrafting . creepyfriend ;
import java . io . File ;
import java . io . FileOutputStream ;
import java . io . IOException ;
import java . io . InputStream ;
import java . util . ArrayList ;
import java . util . concurrent . ConcurrentHashMap ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import org . bukkit . entity . LivingEntity ;
import org . bukkit . entity . Player ;
import org . bukkit . event . Listener ;
import org . bukkit . plugin . PluginDescriptionFile ;
import org . bukkit . plugin . PluginManager ;
import org . bukkit . plugin . java . JavaPlugin ;
public class CreepyFriend extends JavaPlugin {
public final static Logger log = Logger . getLogger ( " ) ;
public final Listener friend = new Friend ( this ) ;
public ConcurrentHashMap < String , ArrayList < Integer >> friends = new ConcurrentHashMap < String , ArrayList < Integer >> ( ) ;
public ArrayList < Integer > friendlies = new ArrayList < Integer > ( ) ;
public ConcurrentHashMap < Integer , String > targets = new ConcurrentHashMap < Integer , String > ( ) ;
protected void createDefaultConfiguration ( String name ) {
File actual = new File ( getDataFolder ( ) , name ) ;
if ( ! actual . exists ( ) ) {
InputStream input =
this . getClass ( ) . getResourceAsStream ( " + name ) ;
if ( input != null ) {
FileOutputStream output = null ;
try {
output = new FileOutputStream ( actual ) ;
byte [ ] buf = new byte [ <num> ] ;
int length = <num> ;
while ( ( length = input . read ( buf ) ) > <num> ) {
output . write ( buf , <num> , length ) ;
}
log . log ( Level . INFO , getDescription ( ) . getName ( )
+ " + name ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
} finally {
try {
if ( input != null )
input . close ( ) ;
} catch ( IOException e ) { }
try {
if ( output != null )
output . close ( ) ;
} catch ( IOException e ) { }
}
}
}
}
public void onDisable ( ) {
PluginDescriptionFile pdfFile = this . getDescription ( ) ;
log . log ( Level . INFO , " + pdfFile . getName ( ) + " + pdfFile . getVersion ( ) + " ) ;
}
public void onEnable ( ) {
new File ( " ) . mkdir ( ) ;
createDefaultConfiguration ( " ) ;
PluginDescriptionFile pdfFile = this . getDescription ( ) ;
PluginManager pm = getServer ( ) . getPluginManager ( ) ;
pm . registerEvents ( friend , this ) ;
log . log ( Level . INFO , " + pdfFile . getName ( ) + " + pdfFile . getVersion ( ) + " ) ;
}
public void addFriends ( Player p , LivingEntity c ) {
if ( friends . containsKey ( p . getName ( ) ) ) {
friends . get ( p . getName ( ) ) . add ( c . getEntityId ( ) ) ;
} else {
ArrayList < Integer > array = new ArrayList < Integer > ( ) ;
array . add ( c . getEntityId ( ) ) ;
friends . put ( p . getName ( ) , array ) ;
}
friendlies . add ( c . getEntityId ( ) ) ;
return ;
}
}
package paintchat ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import java . io . DataInputStream ;
import java . io . DataOutputStream ;
import java . io . IOException ;
import java . io . ObjectInputStream ;
import java . io . ObjectOutputStream ;
import java . net . ServerSocket ;
import java . net . Socket ;
import java . util . ArrayList ;
import javax . swing . JTextArea ;
public class Server extends PaintPad implements Runnable , ActionListener {
Thread thread = new Thread ( this ) ;
ServerSocket server = null ;
Socket socket = null ;
int port ;
ArrayList < ServerThread > list = new ArrayList < ServerThread > ( ) ;
Server ( String title , int port ) {
super ( title ) ;
this . port = port ;
thread . start ( ) ;
}
@Override
public void send ( Graphic obj ) {
System . out . println ( " + list . size ( ) ) ;
for ( int i = <num> ; i < list . size ( ) ; ++ i ) {
list . get ( i ) . send ( obj ) ;
}
}
public void send ( Graphic obj , ServerThread client ) {
System . out . println ( " + list . size ( ) ) ;
for ( int i = <num> ; i < list . size ( ) ; ++ i ) {
if ( list . get ( i ) != client ) list . get ( i ) . send ( obj ) ;
}
}
public void run ( ) {
try {
server = new ServerSocket ( this . port ) ;
} catch ( IOException e ) { }
setStratBar ( " ) ;
while ( true ) {
try {
socket = server . accept ( ) ;
setStratBar ( " + socket . getInetAddress ( ) + " ) ;
System . out . println ( " ) ;
ServerThread client = new ServerThread ( socket , this ) ;
list . add ( client ) ;
client . start ( ) ;
} catch ( Exception e ) {
setStratBar ( " ) ;
System . out . println ( " ) ;
}
}
}
public static void main ( String args [ ] ) {
new Server ( " , <num> ) ;
}
}
class ServerThread extends Thread {
Socket socket ;
ObjectInputStream in = null ;
ObjectOutputStream out = null ;
Server server ;
ServerThread ( Socket t , Server s ) {
socket = t ;
server = s ;
try {
in = new ObjectInputStream ( socket . getInputStream ( ) ) ;
out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ;
} catch ( IOException e ) { }
}
public void send ( Graphic obj ) {
try {
System . out . println ( obj ) ;
out . writeObject ( obj ) ;
out . flush ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
public void run ( ) {
while ( true ) {
System . out . println ( " ) ;
try {
Graphic s = ( Graphic ) in . readObject ( ) ;
System . out . println ( " ) ;
server . paintarea . itemList [ server . paintarea . index ] = s ;
server . send ( s , this ) ;
server . paintarea . index ++ ;
server . paintarea . createNewitem ( ) ;
server . paintarea . repaint ( ) ;
} catch ( Exception e ) {
break ;
}
}
}
}
package paintchat ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import java . io . DataInputStream ;
import java . io . DataOutputStream ;
import java . io . IOException ;
import java . io . ObjectInputStream ;
import java . io . ObjectOutputStream ;
import java . net . ServerSocket ;
import java . net . Socket ;
import java . util . ArrayList ;
import javax . swing . JTextArea ;
public class Client extends PaintPad implements Runnable , ActionListener {
Thread thread = new Thread ( this ) ;
Socket socket = null ;
String server ;
int port ;
ObjectInputStream in = null ;
ObjectOutputStream out = null ;
Client ( String title , String server , int port ) {
super ( title ) ;
this . server = server ;
this . port = port ;
thread . start ( ) ;
}
@Override
public void send ( Graphic obj ) {
try {
System . out . println ( " ) ;
out . writeObject ( obj ) ;
out . flush ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
public void run ( ) {
setStratBar ( " ) ;
try {
socket = new Socket ( server , port ) ;
out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ;
in = new ObjectInputStream ( socket . getInputStream ( ) ) ;
} catch ( Exception e ) {
setStratBar ( String . format ( " , server , port ) ) ;
System . out . println ( " ) ;
}
while ( true ) {
System . out . println ( " ) ;
try {
Graphic s = ( Graphic ) in . readObject ( ) ;
System . out . println ( " ) ;
paintarea . itemList [ paintarea . index ] = s ;
paintarea . index ++ ;
paintarea . createNewitem ( ) ;
paintarea . repaint ( ) ;
} catch ( Exception e ) {
setStratBar ( " ) ;
break ;
}
}
}
public static void main ( String args [ ] ) {
new Client ( " , " , <num> ) ;
}
}
package paintchat ;
import java . awt . Color ;
import java . awt . Graphics2D ;
import java . io . * ;
import javax . imageio . ImageIO ;
import javax . swing . * ;
import javax . swing . filechooser . * ;
import java . awt . geom . AffineTransform ;
import java . awt . image . BufferedImage ;
import java . awt . image . <unk> ;
public class FileClass {
private PaintPad paintpad ;
PaintArea paintarea = null ;
FileClass ( PaintPad dp , PaintArea da ) {
paintpad = dp ;
paintarea = da ;
}
public void newFile ( ) {
paintarea . setIndex ( <num> ) ;
paintarea . setCurrentChoice ( <num> ) ;
paintarea . setColor ( Color . black ) ;
paintarea . setStroke ( <num> ) ;
paintarea . createNewitem ( ) ;
paintarea . repaint ( ) ;
}
public void openFile ( ) {
JFileChooser filechooser = new JFileChooser ( ) ;
filechooser . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ;
int returnVal = filechooser . showOpenDialog ( paintpad ) ;
if ( returnVal == JFileChooser . CANCEL_OPTION ) {
return ;
}
File fileName = filechooser . getSelectedFile ( ) ;
fileName . canRead ( ) ;
if ( fileName == null || fileName . getName ( ) . equals ( " ) )
{
JOptionPane . showMessageDialog ( filechooser , " , " ,
JOptionPane . ERROR_MESSAGE ) ;
}
else {
try {
BufferedImage image = ImageIO . read ( fileName ) ;
Graphics2D g2d = ( Graphics2D ) paintarea . getGraphics ( ) ;
g2d . drawRenderedImage ( image , AffineTransform . <unk> ( <num> , <num> ) ) ;
} catch ( FileNotFoundException e ) {
JOptionPane . showMessageDialog ( paintpad , " , " ,
JOptionPane . ERROR_MESSAGE ) ;
} catch ( IOException e ) {
JOptionPane . showMessageDialog ( paintpad , " , " ,
JOptionPane . ERROR_MESSAGE ) ;
}
}
}
public void saveFile ( ) {
JFileChooser filechooser = new JFileChooser ( ) ;
filechooser . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ;
int result = filechooser . showSaveDialog ( paintpad ) ;
if ( result == JFileChooser . CANCEL_OPTION ) {
return ;
}
File fileName = filechooser . getSelectedFile ( ) ;
fileName . canWrite ( ) ;
if ( fileName == null || fileName . getName ( ) . equals ( " ) )
{
JOptionPane . showMessageDialog ( filechooser , " , " ,
JOptionPane . ERROR_MESSAGE ) ;
} else {
try {
fileName . delete ( ) ;
BufferedImage image = new BufferedImage ( paintarea . getWidth ( ) , paintarea . getHeight ( ) , BufferedImage . TYPE_INT_RGB ) ;
Graphics2D g2d = image . createGraphics ( ) ;
paintarea . paint ( g2d ) ;
ImageIO . write ( image , " , new File ( fileName + " ) ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
}
}
package paintchat ;
public class <unk> {
public static void main ( String [ ] args ) throws InterruptedException {
new Server ( " , <num> ) ;
Thread . sleep ( <num> ) ;
new Client ( " , " , <num> ) ;
new Client ( " , " , <num> ) ;
}
}
package paintchat ;
import java . awt . Dimension ;
import java . awt . FlowLayout ;
import java . awt . Font ;
import java . awt . GraphicsEnvironment ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import java . awt . event . ItemEvent ;
import java . awt . event . ItemListener ;
import javax . swing . Box ;
import javax . swing . JButton ;
import javax . swing . JCheckBox ;
import javax . swing . JComboBox ;
import javax . swing . JDialog ;
import javax . swing . JFrame ;
public class FontDialog extends JDialog implements ItemListener , ActionListener {
private JCheckBox bold , italic ;
private JComboBox styles ;
String [ ] fontName ;
PaintArea paintarea ;
JButton button ;
FontDialog ( JFrame f , String s , boolean b , PaintArea da ) {
super ( f , s , b ) ;
setLayout ( new FlowLayout ( ) ) ;
setBounds ( <num> , <num> , <num> , <num> ) ;
this . paintarea = da ;
init ( ) ;
}
public void init ( ) {
bold = new JCheckBox ( " ) ;
bold . setFont ( new Font ( Font . DIALOG , Font . BOLD , <num> ) ) ;
bold . addItemListener ( this ) ;
italic = new JCheckBox ( " ) ;
italic . addItemListener ( this ) ;
italic . setFont ( new Font ( Font . DIALOG , Font . ITALIC , <num> ) ) ;
GraphicsEnvironment ge = GraphicsEnvironment
. getLocalGraphicsEnvironment ( ) ;
fontName = ge . getAvailableFontFamilyNames ( ) ;
styles = new JComboBox ( fontName ) ;
styles . addItemListener ( this ) ;
styles . setMaximumSize ( new Dimension ( <num> , <num> ) ) ;
styles . setFont ( new Font ( Font . DIALOG , Font . BOLD , <num> ) ) ;
button = new JButton ( " ) ;
button . addActionListener ( this ) ;
add ( Box . createHorizontalStrut ( <num> ) ) ;
add ( Box . createHorizontalStrut ( <num> ) ) ;
add ( Box . createHorizontalStrut ( <num> ) ) ;
add ( Box . createHorizontalStrut ( <num> ) ) ;
add ( Box . createHorizontalStrut ( <num> ) ) ;
add ( Box . createHorizontalStrut ( <num> ) ) ;
add ( bold ) ;
add ( italic ) ;
add ( styles ) ;
add ( Box . createHorizontalStrut ( <num> ) ) ;
add ( Box . createHorizontalStrut ( <num> ) ) ;
add ( Box . createHorizontalStrut ( <num> ) ) ;
add ( button ) ;
}
public void itemStateChanged ( ItemEvent e ) {
if ( e . getSource ( ) == bold )
{
if ( e . getStateChange ( ) == ItemEvent . SELECTED )
paintarea . setFont ( <num> , Font . BOLD ) ;
else
paintarea . setFont ( <num> , Font . PLAIN ) ;
} else if ( e . getSource ( ) == italic )
{
if ( e . getStateChange ( ) == ItemEvent . SELECTED )
paintarea . setFont ( <num> , Font . ITALIC ) ;
else
paintarea . setFont ( <num> , Font . PLAIN ) ;
} else if ( e . getSource ( ) == styles )
{
paintarea . stytle = fontName [ styles . getSelectedIndex ( ) ] ;
}
}
public void actionPerformed ( ActionEvent e ) {
if ( e . getSource ( ) == button ) {
setVisible ( false ) ;
}
}
}
package paintchat ;
import java . awt . * ;
import java . awt . event . * ;
import java . io . InputStreamReader ;
import java . io . Reader ;
import javax . swing . * ;
public class PaintPad extends JFrame implements ActionListener {
protected JToolBar toolpanel ;
protected JMenuBar bar ;
protected JMenu file , edit , help ;
protected JMenuItem newfile , openfile , savefile , exit ;
protected JMenuItem setfont , setcolor , setwidth ;
protected JMenuItem helpin , helpmain ;
protected JLabel startbar ;
protected PaintArea paintarea ;
protected Help helpobject ;
protected FileClass fileclass ;
protected FontDialog fontDialog ;
protected String names [ ] = { " , " , " , " , " , " , " , " , " ,
" , " , " , " , " } ;
protected Icon icons [ ] ;
protected String tiptext [ ] = {
" , " , " , " , " , " , " ,
" , " , " , " , " , " , " } ;
JButton button [ ] ;
public PaintPad ( String string ) {
super ( string ) ;
startbar = new JLabel ( " ) ;
paintarea = new PaintArea ( this ) ;
initMenubar ( ) ;
initToolbar ( ) ;
Container con = getContentPane ( ) ;
con . add ( toolpanel , BorderLayout . WEST ) ;
con . add ( paintarea , BorderLayout . CENTER ) ;
con . add ( startbar , BorderLayout . SOUTH ) ;
setBounds ( <num> , <num> , <num> , <num> ) ;
setVisible ( true ) ;
validate ( ) ;
setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
}
public void initMenubar ( ) {
file = new JMenu ( " ) ;
edit = new JMenu ( " ) ;
help = new JMenu ( " ) ;
bar = new JMenuBar ( ) ;
bar . add ( file ) ;
bar . add ( edit ) ;
bar . add ( help ) ;
setJMenuBar ( bar ) ;
file . setMnemonic ( F' ) ;
help . setMnemonic ( H' ) ;
newfile = new JMenuItem ( " ) ;
openfile = new JMenuItem ( " ) ;
savefile = new JMenuItem ( " ) ;
exit = new JMenuItem ( " ) ;
file . add ( newfile ) ;
file . add ( openfile ) ;
file . add ( savefile ) ;
file . add ( exit ) ;
newfile . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_N ,
InputEvent . CTRL_MASK ) ) ;
openfile . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_O ,
InputEvent . CTRL_MASK ) ) ;
savefile . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_S ,
InputEvent . CTRL_MASK ) ) ;
exit . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_E ,
InputEvent . CTRL_MASK ) ) ;
newfile . addActionListener ( this ) ;
openfile . addActionListener ( this ) ;
savefile . addActionListener ( this ) ;
exit . addActionListener ( this ) ;
setfont = new JMenuItem ( " ) ;
setcolor = new JMenuItem ( " ) ;
setwidth = new JMenuItem ( " ) ;
fontDialog = new FontDialog ( this , " , false , paintarea ) ;
edit . add ( setfont ) ;
edit . add ( setcolor ) ;
edit . add ( setwidth ) ;
setfont . addActionListener ( this ) ;
setcolor . addActionListener ( this ) ;
setwidth . addActionListener ( this ) ;
helpmain = new JMenuItem ( " ) ;
helpin = new JMenuItem ( " ) ;
help . add ( helpmain ) ;
help . addSeparator ( ) ;
help . add ( helpin ) ;
helpin . addActionListener ( this ) ;
helpmain . addActionListener ( this ) ;
helpobject = new Help ( this ) ;
fileclass = new FileClass ( this , paintarea ) ;
}
public void initToolbar ( ) {
toolpanel = new JToolBar ( JToolBar . VERTICAL ) ;
icons = new ImageIcon [ names . length ] ;
button = new JButton [ names . length ] ;
for ( int i = <num> ; i < names . length ; i ++ ) {
icons [ i ] = new ImageIcon ( getClass ( ) . getResource (
" + names [ i ] + " ) ) ;
button [ i ] = new JButton ( " , icons [ i ] ) ;
button [ i ] . setToolTipText ( tiptext [ i ] ) ;
toolpanel . add ( Box . createHorizontalStrut ( <num> ) ) ;
toolpanel . add ( button [ i ] ) ;
button [ i ] . setBorder ( null ) ;
button [ i ] . addActionListener ( this ) ;
}
}
public void setStratBar ( String s ) {
startbar . setText ( s ) ;
}
public void send ( Graphic obj ) {
}
public void actionPerformed ( ActionEvent e ) {
for ( int i = <num> ; i <= <num> ; i ++ ) {
if ( e . getSource ( ) == button [ i ] && i != <num> ) {
paintarea . setCurrentChoice ( i ) ;
paintarea . createNewitem ( ) ;
paintarea . repaint ( ) ;
}
}
if ( e . getSource ( ) == newfile )
{
fileclass . newFile ( ) ;
} else if ( e . getSource ( ) == openfile )
{
fileclass . openFile ( ) ;
} else if ( e . getSource ( ) == savefile )
{
fileclass . saveFile ( ) ;
} else if ( e . getSource ( ) == exit )
{
System . exit ( <num> ) ;
} else if ( e . getSource ( ) == button [ <num> ] || e . getSource ( ) == setcolor )
{
paintarea . chooseColor ( ) ;
} else if ( e . getSource ( ) == button [ <num> ] || e . getSource ( ) == setwidth )
{
paintarea . setStroke ( ) ;
} else if ( e . getSource ( ) == button [ <num> ] )
{
JOptionPane . showMessageDialog ( null , " , " ,
JOptionPane . INFORMATION_MESSAGE ) ;
paintarea . setCurrentChoice ( <num> ) ;
paintarea . createNewitem ( ) ;
paintarea . repaint ( ) ;
} else if ( e . getSource ( ) == helpin )
{
helpobject . AboutBook ( ) ;
} else if ( e . getSource ( ) == helpmain )
{
helpobject . MainHeip ( ) ;
} else if ( e . getSource ( ) == setfont )
{
fontDialog . setLocation ( this . getBounds ( ) . x + <num> , this . getBounds ( ) . y + <num> ) ;
fontDialog . setVisible ( true ) ;
}
}
}
package paintchat ;
import java . awt . * ;
import java . awt . event . * ;
import javax . swing . * ;
import java . awt . event . MouseMotionAdapter ;
public class PaintArea extends JPanel {
PaintPad paintpad = null ;
Graphic [ ] itemList = new Graphic [ <num> ] ; ;
private int currentChoice = <num> ;
int index = <num> ;
private Color color = Color . black ;
int R , G , B ;
int f1 , f2 ;
String stytle ;
float stroke = <num> ;
PaintArea ( PaintPad dp ) {
paintpad = dp ;
setCursor ( Cursor . getPredefinedCursor ( Cursor . CROSSHAIR_CURSOR ) ) ;
setBackground ( Color . white ) ;
addMouseListener ( new MouseA ( ) ) ;
addMouseMotionListener ( new MouseB ( ) ) ;
createNewitem ( ) ;
}
public void paintComponent ( Graphics g ) {
super . paintComponent ( g ) ;
Graphics2D g2d = ( Graphics2D ) g ;
int j = <num> ;
while ( j <= index ) {
draw ( g2d , itemList [ j ] ) ;
j ++ ;
}
}
void draw ( Graphics2D g2d , Graphic i ) {
i . draw ( g2d ) ;
}
public Graphic createNewitem ( ) {
if ( currentChoice == <num> )
setCursor ( Cursor . getPredefinedCursor ( Cursor . TEXT_CURSOR ) ) ;
else
setCursor ( Cursor . getPredefinedCursor ( Cursor . CROSSHAIR_CURSOR ) ) ;
switch ( currentChoice ) {
case <num> :
itemList [ index ] = new Pencil ( ) ;
break ;
case <num> :
itemList [ index ] = new Word ( ) ;
break ;
case <num> :
itemList [ index ] = new Line ( ) ;
break ;
case <num> :
itemList [ index ] = new Rect ( ) ;
break ;
case <num> :
itemList [ index ] = new fillRect ( ) ;
break ;
case <num> :
itemList [ index ] = new Oval ( ) ;
break ;
case <num> :
itemList [ index ] = new fillOval ( ) ;
break ;
case <num> :
itemList [ index ] = new Circle ( ) ;
break ;
case <num> :
itemList [ index ] = new fillCircle ( ) ;
break ;
case <num> :
itemList [ index ] = new RoundRect ( ) ;
break ;
case <num> :
itemList [ index ] = new fillRoundRect ( ) ;
break ;
case <num> :
itemList [ index ] = new Rubber ( ) ;
break ;
}
itemList [ index ] . type = currentChoice ;
itemList [ index ] . R = R ;
itemList [ index ] . G = G ;
itemList [ index ] . B = B ;
itemList [ index ] . stroke = stroke ;
return itemList [ index ] ;
}
public void setIndex ( int x ) {
index = x ;
}
public int getIndex ( ) {
return index ;
}
public void setColor ( Color color )
{
this . color = color ;
}
public void setStroke ( float f )
{
stroke = f ;
}
public void chooseColor ( )
{
color = <unk> . showDialog ( paintpad , " , color ) ;
try {
R = color . getRed ( ) ;
G = color . getGreen ( ) ;
B = color . getBlue ( ) ;
} catch ( Exception e ) {
R = <num> ;
G = <num> ;
B = <num> ;
}
itemList [ index ] . R = R ;
itemList [ index ] . G = G ;
itemList [ index ] . B = B ;
}
public void setStroke ( )
{
String input ;
input = JOptionPane . showInputDialog ( " ) ;
try {
stroke = Float . parseFloat ( input ) ;
} catch ( Exception e ) {
stroke = <num> ;
}
itemList [ index ] . stroke = stroke ;
}
public void setCurrentChoice ( int i )
{
currentChoice = i ;
}
public void setFont ( int i , int font )
{
if ( i == <num> ) {
f1 = font ;
} else
f2 = font ;
}
class MouseA extends MouseAdapter {
@Override
public void mouseEntered ( MouseEvent me ) {
paintpad . setStratBar ( " + me . getX ( ) + " + me . getY ( ) + " ) ;
}
@Override
public void mouseExited ( MouseEvent me ) {
paintpad . setStratBar ( " + me . getX ( ) + " + me . getY ( ) + " ) ;
}
@Override
public void mousePressed ( MouseEvent me ) {
paintpad . setStratBar ( " + me . getX ( ) + " + me . getY ( ) + " ) ;
itemList [ index ] . x1 = itemList [ index ] . x2 = me . getX ( ) ;
itemList [ index ] . y1 = itemList [ index ] . y2 = me . getY ( ) ;
if ( currentChoice == <num> || currentChoice == <num> ) {
itemList [ index ] . x1 = itemList [ index ] . x2 = me . getX ( ) ;
itemList [ index ] . y1 = itemList [ index ] . y2 = me . getY ( ) ;
index ++ ;
createNewitem ( ) ;
}
if ( currentChoice == <num> ) {
itemList [ index ] . x1 = me . getX ( ) ;
itemList [ index ] . y1 = me . getY ( ) ;
String input ;
input = JOptionPane . showInputDialog ( " ) ;
itemList [ index ] . s1 = input ;
itemList [ index ] . x2 = f1 ;
itemList [ index ] . y2 = f2 ;
itemList [ index ] . s2 = stytle ;
paintpad . send ( itemList [ index ] ) ;
index ++ ;
currentChoice = <num> ;
createNewitem ( ) ;
repaint ( ) ;
}
}
@Override
public void mouseReleased ( MouseEvent me ) {
paintpad . setStratBar ( " + me . getX ( ) + " + me . getY ( ) + " ) ;
if ( currentChoice == <num> || currentChoice == <num> ) {
itemList [ index ] . x1 = me . getX ( ) ;
itemList [ index ] . y1 = me . getY ( ) ;
}
itemList [ index ] . x2 = me . getX ( ) ;
itemList [ index ] . y2 = me . getY ( ) ;
repaint ( ) ;
paintpad . send ( itemList [ index ] ) ;
index ++ ;
Graphic item = createNewitem ( ) ;
}
}
class MouseB extends MouseMotionAdapter {
public void mouseDragged ( MouseEvent me )
{
paintpad . setStratBar ( " + me . getX ( ) + " + me . getY ( ) + " ) ;
if ( currentChoice == <num> || currentChoice == <num> ) {
itemList [ index  <num> ] . x1 = itemList [ index ] . x2 = itemList [ index ] . x1 = me . getX ( ) ;
itemList [ index  <num> ] . y1 = itemList [ index ] . y2 = itemList [ index ] . y1 = me . getY ( ) ;
index ++ ;
Graphic item = createNewitem ( ) ;
paintpad . send ( itemList [ index  <num> ] ) ;
} else {
itemList [ index ] . x2 = me . getX ( ) ;
itemList [ index ] . y2 = me . getY ( ) ;
}
repaint ( ) ;
}
public void mouseMoved ( MouseEvent me )
{
paintpad . setStratBar ( " + me . getX ( ) + " + me . getY ( ) + " ) ;
}
}
}
package paintchat ;
import javax . swing . JFrame ;
import javax . swing . JOptionPane ;
public class Help extends JFrame {
private PaintPad paintpad = null ;
Help ( PaintPad dp ) {
paintpad = dp ;
}
public void MainHeip ( ) {
JOptionPane . showMessageDialog ( this , " , " ,
JOptionPane . WARNING_MESSAGE ) ;
}
public void AboutBook ( ) {
JOptionPane . showMessageDialog ( paintpad , " , " , JOptionPane . WARNING_MESSAGE ) ;
}
}
package paintchat ;
import java . awt . BasicStroke ;
import java . awt . Color ;
import java . awt . Font ;
import java . awt . Graphics2D ;
import java . io . Serializable ;
public class Graphic implements Serializable {
public int x1 = <num> , x2 = <num> , y1 = <num> , y2 = <num> ;
public int R = <num> , G = <num> , B = <num> ;
public float stroke = <num> ;
public int type = <num> ;
public String s1 = " ;
public String s2 = " ;
void draw ( Graphics2D g2d ) {
}
}
class Line extends Graphic
{
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setStroke ( new BasicStroke ( stroke , BasicStroke . CAP_ROUND ,
BasicStroke . JOIN_BEVEL ) ) ;
g2d . drawLine ( x1 , y1 , x2 , y2 ) ;
}
}
class Rect extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setStroke ( new BasicStroke ( stroke ) ) ;
g2d . drawRect ( Math . min ( x1 , x2 ) , Math . min ( y2 , y2 ) , Math . abs ( x1  x2 ) ,
Math . abs ( y1  y2 ) ) ;
}
}
class fillRect extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setStroke ( new BasicStroke ( stroke ) ) ;
g2d . fillRect ( Math . min ( x1 , x2 ) , Math . min ( y2 , y2 ) , Math . abs ( x1  x2 ) ,
Math . abs ( y1  y2 ) ) ;
}
}
class Oval extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setStroke ( new BasicStroke ( stroke ) ) ;
g2d . drawOval ( Math . min ( x1 , x2 ) , Math . min ( y2 , y2 ) , Math . abs ( x1  x2 ) ,
Math . abs ( y1  y2 ) ) ;
}
}
class fillOval extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setStroke ( new BasicStroke ( stroke ) ) ;
g2d . fillOval ( Math . min ( x1 , x2 ) , Math . min ( y2 , y2 ) , Math . abs ( x1  x2 ) ,
Math . abs ( y1  y2 ) ) ;
}
}
class Circle extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setStroke ( new BasicStroke ( stroke ) ) ;
g2d . drawOval ( Math . min ( x1 , x2 ) , Math . min ( y2 , y2 ) ,
Math . max ( Math . abs ( x1  x2 ) , Math . abs ( y1  y2 ) ) ,
Math . max ( Math . abs ( x1  x2 ) , Math . abs ( y1  y2 ) ) ) ;
}
}
class fillCircle extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setStroke ( new BasicStroke ( stroke ) ) ;
g2d . fillOval ( Math . min ( x1 , x2 ) , Math . min ( y2 , y2 ) ,
Math . max ( Math . abs ( x1  x2 ) , Math . abs ( y1  y2 ) ) ,
Math . max ( Math . abs ( x1  x2 ) , Math . abs ( y1  y2 ) ) ) ;
}
}
class RoundRect extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setStroke ( new BasicStroke ( stroke ) ) ;
g2d . drawRoundRect ( Math . min ( x1 , x2 ) , Math . min ( y2 , y2 ) ,
Math . abs ( x1  x2 ) , Math . abs ( y1  y2 ) , <num> , <num> ) ;
}
}
class fillRoundRect extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setStroke ( new BasicStroke ( stroke ) ) ;
g2d . fillRoundRect ( Math . min ( x1 , x2 ) , Math . min ( y2 , y2 ) ,
Math . abs ( x1  x2 ) , Math . abs ( y1  y2 ) , <num> , <num> ) ;
}
}
class Pencil extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setStroke ( new BasicStroke ( stroke , BasicStroke . CAP_ROUND ,
BasicStroke . JOIN_BEVEL ) ) ;
g2d . drawLine ( x1 , y1 , x2 , y2 ) ;
}
}
class Rubber extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( <num> , <num> , <num> ) ) ;
g2d . setStroke ( new BasicStroke ( stroke + <num> , BasicStroke . CAP_ROUND ,
BasicStroke . JOIN_BEVEL ) ) ;
g2d . drawLine ( x1 , y1 , x2 , y2 ) ;
}
}
class Word extends Graphic {
void draw ( Graphics2D g2d ) {
g2d . setPaint ( new Color ( R , G , B ) ) ;
g2d . setFont ( new Font ( s2 , x2 + y2 , ( ( int ) stroke ) * <num> ) ) ;
if ( s1 != null )
g2d . drawString ( s1 , x1 , y1 ) ;
}
package jsyntaxpane ;
import java . awt . Color ;
import java . awt . Font ;
import java . awt . Graphics ;
import java . awt . Graphics2D ;
import java . awt . RenderingHints ;
import java . awt . Shape ;
import java . util . HashMap ;
import java . util . Iterator ;
import java . util . Map ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . Element ;
import javax . swing . text . PlainView ;
import javax . swing . text . Segment ;
import javax . swing . text . ViewFactory ;
import jsyntaxpane . util . Configuration ;
public class SyntaxView extends PlainView {
public static final String PROPERTY_RIGHT_MARGIN_COLOR = " ;
public static final String PROPERTY_RIGHT_MARGIN_COLUMN = " ;
public static final String PROPERTY_SINGLE_COLOR_SELECT = " ;
public static final String PROPERTY_TEXTAA = " ;
private static final Logger log = Logger . getLogger ( SyntaxView . class . getName ( ) ) ;
private SyntaxStyle DEFAULT_STYLE = SyntaxStyles . getInstance ( ) . getStyle ( TokenType . DEFAULT ) ;
private final boolean singleColorSelect ;
private final int rightMarginColumn ;
private final Color rightMarginColor ;
private final Object textAAHint ;
public SyntaxView ( Element element , Configuration config , String prefix ) {
super ( element ) ;
singleColorSelect = config . getPrefixBoolean ( prefix , PROPERTY_SINGLE_COLOR_SELECT , false ) ;
rightMarginColor = new Color ( config . getPrefixInteger ( prefix , PROPERTY_RIGHT_MARGIN_COLOR ,
<num> ) ) ;
rightMarginColumn = config . getPrefixInteger ( prefix , PROPERTY_RIGHT_MARGIN_COLUMN ,
0 ) ;
String textaa = config . getPrefixProperty ( prefix , PROPERTY_TEXTAA ,
" ) ;
textAAHint = TEXT_AA_HINT_NAMES . get ( textaa ) ;
}
@Override
protected int drawUnselectedText ( Graphics graphics , int x , int y , int p0 ,
int p1 ) {
Graphics2D graphics2D = ( Graphics2D ) graphics ;
graphics2D . setRenderingHint ( RenderingHints . <unk> ,
textAAHint ) ;
Font saveFont = graphics . getFont ( ) ;
Color saveColor = graphics . getColor ( ) ;
SyntaxDocument doc = ( SyntaxDocument ) getDocument ( ) ;
Segment segment = <unk> ( ) ;
if ( rightMarginColumn > <num> ) {
int m_x = rightMarginColumn * graphics . getFontMetrics ( ) . charWidth ( m' ) ;
int h = graphics . getFontMetrics ( ) . getHeight ( ) ;
graphics . setColor ( rightMarginColor ) ;
graphics . drawLine ( m_x , y , m_x , y  h ) ;
}
try {
Iterator < Token > i = doc . getTokens ( p0 , p1 ) ;
int start = p0 ;
while ( i . hasNext ( ) ) {
Token t = i . next ( ) ;
if ( start < t . start ) {
doc . getText ( start , t . start  start , segment ) ;
x = DEFAULT_STYLE . drawText ( segment , x , y , graphics , this , start ) ;
}
int l = t . length ;
int s = t . start ;
if ( s < p0 ) {
l -= ( p0  s ) ;
s = p0 ;
}
if ( s + l > p1 ) {
l = p1  s ;
}
doc . getText ( s , l , segment ) ;
x = SyntaxStyles . getInstance ( ) . drawText ( segment , x , y , graphics , this , t ) ;
start = t . end ( ) ;
}
if ( start < p1 ) {
doc . getText ( start , p1  start , segment ) ;
x = DEFAULT_STYLE . drawText ( segment , x , y , graphics , this , start ) ;
}
} catch ( BadLocationException ex ) {
System . err . println ( " + ex . offsetRequested ( ) ) ;
log . log ( Level . SEVERE , null , ex ) ;
} finally {
graphics . setFont ( saveFont ) ;
graphics . setColor ( saveColor ) ;
}
return x ;
}
@Override
protected int <unk> ( Graphics graphics , int x , int y , int p0 , int p1 )
throws BadLocationException {
if ( singleColorSelect ) {
if ( rightMarginColumn > <num> ) {
int m_x = rightMarginColumn * graphics . getFontMetrics ( ) . charWidth ( m' ) ;
int h = graphics . getFontMetrics ( ) . getHeight ( ) ;
graphics . setColor ( rightMarginColor ) ;
graphics . drawLine ( m_x , y , m_x , y  h ) ;
}
return super . drawUnselectedText ( graphics , x , y , p0 , p1 ) ;
} else {
return drawUnselectedText ( graphics , x , y , p0 , p1 ) ;
}
}
@Override
protected void updateDamage ( javax . swing . event . DocumentEvent changes ,
Shape a ,
ViewFactory f ) {
super . updateDamage ( changes , a , f ) ;
java . awt . Component host = getContainer ( ) ;
host . repaint ( ) ;
}
private static Map < String , Object > TEXT_AA_HINT_NAMES =
new HashMap < String , Object > ( ) ;
static {
TEXT_AA_HINT_NAMES . put ( " , RenderingHints . <unk> ) ;
TEXT_AA_HINT_NAMES . put ( " , RenderingHints . <unk> ) ;
TEXT_AA_HINT_NAMES . put ( " , RenderingHints . <unk> ) ;
TEXT_AA_HINT_NAMES . put ( " , RenderingHints . <unk> ) ;
TEXT_AA_HINT_NAMES . put ( " , RenderingHints . VALUE_TEXT_ANTIALIAS_LCD_VBGR ) ;
TEXT_AA_HINT_NAMES . put ( " , RenderingHints . VALUE_TEXT_ANTIALIAS_LCD_VBGR ) ;
TEXT_AA_HINT_NAMES . put ( " , RenderingHints . <unk> ) ;
TEXT_AA_HINT_NAMES . put ( " , RenderingHints . <unk> ) ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . Lexer ;
import jsyntaxpane . lexers . CLexer ;
public class CSyntaxKit extends DefaultSyntaxKit {
public CSyntaxKit ( ) {
super ( new CLexer ( ) ) ;
}
CSyntaxKit ( Lexer lexer ) {
super ( lexer ) ;
}
}
package jsyntaxpane . actions ;
import java . awt . Component ;
import java . awt . Frame ;
import java . awt . Point ;
import java . awt . Rectangle ;
import java . awt . Window ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import javax . swing . JComboBox ;
import javax . swing . MutableComboBoxModel ;
import javax . swing . SwingUtilities ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . Document ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . PlainDocument ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . Token ;
public class ActionUtils {
public static String getIndent ( String line ) {
if ( line == null || line . length ( ) == <num> ) {
return " ;
}
int i = <num> ;
while ( i < line . length ( ) && line . charAt ( i ) ==  ' ) {
i ++ ;
}
return line . substring ( <num> , i ) ;
}
public static String [ ] getSelectedLines ( JTextComponent target ) {
String [ ] lines = null ;
try {
PlainDocument pDoc = ( PlainDocument ) target . getDocument ( ) ;
int start = pDoc . getParagraphElement ( target . getSelectionStart ( ) ) . getStartOffset ( ) ;
int end ;
if ( target . getSelectionStart ( ) == target . getSelectionEnd ( ) ) {
end = pDoc . getParagraphElement ( target . getSelectionEnd ( ) ) . getEndOffset ( ) ;
} else {
end = pDoc . getParagraphElement ( target . getSelectionEnd ( )  <num> ) . getEndOffset ( ) ;
}
target . select ( start , end ) ;
lines = pDoc . getText ( start , end  start ) . split ( " ) ;
target . select ( start , end ) ;
} catch ( BadLocationException ex ) {
Logger . getLogger ( ActionUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ;
lines = EMPTY_STRING_ARRAY ;
}
return lines ;
}
public static String getLine ( JTextComponent target ) {
return getLineAt ( target , target . getCaretPosition ( ) ) ;
}
public static String getLineAt ( JTextComponent target , int pos ) {
String line = null ;
Document doc = target . getDocument ( ) ;
if ( doc instanceof PlainDocument ) {
PlainDocument pDoc = ( PlainDocument ) doc ;
int start = pDoc . getParagraphElement ( pos ) . getStartOffset ( ) ;
int end = pDoc . getParagraphElement ( pos ) . getEndOffset ( ) ;
try {
line = doc . getText ( start , end  start ) ;
if ( line != null && line . endsWith ( " ) ) {
line = line . substring ( <num> , line . length ( )  <num> ) ;
}
} catch ( BadLocationException ex ) {
Logger . getLogger ( ActionUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ;
}
}
return line ;
}
public static Frame getFrameFor ( Component comp ) {
Window w = SwingUtilities . <unk> ( comp ) ;
if ( w != null && w instanceof Frame ) {
Frame frame = ( Frame ) w ;
return frame ;
}
return null ;
}
public static String getTokenStringAt (
SyntaxDocument doc , int pos ) {
String word = " ;
Token t = doc . getTokenAt ( pos ) ;
if ( t != null ) {
try {
word = doc . getText ( t . start , t . length ) ;
} catch ( BadLocationException ex ) {
Logger . getLogger ( ActionUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ;
}
}
return word ;
}
public static SyntaxDocument getSyntaxDocument ( JTextComponent component ) {
if ( component == null ) {
return null ;
}
Document doc = component . getDocument ( ) ;
if ( doc instanceof SyntaxDocument ) {
return ( SyntaxDocument ) doc ;
} else {
return null ;
}
}
public static int getLineNumber ( JTextComponent editor , int pos )
throws BadLocationException {
if ( getSyntaxDocument ( editor ) != null ) {
SyntaxDocument sdoc = getSyntaxDocument ( editor ) ;
return sdoc . getLineNumberAt ( pos ) ;
} else {
Document doc = editor . getDocument ( ) ;
return doc . getDefaultRootElement ( ) . getElementIndex ( pos ) ;
}
}
public static int getColumnNumber ( JTextComponent editor , int pos )
throws BadLocationException {
Rectangle r = editor . modelToView ( pos ) ;
int start = editor . viewToModel ( new Point ( <num> , r . y ) ) ;
int column = pos  start ;
return column ;
}
public static int getDocumentPosition ( JTextComponent editor , int line ,
int column ) {
int lineHeight = editor . getFontMetrics ( editor . getFont ( ) ) . getHeight ( ) ;
int charWidth = editor . getFontMetrics ( editor . getFont ( ) ) . charWidth ( m' ) ;
int y = line * lineHeight ;
int x = column * charWidth ;
Point pt = new Point ( x , y ) ;
int pos = editor . viewToModel ( pt ) ;
return pos ;
}
public static int getLineCount ( JTextComponent pane ) {
SyntaxDocument sdoc = getSyntaxDocument ( pane ) ;
if ( sdoc != null ) {
return sdoc . getLineCount ( ) ;
}
int count = <num> ;
try {
int p = pane . getDocument ( ) . getLength ( )  <num> ;
if ( p > <num> ) {
count = getLineNumber ( pane , p ) ;
}
} catch ( BadLocationException ex ) {
Logger . getLogger ( ActionUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ;
}
return count ;
}
public static void insertIntoCombo ( JComboBox combo , Object item ) {
MutableComboBoxModel model = ( MutableComboBoxModel ) combo . getModel ( ) ;
if ( model . getSize ( ) == <num> ) {
model . insertElementAt ( item , <num> ) ;
return ;
}
Object o = model . getElementAt ( <num> ) ;
if ( o . equals ( item ) ) {
return ;
}
model . removeElement ( item ) ;
model . insertElementAt ( item , <num> ) ;
combo . setSelectedIndex ( <num> ) ;
}
public static String <unk> ( String source , int repeat ) {
if ( repeat < <num> ) {
throw new IllegalArgumentException ( " + repeat + " ) ;
}
if ( repeat == <num> || source == null || source . length ( ) == <num> ) {
return " ;
}
StringBuffer buffer = new StringBuffer ( ) ;
for ( int i = <num> ; i < repeat ; i ++ ) {
buffer . append ( source ) ;
}
return buffer . toString ( ) ;
}
public static boolean isEmptyOrBlanks ( String string ) {
if ( string == null || string . length ( ) == <num> ) {
return true ;
}
for ( int i = <num> ; i < string . length ( ) ; i ++ ) {
char c = string . charAt ( i ) ;
if ( ! Character . isWhitespace ( c ) ) {
return false ;
}
}
return true ;
}
public static int getTabSize ( JTextComponent text ) {
Integer tabs = ( Integer ) text . getDocument ( ) . getProperty ( PlainDocument . tabSizeAttribute ) ;
return ( null == tabs ) ? <num> : tabs . intValue ( ) ;
}
public static void insertMagicString ( JTextComponent target , int dot , String toInsert )
throws BadLocationException {
Document doc = target . getDocument ( ) ;
if ( toInsert . indexOf ( |' ) >= <num> ) {
int ofst = toInsert . indexOf ( |' ) ;
int ofst2 = toInsert . indexOf ( |' , ofst + <num> ) ;
toInsert = toInsert . replace ( " , " ) ;
doc . insertString ( dot , toInsert , null ) ;
dot = target . getCaretPosition ( ) ;
final int strLength = toInsert . length ( ) ;
if ( ofst2 > <num> ) {
target . select ( dot + ofst  strLength , dot + ofst2  strLength  <num> ) ;
} else {
target . setCaretPosition ( dot + ofst  strLength ) ;
}
} else {
doc . insertString ( dot , toInsert , null ) ;
}
}
static String [ ] EMPTY_STRING_ARRAY = new String [ <num> ] ;
static String SPACES = " ;
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import java . awt . event . KeyEvent ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . util . Configuration ;
public class DuplicateLinesAction extends TextAction implements SyntaxAction {
public DuplicateLinesAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
try {
SyntaxDocument sDoc = ( SyntaxDocument ) target . getDocument ( ) ;
int st = sDoc . getLineStartOffset ( target . getSelectionStart ( ) ) ;
int en = sDoc . getLineEndOffset ( target . getSelectionEnd ( ) ) ;
String dupLines = sDoc . getText ( st , en  st ) ;
sDoc . insertString ( st , dupLines , null ) ;
} catch ( BadLocationException ex ) {
Logger . getLogger ( DuplicateLinesAction . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ;
}
}
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . util . Configuration ;
public class JIndentAction extends TextAction implements SyntaxAction {
public JIndentAction ( ) {
super ( " ) ;
}
@Override
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
SyntaxDocument sDoc = ActionUtils . getSyntaxDocument ( target ) ;
int pos = target . getCaretPosition ( ) ;
int start = sDoc . getParagraphElement ( pos ) . getStartOffset ( ) ;
String line = ActionUtils . getLine ( target ) ;
String lineToPos = line . substring ( <num> , pos  start ) ;
String prefix = ActionUtils . getIndent ( line ) ;
int tabSize = ActionUtils . getTabSize ( target ) ;
if ( lineToPos . trim ( ) . endsWith ( " ) ) {
prefix += ActionUtils . SPACES . substring ( <num> , tabSize ) ;
} else {
String noComment = sDoc . getUncommentedText ( start , pos ) ;
if ( noComment . trim ( ) . endsWith ( " ) ) {
prefix += ActionUtils . SPACES . substring ( <num> , tabSize ) ;
}
}
target . replaceSelection ( " + prefix ) ;
}
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . lexers . JavaScriptLexer ;
public class JavaScriptSyntaxKit extends DefaultSyntaxKit {
public JavaScriptSyntaxKit ( ) {
super ( new JavaScriptLexer ( ) ) ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import java . util . regex . Matcher ;
import java . util . regex . Pattern ;
import javax . swing . JOptionPane ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . util . Configuration ;
public class FindReplaceActions implements SyntaxAction {
private Pattern pattern = null ;
private boolean wrap = true ;
private final FindDialogAction findDialogAction = new FindDialogAction ( ) ;
private final FindNextAction findNextAction = new FindNextAction ( ) ;
private ReplaceDialog dlg ;
public FindReplaceActions ( ) {
}
public TextAction <unk> ( ) {
return findDialogAction ;
}
public TextAction <unk> ( ) {
return findNextAction ;
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
if ( key . equals ( " ) ) {
return findDialogAction ;
} else if ( key . equals ( " ) ) {
return findDialogAction ;
} else if ( key . equals ( " ) ) {
return findNextAction ;
} else {
throw new IllegalArgumentException ( " + key ) ;
}
}
class FindDialogAction extends TextAction {
public FindDialogAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
showDialog ( target ) ;
}
}
}
class FindNextAction extends TextAction {
public FindNextAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
if ( pattern == null ) {
return ;
}
JTextComponent target = getTextComponent ( e ) ;
doFindNext ( target ) ;
}
}
public void msgNotFound ( ) {
JOptionPane . showMessageDialog ( null ,
" + pattern + " ,
" , JOptionPane . INFORMATION_MESSAGE ) ;
}
private void showDialog ( JTextComponent target ) {
if ( dlg == null ) {
dlg = new ReplaceDialog ( target , FindReplaceActions . this ) ;
}
dlg . setVisible ( true ) ;
}
public void doFindNext ( JTextComponent target ) {
if ( target == null || pattern == null ) {
return ;
}
SyntaxDocument sDoc = ActionUtils . getSyntaxDocument ( target ) ;
if ( sDoc == null ) {
return ;
}
int start = target . getCaretPosition ( ) + <num> ;
if ( start >= sDoc . getLength ( ) ) {
start = <num> ;
}
Matcher matcher = sDoc . getMatcher ( pattern , start ) ;
if ( matcher != null && matcher . find ( ) ) {
target . select ( matcher . start ( ) + start , matcher . end ( ) + start ) ;
} else {
if ( isWrap ( ) ) {
matcher = sDoc . getMatcher ( pattern ) ;
if ( matcher != null && matcher . find ( ) ) {
target . select ( matcher . start ( ) , matcher . end ( ) ) ;
} else {
msgNotFound ( ) ;
}
} else {
msgNotFound ( ) ;
}
}
}
public void replaceAll ( JTextComponent target , String replacement ) {
SyntaxDocument sDoc = ActionUtils . getSyntaxDocument ( target ) ;
if ( pattern == null || sDoc == null ) {
return ;
}
Matcher matcher = sDoc . getMatcher ( pattern ) ;
String newText = matcher . replaceAll ( replacement ) ;
target . setText ( newText ) ;
}
public Pattern getPattern ( ) {
return pattern ;
}
public void setPattern ( Pattern pattern ) {
this . pattern = pattern ;
}
public boolean isWrap ( ) {
return wrap ;
}
public void setWrap ( boolean wrap ) {
this . wrap = wrap ;
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import javax . swing . text . DefaultEditorKit ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . PlainDocument ;
import javax . swing . text . TextAction ;
import jsyntaxpane . util . Configuration ;
public class IndentAction extends DefaultEditorKit . <unk>
implements SyntaxAction {
public IndentAction ( ) {
super ( ) ;
}
@Override
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
String selected = target . getSelectedText ( ) ;
if ( selected == null ) {
PlainDocument pDoc = ( PlainDocument ) target . getDocument ( ) ;
Integer tabStop = ( Integer ) pDoc . getProperty ( PlainDocument . tabSizeAttribute ) ;
int lineStart = pDoc . getParagraphElement ( target . getCaretPosition ( ) ) . getStartOffset ( ) ;
int column = target . getCaretPosition ( )  lineStart ;
int needed = tabStop  ( column % tabStop ) ;
target . replaceSelection ( ActionUtils . SPACES . substring ( <num> , needed ) ) ;
} else {
String [ ] lines = ActionUtils . getSelectedLines ( target ) ;
int start = target . getSelectionStart ( ) ;
StringBuilder sb = new StringBuilder ( ) ;
for ( String line : lines ) {
sb . append ( \t' ) ;
sb . append ( line ) ;
sb . append ( \n' ) ;
}
target . replaceSelection ( sb . toString ( ) ) ;
target . select ( start , start + sb . length ( ) ) ;
}
}
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . util ;
import java . awt . Color ;
import java . util . Properties ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import java . util . regex . Pattern ;
public class Configuration extends Properties {
public Configuration ( Properties defaults ) {
super ( defaults ) ;
}
private Configuration ( ) {
super ( ) ;
}
public String getPrefixProperty ( String prefix , String key , String Default ) {
String v = super . getProperty ( prefix + " + key ) ;
if ( v != null ) {
return v ;
}
return super . getProperty ( key , Default ) ;
}
public int getPrefixInteger ( String prefix , String key , int Default ) {
String v = getPrefixProperty ( prefix , key , null ) ;
if ( v == null ) {
return Default ;
}
try {
int i = Integer . decode ( v ) ;
return i ;
} catch ( NumberFormatException e ) {
LOG . log ( Level . WARNING , null , e ) ;
return Default ;
}
}
public String [ ] getPrefixPropertyList ( String prefix , String key ) {
String v = getProperty ( prefix + " + key ) ;
if ( v == null ) {
v = getProperty ( key ) ;
}
if ( v == null ) {
return EMPTY_LIST ;
}
return COMMA_SEPARATOR . split ( v ) ;
}
public boolean getPrefixBoolean ( String prefix , String key , boolean Default ) {
String b = getPrefixProperty ( prefix , key , null ) ;
if ( b == null ) {
return Default ;
}
return Boolean . parseBoolean ( b . trim ( ) ) ;
}
public Color getPrefixColor ( String prefix , String key , Color Default ) {
String c = getPrefixProperty ( prefix , key , null ) ;
if ( c == null ) {
return Default ;
}
try {
return Color . decode ( c ) ;
} catch ( NumberFormatException e ) {
return Default ;
}
}
public Configuration subConfig ( String prefix , String keyPrefix ) {
Configuration sub = new Configuration ( ) ;
addToSubConf ( sub , keyPrefix ) ;
addToSubConf ( sub , prefix + " + keyPrefix ) ;
return sub ;
}
private void addToSubConf ( Configuration subConf , String prefix ) {
int prefixLen = prefix . length ( ) ;
for ( String k : stringPropertyNames ( ) ) {
if ( k . startsWith ( prefix ) ) {
subConf . put ( k . substring ( prefixLen ) , getProperty ( k ) ) ;
}
}
}
public static final String [ ] EMPTY_LIST = new String [ <num> ] ;
public static final Pattern COMMA_SEPARATOR = Pattern . compile ( " ) ;
private static final Logger LOG = Logger . getLogger ( Configuration . class . getName ( ) ) ;
}
package jsyntaxpane ;
import java . awt . Color ;
import java . awt . Font ;
import java . awt . FontMetrics ;
import java . awt . Graphics ;
import javax . swing . text . Segment ;
import javax . swing . text . TabExpander ;
import javax . swing . text . Utilities ;
public final class SyntaxStyle {
private Color color ;
private int fontStyle ;
public SyntaxStyle ( ) {
super ( ) ;
}
public SyntaxStyle ( Color color , boolean bold , boolean italic ) {
super ( ) ;
this . color = color ;
setBold ( bold ) ;
setItalic ( italic ) ;
}
public SyntaxStyle ( Color color , int fontStyle ) {
super ( ) ;
this . color = color ;
this . fontStyle = fontStyle ;
}
SyntaxStyle ( String str ) {
String [ ] parts = str . split ( " ) ;
if ( parts . length != <num> ) {
throw new IllegalArgumentException ( " + str ) ;
}
this . color = new Color ( Integer . decode ( parts [ <num> ] ) ) ;
this . fontStyle = Integer . decode ( parts [ <num> ] ) ;
}
public boolean <unk> ( ) {
return ( fontStyle & Font . BOLD ) != <num> ;
}
public void setBold ( Boolean bold ) {
if ( bold ) {
fontStyle |= Font . BOLD ;
} else {
int mask =  <num> ^ Font . BOLD ;
fontStyle = ( fontStyle & ( mask ) ) ;
}
}
public String <unk> ( ) {
return String . format ( " , color . getRGB ( ) & <num> ) ;
}
public void <unk> ( String color ) {
this . color = Color . decode ( color ) ;
}
public Boolean <unk> ( ) {
return ( fontStyle & Font . ITALIC ) != <num> ;
}
public void setItalic ( Boolean italic ) {
if ( italic ) {
fontStyle |= Font . ITALIC ;
} else {
fontStyle = ( fontStyle & (  <num> ^ Font . ITALIC ) ) ;
}
}
public int getFontStyle ( ) {
return fontStyle ;
}
public Color getColor ( ) {
return color ;
}
public int drawText ( Segment segment , int x , int y ,
Graphics graphics , TabExpander e , int startOffset ) {
graphics . setFont ( graphics . getFont ( ) . deriveFont ( getFontStyle ( ) ) ) ;
FontMetrics fontMetrics = graphics . getFontMetrics ( ) ;
int a = fontMetrics . getAscent ( ) ;
int h = a + fontMetrics . getDescent ( ) ;
int w = Utilities . <unk> ( segment , fontMetrics , <num> , e , startOffset ) ;
int rX = x  <num> ;
int rY = y  a ;
int rW = w + <num> ;
int rH = h ;
if ( ( getFontStyle ( ) & <num> ) != <num> ) {
graphics . setColor ( Color . decode ( " ) ) ;
graphics . fillRect ( rX , rY , rW , rH ) ;
}
graphics . setColor ( getColor ( ) ) ;
x = Utilities . drawTabbedText ( segment , x , y , graphics , e , startOffset ) ;
if ( ( getFontStyle ( ) & <num> ) != <num> ) {
graphics . setColor ( Color . RED ) ;
graphics . drawRect ( rX , rY , rW , rH ) ;
}
return x ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . PlainDocument ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . util . Configuration ;
public class JavaIndentAction extends TextAction implements SyntaxAction {
public JavaIndentAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
String line = ActionUtils . getLine ( target ) ;
String prefix = ActionUtils . getIndent ( line ) ;
Integer tabSize = ( Integer ) target . getDocument ( ) . getProperty ( PlainDocument . tabSizeAttribute ) ;
if ( line . trim ( ) . endsWith ( " ) ) {
prefix += ActionUtils . SPACES . substring ( <num> , tabSize ) ;
}
SyntaxDocument sDoc = ActionUtils . getSyntaxDocument ( target ) ;
if ( sDoc != null && line . trim ( ) . equals ( " ) ) {
int pos = target . getCaretPosition ( ) ;
int start = sDoc . getParagraphElement ( pos ) . getStartOffset ( ) ;
int end = sDoc . getParagraphElement ( pos ) . getEndOffset ( ) ;
if ( end >= sDoc . getLength ( ) ) {
end  ;
}
if ( line . startsWith ( ActionUtils . SPACES . substring ( <num> , tabSize ) ) ) {
try {
sDoc . replace ( start , end  start , line . substring ( tabSize ) + " , null ) ;
} catch ( BadLocationException ex ) {
Logger . getLogger ( ActionUtils . class . getName ( ) ) . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ;
}
} else {
target . replaceSelection ( " + prefix ) ;
}
} else {
target . replaceSelection ( " + prefix ) ;
}
}
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane ;
import java . io . Serializable ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . Document ;
public class Token implements Serializable , Comparable {
public final TokenType type ;
public final int start ;
public final int length ;
public final byte pairValue ;
public Token ( TokenType type , int start , int length ) {
this . type = type ;
this . start = start ;
this . length = length ;
this . pairValue = <num> ;
}
public Token ( TokenType type , int start , int length , byte pairValue ) {
this . type = type ;
this . start = start ;
this . length = length ;
this . pairValue = pairValue ;
}
@Override
public boolean equals ( Object obj ) {
if ( obj instanceof Object ) {
Token token = ( Token ) obj ;
return ( ( this . start == token . start ) &&
( this . length == token . length ) &&
( this . type . equals ( token . type ) ) ) ;
} else {
return false ;
}
}
@Override
public int hashCode ( ) {
return start ;
}
@Override
public String toString ( ) {
return String . format ( " , type , start , length , pairValue ) ;
}
@Override
public int compareTo ( Object o ) {
Token t = ( Token ) o ;
if ( this . start != t . start ) {
return ( this . start  t . start ) ;
} else if ( this . length != t . length ) {
return ( this . length  t . length ) ;
} else {
return this . type . compareTo ( t . type ) ;
}
}
public int end ( ) {
return start + length ;
}
public String getText ( Document doc ) {
String text = null ;
try {
text = doc . getText ( start , length ) ;
} catch ( BadLocationException ex ) {
Logger . getLogger ( Token . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ;
}
return text ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . util . Configuration ;
public class DeleteLinesAction extends TextAction implements SyntaxAction {
public DeleteLinesAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
try {
SyntaxDocument sDoc = ( SyntaxDocument ) target . getDocument ( ) ;
int st = sDoc . getLineStartOffset ( target . getSelectionStart ( ) ) ;
int en = sDoc . getLineEndOffset ( target . getSelectionEnd ( ) ) ;
sDoc . remove ( st , en  st ) ;
} catch ( BadLocationException ex ) {
Logger . getLogger ( DeleteLinesAction . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ;
}
}
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . util ;
import java . io . BufferedReader ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . InputStreamReader ;
import java . net . URL ;
import java . nio . charset . Charset ;
import java . util . ArrayList ;
import java . util . Enumeration ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
import java . util . Properties ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
public class JarServiceProvider {
private static final Logger LOG = Logger . getLogger ( JarServiceProvider . class . getName ( ) ) ;
private JarServiceProvider ( ) {
}
public static List < Object > <unk> ( Class cls ) throws IOException {
ArrayList < Object > l = new ArrayList < Object > ( ) ;
ClassLoader cl = JarServiceProvider . class . getClassLoader ( ) ;
cl = cl == null ? ClassLoader . getSystemClassLoader ( ) : cl ;
if ( cl != null ) {
String serviceFile = " + cls . getName ( ) ;
Enumeration < URL > e = cl . getResources ( serviceFile ) ;
while ( e . hasMoreElements ( ) ) {
URL u = e . nextElement ( ) ;
InputStream is = u . openStream ( ) ;
BufferedReader br = null ;
try {
br = new BufferedReader (
new InputStreamReader ( is , Charset . forName ( " ) ) ) ;
String str = null ;
while ( ( str = br . readLine ( ) ) != null ) {
int commentStartIdx = str . indexOf ( " ) ;
if ( commentStartIdx !=  <num> ) {
str = str . substring ( <num> , commentStartIdx ) ;
}
str = str . trim ( ) ;
if ( str . length ( ) == <num> ) {
continue ;
}
try {
Object obj = cl . loadClass ( str ) . newInstance ( ) ;
l . add ( obj ) ;
} catch ( Exception ex ) {
LOG . warning ( " + str ) ;
LOG . warning ( ex . getMessage ( ) ) ;
}
}
} finally {
if ( br != null ) {
br . close ( ) ;
}
}
}
}
return l ;
}
public static Properties readProperties ( Class clazz ) {
return readProperties ( clazz . getName ( ) ) ;
}
public static Properties readProperties ( String name ) {
ClassLoader cl = JarServiceProvider . class . getClassLoader ( ) ;
cl = cl == null ? ClassLoader . getSystemClassLoader ( ) : cl ;
Properties props = new Properties ( ) ;
if ( cl != null ) {
InputStream is = null ;
try {
String serviceFile = " +
name . toLowerCase ( ) + " ;
URL loc = cl . getResource ( serviceFile ) ;
if ( loc != null ) {
is = loc . openStream ( ) ;
props . load ( is ) ;
}
} catch ( IOException ex ) {
LOG . log ( Level . SEVERE , null , ex ) ;
} finally {
try {
if ( is != null ) {
is . close ( ) ;
}
} catch ( IOException ex ) {
LOG . log ( Level . SEVERE , null , ex ) ;
}
}
}
return props ;
}
public static Map < String , String > readStringsMap ( String name ) {
Properties props = readProperties ( name ) ;
HashMap < String , String > map = new HashMap < String , String > ( ) ;
if ( props != null ) {
for ( Map . Entry e : props . entrySet ( ) ) {
map . put ( e . getKey ( ) . toString ( ) , e . getValue ( ) . toString ( ) ) ;
}
}
return map ;
}
}
package jsyntaxpane . actions ;
import java . awt . Font ;
import java . awt . event . KeyEvent ;
import java . util . Vector ;
import javax . swing . event . DocumentEvent ;
import javax . swing . event . DocumentListener ;
public class ComboCompletionDialog extends javax . swing . JDialog {
private String result = null ;
public String escapeChars = " ;
public String [ ] items ;
public ComboCompletionDialog ( java . awt . Frame parent , boolean modal ,
String [ ] items ) {
super ( parent , modal ) ;
initComponents ( ) ;
this . items = items ;
jLstItems . setListData ( items ) ;
jTxtItem . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) {
public void insertUpdate ( DocumentEvent e ) {
refilterList ( ) ;
}
public void removeUpdate ( DocumentEvent e ) {
refilterList ( ) ;
}
public void changedUpdate ( DocumentEvent e ) {
refilterList ( ) ;
}
} ) ;
jTxtItem . <unk> ( false ) ;
}
public void setFonts ( Font font ) {
jTxtItem . setFont ( font ) ;
jLstItems . setFont ( font ) ;
doLayout ( ) ;
}
public void setText ( String abbrev ) {
jTxtItem . setText ( abbrev ) ;
}
private void refilterList ( ) {
String prefix = jTxtItem . getText ( ) ;
Vector < String > filtered = new Vector < String > ( ) ;
Object selected = jLstItems . getSelectedValue ( ) ;
for ( String s : items ) {
if ( s . startsWith ( prefix ) ) {
filtered . add ( s ) ;
}
}
jLstItems . setListData ( filtered ) ;
if ( selected != null ) {
jLstItems . setSelectedValue ( selected , true ) ;
} else {
jLstItems . setSelectedIndex ( <num> ) ;
}
}
@SuppressWarnings("unchecked")
private void initComponents ( ) {
jTxtItem = new javax . swing . JTextField ( ) ;
jScrollPane1 = new javax . swing . JScrollPane ( ) ;
jLstItems = new javax . swing . JList ( ) ;
setDefaultCloseOperation ( javax . swing . WindowConstants . DISPOSE_ON_CLOSE ) ;
setResizable ( false ) ;
setUndecorated ( true ) ;
jTxtItem . setBorder ( null ) ;
jTxtItem . addKeyListener ( new java . awt . event . KeyAdapter ( ) {
public void keyPressed ( java . awt . event . KeyEvent evt ) {
jTxtItemKeyPressed ( evt ) ;
}
} ) ;
jLstItems . setSelectionMode ( javax . swing . ListSelectionModel . SINGLE_SELECTION ) ;
jLstItems . setFocusable ( false ) ;
jScrollPane1 . setViewportView ( jLstItems ) ;
javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ;
getContentPane ( ) . setLayout ( layout ) ;
layout . setHorizontalGroup (
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addComponent ( jTxtItem , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addComponent ( jScrollPane1 , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
) ;
layout . setVerticalGroup (
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( layout . createSequentialGroup ( )
. addComponent ( jTxtItem , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE )
. addGap ( <num> , <num> , <num> )
. addComponent ( jScrollPane1 , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE ) )
) ;
pack ( ) ;
}
private void jTxtItemKeyPressed ( java . awt . event . KeyEvent evt ) {
int i = jLstItems . getSelectedIndex ( ) ;
switch ( evt . getKeyCode ( ) ) {
case KeyEvent . VK_ESCAPE :
result = jTxtItem . getText ( ) ;
setVisible ( false ) ;
return ;
case KeyEvent . VK_DOWN :
if ( i < jLstItems . getModel ( ) . getSize ( )  <num> ) {
i ++ ;
}
jLstItems . setSelectedIndex ( i ) ;
jLstItems . ensureIndexIsVisible ( i ) ;
break ;
case KeyEvent . VK_UP :
if ( i > <num> ) {
i  ;
}
jLstItems . setSelectedIndex ( i ) ;
jLstItems . ensureIndexIsVisible ( i ) ;
break ;
}
if ( escapeChars . indexOf ( evt . getKeyChar ( ) ) >= <num> ) {
if ( jLstItems . getSelectedIndex ( ) >= <num> ) {
result = jLstItems . getSelectedValue ( ) . toString ( ) ;
} else {
result = jTxtItem . getText ( ) ;
}
char pressed = evt . getKeyChar ( ) ;
if ( pressed != \n' ) {
result += ( pressed == \t' ) ?  ' : pressed ;
}
setVisible ( false ) ;
}
}
public String getResult ( ) {
return result == null ? " : result ;
}
private javax . swing . JList jLstItems ;
private javax . swing . JScrollPane jScrollPane1 ;
private javax . swing . JTextField jTxtItem ;
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . lexers . RubyLexer ;
public class RubySyntaxKit extends DefaultSyntaxKit {
public RubySyntaxKit ( ) {
super ( new RubyLexer ( ) ) ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . util . Configuration ;
public class RedoAction extends TextAction implements SyntaxAction {
public RedoAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
if ( target . getDocument ( ) instanceof SyntaxDocument ) {
SyntaxDocument sDoc = ( SyntaxDocument ) target . getDocument ( ) ;
sDoc . doRedo ( ) ;
}
}
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . lexers . PythonLexer ;
public class PythonSyntaxKit extends DefaultSyntaxKit {
public PythonSyntaxKit ( ) {
super ( new PythonLexer ( ) ) ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import java . util . WeakHashMap ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . util . Configuration ;
public class GotoLineAction extends TextAction implements SyntaxAction {
private static WeakHashMap < JTextComponent , GotoLineDialog > DIALOGS =
new WeakHashMap < JTextComponent , GotoLineDialog > ( ) ;
public GotoLineAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
GotoLineDialog dlg = DIALOGS . get ( target ) ;
if ( dlg == null ) {
dlg = new GotoLineDialog ( target ) ;
DIALOGS . put ( target , dlg ) ;
}
dlg . setVisible ( true ) ;
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . util . Configuration ;
public class UndoAction extends TextAction implements SyntaxAction {
public UndoAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
if ( target . getDocument ( ) instanceof SyntaxDocument ) {
SyntaxDocument sDoc = ( SyntaxDocument ) target . getDocument ( ) ;
sDoc . doUndo ( ) ;
}
}
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane ;
public enum TokenType {
OPERATOR ,
KEYWORD ,
<unk> ,
IDENTIFIER ,
NUMBER ,
STRING ,
<unk> ,
COMMENT ,
COMMENT2 ,
<unk> ,
<unk> ,
TYPE ,
<unk> ,
<unk> ,
DEFAULT ,
WARNING ,
ERROR
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . lexers . XmlLexer ;
public class XmlSyntaxKit extends DefaultSyntaxKit {
public XmlSyntaxKit ( ) {
super ( new XmlLexer ( ) ) ;
}
}
package jsyntaxpane . actions ;
import javax . swing . text . TextAction ;
import jsyntaxpane . util . Configuration ;
public interface SyntaxAction {
public void config ( Configuration config , String prefix , String name ) ;
public TextAction getAction ( String name ) ;
}
package jsyntaxpane . components ;
import javax . swing . JEditorPane ;
import jsyntaxpane . util . Configuration ;
public interface SyntaxComponent {
public void config ( Configuration config , String prefix ) ;
public void install ( JEditorPane editor ) ;
public void deinstall ( JEditorPane editor ) ;
}
package jsyntaxpane . actions ;
import java . awt . Frame ;
import java . awt . Point ;
import java . awt . Rectangle ;
import java . awt . event . ActionEvent ;
import java . util . Map ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import javax . swing . SwingUtilities ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . Token ;
import jsyntaxpane . util . Configuration ;
public class ComboCompletionAction extends TextAction implements SyntaxAction {
Map < String , String > completions ;
ComboCompletionDialog dlg ;
private String [ ] items ;
public ComboCompletionAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null && target . getDocument ( ) instanceof SyntaxDocument ) {
SyntaxDocument sDoc = ( SyntaxDocument ) target . getDocument ( ) ;
int dot = target . getCaretPosition ( ) ;
Token token = sDoc . getTokenAt ( dot ) ;
String abbrev = " ;
try {
if ( token != null ) {
abbrev = token . getText ( sDoc ) ;
sDoc . remove ( token . start , token . length ) ;
dot = token . start ;
}
Frame frame = ActionUtils . getFrameFor ( target ) ;
if ( dlg == null ) {
dlg = new ComboCompletionDialog ( frame , true , items ) ;
}
dlg . setLocationRelativeTo ( frame ) ;
Point p = frame . getLocation ( ) ;
Rectangle rt = target . modelToView ( dot ) ;
Point loc = new Point ( rt . x , rt . y ) ;
loc = SwingUtilities . convertPoint ( target , loc , frame ) ;
SwingUtilities . <unk> ( loc , frame ) ;
dlg . setLocation ( loc ) ;
dlg . setFonts ( target . getFont ( ) ) ;
dlg . setText ( abbrev ) ;
dlg . setVisible ( true ) ;
String res = dlg . getResult ( ) ;
ActionUtils . insertMagicString ( target , dot , res ) ;
} catch ( BadLocationException ex ) {
Logger . getLogger ( ComboCompletionAction . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ;
}
}
}
public void config ( Configuration config , String prefix , String name ) {
items = config . getPrefixPropertyList ( prefix , name + " ) ;
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . lexers . BashLexer ;
public class BashSyntaxKit extends DefaultSyntaxKit {
public BashSyntaxKit ( ) {
super ( new BashLexer ( ) ) ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . lexers . CppLexer ;
public class CppSyntaxKit extends CSyntaxKit {
public CppSyntaxKit ( ) {
super ( new CppLexer ( ) ) ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . lexers . SqlLexer ;
public class SqlSyntaxKit extends DefaultSyntaxKit {
public SqlSyntaxKit ( ) {
super ( new SqlLexer ( ) ) ;
}
}
package jsyntaxpane ;
public abstract class <unk> implements Lexer {
protected int tokenStart ;
protected int tokenLength ;
protected Token token ( TokenType type , int tStart , int tLength ,
int newStart , int newLength ) {
tokenStart = newStart ;
tokenLength = newLength ;
return new Token ( type , tStart , tLength ) ;
}
protected CharSequence <unk> ( ) {
return yytext ( ) ;
}
}
package jsyntaxpane . components ;
import java . awt . * ;
import java . awt . event . MouseAdapter ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseListener ;
import java . beans . PropertyChangeEvent ;
import java . beans . PropertyChangeListener ;
import java . util . logging . Logger ;
import javax . swing . * ;
import javax . swing . event . DocumentEvent ;
import javax . swing . event . DocumentListener ;
import javax . swing . text . JTextComponent ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . actions . GotoLineDialog ;
import jsyntaxpane . actions . ActionUtils ;
import jsyntaxpane . util . Configuration ;
public class LineNumbersRuler extends JComponent
implements SyntaxComponent , PropertyChangeListener , DocumentListener {
public static final String PROPERTY_BACKGROUND = " ;
public static final String PROPERTY_FOREGROUND = " ;
public static final String PROPERTY_LEFT_MARGIN = " ;
public static final String PROPERTY_RIGHT_MARGIN = " ;
public static final int DEFAULT_R_MARGIN = <num> ;
public static final int DEFAULT_L_MARGIN = <num> ;
private JEditorPane pane ;
private String format ;
private int lineCount =  <num> ;
private int r_margin ;
private int l_margin ;
private int charHeight ;
private int charWidth ;
private GotoLineDialog gotoLineDialog = null ;
private MouseListener mouseListener = null ;
static enum Status {
INSTALLING ,
DEINSTALLING
}
private Status status ;
public LineNumbersRuler ( ) {
super ( ) ;
}
@Override
protected void paintComponent ( Graphics g ) {
g . setFont ( pane . getFont ( ) ) ;
Rectangle clip = g . getClipBounds ( ) ;
g . setColor ( getBackground ( ) ) ;
g . fillRect ( clip . x , clip . y , clip . width , clip . height ) ;
g . setColor ( getForeground ( ) ) ;
int lh = charHeight ;
int end = clip . y + clip . height + lh ;
int lineNum = clip . y / lh + <num> ;
for ( int y = ( clip . y / lh ) * lh + lh  <num> ; y <= end ; y += lh ) {
String text = String . format ( format , lineNum ) ;
g . drawString ( text , l_margin , y ) ;
lineNum ++ ;
if ( lineNum > lineCount ) {
break ;
}
}
}
private void updateSize ( ) {
int newLineCount = ActionUtils . getLineCount ( pane ) ;
if ( newLineCount == lineCount ) {
return ;
}
lineCount = newLineCount ;
int h = lineCount * charHeight + pane . getHeight ( ) ;
int d = ( int ) Math . log10 ( lineCount ) + <num> ;
if ( d < <num> ) {
d = <num> ;
}
int w = d * charWidth + r_margin + l_margin ;
format = " + d + " ;
setPreferredSize ( new Dimension ( w , h ) ) ;
if ( getParent ( ) != null ) {
getParent ( ) . doLayout ( ) ;
}
}
public JScrollPane getScrollPane ( JTextComponent editorPane ) {
Container p = editorPane . getParent ( ) ;
while ( p != null ) {
if ( p instanceof JScrollPane ) {
return ( JScrollPane ) p ;
}
p = p . getParent ( ) ;
}
return null ;
}
public void config ( Configuration config , String prefix ) {
r_margin = config . getPrefixInteger ( prefix ,
PROPERTY_RIGHT_MARGIN , DEFAULT_R_MARGIN ) ;
l_margin = config . getPrefixInteger ( prefix ,
PROPERTY_LEFT_MARGIN , DEFAULT_L_MARGIN ) ;
Color foreground = config . getPrefixColor ( prefix ,
PROPERTY_FOREGROUND ,
Color . BLACK ) ;
setForeground ( foreground ) ;
Color back = config . getPrefixColor ( prefix ,
PROPERTY_BACKGROUND ,
Color . WHITE ) ;
setBackground ( back ) ;
}
public void install ( JEditorPane editor ) {
this . pane = editor ;
charHeight = pane . getFontMetrics ( pane . getFont ( ) ) . getHeight ( ) ;
charWidth = pane . getFontMetrics ( pane . getFont ( ) ) . charWidth ( <num>  ) ;
editor . addPropertyChangeListener ( this ) ;
JScrollPane sp = getScrollPane ( pane ) ;
if ( sp == null ) {
Logger . getLogger ( this . getClass ( ) . getName ( ) ) . warning (
" +
" ) ;
} else {
sp . setRowHeaderView ( this ) ;
this . pane . getDocument ( ) . addDocumentListener ( this ) ;
updateSize ( ) ;
gotoLineDialog = new GotoLineDialog ( pane ) ;
mouseListener = new MouseAdapter ( ) {
@Override
public void mouseClicked ( MouseEvent e ) {
gotoLineDialog . setVisible ( true ) ;
}
} ;
addMouseListener ( mouseListener ) ;
}
status = Status . INSTALLING ;
}
public void deinstall ( JEditorPane editor ) {
removeMouseListener ( mouseListener ) ;
status = Status . DEINSTALLING ;
JScrollPane sp = getScrollPane ( editor ) ;
if ( sp != null ) {
editor . getDocument ( ) . removeDocumentListener ( this ) ;
sp . setRowHeaderView ( null ) ;
}
}
public void propertyChange ( PropertyChangeEvent evt ) {
if ( evt . getPropertyName ( ) . equals ( " ) ) {
if ( evt . getOldValue ( ) instanceof SyntaxDocument ) {
SyntaxDocument syntaxDocument = ( SyntaxDocument ) evt . getOldValue ( ) ;
syntaxDocument . removeDocumentListener ( this ) ;
}
if ( evt . getNewValue ( ) instanceof SyntaxDocument && status . equals ( Status . INSTALLING ) ) {
SyntaxDocument syntaxDocument = ( SyntaxDocument ) evt . getNewValue ( ) ;
syntaxDocument . addDocumentListener ( this ) ;
}
} else if ( evt . getPropertyName ( ) . equals ( " ) ) {
charHeight = pane . getFontMetrics ( pane . getFont ( ) ) . getHeight ( ) ;
charWidth = pane . getFontMetrics ( pane . getFont ( ) ) . charWidth ( <num>  ) ;
}
}
public void insertUpdate ( DocumentEvent e ) {
updateSize ( ) ;
}
public void removeUpdate ( DocumentEvent e ) {
updateSize ( ) ;
}
public void changedUpdate ( DocumentEvent e ) {
updateSize ( ) ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import java . util . HashMap ;
import java . util . Map ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . util . Configuration ;
public class PairAction extends TextAction implements SyntaxAction {
public PairAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
String left = e . getActionCommand ( ) ;
String right = PAIRS . get ( left ) ;
String selected = target . getSelectedText ( ) ;
if ( selected != null ) {
target . replaceSelection ( left + selected + right ) ;
} else {
target . replaceSelection ( left + right ) ;
}
target . setCaretPosition ( target . getCaretPosition ( )  <num> ) ;
}
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
private static Map < String , String > PAIRS = new HashMap < String , String > ( <num> ) ;
static {
PAIRS . put ( " , " ) ;
PAIRS . put ( " , " ) ;
PAIRS . put ( " , " ) ;
PAIRS . put ( " , " ) ;
}
}
package jsyntaxpane ;
import java . awt . Color ;
import java . util . logging . Level ;
import java . awt . Font ;
import java . awt . GraphicsEnvironment ;
import java . util . ArrayList ;
import java . util . Arrays ;
import java . util . HashMap ;
import java . util . HashSet ;
import java . util . List ;
import java . util . Map ;
import java . util . Properties ;
import java . util . Set ;
import java . util . logging . Logger ;
import java . util . regex . Pattern ;
import javax . swing . JEditorPane ;
import javax . swing . KeyStroke ;
import javax . swing . text . DefaultEditorKit ;
import javax . swing . text . Document ;
import javax . swing . text . Element ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . Keymap ;
import javax . swing . text . TextAction ;
import javax . swing . text . View ;
import javax . swing . text . ViewFactory ;
import jsyntaxpane . actions . SyntaxAction ;
import jsyntaxpane . components . SyntaxComponent ;
import jsyntaxpane . util . Configuration ;
import jsyntaxpane . util . JarServiceProvider ;
public class DefaultSyntaxKit extends DefaultEditorKit implements ViewFactory {
public static Font DEFAULT_FONT ;
private static Set < String > CONTENTS = new HashSet < String > ( ) ;
private static boolean initialized = false ;
private Lexer lexer ;
private static final Logger LOG = Logger . getLogger ( DefaultSyntaxKit . class . getName ( ) ) ;
public static final Pattern <unk> = Pattern . compile ( " ) ;
private List < SyntaxComponent > editorComponents = new ArrayList < SyntaxComponent > ( ) ;
private Map < String , SyntaxAction > editorActions = new HashMap < String , SyntaxAction > ( ) ;
private static Configuration CONFIG ;
static {
initKit ( ) ;
}
public DefaultSyntaxKit ( Lexer lexer ) {
super ( ) ;
this . lexer = lexer ;
}
@Override
public ViewFactory <unk> ( ) {
return this ;
}
@Override
public View create ( Element element ) {
return new SyntaxView ( element , CONFIG , this . getClass ( ) . getSimpleName ( ) ) ;
}
@Override
public void install ( JEditorPane editorPane ) {
super . install ( editorPane ) ;
editorPane . setFont ( DEFAULT_FONT ) ;
Keymap km_parent = JTextComponent . <unk> ( JTextComponent . <unk> ) ;
Keymap km_new = JTextComponent . <unk> ( null , km_parent ) ;
String kitName = this . getClass ( ) . getSimpleName ( ) ;
Color caretColor = CONFIG . getPrefixColor ( kitName , " , Color . BLACK ) ;
editorPane . <unk> ( caretColor ) ;
addSyntaxActions ( km_new , kitName ) ;
editorPane . <unk> ( km_new ) ;
String [ ] components = CONFIG . getPrefixPropertyList ( kitName , " ) ;
for ( String c : components ) {
try {
@SuppressWarnings("unchecked")
Class < SyntaxComponent > compClass = ( Class < SyntaxComponent > ) Class . forName ( c ) ;
SyntaxComponent comp = compClass . newInstance ( ) ;
comp . config ( CONFIG , kitName ) ;
comp . install ( editorPane ) ;
editorComponents . add ( comp ) ;
} catch ( InstantiationException ex ) {
LOG . log ( Level . SEVERE , null , ex ) ;
} catch ( IllegalAccessException ex ) {
LOG . log ( Level . SEVERE , null , ex ) ;
} catch ( ClassNotFoundException ex ) {
LOG . log ( Level . SEVERE , null , ex ) ;
}
}
}
@Override
public void deinstall ( JEditorPane editorPane ) {
for ( SyntaxComponent c : editorComponents ) {
c . deinstall ( editorPane ) ;
}
editorComponents . clear ( ) ;
}
public void addSyntaxActions ( Keymap map , String prefix ) {
Configuration actionsConf = CONFIG . subConfig ( prefix , " ) ;
for ( String actionName : actionsConf . stringPropertyNames ( ) ) {
String [ ] values = Configuration . COMMA_SEPARATOR . split (
actionsConf . getProperty ( actionName ) ) ;
String actionClass = values [ <num> ] ;
SyntaxAction action = editorActions . get ( actionClass ) ;
if ( action == null ) {
action = createAction ( actionClass ) ;
action . config ( CONFIG , prefix , actionName ) ;
}
String keyStrokeString = values [ <num> ] ;
KeyStroke ks = KeyStroke . getKeyStroke ( keyStrokeString ) ;
if ( ks == null ) {
throw new IllegalArgumentException ( " +
keyStrokeString ) ;
}
TextAction ta = action . getAction ( actionName ) ;
if ( ta == null ) {
throw new IllegalArgumentException ( " +
actionName ) ;
}
map . <unk> ( ks , ta ) ;
}
}
private SyntaxAction createAction ( String actionClassName ) {
SyntaxAction action = null ;
try {
Class clazz = Class . forName ( actionClassName ) ;
action = ( SyntaxAction ) clazz . newInstance ( ) ;
editorActions . put ( actionClassName , action ) ;
} catch ( InstantiationException ex ) {
throw new IllegalArgumentException ( " +
actionClassName , ex ) ;
} catch ( IllegalAccessException ex ) {
throw new IllegalArgumentException ( " +
actionClassName , ex ) ;
} catch ( ClassNotFoundException ex ) {
throw new IllegalArgumentException ( " +
actionClassName , ex ) ;
} catch ( ClassCastException ex ) {
throw new IllegalArgumentException ( " +
actionClassName , ex ) ;
}
return action ;
}
@Override
public Document <unk> ( ) {
return new SyntaxDocument ( lexer ) ;
}
public static void initKit ( ) {
CONFIG = new Configuration ( JarServiceProvider . readProperties ( " ) ) ;
GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ;
String [ ] fonts = ge . getAvailableFontFamilyNames ( ) ;
Arrays . sort ( fonts ) ;
if ( Arrays . binarySearch ( fonts , " ) >= <num> ) {
DEFAULT_FONT = new Font ( " , Font . PLAIN , <num> ) ;
} else if ( Arrays . binarySearch ( fonts , " ) >= <num> ) {
DEFAULT_FONT = new Font ( " , Font . PLAIN , <num> ) ;
} else if ( Arrays . binarySearch ( fonts , " ) >= <num> ) {
DEFAULT_FONT = new Font ( " , Font . PLAIN , <num> ) ;
}
Properties kitsForTypes = JarServiceProvider . readProperties ( " ) ;
for ( String type : kitsForTypes . stringPropertyNames ( ) ) {
String classname = kitsForTypes . getProperty ( type ) ;
registerContentType ( type , classname ) ;
}
initialized = true ;
}
public static void registerContentType ( String type , String classname ) {
JEditorPane . <unk> ( type , classname ) ;
CONTENTS . add ( type ) ;
}
public static String [ ] getContentTypes ( ) {
String [ ] types = CONTENTS . toArray ( new String [ <num> ] ) ;
Arrays . sort ( types ) ;
return types ;
}
public static Configuration getConfig ( ) {
if ( ! initialized ) {
initKit ( ) ;
}
return CONFIG ;
}
public static void setConfig ( Properties config ) {
DefaultSyntaxKit . CONFIG . putAll ( config ) ;
}
public static void setProperty ( String key , String value ) {
if ( ! initialized ) {
initKit ( ) ;
}
CONFIG . put ( key , value ) ;
}
public static String getProperty ( String key ) {
if ( ! initialized ) {
initKit ( ) ;
}
return CONFIG . getProperty ( key ) ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ContainerEvent ;
import java . awt . event . KeyEvent ;
import jsyntaxpane . components . Markers ;
import java . awt . Color ;
import java . awt . Component ;
import java . awt . Container ;
import java . awt . HeadlessException ;
import java . awt . event . ContainerListener ;
import java . awt . event . KeyListener ;
import java . util . regex . Pattern ;
import java . util . regex . PatternSyntaxException ;
import javax . swing . JOptionPane ;
import javax . swing . event . CaretEvent ;
import javax . swing . event . CaretListener ;
import javax . swing . text . JTextComponent ;
public class ReplaceDialog extends javax . swing . JDialog implements CaretListener , KeyListener , ContainerListener {
private JTextComponent textComponent ;
private FindReplaceActions finder ;
private static Markers . SimpleMarker SEARCH_MARKER = new Markers . SimpleMarker ( Color . YELLOW ) ;
public ReplaceDialog ( JTextComponent text ,
FindReplaceActions finderActions ) {
super ( ActionUtils . getFrameFor ( text ) , false ) ;
initComponents ( ) ;
registerKeyAction ( this ) ;
textComponent = text ;
finder = finderActions ;
textComponent . addCaretListener ( this ) ;
setLocationRelativeTo ( text . getRootPane ( ) ) ;
}
public void updateHighlights ( ) {
Markers . removeMarkers ( textComponent , SEARCH_MARKER ) ;
if ( jTglHighlight . isSelected ( ) ) {
Markers . markAll ( textComponent , finder . getPattern ( ) , SEARCH_MARKER ) ;
}
}
private void showRegexpError ( PatternSyntaxException ex ) throws HeadlessException {
JOptionPane . showMessageDialog ( this , " + ex . getMessage ( ) ,
" , JOptionPane . ERROR_MESSAGE ) ;
jCmbFind . requestFocus ( ) ;
}
private void updateFinder ( ) {
int flag = <num> ;
if ( ! jChkRegex . isSelected ( ) ) {
flag |= Pattern . LITERAL ;
}
flag |= ( jChkIgnoreCase . isSelected ( ) ) ? Pattern . CASE_INSENSITIVE : <num> ;
if ( jChkIgnoreCase . isSelected ( ) ) {
flag |= Pattern . CASE_INSENSITIVE ;
}
String regex = ( String ) jCmbFind . getSelectedItem ( ) ;
if ( regex != null && regex . length ( ) > <num> ) {
Pattern pattern = Pattern . compile ( regex , flag ) ;
finder . setWrap ( jChkWrap . isSelected ( ) ) ;
finder . setPattern ( pattern ) ;
ActionUtils . insertIntoCombo ( jCmbFind , regex ) ;
} else {
finder . setPattern ( null ) ;
}
}
@SuppressWarnings("unchecked")
private void initComponents ( ) {
jLabel1 = new javax . swing . JLabel ( ) ;
jBtnNext = new javax . swing . JButton ( ) ;
jLblStatus = new javax . swing . JLabel ( ) ;
jBtnReplaceAll = new javax . swing . JButton ( ) ;
jChkWrap = new javax . swing . JCheckBox ( ) ;
jChkRegex = new javax . swing . JCheckBox ( ) ;
jChkIgnoreCase = new javax . swing . JCheckBox ( ) ;
jLabel2 = new javax . swing . JLabel ( ) ;
jTglHighlight = new javax . swing . JToggleButton ( ) ;
jCmbReplace = new javax . swing . JComboBox ( ) ;
jCmbFind = new javax . swing . JComboBox ( ) ;
setTitle ( " ) ;
setName ( " ) ;
setResizable ( false ) ;
jLabel1 . setText ( " ) ;
jBtnNext . setMnemonic ( N' ) ;
jBtnNext . setText ( " ) ;
jBtnNext . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
jBtnNextActionPerformed ( evt ) ;
}
} ) ;
jBtnReplaceAll . setMnemonic ( H' ) ;
jBtnReplaceAll . setText ( " ) ;
jBtnReplaceAll . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
jBtnReplaceAllActionPerformed ( evt ) ;
}
} ) ;
jChkWrap . setMnemonic ( W' ) ;
jChkWrap . setText ( " ) ;
jChkWrap . setToolTipText ( " ) ;
jChkRegex . setMnemonic ( R' ) ;
jChkRegex . setText ( " ) ;
jChkIgnoreCase . setMnemonic ( I' ) ;
jChkIgnoreCase . setText ( " ) ;
jLabel2 . setText ( " ) ;
jTglHighlight . setText ( " ) ;
jTglHighlight . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
jTglHighlightActionPerformed ( evt ) ;
}
} ) ;
jCmbReplace . setEditable ( true ) ;
jCmbFind . setEditable ( true ) ;
javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ;
getContentPane ( ) . setLayout ( layout ) ;
layout . setHorizontalGroup (
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( layout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING )
. addComponent ( jLabel2 )
. addComponent ( jLabel1 ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( layout . createSequentialGroup ( )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addComponent ( jChkRegex )
. addComponent ( jChkIgnoreCase ) )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( layout . createSequentialGroup ( )
. addGap ( <num> , <num> , <num> )
. addComponent ( jLblStatus , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addGap ( <num> , <num> , <num> ) )
. addGroup ( layout . createSequentialGroup ( )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addComponent ( jChkWrap , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) )
. addComponent ( jCmbFind , <num> , <num> , Short . MAX_VALUE )
. addComponent ( jCmbReplace , <num> , <num> , Short . MAX_VALUE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING )
. addComponent ( jBtnReplaceAll , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addComponent ( jBtnNext , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addComponent ( jTglHighlight , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE ) )
. addContainerGap ( ) )
) ;
layout . setVerticalGroup (
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( layout . createSequentialGroup ( )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( layout . createSequentialGroup ( )
. addGap ( <num> , <num> , <num> )
. addComponent ( jLblStatus ) )
. addGroup ( layout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( jLabel1 )
. addComponent ( jCmbFind , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addComponent ( jBtnNext ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( jLabel2 )
. addComponent ( jBtnReplaceAll )
. addComponent ( jCmbReplace , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( jChkRegex )
. addComponent ( jChkWrap , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE )
. addComponent ( jTglHighlight ) ) ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addComponent ( jChkIgnoreCase )
. addContainerGap ( ) )
) ;
pack ( ) ;
}
private void jBtnNextActionPerformed ( java . awt . event . ActionEvent evt ) {
try {
updateFinder ( ) ;
finder . doFindNext ( textComponent ) ;
textComponent . requestFocusInWindow ( ) ;
} catch ( PatternSyntaxException ex ) {
showRegexpError ( ex ) ;
}
}
private void jBtnReplaceAllActionPerformed ( java . awt . event . ActionEvent evt ) {
try {
updateFinder ( ) ;
String replacement = ( String ) jCmbReplace . getSelectedItem ( ) ;
ActionUtils . insertIntoCombo ( jCmbFind , replacement ) ;
finder . replaceAll ( textComponent , replacement ) ;
textComponent . requestFocusInWindow ( ) ;
} catch ( PatternSyntaxException ex ) {
showRegexpError ( ex ) ;
}
}
private void jTglHighlightActionPerformed ( java . awt . event . ActionEvent evt ) {
updateFinder ( ) ;
updateHighlights ( ) ;
}
private javax . swing . JButton jBtnNext ;
private javax . swing . JButton jBtnReplaceAll ;
private javax . swing . JCheckBox jChkIgnoreCase ;
private javax . swing . JCheckBox jChkRegex ;
private javax . swing . JCheckBox jChkWrap ;
private javax . swing . JComboBox jCmbFind ;
private javax . swing . JComboBox jCmbReplace ;
private javax . swing . JLabel jLabel1 ;
private javax . swing . JLabel jLabel2 ;
private javax . swing . JLabel jLblStatus ;
private javax . swing . JToggleButton jTglHighlight ;
public void caretUpdate ( CaretEvent e ) {
updateHighlights ( ) ;
}
public void keyTyped ( KeyEvent arg0 ) {
}
public void keyPressed ( KeyEvent e ) {
if ( e . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) {
this . setVisible ( false ) ;
}
}
public void keyReleased ( KeyEvent arg0 ) {
}
public void <unk> ( ContainerEvent e ) {
registerKeyAction ( e . getChild ( ) ) ;
}
public void <unk> ( ContainerEvent e ) {
registerKeyAction ( e . getChild ( ) ) ;
}
private void registerKeyAction ( Component c ) {
if ( c instanceof ReplaceDialog == false ) {
c . removeKeyListener ( this ) ;
c . addKeyListener ( this ) ;
}
if ( c instanceof Container ) {
Container cnt = ( Container ) c ;
cnt . <unk> ( this ) ;
cnt . <unk> ( this ) ;
Component [ ] ch = cnt . getComponents ( ) ;
for ( int i = <num> ; i < ch . length ; i ++ ) {
registerKeyAction ( ch [ i ] ) ;
}
}
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . lexers . JFlexLexer ;
public class JFlexSyntaxKit extends JavaSyntaxKit {
public JFlexSyntaxKit ( ) {
super ( new JFlexLexer ( ) ) ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . Lexer ;
import jsyntaxpane . lexers . ClojureLexer ;
public class ClojureSyntaxKit extends DefaultSyntaxKit {
public ClojureSyntaxKit ( ) {
super ( new ClojureLexer ( ) ) ;
}
public ClojureSyntaxKit ( Lexer lexer ) {
super ( lexer ) ;
}
}
package jsyntaxpane . actions ;
import javax . swing . JOptionPane ;
import javax . swing . text . JTextComponent ;
public class GotoLineDialog extends javax . swing . JDialog {
private JTextComponent text ;
public GotoLineDialog ( JTextComponent text ) {
super ( ActionUtils . getFrameFor ( text ) , false ) ;
initComponents ( ) ;
this . text = text ;
setLocationRelativeTo ( text . getRootPane ( ) ) ;
}
@SuppressWarnings("unchecked")
private void initComponents ( ) {
jCmbLineNumbers = new javax . swing . JComboBox ( ) ;
jBtnOk = new javax . swing . JButton ( ) ;
setTitle ( " ) ;
setModal ( true ) ;
setName ( " ) ;
setResizable ( false ) ;
jCmbLineNumbers . setEditable ( true ) ;
jCmbLineNumbers . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
jCmbLineNumbersActionPerformed ( evt ) ;
}
} ) ;
jBtnOk . setText ( " ) ;
jBtnOk . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
jBtnOkActionPerformed ( evt ) ;
}
} ) ;
javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ;
getContentPane ( ) . setLayout ( layout ) ;
layout . setHorizontalGroup (
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( layout . createSequentialGroup ( )
. addContainerGap ( )
. addComponent ( jCmbLineNumbers , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addComponent ( jBtnOk , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addContainerGap ( ) )
) ;
layout . setVerticalGroup (
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( layout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( jCmbLineNumbers , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE )
. addComponent ( jBtnOk ) )
. addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) )
) ;
pack ( ) ;
}
private void jBtnOkActionPerformed ( java . awt . event . ActionEvent evt ) {
setTextPos ( ) ;
}
private void setTextPos ( ) {
Object line = jCmbLineNumbers . getSelectedItem ( ) ;
if ( line != null ) {
try {
int lineNr = Integer . parseInt ( line . toString ( ) ) ;
int pos = ActionUtils . getDocumentPosition ( text , lineNr , <num> ) ;
ActionUtils . insertIntoCombo ( jCmbLineNumbers , line ) ;
text . setCaretPosition ( pos ) ;
setVisible ( false ) ;
} catch ( NumberFormatException ex ) {
JOptionPane . showMessageDialog ( this , " + line ,
" , JOptionPane . ERROR_MESSAGE ) ;
}
}
}
private void jCmbLineNumbersActionPerformed ( java . awt . event . ActionEvent evt ) {
setTextPos ( ) ;
}
private javax . swing . JButton jBtnOk ;
private javax . swing . JComboBox jCmbLineNumbers ;
}
package jsyntaxpane . components ;
import jsyntaxpane . actions . * ;
import java . awt . Color ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import java . util . regex . Matcher ;
import java . util . regex . Pattern ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . DefaultHighlighter ;
import javax . swing . text . Highlighter ;
import javax . swing . text . JTextComponent ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . Token ;
public class Markers {
public static class SimpleMarker extends DefaultHighlighter . DefaultHighlightPainter {
public SimpleMarker ( Color color ) {
super ( color ) ;
}
}
public static void removeMarkers ( JTextComponent component , SimpleMarker marker ) {
Highlighter hilite = component . getHighlighter ( ) ;
Highlighter . Highlight [ ] hilites = hilite . getHighlights ( ) ;
for ( int i = <num> ; i < hilites . length ; i ++ ) {
if ( hilites [ i ] . getPainter ( ) instanceof SimpleMarker ) {
SimpleMarker hMarker = ( SimpleMarker ) hilites [ i ] . getPainter ( ) ;
if ( marker == null || hMarker . equals ( marker ) ) {
hilite . removeHighlight ( hilites [ i ] ) ;
}
}
}
}
public static void removeMarkers ( JTextComponent editorPane ) {
removeMarkers ( editorPane , null ) ;
}
public static void markToken ( JTextComponent pane , Token token , SimpleMarker marker ) {
markText ( pane , token . start , token . end ( ) , marker ) ;
}
public static void markText ( JTextComponent pane , int start , int end , SimpleMarker marker ) {
try {
Highlighter hiliter = pane . getHighlighter ( ) ;
int selStart = pane . getSelectionStart ( ) ;
int selEnd = pane . getSelectionEnd ( ) ;
if ( selStart == selEnd || end < selStart || start > selStart ) {
hiliter . addHighlight ( start , end , marker ) ;
return ;
}
if ( selStart > start && selStart < end ) {
hiliter . addHighlight ( start , selStart , marker ) ;
}
if ( selEnd > start && selEnd < end ) {
hiliter . addHighlight ( selEnd , end , marker ) ;
}
} catch ( BadLocationException ex ) {
LOG . log ( Level . SEVERE , null , ex ) ;
}
}
public static void markAll ( JTextComponent pane , Pattern pattern , SimpleMarker marker ) {
SyntaxDocument sDoc = ActionUtils . getSyntaxDocument ( pane ) ;
if ( sDoc == null || pattern == null ) {
return ;
}
Matcher matcher = sDoc . getMatcher ( pattern ) ;
while ( matcher . find ( ) ) {
markText ( pane , matcher . start ( ) , matcher . end ( ) , marker ) ;
}
}
private static final Logger LOG = Logger . getLogger ( Markers . class . getName ( ) ) ;
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . Token ;
import jsyntaxpane . util . Configuration ;
public class JUnindentAction extends TextAction implements SyntaxAction {
public JUnindentAction ( ) {
super ( " ) ;
}
@Override
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
SyntaxDocument sDoc = ActionUtils . getSyntaxDocument ( target ) ;
int pos = target . getCaretPosition ( ) ;
int start = sDoc . getParagraphElement ( pos ) . getStartOffset ( ) ;
String line = ActionUtils . getLine ( target ) ;
if ( ActionUtils . isEmptyOrBlanks ( line ) ) {
try {
sDoc . insertString ( pos , " , null ) ;
Token t = sDoc . getPairFor ( sDoc . getTokenAt ( pos ) ) ;
if ( null != t ) {
String pairLine = ActionUtils . getLineAt ( target , t . start ) ;
String indent = ActionUtils . getIndent ( pairLine ) ;
sDoc . replace ( start , line . length ( ) + <num> , indent + " , null ) ;
}
} catch ( BadLocationException <unk> ) {
target . replaceSelection ( " ) ;
}
} else {
target . replaceSelection ( " ) ;
}
}
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . Lexer ;
import jsyntaxpane . lexers . JavaLexer ;
public class JavaSyntaxKit extends DefaultSyntaxKit {
public JavaSyntaxKit ( ) {
super ( new JavaLexer ( ) ) ;
}
JavaSyntaxKit ( Lexer lexer ) {
super ( lexer ) ;
}
}
package jsyntaxpane ;
import javax . swing . undo . CannotRedoException ;
import javax . swing . undo . CannotUndoException ;
import javax . swing . undo . CompoundEdit ;
import javax . swing . undo . UndoManager ;
import javax . swing . undo . UndoableEdit ;
public class CompoundUndoManager extends UndoManager {
public static final int IDLE_DELAY_MS = <num> ;
long startMillis = <num> ;
CompoundEdit comp = null ;
public CompoundUndoManager ( ) {
}
@Override
public synchronized boolean addEdit ( UndoableEdit anEdit ) {
long now = System . currentTimeMillis ( ) ;
if ( comp == null ) {
comp = new CompoundEdit ( ) ;
}
comp . addEdit ( anEdit ) ;
if ( now  startMillis > IDLE_DELAY_MS ) {
comp . end ( ) ;
super . addEdit ( comp ) ;
comp = null ;
}
startMillis = now ;
return true ;
}
@Override
public synchronized boolean canRedo ( ) {
commitCompound ( ) ;
return super . canRedo ( ) ;
}
@Override
public synchronized boolean canUndo ( ) {
commitCompound ( ) ;
return super . canUndo ( ) ;
}
@Override
public synchronized void discardAllEdits ( ) {
comp = null ;
super . discardAllEdits ( ) ;
}
@Override
public synchronized void redo ( ) throws CannotRedoException {
commitCompound ( ) ;
super . redo ( ) ;
}
@Override
public synchronized void undo ( ) throws CannotUndoException {
commitCompound ( ) ;
super . undo ( ) ;
}
private void commitCompound ( ) {
if ( comp != null ) {
comp . end ( ) ;
super . addEdit ( comp ) ;
comp = null ;
}
}
}
package jsyntaxpane ;
import java . io . CharArrayReader ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . Collections ;
import java . util . Iterator ;
import java . util . List ;
import java . util . ListIterator ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import java . util . regex . Matcher ;
import java . util . regex . Pattern ;
import javax . swing . event . DocumentEvent ;
import javax . swing . event . UndoableEditEvent ;
import javax . swing . event . UndoableEditListener ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . Element ;
import javax . swing . text . PlainDocument ;
import javax . swing . text . Segment ;
import javax . swing . undo . UndoManager ;
public class SyntaxDocument extends PlainDocument {
Lexer lexer ;
List < Token > tokens ;
UndoManager undo = new CompoundUndoManager ( ) ;
public SyntaxDocument ( Lexer lexer ) {
super ( ) ;
<unk> ( PlainDocument . tabSizeAttribute , <num> ) ;
this . lexer = lexer ;
<unk> ( new UndoableEditListener ( ) {
@Override
public void <unk> ( UndoableEditEvent evt ) {
if ( evt . getEdit ( ) . <unk> ( ) ) {
undo . addEdit ( evt . getEdit ( ) ) ;
}
}
} ) ;
}
private void parse ( ) {
if ( lexer == null ) {
tokens = null ;
return ;
}
List < Token > toks = new ArrayList < Token > ( getLength ( ) / <num> ) ;
long ts = System . nanoTime ( ) ;
int len = getLength ( ) ;
try {
Segment seg = new Segment ( ) ;
getText ( <num> , getLength ( ) , seg ) ;
CharArrayReader reader = new CharArrayReader ( seg . array , seg . offset , seg . count ) ;
lexer . yyreset ( reader ) ;
Token token ;
while ( ( token = lexer . yylex ( ) ) != null ) {
toks . add ( token ) ;
}
} catch ( BadLocationException ex ) {
log . log ( Level . SEVERE , null , ex ) ;
} catch ( IOException ex ) {
log . log ( Level . SEVERE , null , ex ) ;
} finally {
if ( log . isLoggable ( Level . FINEST ) ) {
log . <unk> ( String . format ( " ,
len , ( System . nanoTime ( )  ts ) / <num> , toks . size ( ) ) ) ;
}
tokens = toks ;
}
}
@Override
protected void fireChangedUpdate ( DocumentEvent e ) {
parse ( ) ;
super . fireChangedUpdate ( e ) ;
}
@Override
protected void fireInsertUpdate ( DocumentEvent e ) {
parse ( ) ;
super . fireInsertUpdate ( e ) ;
}
@Override
protected void fireRemoveUpdate ( DocumentEvent e ) {
parse ( ) ;
super . fireRemoveUpdate ( e ) ;
}
@Override
protected void fireUndoableEditUpdate ( UndoableEditEvent e ) {
parse ( ) ;
super . fireUndoableEditUpdate ( e ) ;
}
public void replaceToken ( Token token , String replacement ) {
try {
replace ( token . start , token . length , replacement , null ) ;
} catch ( BadLocationException ex ) {
log . log ( Level . WARNING , " + token , ex ) ;
}
}
class TokenIterator implements ListIterator < Token > {
int start ;
int end ;
int ndx = <num> ;
@SuppressWarnings("unchecked")
private TokenIterator ( int start , int end ) {
this . start = start ;
this . end = end ;
if ( tokens != null && ! tokens . isEmpty ( ) ) {
Token token = new Token ( TokenType . COMMENT , start , end  start ) ;
ndx = Collections . binarySearch ( ( List ) tokens , token ) ;
if ( ndx < <num> ) {
ndx = (  ndx  <num>  <num> < <num> ) ? <num> : (  ndx  <num>  <num> ) ;
Token t = tokens . get ( ndx ) ;
if ( t . end ( ) <= start ) {
ndx ++ ;
}
}
}
}
@Override
public boolean hasNext ( ) {
if ( tokens == null ) {
return false ;
}
if ( ndx >= tokens . size ( ) ) {
return false ;
}
Token t = tokens . get ( ndx ) ;
if ( t . start >= end ) {
return false ;
}
return true ;
}
@Override
public Token next ( ) {
return tokens . get ( ndx ++ ) ;
}
@Override
public void remove ( ) {
throw new UnsupportedOperationException ( ) ;
}
public boolean hasPrevious ( ) {
if ( tokens == null ) {
return false ;
}
if ( ndx <= <num> ) {
return false ;
}
Token t = tokens . get ( ndx ) ;
if ( t . end ( ) <= start ) {
return false ;
}
return true ;
}
@Override
public Token previous ( ) {
return tokens . get ( ndx  ) ;
}
@Override
public int nextIndex ( ) {
return ndx + <num> ;
}
@Override
public int previousIndex ( ) {
return ndx  <num> ;
}
@Override
public void set ( Token e ) {
throw new UnsupportedOperationException ( ) ;
}
@Override
public void add ( Token e ) {
throw new UnsupportedOperationException ( ) ;
}
}
public Iterator < Token > getTokens ( int start , int end ) {
return new TokenIterator ( start , end ) ;
}
public Token getTokenAt ( int pos ) {
if ( tokens == null || tokens . isEmpty ( ) || pos > getLength ( ) ) {
return null ;
}
Token tok = null ;
Token tKey = new Token ( TokenType . DEFAULT , pos , <num> ) ;
@SuppressWarnings("unchecked")
int ndx = Collections . binarySearch ( ( List ) tokens , tKey ) ;
if ( ndx < <num> ) {
ndx = (  ndx  <num>  <num> < <num> ) ? <num> : (  ndx  <num>  <num> ) ;
Token t = tokens . get ( ndx ) ;
if ( ( t . start <= pos ) && ( pos <= t . end ( ) ) ) {
tok = t ;
}
} else {
tok = tokens . get ( ndx ) ;
}
return tok ;
}
public Token getPairFor ( Token t ) {
if ( t == null || t . pairValue == <num> ) {
return null ;
}
Token p = null ;
int ndx = tokens . indexOf ( t ) ;
int w = t . pairValue ;
int direction = ( t . pairValue > <num> ) ? <num> :  <num> ;
boolean done = false ;
int v = Math . abs ( t . pairValue ) ;
while ( ! done ) {
ndx += direction ;
if ( ndx < <num> || ndx >= tokens . size ( ) ) {
break ;
}
Token current = tokens . get ( ndx ) ;
if ( Math . abs ( current . pairValue ) == v ) {
w += current . pairValue ;
if ( w == <num> ) {
p = current ;
done = true ;
}
}
}
return p ;
}
public void doUndo ( ) {
if ( undo . canUndo ( ) ) {
undo . undo ( ) ;
parse ( ) ;
}
}
public void doRedo ( ) {
if ( undo . canRedo ( ) ) {
undo . redo ( ) ;
parse ( ) ;
}
}
@Deprecated
public int getIndexOf ( String search , int start ) {
int flag = Pattern . LITERAL ;
Pattern pattern = Pattern . compile ( search , flag ) ;
return getIndexOf ( pattern , start ) ;
}
@Deprecated
public int getIndexOf ( Pattern pattern , int start ) {
int ndx =  <num> ;
if ( pattern == null || getLength ( ) == <num> ) {
return  <num> ;
}
try {
Segment segment = new Segment ( ) ;
getText ( start , getLength ( )  start , segment ) ;
Matcher m = pattern . matcher ( segment ) ;
if ( m . find ( ) ) {
ndx = m . start ( ) + start ;
}
} catch ( BadLocationException ex ) {
log . log ( Level . SEVERE , null , ex ) ;
}
return ndx ;
}
public Matcher getMatcher ( Pattern pattern ) {
return getMatcher ( pattern , <num> , getLength ( ) ) ;
}
public Matcher getMatcher ( Pattern pattern , int start ) {
return getMatcher ( pattern , start , getLength ( )  start ) ;
}
public Matcher getMatcher ( Pattern pattern , int start , int length ) {
Matcher matcher = null ;
if ( getLength ( ) == <num> ) {
return null ;
}
try {
Segment seg = new Segment ( ) ;
getText ( start , length , seg ) ;
matcher = pattern . matcher ( seg ) ;
} catch ( BadLocationException ex ) {
log . log ( Level . SEVERE , " + ex . offsetRequested ( ) , ex ) ;
}
return matcher ;
}
public void clearUndos ( ) {
undo . discardAllEdits ( ) ;
}
public String getLineAt ( int pos ) throws BadLocationException {
Element e = getParagraphElement ( pos ) ;
Segment seg = new Segment ( ) ;
getText ( e . getStartOffset ( ) , e . getEndOffset ( )  e . getStartOffset ( ) , seg ) ;
char last = seg . last ( ) ;
if ( last == \n' || last == \r' ) {
return seg . subSequence ( <num> , seg . length ( )  <num> ) . toString ( ) ;
}
return seg . toString ( ) ;
}
public void <unk> ( int pos )
throws BadLocationException {
Element e = getParagraphElement ( pos ) ;
remove ( e . getStartOffset ( ) , getElementLength ( e ) ) ;
}
public void <unk> ( int pos , String newLines )
throws BadLocationException {
Element e = getParagraphElement ( pos ) ;
replace ( e . getStartOffset ( ) , getElementLength ( e ) , newLines , null ) ;
}
private int getElementLength ( Element e ) {
int end = e . getEndOffset ( ) ;
if ( end >= ( getLength ( )  <num> ) ) {
end  ;
}
return end  e . getStartOffset ( ) ;
}
public synchronized String getUncommentedText ( int aStart , int anEnd ) {
readLock ( ) ;
StringBuilder result = new StringBuilder ( ) ;
Iterator < Token > iter = getTokens ( aStart , anEnd ) ;
while ( iter . hasNext ( ) ) {
Token t = iter . next ( ) ;
if ( TokenType . COMMENT != t . type && TokenType . COMMENT2 != t . type ) {
result . append ( t . getText ( this ) ) ;
}
}
readUnlock ( ) ;
return result . toString ( ) ;
}
public int getLineStartOffset ( int pos ) {
return getParagraphElement ( pos ) . getStartOffset ( ) ;
}
public int getLineEndOffset ( int pos ) {
int end = <num> ;
end = getParagraphElement ( pos ) . getEndOffset ( ) ;
if ( end >= getLength ( ) ) {
end = getLength ( ) ;
}
return end ;
}
public int getLineCount ( ) {
Element e = getDefaultRootElement ( ) ;
int cnt = e . getElementCount ( ) ;
return cnt ;
}
public int getLineNumberAt ( int pos ) {
int lineNr = getDefaultRootElement ( ) . getElementIndex ( pos ) ;
return lineNr ;
}
@Override
public String toString ( ) {
return " + lexer + " + ( ( tokens == null ) ? <num> : tokens . size ( ) ) + " +
hashCode ( ) ;
}
private static final Logger log = Logger . getLogger ( SyntaxDocument . class . getName ( ) ) ;
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . lexers . PropertiesLexer ;
public class PropertiesSyntaxKit extends DefaultSyntaxKit {
public PropertiesSyntaxKit ( ) {
super ( new PropertiesLexer ( ) ) ;
}
}
package jsyntaxpane . actions ;
import javax . swing . JLabel ;
import javax . swing . event . CaretEvent ;
import javax . swing . event . CaretListener ;
import javax . swing . text . BadLocationException ;
import javax . swing . text . JTextComponent ;
import jsyntaxpane . SyntaxDocument ;
public class CaretMonitor implements CaretListener {
private JLabel label ;
private JTextComponent text ;
public CaretMonitor ( JTextComponent text , JLabel label ) {
this . label = label ;
this . text = text ;
text . addCaretListener ( this ) ;
}
public void caretUpdate ( CaretEvent evt ) {
if ( text . getDocument ( ) instanceof SyntaxDocument ) {
try {
if ( text . getSelectionStart ( ) == text . getSelectionEnd ( ) ) {
int pos = evt . getDot ( ) ;
String loc = String . format ( " ,
ActionUtils . getLineNumber ( text , pos ) + <num> ,
ActionUtils . getColumnNumber ( text , pos ) + <num> ,
pos ) ;
label . setText ( loc ) ;
} else {
int start = text . getSelectionStart ( ) ;
int end = text . getSelectionEnd ( ) ;
String loc = String . format ( " ,
ActionUtils . getLineNumber ( text , start ) + <num> ,
ActionUtils . getColumnNumber ( text , start ) + <num> ,
ActionUtils . getLineNumber ( text , end ) + <num> ,
ActionUtils . getColumnNumber ( text , end ) + <num> ,
( end  start ) ) ;
label . setText ( loc ) ;
}
} catch ( BadLocationException ex ) {
label . setText ( " + ex . getMessage ( ) ) ;
}
} else {
label . setText ( " ) ;
}
}
@Override
protected void finalize ( ) throws Throwable {
text . removeCaretListener ( this ) ;
super . finalize ( ) ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . PlainDocument ;
import javax . swing . text . TextAction ;
import jsyntaxpane . util . Configuration ;
public class UnindentAction extends TextAction implements SyntaxAction {
public UnindentAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
Integer tabStop = ( Integer ) target . getDocument ( ) . getProperty ( PlainDocument . tabSizeAttribute ) ;
String indent = ActionUtils . SPACES . substring ( <num> , tabStop ) ;
if ( target != null ) {
String [ ] lines = ActionUtils . getSelectedLines ( target ) ;
int start = target . getSelectionStart ( ) ;
StringBuilder sb = new StringBuilder ( ) ;
for ( String line : lines ) {
if ( line . startsWith ( indent ) ) {
sb . append ( line . substring ( indent . length ( ) ) ) ;
} else if ( line . startsWith ( " ) ) {
sb . append ( line . substring ( <num> ) ) ;
} else {
sb . append ( line ) ;
}
sb . append ( \n' ) ;
}
target . replaceSelection ( sb . toString ( ) ) ;
target . select ( start , start + sb . length ( ) ) ;
}
}
public void config ( Configuration config , String prefix , String name ) {
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . components ;
import java . awt . Color ;
import jsyntaxpane . actions . * ;
import javax . swing . JEditorPane ;
import javax . swing . event . CaretEvent ;
import javax . swing . event . CaretListener ;
import javax . swing . text . JTextComponent ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . Token ;
import jsyntaxpane . util . Configuration ;
public class PairsMarker implements CaretListener , SyntaxComponent {
public static final String PROPERTY_COLOR = " ;
private JTextComponent pane ;
private Markers . SimpleMarker marker ;
public PairsMarker ( ) {
}
@Override
public void caretUpdate ( CaretEvent e ) {
removeMarkers ( ) ;
int pos = e . getDot ( ) ;
SyntaxDocument doc = ActionUtils . getSyntaxDocument ( pane ) ;
Token token = doc . getTokenAt ( pos ) ;
if ( token != null && token . pairValue != <num> ) {
Markers . markToken ( pane , token , marker ) ;
Token other = doc . getPairFor ( token ) ;
if ( other != null ) {
Markers . markToken ( pane , other , marker ) ;
}
}
}
public void removeMarkers ( ) {
Markers . removeMarkers ( pane , marker ) ;
}
public void config ( Configuration config , String prefix ) {
Color markerColor = new Color ( config . getPrefixInteger ( prefix ,
PROPERTY_COLOR ,
<num> ) ) ;
this . marker = new Markers . SimpleMarker ( markerColor ) ;
}
public void install ( JEditorPane editor ) {
pane = editor ;
pane . addCaretListener ( this ) ;
}
public void deinstall ( JEditorPane editor ) {
pane . removeCaretListener ( this ) ;
removeMarkers ( ) ;
}
}
package jsyntaxpane ;
import java . awt . Color ;
import java . awt . Font ;
import java . awt . Graphics ;
import java . util . HashMap ;
import java . util . Map ;
import java . util . Properties ;
import java . util . logging . Logger ;
import javax . swing . text . Segment ;
import javax . swing . text . TabExpander ;
import jsyntaxpane . util . JarServiceProvider ;
public class SyntaxStyles {
public void mergeStyles ( Properties styles ) {
for ( String token : styles . stringPropertyNames ( ) ) {
String stv = styles . getProperty ( token ) ;
try {
TokenType tt = TokenType . valueOf ( token ) ;
SyntaxStyle tokenStyle = new SyntaxStyle ( stv ) ;
put ( tt , tokenStyle ) ;
} catch ( IllegalArgumentException ex ) {
LOG . warning ( " + token ) ;
}
}
}
Map < TokenType , SyntaxStyle > styles ;
private static SyntaxStyles instance = createInstance ( ) ;
private static final Logger LOG = Logger . getLogger ( SyntaxStyles . class . getName ( ) ) ;
private static SyntaxStyle DEFAULT_STYLE = new SyntaxStyle ( Color . BLACK , Font . PLAIN ) ;
private SyntaxStyles ( ) {
}
private static SyntaxStyles createInstance ( ) {
SyntaxStyles syntaxstyles = new SyntaxStyles ( ) ;
Properties styles = JarServiceProvider . readProperties ( SyntaxStyles . class ) ;
syntaxstyles . mergeStyles ( styles ) ;
return syntaxstyles ;
}
public static SyntaxStyles getInstance ( ) {
return instance ;
}
public void put ( TokenType type , SyntaxStyle style ) {
if ( styles == null ) {
styles = new HashMap < TokenType , SyntaxStyle > ( ) ;
}
styles . put ( type , style ) ;
}
@Deprecated
public void <unk> ( Graphics g , TokenType type ) {
Font c = g . getFont ( ) ;
SyntaxStyle ss = styles . get ( type ) ;
if ( ss != null ) {
g . setFont ( g . getFont ( ) . deriveFont ( ss . getFontStyle ( ) ) ) ;
g . setColor ( ss . getColor ( ) ) ;
} else {
g . setFont ( g . getFont ( ) . deriveFont ( Font . PLAIN ) ) ;
g . setColor ( Color . BLACK ) ;
}
}
public SyntaxStyle getStyle ( TokenType type ) {
if ( styles . containsKey ( type ) ) {
return styles . get ( type ) ;
} else {
return DEFAULT_STYLE ;
}
}
public int drawText ( Segment segment , int x , int y ,
Graphics graphics , TabExpander e , Token token ) {
SyntaxStyle s = getStyle ( token . type ) ;
return s . drawText ( segment , x , y , graphics , e , token . start ) ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . lexers . GroovyLexer ;
public class GroovySyntaxKit extends JavaSyntaxKit {
public GroovySyntaxKit ( ) {
super ( new GroovyLexer ( ) ) ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import java . util . Map ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . Token ;
import jsyntaxpane . util . Configuration ;
import jsyntaxpane . util . JarServiceProvider ;
public class MapCompletionAction extends TextAction implements SyntaxAction {
Map < String , String > completions ;
public MapCompletionAction ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null && target . getDocument ( ) instanceof SyntaxDocument ) {
SyntaxDocument sDoc = ( SyntaxDocument ) target . getDocument ( ) ;
int dot = target . getCaretPosition ( ) ;
Token token = sDoc . getTokenAt ( dot ) ;
if ( token != null ) {
String abbriv = ActionUtils . getTokenStringAt ( sDoc , dot ) ;
if ( completions . containsKey ( abbriv ) ) {
String completed = completions . get ( abbriv ) ;
if ( completed . indexOf ( |' ) >= <num> ) {
int ofst = completed . length ( )  completed . indexOf ( |' )  <num> ;
sDoc . replaceToken ( token , completed . replace ( " , " ) ) ;
target . setCaretPosition ( target . getCaretPosition ( )  ofst ) ;
} else {
sDoc . replaceToken ( token , completed ) ;
}
}
}
}
}
public void config ( Configuration config , String prefix , String name ) {
String completionsFile = config . getPrefixProperty ( prefix , " , " ) ;
if ( completionsFile != null ) {
completions = JarServiceProvider . readStringsMap ( completionsFile ) ;
}
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . lexers . DOSBatchLexer ;
public class DOSBatchSyntaxKit extends DefaultSyntaxKit {
public DOSBatchSyntaxKit ( ) {
super ( new DOSBatchLexer ( ) ) ;
}
}
package jsyntaxpane ;
import java . io . Reader ;
public interface Lexer {
public void yyreset ( Reader reader ) ;
public Token yylex ( ) throws java . io . IOException ;
public char <unk> ( int pos ) ;
public int yylength ( ) ;
public String yytext ( ) ;
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
public class SmartIndent extends TextAction {
public SmartIndent ( ) {
super ( " ) ;
}
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null ) {
String line = ActionUtils . getLine ( target ) ;
target . replaceSelection ( " + ActionUtils . getIndent ( line ) ) ;
}
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . lexers . TALLexer ;
public class TALSyntaxKit extends DefaultSyntaxKit {
public TALSyntaxKit ( ) {
super ( new TALLexer ( ) ) ;
}
}
package jsyntaxpane . actions ;
import java . awt . event . ActionEvent ;
import java . awt . event . KeyEvent ;
import java . security . KeyStore ;
import java . util . regex . Matcher ;
import java . util . regex . Pattern ;
import javax . swing . text . JTextComponent ;
import javax . swing . text . TextAction ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . util . Configuration ;
public class ToggleCommentsAction extends TextAction implements SyntaxAction {
protected String lineCommentStart = " ;
protected Pattern lineCommentPattern = null ;
public ToggleCommentsAction ( ) {
super ( " ) ;
}
@Override
public void actionPerformed ( ActionEvent e ) {
JTextComponent target = getTextComponent ( e ) ;
if ( target != null && target . getDocument ( ) instanceof SyntaxDocument ) {
String [ ] lines = ActionUtils . getSelectedLines ( target ) ;
StringBuffer toggled = new StringBuffer ( ) ;
for ( int i = <num> ; i < lines . length ; i ++ ) {
Matcher m = lineCommentPattern . matcher ( lines [ i ] ) ;
if ( m . find ( ) ) {
toggled . append ( m . replaceFirst ( " ) ) ;
} else {
toggled . append ( lineCommentStart ) ;
toggled . append ( lines [ i ] ) ;
}
toggled . append ( \n' ) ;
}
target . replaceSelection ( toggled . toString ( ) ) ;
}
}
public void config ( Configuration config , String prefix , String name ) {
lineCommentStart = config . getPrefixProperty ( prefix ,
name + " , " ) . replace ( " , " ) ;
lineCommentPattern = Pattern . compile ( " + lineCommentStart + " ) ;
}
public TextAction getAction ( String key ) {
return this ;
}
}
package jsyntaxpane . syntaxkits ;
import jsyntaxpane . DefaultSyntaxKit ;
import jsyntaxpane . Lexer ;
import jsyntaxpane . lexers . ScalaLexer ;
public class ScalaSyntaxKit extends DefaultSyntaxKit {
public ScalaSyntaxKit ( ) {
super ( new ScalaLexer ( ) ) ;
}
public ScalaSyntaxKit ( Lexer lexer ) {
super ( lexer ) ;
}
}
package jsyntaxpane . components ;
import jsyntaxpane . actions . * ;
import java . awt . Color ;
import java . util . HashSet ;
import java . util . Iterator ;
import java . util . Set ;
import java . util . logging . Logger ;
import javax . swing . JEditorPane ;
import javax . swing . event . CaretEvent ;
import javax . swing . event . CaretListener ;
import jsyntaxpane . SyntaxDocument ;
import jsyntaxpane . Token ;
import jsyntaxpane . TokenType ;
import jsyntaxpane . util . Configuration ;
public class TokenMarker implements SyntaxComponent , CaretListener {
public static final String DEFAULT_TOKENTYPES = " ;
public static final String PROPERTY_COLOR = " ;
public static final String PROPERTY_TOKENTYPES = " ;
private static final int DEFAULT_COLOR = <num> ;
private JEditorPane pane ;
private Set < TokenType > tokenTypes = new HashSet < TokenType > ( ) ;
private Markers . SimpleMarker marker ;
public TokenMarker ( ) {
}
@Override
public void caretUpdate ( CaretEvent e ) {
int pos = e . getDot ( ) ;
SyntaxDocument doc = ActionUtils . getSyntaxDocument ( pane ) ;
Token token = doc . getTokenAt ( pos ) ;
removeMarkers ( ) ;
if ( token != null && tokenTypes . contains ( token . type ) ) {
addMarkers ( token ) ;
}
}
public void removeMarkers ( ) {
Markers . removeMarkers ( pane , marker ) ;
}
void addMarkers ( Token tok ) {
SyntaxDocument sDoc = ( SyntaxDocument ) pane . getDocument ( ) ;
sDoc . readLock ( ) ;
String text = tok . getText ( sDoc ) ;
Iterator < Token > it = sDoc . getTokens ( <num> , sDoc . getLength ( ) ) ;
while ( it . hasNext ( ) ) {
Token nextToken = it . next ( ) ;
if ( nextToken . length == tok . length && text . equals ( nextToken . getText ( sDoc ) ) ) {
Markers . markToken ( pane , nextToken , marker ) ;
}
}
sDoc . readUnlock ( ) ;
}
@Override
public void config ( Configuration config , String prefix ) {
Color markerColor = new Color ( config . getPrefixInteger ( prefix ,
PROPERTY_COLOR , DEFAULT_COLOR ) ) ;
this . marker = new Markers . SimpleMarker ( markerColor ) ;
String types = config . getPrefixProperty ( prefix ,
PROPERTY_TOKENTYPES , DEFAULT_TOKENTYPES ) ;
for ( String type : types . split ( " ) ) {
try {
TokenType tt = TokenType . valueOf ( type ) ;
tokenTypes . add ( tt ) ;
} catch ( IllegalArgumentException e ) {
LOG . warning ( " + prefix +
" + type ) ;
}
}
}
@Override
public void install ( JEditorPane editor ) {
this . pane = editor ;
pane . addCaretListener ( this ) ;
}
@Override
public void deinstall ( JEditorPane editor ) {
removeMarkers ( ) ;
pane . removeCaretListener ( this ) ;
}
private static final Logger LOG = Logger . getLogger ( TokenMarker . class . getName ( ) ) ;
}
package jsyntaxpane ;
import java . awt . event . ItemEvent ;
import java . awt . Rectangle ;
import javax . swing . DefaultComboBoxModel ;
import javax . swing . text . BadLocationException ;
import jsyntaxpane . actions . CaretMonitor ;
public class SyntaxTester extends javax . swing . JFrame {
public SyntaxTester ( ) {
DefaultSyntaxKit . initKit ( ) ;
initComponents ( ) ;
jCmbLangs . setModel ( new DefaultComboBoxModel ( DefaultSyntaxKit . getContentTypes ( ) ) ) ;
jCmbLangs . setSelectedItem ( " ) ;
new CaretMonitor ( jEdtTest , lblCaretPos ) ;
}
private void initComponents ( ) {
lblCaretPos = new javax . swing . JLabel ( ) ;
jScrollPane1 = new javax . swing . JScrollPane ( ) ;
jEdtTest = new javax . swing . JEditorPane ( ) ;
lblToken = new javax . swing . JLabel ( ) ;
jCmbLangs = new javax . swing . JComboBox ( ) ;
setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ;
setTitle ( " ) ;
lblCaretPos . setText ( " ) ;
jEdtTest . setContentType ( " ) ;
jEdtTest . setFont ( new java . awt . Font ( " , <num> , <num> ) ) ;
jEdtTest . addCaretListener ( new javax . swing . event . CaretListener ( ) {
public void caretUpdate ( javax . swing . event . CaretEvent evt ) {
jEdtTestCaretUpdate ( evt ) ;
}
} ) ;
jScrollPane1 . setViewportView ( jEdtTest ) ;
lblToken . setFont ( new java . awt . Font ( " , <num> , <num> ) ) ;
lblToken . setText ( " ) ;
jCmbLangs . <unk> ( <num> ) ;
jCmbLangs . setFocusable ( false ) ;
jCmbLangs . addItemListener ( new java . awt . event . ItemListener ( ) {
public void itemStateChanged ( java . awt . event . ItemEvent evt ) {
jCmbLangsItemStateChanged ( evt ) ;
}
} ) ;
javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ;
getContentPane ( ) . setLayout ( layout ) ;
layout . setHorizontalGroup (
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING )
. addComponent ( lblToken , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addGroup ( layout . createSequentialGroup ( )
. addComponent ( jCmbLangs , <num> , <num> , Short . MAX_VALUE )
. addGap ( <num> , <num> , <num> )
. addComponent ( lblCaretPos , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addComponent ( jScrollPane1 , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE ) )
. addContainerGap ( ) )
) ;
layout . setVerticalGroup (
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( )
. addContainerGap ( )
. addComponent ( jScrollPane1 , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addGap ( <num> , <num> , <num> )
. addComponent ( lblToken , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED )
. addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( jCmbLangs , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE )
. addComponent ( lblCaretPos , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE ) )
. addContainerGap ( ) )
) ;
pack ( ) ;
}
private void jEdtTestCaretUpdate ( javax . swing . event . CaretEvent evt ) {
if ( jEdtTest . getDocument ( ) instanceof SyntaxDocument ) {
SyntaxDocument sDoc = ( SyntaxDocument ) jEdtTest . getDocument ( ) ;
Token t = sDoc . getTokenAt ( evt . getDot ( ) ) ;
if ( t != null ) {
try {
String tData = sDoc . getText ( t . start , Math . min ( t . length , <num> ) ) ;
if ( t . length > <num> ) {
tData += " ;
}
lblToken . setText ( t . toString ( ) + " + tData ) ;
} catch ( BadLocationException ex ) {
System . err . println ( ex ) ;
ex . printStackTrace ( ) ;
}
}
}
}
private void jCmbLangsItemStateChanged ( java . awt . event . ItemEvent evt ) {
if ( evt . getStateChange ( ) == ItemEvent . SELECTED ) {
String lang = jCmbLangs . getSelectedItem ( ) . toString ( ) ;
String t = jEdtTest . getText ( ) ;
int caretPosition = jEdtTest . getCaretPosition ( ) ;
Rectangle visibleRectangle = jEdtTest . <unk> ( ) ;
jEdtTest . setContentType ( lang ) ;
SyntaxDocument sDoc = ( SyntaxDocument ) jEdtTest . getDocument ( ) ;
jEdtTest . setText ( t ) ;
sDoc . clearUndos ( ) ;
jEdtTest . setCaretPosition ( caretPosition ) ;
jEdtTest . scrollRectToVisible ( visibleRectangle ) ;
}
}
public static void main ( String args [ ] ) {
java . awt . EventQueue . invokeLater ( new Runnable ( ) {
@Override
public void run ( ) {
new SyntaxTester ( ) . setVisible ( true ) ;
}
} ) ;
}
private javax . swing . JComboBox jCmbLangs ;
private javax . swing . JEditorPane jEdtTest ;
private javax . swing . JScrollPane jScrollPane1 ;
private javax . swing . JLabel lblCaretPos ;
private javax . swing . JLabel lblToken ;
}
package com . snaplogic . ServiceNow ;
import java . io . IOException ;
import java . net . HttpURLConnection ;
import java . net . MalformedURLException ;
import java . net . URL ;
import java . util . ArrayList ;
import java . util . HashSet ;
import java . util . Iterator ;
import java . util . List ;
import java . util . Map ;
import java . util . Set ;
import org . codehaus . jackson . map . JsonMappingException ;
import org . codehaus . jackson . map . ObjectMapper ;
import org . snaplogic . cc . Capabilities ;
import org . snaplogic . cc . Capability ;
import org . snaplogic . cc . ComponentAPI ;
import org . snaplogic . cc . InputView ;
import org . snaplogic . cc . OutputView ;
import org . snaplogic . cc . prop . SimpleProp ;
import org . snaplogic . cc . prop . SimpleProp . SimplePropType ;
import org . snaplogic . codehaus . jackson . JsonParseException ;
import org . snaplogic . common . ComponentResourceErr ;
import org . snaplogic . common . Field ;
import org . snaplogic . common . Record ;
import org . snaplogic . common . exceptions . SnapComponentException ;
import org . snaplogic . snapi . ResDef ;
import org . snaplogic . util . Base64 ;
public class <unk> extends ComponentAPI {
@Override
public String getAPIVersion ( ) {
return " ;
}
public String getLabel ( ) {
return " ;
}
@Override
public String getComponentVersion ( ) {
return " ;
}
@Override
public Capabilities getCapabilities ( ) {
return new Capabilities ( ) {
{
put ( Capability . INPUT_VIEW_LOWER_LIMIT , <num> ) ;
put ( Capability . INPUT_VIEW_UPPER_LIMIT , <num> ) ;
put ( Capability . OUTPUT_VIEW_LOWER_LIMIT , <num> ) ;
put ( Capability . OUTPUT_VIEW_UPPER_LIMIT , <num> ) ;
}
} ;
}
@Override
public void createResourceTemplate ( ) {
setPropertyDef ( " , new SimpleProp (
" ,
SimplePropType . SnapString , " , true ) ) ;
setPropertyDef (
" ,
new SimpleProp (
" ,
SimplePropType . SnapString ,
" ,
true ) ) ;
}
private final String [ ] serviceNowJsonFields = { " , " ,
" , " , " , " ,
" , " , " , " , " ,
" , " , " , " , " ,
" , " , " ,
" , " , " , " ,
" , " , " , " , " ,
" , " , " , " , " ,
" , " , " , " , " ,
" , " , " , " ,
" , " , " , " ,
" , " , " , " ,
" , " , " , " ,
" , " , " , " ,
" , " , " , " ,
" , " , " ,
" , " , " , " ,
" , " , " , " ,
" } ;
public void <unk> ( ComponentResourceErr <unk> ) {
List < Field > outputViewFields = new ArrayList < Field > ( ) ;
for ( String attribute : serviceNowJsonFields ) {
outputViewFields . add ( new Field ( attribute ,
Field . <unk> . SnapString ) ) ;
}
<unk> ( " , outputViewFields , " , true ) ;
}
public void execute ( Map < String , InputView > <unk> ,
Map < String , OutputView > outputViews ) {
String connection = getStringPropertyValue ( " ) ;
String query = getStringPropertyValue ( " ) ;
if ( connection == null ) {
throw new SnapComponentException ( " ) ;
}
ResDef resdef = this . <unk> ( connection ) ;
String host = resdef . getPropertyValue ( " ) . toString ( ) ;
String username = resdef . getPropertyValue ( " ) . toString ( ) ;
String password = resdef . getPropertyValue ( " ) . toString ( ) ;
OutputView outputView = outputViews . values ( ) . iterator ( ) . next ( ) ;
Record outRec ;
try {
URL url = new URL (
host
+ "
+ query ) ;
List incidents = this . getIncidents ( url , username , password ) ;
Iterator i = incidents . iterator ( ) ;
while ( i . hasNext ( ) ) {
Map < String , String > incident = ( Map < String , String > ) i . next ( ) ;
outRec = outputView . createRecord ( ) ;
for ( String attributeKey : incident . keySet ( ) ) {
outRec . set ( attributeKey , incident . get ( attributeKey ) ) ;
}
outputView . writeRecord ( outRec ) ;
}
} catch ( MalformedURLException e ) {
e . printStackTrace ( ) ;
} catch ( JsonParseException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
outputView . completed ( ) ;
}
private List getIncidents ( URL url , String username , String password )
throws org . codehaus . jackson . JsonParseException ,
JsonMappingException , IOException {
HttpURLConnection urlConn = ( HttpURLConnection ) url . openConnection ( ) ;
String authorizationString = "
+ Base64 . <unk> ( ( username + " + password ) . getBytes ( ) ) ;
urlConn . setRequestProperty ( " , authorizationString ) ;
ObjectMapper mapper = new ObjectMapper ( ) ;
Map < String , Object > userData = mapper . readValue (
urlConn . getInputStream ( ) , Map . class ) ;
List incidents = new ArrayList ( ) ;
for ( String recordKey : userData . keySet ( ) ) {
incidents . addAll ( ( List ) userData . get ( recordKey ) ) ;
return incidents ;
}
return incidents ;
}
}
package com . snaplogic . ServiceNow ;
import java . util . Map ;
import org . snaplogic . cc . Capabilities ;
import org . snaplogic . cc . Capability ;
import org . snaplogic . cc . ComponentAPI ;
import org . snaplogic . cc . InputView ;
import org . snaplogic . cc . OutputView ;
import org . snaplogic . cc . prop . SimpleProp ;
import org . snaplogic . cc . prop . SimpleProp . SimplePropType ;
public class Connection extends ComponentAPI {
@Override
public String getAPIVersion ( ) {
return " ;
}
@Override
public String getComponentVersion ( ) {
return " ;
}
public String getLabel ( ) {
return " ;
}
public Capabilities getCapabilities ( ) {
return new Capabilities ( ) {
{
put ( Capability . INPUT_VIEW_LOWER_LIMIT , <num> ) ;
put ( Capability . INPUT_VIEW_UPPER_LIMIT , <num> ) ;
put ( Capability . OUTPUT_VIEW_LOWER_LIMIT , <num> ) ;
put ( Capability . OUTPUT_VIEW_UPPER_LIMIT , <num> ) ;
}
} ;
}
public void createResourceTemplate ( ) {
setPropertyDef ( " , new SimpleProp ( " ,
SimplePropType . SnapString , " , true ) ) ;
setPropertyDef ( " , new SimpleProp ( " ,
SimplePropType . SnapString , " , true ) ) ;
setPropertyDef ( " , new SimpleProp ( " ,
SimplePropType . SnapString , " ,
new org . snaplogic . snapi . PropertyConstraint (
org . snaplogic . snapi . PropertyConstraint . Type . OBFUSCATE ,
0 ) , false ) ) ;
}
@Override
public void execute ( Map < String , InputView > arg0 ,
Map < String , OutputView > arg1 ) {
}
}
package com . snaplogic . ServiceNow ;
import org . junit . After ;
import org . junit . AfterClass ;
import org . junit . Before ;
import org . junit . BeforeClass ;
import org . junit . Test ;
import static org . junit . Assert . * ;
public class SampleSnapTest {
public SampleSnapTest ( ) {
}
@BeforeClass
public static void setUpClass ( ) throws Exception {
}
@AfterClass
public static void tearDownClass ( ) throws Exception {
}
@Before
public void setUp ( ) {
}
@After
public void tearDown ( ) {
}
@Test
public void <unk> ( ) {
assertTrue ( true ) ;
}
package br . com . programmers . animasom_alegria ;
import java . io . IOException ;
import android . content . Context ;
import android . content . res . AssetFileDescriptor ;
import android . media . MediaPlayer ;
import android . os . Handler ;
import android . view . View ;
public class AnimationManager {
private final long DEFAULT_TIMER_INTERVAL = <num> ;
private boolean _running ;
private MediaPlayer _player ;
private Handler _timerHandler ;
private View _image1 = null ;
private View _image2 = null ;
private String _assetName = null ;
private Context _currentContext = null ;
public AnimationManager ( Context context , View image1 , View image2 , String assetName ) {
this . _currentContext = context ;
this . _image1 = image1 ;
this . _image2 = image2 ;
this . _assetName = assetName ;
this . _running = false ;
this . _timerHandler = new Handler ( ) ;
this . _player = new MediaPlayer ( ) ;
this . initializeVisibilityState ( ) ;
this . initializeMediaPlayer ( ) ;
}
public boolean getIsRunning ( ) {
return this . _running ;
}
public void stopAnimantion ( ) {
this . _timerHandler . removeCallbacks ( this . _updateUI ) ;
this . initializeVisibilityState ( ) ;
this . _running = false ;
}
public void startAnimation ( ) {
this . _running = true ;
this . _timerHandler . removeCallbacks ( this . _updateUI ) ;
this . _timerHandler . postDelayed ( this . _updateUI , <num> ) ;
this . _player . start ( ) ;
}
private Runnable _updateUI = new Runnable ( ) {
public void run ( ) {
if ( _player . isPlaying ( ) ) {
switchVisibility ( ) ;
_timerHandler . postDelayed ( _updateUI , DEFAULT_TIMER_INTERVAL ) ;
}
else {
stopAnimantion ( ) ;
}
}
} ;
private void initializeVisibilityState ( ) {
this . _image1 . setVisibility ( View . VISIBLE ) ;
this . _image2 . setVisibility ( View . GONE ) ;
}
private void switchVisibility ( ) {
int oldVisibility = this . _image1 . getVisibility ( ) ;
this . _image1 . setVisibility ( this . _image2 . getVisibility ( ) ) ;
this . _image2 . setVisibility ( oldVisibility ) ;
}
private void initializeMediaPlayer ( ) {
try {
AssetFileDescriptor descriptor = this . _currentContext . getAssets ( ) . openFd ( this . _assetName ) ;
this . _player . setDataSource (
descriptor . getFileDescriptor ( ) ,
descriptor . getStartOffset ( ) ,
descriptor . getLength ( ) ) ;
descriptor . close ( ) ;
this . _player . prepare ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
}
package br . com . programmers . animasom_alegria ;
public final class BuildConfig {
public final static boolean DEBUG = true ;
package br . com . programmers . animasom_alegria ;
import android . app . Activity ;
import android . os . Bundle ;
import android . view . View ;
public class <unk> extends Activity {
AnimationManager _am = null ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
View view1 = this . findViewById ( R . id . imageView1 ) ;
View view2 = this . findViewById ( R . id . imageView2 ) ;
this . _am = new AnimationManager ( this . getBaseContext ( ) , view1 , view2 , " ) ;
}
public void ClickHandler ( View view ) {
if ( ! this . _am . getIsRunning ( ) )
this . _am . startAnimation ( ) ;
}
package br . com . programmers . animasom_alegria ;
public final class R {
public static final class attr {
}
public static final class drawable {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int ic_launcher = <num> ;
}
public static final class id {
public static final int imageView1 = <num> ;
public static final int imageView2 = <num> ;
}
public static final class layout {
public static final int main = <num> ;
}
public static final class string {
public static final int app_name = <num> ;
}
}
package t8 . <unk> ;
public class Ticket {
private Customer customer ;
private Flight flight ;
private String ticket ;
public Ticket ( Customer aCustomer , Flight aFlight )
{
customer = aCustomer ;
flight = aFlight ;
}
public void <unk> ( )
{
System . out . println ( customer . getName ( )
+ customer . getConfirmationNumber ( ) ) ;
}
@Override
public String toString ( )
{
ticket = " + customer . getName ( ) + "
+ flight . <unk> ( ) + "
+ flight . <unk> ( ) + " + flight . <unk> ( ) + "
+ flight . <unk> ( ) + " + flight . <unk> ( ) + "
+ customer . getConfirmationNumber ( ) ;
return ticket ;
}
}
import java . awt . Color ;
import java . awt . image . BufferedImage ;
import java . io . File ;
import java . io . IOException ;
import java . util . HashMap ;
import javax . imageio . ImageIO ;
import com . <unk> . <unk> . Kernel ;
public class ImageGrayscale {
BufferedImage imageO ;
BufferedImage imageN ;
int [ ] pixelsO ;
int [ ] pixelsN ;
HashMap < Integer , Integer > lookup = new HashMap < Integer , Integer > ( ) ;
public ImageGrayscale ( ) {
}
public void readImageFile ( String filename ) throws IOException {
readImageFile ( filename , false ) ;
}
public void readImageFile ( String filename , boolean populatePixels )
throws IOException {
imageO = ImageIO . read ( new File ( filename ) ) ;
int width = imageO . getWidth ( ) ;
int height = imageO . getHeight ( ) ;
imageN = new BufferedImage ( width , height , imageO . getType ( ) ) ;
if ( populatePixels ) {
pixelsO = imageO . getRGB ( <num> , <num> , width , height , null , <num> , width ) ;
pixelsN = new int [ pixelsO . length ] ;
}
}
public void writeImageFile ( String filename ) throws IOException {
writeImageFile ( filename , false ) ;
}
public void writeImageFile ( String filename , boolean usePixels )
throws IOException {
if ( usePixels ) {
int width = imageN . getWidth ( ) ;
int height = imageN . getHeight ( ) ;
imageN . setRGB ( <num> , <num> , width , height , pixelsN , <num> , width ) ;
}
ImageIO . write ( imageN , " , new File ( filename ) ) ;
}
public void useGetRGBAndColor ( ) {
int width = imageO . getWidth ( ) ;
int height = imageO . getHeight ( ) ;
for ( int col = <num> ; col < width ; col ++ ) {
for ( int row = <num> ; row < height ; row ++ ) {
Color c = new Color ( imageO . getRGB ( col , row ) , true ) ;
int a = c . getAlpha ( ) ;
int r = c . getRed ( ) ;
int b = c . getBlue ( ) ;
int g = c . getGreen ( ) ;
int x = ( int ) ( ( <num> * r ) + ( <num> * g ) + ( <num> * b ) ) ;
Color cn = new Color ( x , x , x , a ) ;
imageN . setRGB ( col , row , cn . hashCode ( ) ) ;
}
}
}
public void useBitshift ( ) {
int width = imageO . getWidth ( ) ;
int height = imageO . getHeight ( ) ;
for ( int col = <num> ; col < width ; col ++ ) {
for ( int row = <num> ; row < height ; row ++ ) {
int argb = imageO . getRGB ( col , row ) ;
int a = ( argb & <num> ) >> <num> ;
int r = ( argb & <num> ) >> <num> ;
int g = ( argb & <num> ) >> <num> ;
int b = ( argb & <num> ) ;
int x = ( int ) ( ( <num> * r ) + ( <num> * g ) + ( <num> * b ) ) ;
int cn = ( a << <num> ) + ( x << <num> ) + ( x << <num> ) + x ;
imageN . setRGB ( col , row , cn ) ;
}
}
}
public void useIntegerArray ( ) {
int width = imageO . getWidth ( ) ;
int height = imageO . getHeight ( ) ;
int [ ] pixels = imageO . getRGB ( <num> , <num> , width , height , null , <num> , width ) ;
for ( int col = <num> ; col < width ; col ++ ) {
for ( int row = <num> ; row < height ; row ++ ) {
int argb = pixels [ width * row + col ] ;
int a = ( argb & <num> ) >> <num> ;
int r = ( argb & <num> ) >> <num> ;
int g = ( argb & <num> ) >> <num> ;
int b = ( argb & <num> ) ;
int x = ( int ) ( ( <num> * r ) + ( <num> * g ) + ( <num> * b ) ) ;
int cn = ( a << <num> ) + ( x << <num> ) + ( x << <num> ) + x ;
pixels [ width * row + col ] = cn ;
}
}
imageN . setRGB ( <num> , <num> , width , height , pixels , <num> , width ) ;
}
public void usePrePixel ( ) {
int width = imageO . getWidth ( ) ;
int height = imageO . getHeight ( ) ;
for ( int col = <num> ; col < width ; col ++ ) {
for ( int row = <num> ; row < height ; row ++ ) {
int argb = pixelsO [ width * row + col ] ;
int a = ( argb & <num> ) >> <num> ;
int r = ( argb & <num> ) >> <num> ;
int g = ( argb & <num> ) >> <num> ;
int b = ( argb & <num> ) ;
int x = ( int ) ( ( <num> * r ) + ( <num> * g ) + ( <num> * b ) ) ;
int cn = ( a << <num> ) + ( x << <num> ) + ( x << <num> ) + x ;
pixelsN [ width * row + col ] = cn ;
}
}
}
public void useSingleForloop ( ) {
for ( int i = <num> ; i < pixelsO . length ; i ++ ) {
int argb = pixelsO [ i ] ;
int a = ( argb & <num> ) >> <num> ;
int r = ( argb & <num> ) >> <num> ;
int g = ( argb & <num> ) >> <num> ;
int b = ( argb & <num> ) ;
int x = ( int ) ( ( <num> * r ) + ( <num> * g ) + ( <num> * b ) ) ;
int cn = ( a << <num> ) + ( x << <num> ) + ( x << <num> ) + x ;
pixelsN [ i ] = cn ;
}
}
public void usePreDeclared ( ) {
int i , argb , a , r , g , b , x , cn ;
for ( i = <num> ; i < pixelsO . length ; i ++ ) {
argb = pixelsO [ i ] ;
a = ( argb & <num> ) >> <num> ;
r = ( argb & <num> ) >> <num> ;
g = ( argb & <num> ) >> <num> ;
b = ( argb & <num> ) ;
x = ( int ) ( ( <num> * r ) + ( <num> * g ) + ( <num> * b ) ) ;
cn = ( a << <num> ) + ( x << <num> ) + ( x << <num> ) + x ;
pixelsN [ i ] = cn ;
}
}
public void useIntegersOnly ( ) {
int i , argb , a , r , g , b , x , cn ;
for ( i = <num> ; i < pixelsO . length ; i ++ ) {
argb = pixelsO [ i ] ;
a = ( argb & <num> ) >> <num> ;
r = ( argb & <num> ) >> <num> ;
g = ( argb & <num> ) >> <num> ;
b = ( argb & <num> ) ;
x = ( int ) ( ( ( <num> * ( r * <num> ) ) + ( <num> * ( g * <num> ) )
+ ( <num> * ( b * <num> ) ) ) / <num> ) ;
cn = ( a << <num> ) + ( x << <num> ) + ( x << <num> ) + x ;
pixelsN [ i ] = cn ;
}
}
public void useLookup ( ) {
int i , argb , a , r , g , b , x ;
Integer cn ;
for ( i = <num> ; i < pixelsO . length ; i ++ ) {
argb = pixelsO [ i ] ;
cn = lookup . get ( argb ) ;
if ( cn == null ) {
a = ( argb & <num> ) >> <num> ;
r = ( argb & <num> ) >> <num> ;
g = ( argb & <num> ) >> <num> ;
b = ( argb & <num> ) ;
x = ( int ) ( ( <num> * r ) + ( <num> * g ) + ( <num> * b ) ) ;
cn = ( a << <num> ) + ( x << <num> ) + ( x << <num> ) + x ;
lookup . put ( argb , cn ) ;
}
pixelsN [ i ] = cn ;
}
}
public void useGPU ( ) {
final int [ ] p = pixelsO ;
Kernel kernel = new Kernel ( ) {
@Override
public void run ( ) {
int i = <unk> ( ) ;
int argb = p [ i ] ;
int a = ( argb & <num> ) >> <num> ;
int r = ( argb & <num> ) >> <num> ;
int g = ( argb & <num> ) >> <num> ;
int b = ( argb & <num> ) ;
int x = ( int ) ( ( <num> * r ) + ( <num> * g )
+ ( <num> * b ) ) ;
int cn = ( a << <num> ) + ( x << <num> ) + ( x << <num> ) + x ;
p [ i ] = cn ;
}
} ;
kernel . execute ( pixelsO . length ) ;
pixelsN = p ;
}
}
import java . io . IOException ;
public class VisionBenchmark {
long startTime , endTime ;
public VisionBenchmark ( int benchSize ) {
try {
ImageGrayscale igs = new ImageGrayscale ( ) ;
igs . readImageFile ( " ) ;
this . benchStart ( ) ;
for ( int i = <num> ; i < benchSize ; i ++ ) {
igs . useGetRGBAndColor ( ) ;
}
this . benchEnd ( " ) ;
igs . writeImageFile ( " ) ;
igs . readImageFile ( " ) ;
this . benchStart ( ) ;
for ( int i = <num> ; i < benchSize ; i ++ ) {
igs . useBitshift ( ) ;
}
this . benchEnd ( " ) ;
igs . writeImageFile ( " ) ;
igs . readImageFile ( " ) ;
this . benchStart ( ) ;
for ( int i = <num> ; i < benchSize ; i ++ ) {
igs . useIntegerArray ( ) ;
}
this . benchEnd ( " ) ;
igs . writeImageFile ( " ) ;
igs . readImageFile ( " , true ) ;
this . benchStart ( ) ;
for ( int i = <num> ; i < benchSize ; i ++ ) {
igs . usePrePixel ( ) ;
}
this . benchEnd ( " ) ;
igs . writeImageFile ( " , true ) ;
igs . readImageFile ( " , true ) ;
this . benchStart ( ) ;
for ( int i = <num> ; i < benchSize ; i ++ ) {
igs . useSingleForloop ( ) ;
}
this . benchEnd ( " ) ;
igs . writeImageFile ( " , true ) ;
igs . readImageFile ( " , true ) ;
this . benchStart ( ) ;
for ( int i = <num> ; i < benchSize ; i ++ ) {
igs . usePreDeclared ( ) ;
}
this . benchEnd ( " ) ;
igs . writeImageFile ( " , true ) ;
igs . readImageFile ( " , true ) ;
this . benchStart ( ) ;
for ( int i = <num> ; i < benchSize ; i ++ ) {
igs . useIntegersOnly ( ) ;
}
this . benchEnd ( " ) ;
igs . writeImageFile ( " , true ) ;
igs . readImageFile ( " , true ) ;
this . benchStart ( ) ;
for ( int i = <num> ; i < benchSize ; i ++ ) {
igs . useLookup ( ) ;
}
this . benchEnd ( " ) ;
igs . writeImageFile ( " , true ) ;
igs . readImageFile ( " , true ) ;
this . benchStart ( ) ;
for ( int i = <num> ; i < benchSize ; i ++ ) {
igs . useGPU ( ) ;
}
this . benchEnd ( " ) ;
igs . writeImageFile ( " , true ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
private void benchStart ( ) {
this . startTime = System . nanoTime ( ) ;
}
private void benchEnd ( String message ) {
this . endTime = System . nanoTime ( ) ;
double duration = ( endTime  startTime ) / <num> ;
System . out . println ( message + " + duration + " ) ;
}
public static void main ( String [ ] args ) {
new VisionBenchmark ( <num> ) ;
}
}
package com . redhat . datagrid . endpoint ;
public class ModelKeys {
public static final String HOTROD_CONNECTOR = " ;
public static final String MEMCACHED_CONNECTOR = " ;
public static final String REST_CONNECTOR = " ;
public static final String NAME = " ;
public static final String SOCKET_BINDING = " ;
public static final String CACHE_CONTAINER = " ;
public static final String WORKER_THREADS = " ;
public static final String IDLE_TIMEOUT = " ;
public static final String TCP_NODELAY = " ;
public static final String SEND_BUFFER_SIZE = " ;
public static final String RECEIVE_BUFFER_SIZE = " ;
public static final String VIRTUAL_SERVER = " ;
public static final String CONTEXT_PATH = " ;
public static final String TOPOLOGY_STATE_TRANSFER = " ;
public static final String LOCK_TIMEOUT = " ;
public static final String REPLICATION_TIMEOUT = " ;
public static final String UPDATE_TIMEOUT = " ;
public static final String EXTERNAL_HOST = " ;
public static final String EXTERNAL_PORT = " ;
public static final String LAZY_RETRIEVAL = " ;
public static final String [ ] CONNECTORS = { HOTROD_CONNECTOR , MEMCACHED_CONNECTOR , REST_CONNECTOR } ;
public static final String [ ] CONNECTOR_ATTRIBUTES = { SOCKET_BINDING , NAME , CACHE_CONTAINER , WORKER_THREADS , IDLE_TIMEOUT , TCP_NODELAY , SEND_BUFFER_SIZE , RECEIVE_BUFFER_SIZE , VIRTUAL_SERVER , CONTEXT_PATH } ;
public static final String [ ] TOPOLOGY_ATTRIBUTES = { LOCK_TIMEOUT , REPLICATION_TIMEOUT , UPDATE_TIMEOUT , EXTERNAL_HOST , EXTERNAL_PORT , LAZY_RETRIEVAL } ;
public static final String <unk> = " ;
}
package com . redhat . datagrid . endpoint ;
import java . util . List ;
import java . util . Locale ;
import org . infinispan . server . <unk> . HotRodServer ;
import org . jboss . as . controller . AbstractAddStepHandler ;
import org . jboss . as . controller . OperationContext ;
import org . jboss . as . controller . OperationFailedException ;
import org . jboss . as . controller . ServiceVerificationHandler ;
import org . jboss . as . controller . descriptions . DescriptionProvider ;
import org . jboss . as . controller . descriptions . ModelDescriptionConstants ;
import org . jboss . as . controller . operations . common . Util ;
import org . jboss . dmr . ModelNode ;
import org . jboss . msc . service . ServiceBuilder ;
import org . jboss . msc . service . ServiceController ;
import static com . redhat . datagrid . endpoint . EndpointUtils . copyIfSet ;
class HotRodSubsystemAdd extends AbstractAddStepHandler implements DescriptionProvider {
static final HotRodSubsystemAdd INSTANCE = new HotRodSubsystemAdd ( ) ;
static ModelNode createOperation ( ModelNode address , ModelNode existing ) {
ModelNode operation = Util . getEmptyOperation ( ModelDescriptionConstants . ADD , address ) ;
populate ( existing , operation ) ;
return operation ;
}
private static void populate ( ModelNode source , ModelNode target ) {
target . setEmptyObject ( ) ;
copyIfSet ( ModelKeys . NAME , source , target ) ;
copyIfSet ( ModelKeys . CACHE_CONTAINER , source , target ) ;
copyIfSet ( ModelKeys . SOCKET_BINDING , source , target ) ;
copyIfSet ( ModelKeys . IDLE_TIMEOUT , source , target ) ;
copyIfSet ( ModelKeys . TCP_NODELAY , source , target ) ;
copyIfSet ( ModelKeys . RECEIVE_BUFFER_SIZE , source , target ) ;
copyIfSet ( ModelKeys . SEND_BUFFER_SIZE , source , target ) ;
copyIfSet ( ModelKeys . WORKER_THREADS , source , target ) ;
}
@Override
public ModelNode getModelDescription ( Locale locale ) {
return EndpointSubsystemProviders . ADD_HOTROD_CONNECTOR_DESC . getModelDescription ( locale ) ;
}
@Override
protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model , ServiceVerificationHandler verificationHandler , List < ServiceController < ? >> newControllers )
throws OperationFailedException {
final ProtocolServerService service = new ProtocolServerService ( operation , HotRodServer . class ) ;
ServiceBuilder < ? > builder = context . getServiceTarget ( ) . addService ( EndpointUtils . getServiceName ( operation , " ) , service ) ;
EndpointUtils . addCacheContainerDependency ( context , builder , service . getCacheContainerName ( ) , service . getCacheManager ( ) ) ;
EndpointUtils . addSocketBindingDependency ( builder , service . getRequiredSocketBindingName ( ) , service . getSocketBinding ( ) ) ;
builder . install ( ) ;
}
@Override
protected void populateModel ( ModelNode source , ModelNode target ) throws OperationFailedException {
populate ( source , target ) ;
}
@Override
protected boolean requiresRuntimeVerification ( ) {
return false ;
}
}
package com . redhat . datagrid . endpoint ;
import java . util . Locale ;
import org . jboss . as . controller . AbstractRemoveStepHandler ;
import org . jboss . as . controller . OperationContext ;
import org . jboss . as . controller . OperationFailedException ;
import org . jboss . as . controller . descriptions . DescriptionProvider ;
import org . jboss . dmr . ModelNode ;
public class MemcachedSubsystemRemove extends AbstractRemoveStepHandler implements DescriptionProvider {
static final MemcachedSubsystemRemove INSTANCE = new MemcachedSubsystemRemove ( ) ;
@Override
protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model )
throws OperationFailedException {
context . removeService ( EndpointUtils . getServiceName ( operation , " ) ) ;
}
@Override
public ModelNode getModelDescription ( Locale locale ) {
return EndpointSubsystemProviders . REMOVE_MEMCACHED_CONNECTOR_DESC . getModelDescription ( locale ) ;
}
}
package com . redhat . datagrid . endpoint ;
import static com . redhat . datagrid . endpoint . EndpointUtils . copyIfSet ;
import java . util . List ;
import java . util . Locale ;
import org . infinispan . server . memcached . MemcachedServer ;
import org . jboss . as . controller . AbstractAddStepHandler ;
import org . jboss . as . controller . OperationContext ;
import org . jboss . as . controller . OperationFailedException ;
import org . jboss . as . controller . ServiceVerificationHandler ;
import org . jboss . as . controller . descriptions . DescriptionProvider ;
import org . jboss . as . controller . descriptions . ModelDescriptionConstants ;
import org . jboss . as . controller . operations . common . Util ;
import org . jboss . dmr . ModelNode ;
import org . jboss . msc . service . ServiceBuilder ;
import org . jboss . msc . service . ServiceController ;
class MemcachedSubsystemAdd extends AbstractAddStepHandler implements DescriptionProvider {
static final MemcachedSubsystemAdd INSTANCE = new MemcachedSubsystemAdd ( ) ;
static ModelNode createOperation ( ModelNode address , ModelNode existing ) {
ModelNode operation = Util . getEmptyOperation ( ModelDescriptionConstants . ADD , address ) ;
populate ( existing , operation ) ;
return operation ;
}
private static void populate ( ModelNode source , ModelNode target ) {
target . setEmptyObject ( ) ;
copyIfSet ( ModelKeys . NAME , source , target ) ;
copyIfSet ( ModelKeys . CACHE_CONTAINER , source , target ) ;
copyIfSet ( ModelKeys . SOCKET_BINDING , source , target ) ;
copyIfSet ( ModelKeys . IDLE_TIMEOUT , source , target ) ;
copyIfSet ( ModelKeys . TCP_NODELAY , source , target ) ;
copyIfSet ( ModelKeys . RECEIVE_BUFFER_SIZE , source , target ) ;
copyIfSet ( ModelKeys . SEND_BUFFER_SIZE , source , target ) ;
copyIfSet ( ModelKeys . WORKER_THREADS , source , target ) ;
}
@Override
public ModelNode getModelDescription ( Locale locale ) {
return EndpointSubsystemProviders . SUBSYTEM_ADD . getModelDescription ( locale ) ;
}
@Override
protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model , ServiceVerificationHandler verificationHandler , List < ServiceController < ? >> newControllers )
throws OperationFailedException {
final ProtocolServerService service = new ProtocolServerService ( operation , MemcachedServer . class ) ;
ServiceBuilder < ? > builder = context . getServiceTarget ( ) . addService ( EndpointUtils . getServiceName ( operation , " ) , service ) ;
EndpointUtils . addCacheContainerDependency ( context , builder , service . getCacheContainerName ( ) , service . getCacheManager ( ) ) ;
EndpointUtils . addSocketBindingDependency ( builder , service . getRequiredSocketBindingName ( ) , service . getSocketBinding ( ) ) ;
builder . install ( ) ;
}
@Override
protected void populateModel ( ModelNode source , ModelNode target ) throws OperationFailedException {
populate ( source , target ) ;
}
@Override
protected boolean requiresRuntimeVerification ( ) {
return false ;
}
}
package com . redhat . datagrid . endpoint ;
import static com . redhat . datagrid . endpoint . EndpointUtils . copyIfSet ;
import java . util . List ;
import java . util . Locale ;
import org . jboss . as . controller . AbstractAddStepHandler ;
import org . jboss . as . controller . OperationContext ;
import org . jboss . as . controller . OperationFailedException ;
import org . jboss . as . controller . ServiceVerificationHandler ;
import org . jboss . as . controller . descriptions . DescriptionProvider ;
import org . jboss . as . controller . descriptions . ModelDescriptionConstants ;
import org . jboss . as . controller . operations . common . Util ;
import org . jboss . as . server . ServerEnvironment ;
import org . jboss . as . server . services . path . AbstractPathService ;
import org . jboss . as . web . VirtualHost ;
import org . jboss . as . web . WebSubsystemServices ;
import org . jboss . dmr . ModelNode ;
import org . jboss . msc . service . ServiceBuilder ;
import org . jboss . msc . service . ServiceController ;
class RestSubsystemAdd extends AbstractAddStepHandler implements DescriptionProvider {
static final RestSubsystemAdd INSTANCE = new RestSubsystemAdd ( ) ;
static ModelNode createOperation ( ModelNode address , ModelNode existing ) {
ModelNode operation = Util . getEmptyOperation ( ModelDescriptionConstants . ADD , address ) ;
populate ( existing , operation ) ;
return operation ;
}
private static void populate ( ModelNode source , ModelNode target ) {
target . setEmptyObject ( ) ;
copyIfSet ( ModelKeys . NAME , source , target ) ;
copyIfSet ( ModelKeys . CACHE_CONTAINER , source , target ) ;
copyIfSet ( ModelKeys . VIRTUAL_SERVER , source , target ) ;
copyIfSet ( ModelKeys . CONTEXT_PATH , source , target ) ;
}
@Override
public ModelNode getModelDescription ( Locale locale ) {
return EndpointSubsystemProviders . ADD_REST_CONNECTOR_DESC . getModelDescription ( locale ) ;
}
@Override
protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model , ServiceVerificationHandler verificationHandler , List < ServiceController < ? >> newControllers )
throws OperationFailedException {
final RestService service = new RestService ( operation ) ;
ServiceBuilder < ? > builder = context . getServiceTarget ( ) . addService ( EndpointUtils . getServiceName ( operation , " ) , service ) ;
EndpointUtils . addCacheContainerDependency ( context , builder , service . getCacheContainerName ( ) , service . getCacheManager ( ) ) ;
builder . addDependency ( AbstractPathService . <unk> ( ServerEnvironment . <unk> ) , String . class , service . getPathInjector ( ) ) ;
builder . addDependency ( WebSubsystemServices . <unk> . append ( service . getVirtualServer ( ) ) , VirtualHost . class , service . getHostInjector ( ) ) ;
builder . addListener ( verificationHandler ) ;
builder . <unk> ( ServiceController . Mode . ACTIVE ) ;
builder . install ( ) ;
}
@Override
protected void populateModel ( ModelNode source , ModelNode target ) throws OperationFailedException {
populate ( source , target ) ;
}
@Override
protected boolean requiresRuntimeVerification ( ) {
return false ;
}
}
package com . redhat . datagrid . endpoint ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . ADD ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . ATTRIBUTES ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . CHILDREN ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . DESCRIPTION ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . HEAD_COMMENT_ALLOWED ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . MAX_OCCURS ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . MIN_OCCURS ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . MODEL_DESCRIPTION ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . NAME ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . NAMESPACE ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . OPERATION_NAME ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . REMOVE ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . REPLY_PROPERTIES ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . REQUEST_PROPERTIES ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . REQUIRED ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . TAIL_COMMENT_ALLOWED ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . TYPE ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . VALUE_TYPE ;
import java . util . Locale ;
import java . util . ResourceBundle ;
import org . jboss . as . controller . descriptions . DescriptionProvider ;
import org . jboss . dmr . ModelNode ;
import org . jboss . dmr . ModelType ;
import com . redhat . datagrid . DataGridConstants ;
public class EndpointSubsystemProviders {
static final String RESOURCE_NAME = EndpointSubsystemProviders . class . getPackage ( ) . getName ( ) + " ;
static final DescriptionProvider SUBSYSTEM = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( final Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( HEAD_COMMENT_ALLOWED ) . set ( true ) ;
node . get ( TAIL_COMMENT_ALLOWED ) . set ( true ) ;
node . get ( NAMESPACE ) . set ( DataGridConstants . NS_ENDPOINT_1_0 ) ;
for ( String connectorType : ModelKeys . CONNECTORS ) {
node . get ( CHILDREN , connectorType , DESCRIPTION ) . set ( bundle . getString ( connectorType + " ) ) ;
node . get ( CHILDREN , connectorType , MIN_OCCURS ) . set ( <num> ) ;
node . get ( CHILDREN , connectorType , MAX_OCCURS ) . set ( Integer . MAX_VALUE ) ;
node . get ( CHILDREN , connectorType , MODEL_DESCRIPTION ) . setEmptyObject ( ) ;
}
return node ;
}
} ;
static final DescriptionProvider SUBSYTEM_ADD = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( OPERATION_NAME ) . set ( ADD ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( REQUEST_PROPERTIES ) . setEmptyObject ( ) ;
node . get ( REPLY_PROPERTIES ) . setEmptyObject ( ) ;
return node ;
}
} ;
static DescriptionProvider HOTROD_CONNECTOR_DESC = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( HEAD_COMMENT_ALLOWED ) . set ( true ) ;
node . get ( TAIL_COMMENT_ALLOWED ) . set ( true ) ;
addModelAttribute ( node , ModelKeys . NAME , bundle . getString ( " ) , ModelType . STRING , false ) ;
addModelAttribute ( node , ModelKeys . CACHE_CONTAINER , bundle . getString ( " ) , ModelType . STRING , true ) ;
addModelAttribute ( node , ModelKeys . SOCKET_BINDING , bundle . getString ( " ) , ModelType . STRING , true ) ;
addModelAttribute ( node , ModelKeys . WORKER_THREADS , bundle . getString ( " ) , ModelType . INT , false ) ;
addModelAttribute ( node , ModelKeys . IDLE_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
addModelAttribute ( node , ModelKeys . TCP_NODELAY , bundle . getString ( " ) , ModelType . BOOLEAN , false ) ;
addModelAttribute ( node , ModelKeys . RECEIVE_BUFFER_SIZE , bundle . getString ( " ) , ModelType . LONG , false ) ;
addModelAttribute ( node , ModelKeys . SEND_BUFFER_SIZE , bundle . getString ( " ) , ModelType . LONG , false ) ;
ModelNode topologyNode = addModelAttribute ( node , ModelKeys . TOPOLOGY_STATE_TRANSFER , bundle . getString ( " ) , ModelType . OBJECT , false ) ;
final ModelNode topologyNodeValue = topologyNode . get ( VALUE_TYPE ) ;
addNode ( topologyNodeValue , ModelKeys . EXTERNAL_HOST , bundle . getString ( " ) , ModelType . STRING , false ) ;
addNode ( topologyNodeValue , ModelKeys . EXTERNAL_PORT , bundle . getString ( " ) , ModelType . INT , false ) ;
addNode ( topologyNodeValue , ModelKeys . LAZY_RETRIEVAL , bundle . getString ( " ) , ModelType . BOOLEAN , false ) ;
addNode ( topologyNodeValue , ModelKeys . LOCK_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
addNode ( topologyNodeValue , ModelKeys . REPLICATION_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
return node ;
}
} ;
static DescriptionProvider ADD_HOTROD_CONNECTOR_DESC = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( final Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( OPERATION_NAME ) . set ( ADD ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
addModelRequestProperty ( node , ModelKeys . NAME , bundle . getString ( " ) , ModelType . STRING , false ) ;
addModelRequestProperty ( node , ModelKeys . CACHE_CONTAINER , bundle . getString ( " ) , ModelType . STRING , true ) ;
addModelRequestProperty ( node , ModelKeys . SOCKET_BINDING , bundle . getString ( " ) , ModelType . STRING , true ) ;
addModelRequestProperty ( node , ModelKeys . WORKER_THREADS , bundle . getString ( " ) , ModelType . INT , false ) ;
addModelRequestProperty ( node , ModelKeys . IDLE_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
addModelRequestProperty ( node , ModelKeys . TCP_NODELAY , bundle . getString ( " ) , ModelType . BOOLEAN , false ) ;
addModelRequestProperty ( node , ModelKeys . RECEIVE_BUFFER_SIZE , bundle . getString ( " ) , ModelType . LONG , false ) ;
addModelRequestProperty ( node , ModelKeys . SEND_BUFFER_SIZE , bundle . getString ( " ) , ModelType . LONG , false ) ;
ModelNode topologyNode = addModelRequestProperty ( node , ModelKeys . TOPOLOGY_STATE_TRANSFER , bundle . getString ( " ) , ModelType . OBJECT , false ) ;
final ModelNode topologyNodeValue = topologyNode . get ( VALUE_TYPE ) ;
addNode ( topologyNodeValue , ModelKeys . EXTERNAL_HOST , bundle . getString ( " ) , ModelType . STRING , false ) ;
addNode ( topologyNodeValue , ModelKeys . EXTERNAL_PORT , bundle . getString ( " ) , ModelType . INT , false ) ;
addNode ( topologyNodeValue , ModelKeys . LAZY_RETRIEVAL , bundle . getString ( " ) , ModelType . BOOLEAN , false ) ;
addNode ( topologyNodeValue , ModelKeys . LOCK_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
addNode ( topologyNodeValue , ModelKeys . REPLICATION_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
node . get ( REPLY_PROPERTIES ) . setEmptyObject ( ) ;
return node ;
}
} ;
static DescriptionProvider REMOVE_HOTROD_CONNECTOR_DESC = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( final Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( OPERATION_NAME ) . set ( REMOVE ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( REQUEST_PROPERTIES , NAME , DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( REQUEST_PROPERTIES , NAME , TYPE ) . set ( ModelType . STRING ) ;
node . get ( REQUEST_PROPERTIES , NAME , REQUIRED ) . set ( true ) ;
node . get ( REPLY_PROPERTIES ) . setEmptyObject ( ) ;
return node ;
}
} ;
static DescriptionProvider MEMCACHED_CONNECTOR_DESC = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( HEAD_COMMENT_ALLOWED ) . set ( true ) ;
node . get ( TAIL_COMMENT_ALLOWED ) . set ( true ) ;
addModelAttribute ( node , ModelKeys . NAME , bundle . getString ( " ) , ModelType . STRING , false ) ;
addModelAttribute ( node , ModelKeys . CACHE_CONTAINER , bundle . getString ( " ) , ModelType . STRING , true ) ;
addModelAttribute ( node , ModelKeys . SOCKET_BINDING , bundle . getString ( " ) , ModelType . STRING , true ) ;
addModelAttribute ( node , ModelKeys . WORKER_THREADS , bundle . getString ( " ) , ModelType . INT , false ) ;
addModelAttribute ( node , ModelKeys . IDLE_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
addModelAttribute ( node , ModelKeys . TCP_NODELAY , bundle . getString ( " ) , ModelType . BOOLEAN , false ) ;
addModelAttribute ( node , ModelKeys . RECEIVE_BUFFER_SIZE , bundle . getString ( " ) , ModelType . LONG , false ) ;
addModelAttribute ( node , ModelKeys . SEND_BUFFER_SIZE , bundle . getString ( " ) , ModelType . LONG , false ) ;
ModelNode topologyNode = addModelAttribute ( node , ModelKeys . TOPOLOGY_STATE_TRANSFER , bundle . getString ( " ) , ModelType . OBJECT , false ) ;
final ModelNode topologyNodeValue = topologyNode . get ( VALUE_TYPE ) ;
addNode ( topologyNodeValue , ModelKeys . EXTERNAL_HOST , bundle . getString ( " ) , ModelType . STRING , false ) ;
addNode ( topologyNodeValue , ModelKeys . EXTERNAL_PORT , bundle . getString ( " ) , ModelType . INT , false ) ;
addNode ( topologyNodeValue , ModelKeys . LAZY_RETRIEVAL , bundle . getString ( " ) , ModelType . BOOLEAN , false ) ;
addNode ( topologyNodeValue , ModelKeys . LOCK_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
addNode ( topologyNodeValue , ModelKeys . REPLICATION_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
return node ;
}
} ;
static DescriptionProvider ADD_MEMCACHED_CONNECTOR_DESC = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( final Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( OPERATION_NAME ) . set ( ADD ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
addModelRequestProperty ( node , ModelKeys . NAME , bundle . getString ( " ) , ModelType . STRING , false ) ;
addModelRequestProperty ( node , ModelKeys . CACHE_CONTAINER , bundle . getString ( " ) , ModelType . STRING , true ) ;
addModelRequestProperty ( node , ModelKeys . SOCKET_BINDING , bundle . getString ( " ) , ModelType . STRING , true ) ;
addModelRequestProperty ( node , ModelKeys . WORKER_THREADS , bundle . getString ( " ) , ModelType . INT , false ) ;
addModelRequestProperty ( node , ModelKeys . IDLE_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
addModelRequestProperty ( node , ModelKeys . TCP_NODELAY , bundle . getString ( " ) , ModelType . BOOLEAN , false ) ;
addModelRequestProperty ( node , ModelKeys . RECEIVE_BUFFER_SIZE , bundle . getString ( " ) , ModelType . LONG , false ) ;
addModelRequestProperty ( node , ModelKeys . SEND_BUFFER_SIZE , bundle . getString ( " ) , ModelType . LONG , false ) ;
ModelNode topologyNode = addModelRequestProperty ( node , ModelKeys . TOPOLOGY_STATE_TRANSFER , bundle . getString ( " ) , ModelType . OBJECT , false ) ;
final ModelNode topologyNodeValue = topologyNode . get ( VALUE_TYPE ) ;
addNode ( topologyNodeValue , ModelKeys . EXTERNAL_HOST , bundle . getString ( " ) , ModelType . STRING , false ) ;
addNode ( topologyNodeValue , ModelKeys . EXTERNAL_PORT , bundle . getString ( " ) , ModelType . INT , false ) ;
addNode ( topologyNodeValue , ModelKeys . LAZY_RETRIEVAL , bundle . getString ( " ) , ModelType . BOOLEAN , false ) ;
addNode ( topologyNodeValue , ModelKeys . LOCK_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
addNode ( topologyNodeValue , ModelKeys . REPLICATION_TIMEOUT , bundle . getString ( " ) , ModelType . LONG , false ) ;
node . get ( REPLY_PROPERTIES ) . setEmptyObject ( ) ;
return node ;
}
} ;
static DescriptionProvider REMOVE_MEMCACHED_CONNECTOR_DESC = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( final Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( OPERATION_NAME ) . set ( REMOVE ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( REQUEST_PROPERTIES , NAME , DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( REQUEST_PROPERTIES , NAME , TYPE ) . set ( ModelType . STRING ) ;
node . get ( REQUEST_PROPERTIES , NAME , REQUIRED ) . set ( true ) ;
node . get ( REPLY_PROPERTIES ) . setEmptyObject ( ) ;
return node ;
}
} ;
static DescriptionProvider REST_CONNECTOR_DESC = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( HEAD_COMMENT_ALLOWED ) . set ( true ) ;
node . get ( TAIL_COMMENT_ALLOWED ) . set ( true ) ;
addModelAttribute ( node , ModelKeys . NAME , bundle . getString ( " ) , ModelType . STRING , false ) ;
addModelAttribute ( node , ModelKeys . CACHE_CONTAINER , bundle . getString ( " ) , ModelType . STRING , true ) ;
addModelAttribute ( node , ModelKeys . VIRTUAL_SERVER , bundle . getString ( " ) , ModelType . STRING , false ) ;
addModelAttribute ( node , ModelKeys . CONTEXT_PATH , bundle . getString ( " ) , ModelType . STRING , false ) ;
return node ;
}
} ;
static DescriptionProvider ADD_REST_CONNECTOR_DESC = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( final Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( OPERATION_NAME ) . set ( ADD ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
addModelRequestProperty ( node , ModelKeys . NAME , bundle . getString ( " ) , ModelType . STRING , false ) ;
addModelRequestProperty ( node , ModelKeys . CACHE_CONTAINER , bundle . getString ( " ) , ModelType . STRING , true ) ;
addModelRequestProperty ( node , ModelKeys . VIRTUAL_SERVER , bundle . getString ( " ) , ModelType . STRING , false ) ;
addModelRequestProperty ( node , ModelKeys . CONTEXT_PATH , bundle . getString ( " ) , ModelType . STRING , false ) ;
node . get ( REPLY_PROPERTIES ) . setEmptyObject ( ) ;
return node ;
}
} ;
static DescriptionProvider REMOVE_REST_CONNECTOR_DESC = new DescriptionProvider ( ) {
@Override
public ModelNode getModelDescription ( final Locale locale ) {
final ResourceBundle bundle = getResourceBundle ( locale ) ;
final ModelNode node = new ModelNode ( ) ;
node . get ( OPERATION_NAME ) . set ( REMOVE ) ;
node . get ( DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( REQUEST_PROPERTIES , NAME , DESCRIPTION ) . set ( bundle . getString ( " ) ) ;
node . get ( REQUEST_PROPERTIES , NAME , TYPE ) . set ( ModelType . STRING ) ;
node . get ( REQUEST_PROPERTIES , NAME , REQUIRED ) . set ( true ) ;
node . get ( REPLY_PROPERTIES ) . setEmptyObject ( ) ;
return node ;
}
} ;
private static ResourceBundle getResourceBundle ( Locale locale ) {
if ( locale == null ) {
locale = Locale . getDefault ( ) ;
}
return ResourceBundle . getBundle ( RESOURCE_NAME , locale ) ;
}
private static ModelNode addNode ( ModelNode parent , String attribute , String description , ModelType type , boolean required ) {
ModelNode node = parent . get ( attribute ) ;
node . get ( DESCRIPTION ) . set ( description ) ;
node . get ( TYPE ) . set ( type ) ;
node . get ( REQUIRED ) . set ( required ) ;
return node ;
}
private static ModelNode addModelAttribute ( ModelNode node , String attribute , String description , ModelType type , boolean required ) {
return addNode ( node . get ( ATTRIBUTES ) , attribute , description , type , required ) ;
}
private static ModelNode addModelRequestProperty ( ModelNode node , String attribute , String description , ModelType type , boolean required ) {
return addNode ( node . get ( REQUEST_PROPERTIES ) , attribute , description , type , required ) ;
}
}
package com . redhat . datagrid . endpoint ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . ADD ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . DESCRIBE ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . OP ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . OP_ADDR ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . SUBSYSTEM ;
import java . io . BufferedReader ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . InputStreamReader ;
import java . util . List ;
import org . jboss . as . controller . PathAddress ;
import org . jboss . as . controller . PathElement ;
import org . jboss . as . subsystem . test . AbstractSubsystemTest ;
import org . jboss . as . subsystem . test . AdditionalInitialization ;
import org . jboss . as . subsystem . test . KernelServices ;
import org . jboss . dmr . ModelNode ;
import org . jboss . msc . service . Service ;
import org . jboss . msc . service . ServiceName ;
import org . jboss . msc . service . ServiceTarget ;
import org . jboss . msc . service . StartContext ;
import org . jboss . msc . service . StartException ;
import org . jboss . msc . service . StopContext ;
import org . junit . Assert ;
import org . junit . Test ;
import com . redhat . datagrid . DataGridConstants ;
public class EndpointSubsystemParsingTestCase extends AbstractSubsystemTest {
private String subsystemXml ;
public EndpointSubsystemParsingTestCase ( ) throws IOException {
super ( DataGridConstants . SN_ENDPOINT . getSimpleName ( ) , new EndpointExtension ( ) ) ;
InputStream is = this . getClass ( ) . getResourceAsStream ( " ) ;
subsystemXml = loadStreamAsString ( is ) ;
}
private static String loadStreamAsString ( InputStream is ) throws java . io . IOException {
StringBuffer s = new StringBuffer ( <num> ) ;
BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ;
char [ ] buf = new char [ <num> ] ;
int numRead = <num> ;
while ( ( numRead = reader . read ( buf ) ) !=  <num> ) {
s . append ( buf , <num> , numRead ) ;
}
reader . close ( ) ;
return s . toString ( ) ;
}
@Test
public void <unk> ( ) throws Exception {
List < ModelNode > operations = super . parse ( subsystemXml ) ;
Assert . assertEquals ( <num> , operations . size ( ) ) ;
ModelNode addSubsystem = operations . get ( <num> ) ;
Assert . assertEquals ( ADD , addSubsystem . get ( OP ) . asString ( ) ) ;
PathAddress addr = PathAddress . pathAddress ( addSubsystem . get ( OP_ADDR ) ) ;
Assert . assertEquals ( <num> , addr . size ( ) ) ;
PathElement element = addr . getElement ( <num> ) ;
Assert . assertEquals ( SUBSYSTEM , element . getKey ( ) ) ;
Assert . assertEquals ( DataGridConstants . SN_ENDPOINT . getSimpleName ( ) , element . getValue ( ) ) ;
}
@Test
public void <unk> ( ) throws Exception {
KernelServices services = super . installInController ( new EndpointAdditionalInitialization ( ) , subsystemXml ) ;
ModelNode model = services . readWholeModel ( ) ;
Assert . assertTrue ( model . get ( SUBSYSTEM ) . hasDefined ( DataGridConstants . SN_ENDPOINT . getSimpleName ( ) ) ) ;
}
@Test
public void <unk> ( ) throws Exception {
KernelServices servicesA = super . installInController ( new EndpointAdditionalInitialization ( ) , subsystemXml ) ;
ModelNode modelA = servicesA . readWholeModel ( ) ;
String marshalled = servicesA . <unk> ( ) ;
KernelServices servicesB = super . installInController ( new EndpointAdditionalInitialization ( ) , marshalled ) ;
ModelNode modelB = servicesB . readWholeModel ( ) ;
super . compare ( modelA , modelB ) ;
}
@Test
public void <unk> ( ) throws Exception {
KernelServices servicesA = super . installInController ( new EndpointAdditionalInitialization ( ) , subsystemXml ) ;
ModelNode modelA = servicesA . readWholeModel ( ) ;
ModelNode describeOp = new ModelNode ( ) ;
describeOp . get ( OP ) . set ( DESCRIBE ) ;
describeOp . get ( OP_ADDR ) . set ( PathAddress . pathAddress ( PathElement . pathElement ( SUBSYSTEM , DataGridConstants . SN_ENDPOINT . getSimpleName ( ) ) ) . toModelNode ( ) ) ;
List < ModelNode > operations = super . <unk> ( servicesA . <unk> ( describeOp ) ) . asList ( ) ;
KernelServices servicesB = super . installInController ( new EndpointAdditionalInitialization ( ) , operations ) ;
ModelNode modelB = servicesB . readWholeModel ( ) ;
super . compare ( modelA , modelB ) ;
}
private static final class EndpointAdditionalInitialization extends AdditionalInitialization {
@Override
protected void <unk> ( ServiceTarget target ) {
target . addService ( MockTransportService . NAME , new MockTransportService ( ) ) . install ( ) ;
}
}
public static class MockTransportService implements Service < MockTransportService > {
public static final ServiceName NAME = ServiceName . JBOSS . append ( " , " , " ) ;
@Override
public MockTransportService getValue ( ) throws IllegalStateException , IllegalArgumentException {
return this ;
}
@Override
public void start ( StartContext context ) throws StartException {
}
@Override
public void stop ( StopContext context ) {
}
}
package com . redhat . datagrid . endpoint ;
import java . io . File ;
import java . lang . reflect . InvocationTargetException ;
import java . lang . reflect . Method ;
import org . apache . catalina . Context ;
import org . apache . catalina . Host ;
import org . apache . catalina . LifecycleException ;
import org . apache . catalina . Loader ;
import org . apache . catalina . Wrapper ;
import org . apache . catalina . core . StandardContext ;
import org . apache . catalina . deploy . ApplicationParameter ;
import org . apache . catalina . startup . ContextConfig ;
import org . apache . tomcat . InstanceManager ;
import org . infinispan . manager . EmbeddedCacheManager ;
import org . jboss . as . web . VirtualHost ;
import org . jboss . as . web . <unk> . WebCtxLoader ;
import org . jboss . dmr . ModelNode ;
import org . jboss . logging . Logger ;
import org . jboss . msc . service . Service ;
import org . jboss . msc . service . ServiceRegistryException ;
import org . jboss . msc . service . StartContext ;
import org . jboss . msc . service . StartException ;
import org . jboss . msc . service . StopContext ;
import org . jboss . msc . value . InjectedValue ;
import org . jboss . resteasy . plugins . server . servlet . HttpServletDispatcher ;
import org . jboss . resteasy . plugins . server . servlet . ResteasyBootstrap ;
public class RestService implements Service < Context > {
private static final String DEFAULT_VIRTUAL_SERVER = " ;
private static final Logger log = Logger . getLogger ( " ) ;
private static final String DEFAULT_CONTEXT_PATH = " ;
private final StandardContext context ;
private final InjectedValue < String > pathInjector = new InjectedValue < String > ( ) ;
private final InjectedValue < VirtualHost > hostInjector = new InjectedValue < VirtualHost > ( ) ;
private final InjectedValue < EmbeddedCacheManager > cacheManagerInjector = new InjectedValue < EmbeddedCacheManager > ( ) ;
private Method cacheManagerSetter ;
private ModelNode config ;
private String virtualServer ;
private String path ;
private String serverName ;
public RestService ( ModelNode config ) {
this . config = config . clone ( ) ;
this . context = new StandardContext ( ) ;
virtualServer = this . config . hasDefined ( ModelKeys . VIRTUAL_SERVER ) ? this . config . get ( ModelKeys . VIRTUAL_SERVER ) . asString ( ) : DEFAULT_VIRTUAL_SERVER ;
path = this . config . hasDefined ( ModelKeys . CONTEXT_PATH ) ? cleanContextPath ( this . config . get ( ModelKeys . CONTEXT_PATH ) . asString ( ) ) : DEFAULT_CONTEXT_PATH ;
this . serverName = config . hasDefined ( ModelKeys . NAME ) ? config . get ( ModelKeys . NAME ) . asString ( ) : " ;
try {
Class < ? > cls = Class . forName ( " , true , getClass ( ) . getClassLoader ( ) ) ;
cacheManagerSetter = cls . getMethod ( " , EmbeddedCacheManager . class ) ;
} catch ( Exception e ) {
throw new ServiceRegistryException ( " , e ) ;
}
}
private static String cleanContextPath ( String s ) {
if ( s . endsWith ( " ) )
return s . substring ( <num> , s . length ( )  <num> ) ;
else
return s ;
}
@Override
public synchronized void start ( StartContext startContext ) throws StartException {
long startTime = System . currentTimeMillis ( ) ;
log . infof ( " ) ;
EmbeddedCacheManager cacheManager = cacheManagerInjector . getValue ( ) ;
try {
cacheManagerSetter . invoke ( null , cacheManager ) ;
} catch ( Exception e ) {
throw new StartException ( " , e ) ;
}
try {
context . setPath ( path ) ;
context . addLifecycleListener ( new ContextConfig ( ) ) ;
context . setDocBase ( pathInjector . getValue ( ) + File . separatorChar + " ) ;
final Loader loader = new WebCtxLoader ( this . getClass ( ) . getClassLoader ( ) ) ;
Host host = hostInjector . getValue ( ) . getHost ( ) ;
loader . setContainer ( host ) ;
context . <unk> ( loader ) ;
context . <unk> ( new LocalInstanceManager ( ) ) ;
addContextApplicationParameter ( context , " , " ) ;
addContextApplicationParameter ( context , " , " ) ;
context . <unk> ( ResteasyBootstrap . class . getName ( ) ) ;
context . <unk> ( true ) ;
context . <unk> ( " ) ;
Wrapper wrapper = context . createWrapper ( ) ;
wrapper . setName ( " ) ;
wrapper . setServletClass ( " ) ;
context . addChild ( wrapper ) ;
context . addServletMapping ( " , " ) ;
context . addMimeMapping ( " , " ) ;
context . addMimeMapping ( " , " ) ;
HttpServletDispatcher hsd = new HttpServletDispatcher ( ) ;
Wrapper hsdWrapper = context . createWrapper ( ) ;
hsdWrapper . setName ( " ) ;
hsdWrapper . <unk> ( hsd ) ;
hsdWrapper . setServletClass ( hsd . getClass ( ) . getName ( ) ) ;
context . addChild ( hsdWrapper ) ;
context . addServletMapping ( " , " ) ;
host . addChild ( context ) ;
context . create ( ) ;
} catch ( Exception e ) {
throw new StartException ( " + serverName , e ) ;
}
try {
context . start ( ) ;
long elapsedTime = Math . max ( System . currentTimeMillis ( )  startTime , <num> ) ;
log . infof ( " , Long . valueOf ( elapsedTime ) ) ;
} catch ( LifecycleException e ) {
throw new StartException ( " + serverName , e ) ;
}
}
public String getVirtualServer ( ) {
return virtualServer ;
}
private static void addContextApplicationParameter ( Context context , String paramName , String paramValue ) {
ApplicationParameter parameter = new ApplicationParameter ( ) ;
parameter . setName ( paramName ) ;
parameter . setValue ( paramValue ) ;
context . addApplicationParameter ( parameter ) ;
}
@Override
public synchronized void stop ( StopContext stopContext ) {
try {
hostInjector . getValue ( ) . getHost ( ) . removeChild ( context ) ;
context . stop ( ) ;
} catch ( LifecycleException e ) {
log . error ( " , e ) ;
}
try {
context . destroy ( ) ;
} catch ( Exception e ) {
log . error ( " , e ) ;
}
}
String getCacheContainerName ( ) {
if ( ! config . hasDefined ( ModelKeys . CACHE_CONTAINER ) ) {
return null ;
}
return config . get ( ModelKeys . CACHE_CONTAINER ) . asString ( ) ;
}
@Override
public synchronized Context getValue ( ) throws IllegalStateException {
final Context context = this . context ;
if ( context == null ) {
throw new IllegalStateException ( ) ;
}
return context ;
}
public InjectedValue < String > getPathInjector ( ) {
return pathInjector ;
}
public InjectedValue < VirtualHost > getHostInjector ( ) {
return hostInjector ;
}
public InjectedValue < EmbeddedCacheManager > getCacheManager ( ) {
return cacheManagerInjector ;
}
private static class LocalInstanceManager implements InstanceManager {
@Override
public Object newInstance ( String className ) throws IllegalAccessException , InvocationTargetException , InstantiationException , ClassNotFoundException {
return Class . forName ( className ) . newInstance ( ) ;
}
@Override
public Object newInstance ( String fqcn , ClassLoader classLoader ) throws IllegalAccessException , InvocationTargetException , InstantiationException , ClassNotFoundException {
return Class . forName ( fqcn , false , classLoader ) . newInstance ( ) ;
}
@Override
public Object newInstance ( Class < ? > c ) throws IllegalAccessException , InvocationTargetException , InstantiationException {
return c . newInstance ( ) ;
}
@Override
public void newInstance ( Object o ) throws IllegalAccessException , InvocationTargetException {
throw new IllegalStateException ( ) ;
}
@Override
public void <unk> ( Object o ) throws IllegalAccessException , InvocationTargetException {
}
}
}
package com . redhat . datagrid . endpoint ;
import java . util . Locale ;
import org . jboss . as . controller . AbstractRemoveStepHandler ;
import org . jboss . as . controller . OperationContext ;
import org . jboss . as . controller . OperationFailedException ;
import org . jboss . as . controller . descriptions . DescriptionProvider ;
import org . jboss . dmr . ModelNode ;
public class HotRodSubsystemRemove extends AbstractRemoveStepHandler implements DescriptionProvider {
static final HotRodSubsystemRemove INSTANCE = new HotRodSubsystemRemove ( ) ;
@Override
protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model )
throws OperationFailedException {
context . removeService ( EndpointUtils . getServiceName ( operation , " ) ) ;
}
@Override
public ModelNode getModelDescription ( Locale locale ) {
return EndpointSubsystemProviders . REMOVE_HOTROD_CONNECTOR_DESC . getModelDescription ( locale ) ;
}
}
package com . redhat . datagrid . endpoint ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . ADD ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . DESCRIBE ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . REMOVE ;
import org . jboss . as . controller . Extension ;
import org . jboss . as . controller . ExtensionContext ;
import org . jboss . as . controller . PathElement ;
import org . jboss . as . controller . SubsystemRegistration ;
import org . jboss . as . controller . parsing . ExtensionParsingContext ;
import org . jboss . as . controller . registry . ManagementResourceRegistration ;
import org . jboss . as . controller . registry . OperationEntry ;
import org . jboss . msc . service . ServiceName ;
import com . redhat . datagrid . DataGridConstants ;
public class EndpointExtension implements Extension {
private final ServiceName serviceName = DataGridConstants . SN_ENDPOINT ;
private final String subsystemName = serviceName . getSimpleName ( ) ;
private final String namespaceUri = DataGridConstants . NS_ENDPOINT_1_0 ;
private final EndpointSubsystemParser parser = new EndpointSubsystemParser ( subsystemName , namespaceUri ) ;
@Override
public final void initialize ( ExtensionContext context ) {
final SubsystemRegistration registration = context . <unk> ( subsystemName ) ;
registration . <unk> ( parser ) ;
final ManagementResourceRegistration subsystem = registration . <unk> ( EndpointSubsystemProviders . SUBSYSTEM ) ;
subsystem . registerOperationHandler ( ADD , EndpointSubsystemAdd . INSTANCE , EndpointSubsystemAdd . INSTANCE , false ) ;
subsystem . registerOperationHandler ( DESCRIBE , EndpointSubsystemDescribe . INSTANCE , EndpointSubsystemDescribe . INSTANCE , false , OperationEntry . EntryType . PRIVATE ) ;
final ManagementResourceRegistration hotrodConnector = subsystem . registerSubModel ( PathElement . pathElement ( ModelKeys . HOTROD_CONNECTOR ) , EndpointSubsystemProviders . HOTROD_CONNECTOR_DESC ) ;
hotrodConnector . registerOperationHandler ( ADD , HotRodSubsystemAdd . INSTANCE , EndpointSubsystemProviders . ADD_HOTROD_CONNECTOR_DESC , false ) ;
hotrodConnector . registerOperationHandler ( REMOVE , HotRodSubsystemRemove . INSTANCE , EndpointSubsystemProviders . REMOVE_HOTROD_CONNECTOR_DESC , false ) ;
final ManagementResourceRegistration memcachedConnector = subsystem . registerSubModel ( PathElement . pathElement ( ModelKeys . MEMCACHED_CONNECTOR ) , EndpointSubsystemProviders . MEMCACHED_CONNECTOR_DESC ) ;
memcachedConnector . registerOperationHandler ( ADD , MemcachedSubsystemAdd . INSTANCE , EndpointSubsystemProviders . ADD_MEMCACHED_CONNECTOR_DESC , false ) ;
memcachedConnector . registerOperationHandler ( REMOVE , MemcachedSubsystemRemove . INSTANCE , EndpointSubsystemProviders . REMOVE_MEMCACHED_CONNECTOR_DESC , false ) ;
final ManagementResourceRegistration restConnector = subsystem . registerSubModel ( PathElement . pathElement ( ModelKeys . REST_CONNECTOR ) , EndpointSubsystemProviders . REST_CONNECTOR_DESC ) ;
restConnector . registerOperationHandler ( ADD , RestSubsystemAdd . INSTANCE , EndpointSubsystemProviders . ADD_REST_CONNECTOR_DESC , false ) ;
restConnector . registerOperationHandler ( REMOVE , RestSubsystemRemove . INSTANCE , EndpointSubsystemProviders . REMOVE_REST_CONNECTOR_DESC , false ) ;
}
@Override
public final void <unk> ( ExtensionParsingContext context ) {
context . <unk> ( namespaceUri , parser ) ;
}
package com . redhat . datagrid . endpoint ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . ADD ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . OP ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . OP_ADDR ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . SUBSYSTEM ;
import java . util . Collections ;
import java . util . List ;
import javax . xml . stream . XMLStreamConstants ;
import javax . xml . stream . XMLStreamException ;
import org . jboss . as . controller . parsing . ParseUtils ;
import org . jboss . as . controller . persistence . SubsystemMarshallingContext ;
import org . jboss . dmr . ModelNode ;
import org . jboss . dmr . Property ;
import org . jboss . staxmapper . XMLElementReader ;
import org . jboss . staxmapper . XMLElementWriter ;
import org . jboss . staxmapper . XMLExtendedStreamReader ;
import org . jboss . staxmapper . XMLExtendedStreamWriter ;
class EndpointSubsystemParser implements XMLStreamConstants , XMLElementReader < List < ModelNode >> , XMLElementWriter < SubsystemMarshallingContext > {
private final String subsystemName ;
private final String namespaceUri ;
EndpointSubsystemParser ( String subsystemName , String namespaceUri ) {
this . subsystemName = subsystemName ;
this . namespaceUri = namespaceUri ;
}
@Override
public void readElement ( final XMLExtendedStreamReader reader , final List < ModelNode > list ) throws XMLStreamException {
final ModelNode address = new ModelNode ( ) ;
address . add ( SUBSYSTEM , subsystemName ) ;
address . protect ( ) ;
final ModelNode subsystem = new ModelNode ( ) ;
subsystem . get ( OP ) . set ( ADD ) ;
subsystem . get ( OP_ADDR ) . set ( address ) ;
list . add ( subsystem ) ;
ModelNode op = null ;
String elemName = null ;
do {
int tag = reader . <unk> ( ) ;
if ( tag != XMLStreamConstants . <unk> ) {
continue ;
}
elemName = reader . getLocalName ( ) ;
if ( ModelKeys . HOTROD_CONNECTOR . equals ( elemName ) ) {
op = readServerConnector ( reader , ModelKeys . HOTROD_CONNECTOR , address ) ;
list . add ( op ) ;
} else if ( ModelKeys . MEMCACHED_CONNECTOR . equals ( elemName ) ) {
op = readServerConnector ( reader , ModelKeys . MEMCACHED_CONNECTOR , address ) ;
list . add ( op ) ;
} else if ( ModelKeys . REST_CONNECTOR . equals ( elemName ) ) {
op = readRestConnector ( reader , ModelKeys . REST_CONNECTOR , address ) ;
list . add ( op ) ;
} else if ( ModelKeys . TOPOLOGY_STATE_TRANSFER . equals ( elemName ) ) {
readTopologyStateTransfer ( reader , op ) ;
} else {
throw ParseUtils . <unk> ( reader ) ;
}
} while ( reader . hasNext ( ) && ! elemName . equals ( SUBSYSTEM ) ) ;
}
private ModelNode readServerConnector ( final XMLExtendedStreamReader reader , final String name , ModelNode parentAddress ) {
final ModelNode op = new ModelNode ( ) ;
op . get ( OP ) . set ( ADD ) ;
String providedName = name ;
String socketBinding = reader . getAttributeValue ( null , ModelKeys . SOCKET_BINDING ) ;
if ( socketBinding == null ) {
ParseUtils . <unk> ( reader , Collections . singleton ( ModelKeys . SOCKET_BINDING ) ) ;
}
op . get ( ModelKeys . SOCKET_BINDING ) . set ( socketBinding ) ;
int attrCnt = reader . getAttributeCount ( ) ;
for ( int i = <num> ; i < attrCnt ; i ++ ) {
String attrName = reader . getAttributeLocalName ( i ) ;
String attrValue = reader . getAttributeValue ( i ) ;
if ( ModelKeys . NAME . equals ( attrName ) ) {
op . get ( ModelKeys . NAME ) . set ( attrValue ) ;
providedName = attrValue ;
} else if ( ModelKeys . CACHE_CONTAINER . equals ( attrName ) ) {
op . get ( ModelKeys . CACHE_CONTAINER ) . set ( attrValue ) ;
} else if ( ModelKeys . WORKER_THREADS . equals ( attrName ) ) {
op . get ( ModelKeys . WORKER_THREADS ) . set ( Integer . parseInt ( attrValue ) ) ;
} else if ( ModelKeys . IDLE_TIMEOUT . equals ( attrName ) ) {
op . get ( ModelKeys . IDLE_TIMEOUT ) . set ( Integer . parseInt ( attrValue ) ) ;
} else if ( ModelKeys . TCP_NODELAY . equals ( attrName ) ) {
op . get ( ModelKeys . TCP_NODELAY ) . set ( Boolean . parseBoolean ( attrValue ) ) ;
} else if ( ModelKeys . SEND_BUFFER_SIZE . equals ( attrName ) ) {
op . get ( ModelKeys . SEND_BUFFER_SIZE ) . set ( Integer . parseInt ( attrValue ) ) ;
} else if ( ModelKeys . RECEIVE_BUFFER_SIZE . equals ( attrName ) ) {
op . get ( ModelKeys . RECEIVE_BUFFER_SIZE ) . set ( Integer . parseInt ( attrValue ) ) ;
} else if ( ModelKeys . SOCKET_BINDING . equals ( attrName ) ) {
} else {
ParseUtils . unexpectedAttribute ( reader , i ) ;
}
}
final ModelNode address = parentAddress . clone ( ) ;
address . add ( name , providedName ) ;
address . protect ( ) ;
op . get ( OP_ADDR ) . set ( address ) ;
return op ;
}
private ModelNode readRestConnector ( final XMLExtendedStreamReader reader , final String name , ModelNode parentAddress ) {
final ModelNode op = new ModelNode ( ) ;
op . get ( OP ) . set ( ADD ) ;
final ModelNode address = parentAddress . clone ( ) ;
address . add ( name , name ) ;
address . protect ( ) ;
op . get ( OP_ADDR ) . set ( address ) ;
int attrCnt = reader . getAttributeCount ( ) ;
for ( int i = <num> ; i < attrCnt ; i ++ ) {
String attrName = reader . getAttributeLocalName ( i ) ;
String attrValue = reader . getAttributeValue ( i ) ;
if ( ModelKeys . NAME . equals ( attrName ) ) {
op . get ( ModelKeys . NAME ) . set ( attrValue ) ;
} else if ( ModelKeys . CACHE_CONTAINER . equals ( attrName ) ) {
op . get ( ModelKeys . CACHE_CONTAINER ) . set ( attrValue ) ;
} else if ( ModelKeys . VIRTUAL_SERVER . equals ( attrName ) ) {
op . get ( ModelKeys . VIRTUAL_SERVER ) . set ( attrValue ) ;
} else if ( ModelKeys . CONTEXT_PATH . equals ( attrName ) ) {
op . get ( ModelKeys . CONTEXT_PATH ) . set ( attrValue ) ;
} else {
ParseUtils . unexpectedAttribute ( reader , i ) ;
}
}
return op ;
}
private void readTopologyStateTransfer ( final XMLExtendedStreamReader reader , final ModelNode operation ) {
ModelNode topologyStateTransfer = operation . get ( ModelKeys . TOPOLOGY_STATE_TRANSFER ) ;
int attrCnt = reader . getAttributeCount ( ) ;
for ( int i = <num> ; i < attrCnt ; i ++ ) {
String attrName = reader . getAttributeLocalName ( i ) ;
String attrValue = reader . getAttributeValue ( i ) ;
if ( ModelKeys . LOCK_TIMEOUT . equals ( attrName ) ) {
topologyStateTransfer . get ( ModelKeys . LOCK_TIMEOUT ) . set ( Integer . parseInt ( attrValue ) ) ;
} else if ( ModelKeys . REPLICATION_TIMEOUT . equals ( attrName ) ) {
topologyStateTransfer . get ( ModelKeys . REPLICATION_TIMEOUT ) . set ( Integer . parseInt ( attrValue ) ) ;
} else if ( ModelKeys . UPDATE_TIMEOUT . equals ( attrName ) ) {
topologyStateTransfer . get ( ModelKeys . UPDATE_TIMEOUT ) . set ( Integer . parseInt ( attrValue ) ) ;
} else if ( ModelKeys . EXTERNAL_HOST . equals ( attrName ) ) {
topologyStateTransfer . get ( ModelKeys . EXTERNAL_HOST ) . set ( attrValue ) ;
} else if ( ModelKeys . EXTERNAL_PORT . equals ( attrName ) ) {
topologyStateTransfer . get ( ModelKeys . EXTERNAL_PORT ) . set ( Integer . parseInt ( attrValue ) ) ;
} else if ( ModelKeys . LAZY_RETRIEVAL . equals ( attrName ) ) {
topologyStateTransfer . get ( ModelKeys . LAZY_RETRIEVAL ) . set ( Boolean . parseBoolean ( attrValue ) ) ;
} else {
ParseUtils . unexpectedAttribute ( reader , i ) ;
}
}
}
@Override
public void writeContent ( final XMLExtendedStreamWriter writer , final SubsystemMarshallingContext context ) throws XMLStreamException {
context . <unk> ( namespaceUri , false ) ;
final ModelNode node = context . <unk> ( ) ;
writeConnectors ( writer , node ) ;
writer . <unk> ( ) ;
}
private void writeConnectors ( final XMLExtendedStreamWriter writer , final ModelNode node ) throws XMLStreamException {
for ( String connectorType : ModelKeys . CONNECTORS ) {
if ( node . hasDefined ( connectorType ) ) {
ModelNode connectors = node . get ( connectorType ) ;
for ( Property property : connectors . asPropertyList ( ) ) {
ModelNode connector = property . getValue ( ) ;
writer . writeEmptyElement ( connectorType ) ;
for ( String connectorAttribute : ModelKeys . CONNECTOR_ATTRIBUTES ) {
if ( connector . hasDefined ( connectorAttribute ) ) {
writer . writeAttribute ( connectorAttribute , connector . get ( connectorAttribute ) . asString ( ) ) ;
}
}
writeTopologyStateTransfer ( writer , connector ) ;
}
}
}
}
private void writeTopologyStateTransfer ( final XMLExtendedStreamWriter writer , final ModelNode node ) throws XMLStreamException {
if ( node . hasDefined ( ModelKeys . TOPOLOGY_STATE_TRANSFER ) ) {
ModelNode topologyStateTransfer = node . get ( ModelKeys . TOPOLOGY_STATE_TRANSFER ) ;
writer . writeEmptyElement ( ModelKeys . TOPOLOGY_STATE_TRANSFER ) ;
for ( String connectorAttribute : ModelKeys . TOPOLOGY_ATTRIBUTES ) {
if ( topologyStateTransfer . hasDefined ( connectorAttribute ) ) {
writer . writeAttribute ( connectorAttribute , topologyStateTransfer . get ( connectorAttribute ) . asString ( ) ) ;
}
}
}
}
}
package com . redhat . datagrid ;
import java . security . AccessController ;
import java . security . PrivilegedAction ;
public class SecurityActions {
interface TCLAction {
class UTIL {
static TCLAction getTCLAction ( ) {
return System . getSecurityManager ( ) == null ? NON_PRIVILEGED : PRIVILEGED ;
}
static ClassLoader getContextClassLoader ( ) {
return getTCLAction ( ) . getContextClassLoader ( ) ;
}
static ClassLoader getContextClassLoader ( Thread thread ) {
return getTCLAction ( ) . getContextClassLoader ( thread ) ;
}
static void setContextClassLoader ( ClassLoader cl ) {
getTCLAction ( ) . setContextClassLoader ( cl ) ;
}
static void setContextClassLoader ( Thread thread , ClassLoader cl ) {
getTCLAction ( ) . setContextClassLoader ( thread , cl ) ;
}
}
TCLAction NON_PRIVILEGED = new TCLAction ( ) {
@Override
public ClassLoader getContextClassLoader ( ) {
return Thread . currentThread ( ) . getContextClassLoader ( ) ;
}
@Override
public ClassLoader getContextClassLoader ( Thread thread ) {
return thread . getContextClassLoader ( ) ;
}
@Override
public void setContextClassLoader ( ClassLoader cl ) {
Thread . currentThread ( ) . setContextClassLoader ( cl ) ;
}
@Override
public void setContextClassLoader ( Thread thread , ClassLoader cl ) {
thread . setContextClassLoader ( cl ) ;
}
} ;
TCLAction PRIVILEGED = new TCLAction ( ) {
private final PrivilegedAction < ClassLoader > getTCLPrivilegedAction = new PrivilegedAction < ClassLoader > ( ) {
@Override
public ClassLoader run ( ) {
return Thread . currentThread ( ) . getContextClassLoader ( ) ;
}
} ;
@Override
public ClassLoader getContextClassLoader ( ) {
return AccessController . doPrivileged ( getTCLPrivilegedAction ) ;
}
@Override
public ClassLoader getContextClassLoader ( final Thread thread ) {
return AccessController . doPrivileged ( new PrivilegedAction < ClassLoader > ( ) {
@Override
public ClassLoader run ( ) {
return thread . getContextClassLoader ( ) ;
}
} ) ;
}
@Override
public void setContextClassLoader ( final ClassLoader cl ) {
AccessController . doPrivileged ( new PrivilegedAction < ClassLoader > ( ) {
@Override
public ClassLoader run ( ) {
Thread . currentThread ( ) . setContextClassLoader ( cl ) ;
return null ;
}
} ) ;
}
@Override
public void setContextClassLoader ( final Thread thread , final ClassLoader cl ) {
AccessController . doPrivileged ( new PrivilegedAction < ClassLoader > ( ) {
@Override
public ClassLoader run ( ) {
thread . setContextClassLoader ( cl ) ;
return null ;
}
} ) ;
}
} ;
ClassLoader getContextClassLoader ( ) ;
ClassLoader getContextClassLoader ( Thread thread ) ;
void setContextClassLoader ( ClassLoader cl ) ;
void setContextClassLoader ( Thread thread , ClassLoader cl ) ;
}
public static ClassLoader getContextClassLoader ( ) {
return TCLAction . UTIL . getContextClassLoader ( ) ;
}
public static void setContextClassLoader ( ClassLoader loader ) {
TCLAction . UTIL . setContextClassLoader ( loader ) ;
}
}
package com . redhat . datagrid . endpoint ;
import java . util . Locale ;
import org . jboss . as . controller . AbstractAddStepHandler ;
import org . jboss . as . controller . OperationFailedException ;
import org . jboss . as . controller . descriptions . DescriptionProvider ;
import org . jboss . as . controller . descriptions . ModelDescriptionConstants ;
import org . jboss . as . controller . operations . common . Util ;
import org . jboss . dmr . ModelNode ;
class EndpointSubsystemAdd extends AbstractAddStepHandler implements DescriptionProvider {
static final EndpointSubsystemAdd INSTANCE = new EndpointSubsystemAdd ( ) ;
static ModelNode createOperation ( ModelNode address , ModelNode existing ) {
ModelNode operation = Util . getEmptyOperation ( ModelDescriptionConstants . ADD , address ) ;
populate ( existing , operation ) ;
return operation ;
}
private static void populate ( ModelNode source , ModelNode target ) {
for ( String connectorType : ModelKeys . CONNECTORS ) {
target . get ( connectorType ) . setEmptyObject ( ) ;
}
}
@Override
public ModelNode getModelDescription ( Locale locale ) {
return EndpointSubsystemProviders . SUBSYTEM_ADD . getModelDescription ( locale ) ;
}
@Override
protected void populateModel ( ModelNode source , ModelNode target ) throws OperationFailedException {
populate ( source , target ) ;
}
@Override
protected boolean requiresRuntimeVerification ( ) {
return false ;
}
}
package com . redhat . datagrid . endpoint ;
import java . util . Locale ;
import org . jboss . as . controller . AbstractRemoveStepHandler ;
import org . jboss . as . controller . OperationContext ;
import org . jboss . as . controller . OperationFailedException ;
import org . jboss . as . controller . descriptions . DescriptionProvider ;
import org . jboss . dmr . ModelNode ;
public class RestSubsystemRemove extends AbstractRemoveStepHandler implements DescriptionProvider {
static final RestSubsystemRemove INSTANCE = new RestSubsystemRemove ( ) ;
@Override
protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model )
throws OperationFailedException {
context . removeService ( EndpointUtils . getServiceName ( operation , " ) ) ;
}
@Override
public ModelNode getModelDescription ( Locale locale ) {
return EndpointSubsystemProviders . REMOVE_REST_CONNECTOR_DESC . getModelDescription ( locale ) ;
}
}
package com . redhat . datagrid . endpoint ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . OP_ADDR ;
import org . infinispan . manager . EmbeddedCacheManager ;
import org . jboss . as . controller . OperationContext ;
import org . jboss . as . controller . PathAddress ;
import org . jboss . as . controller . PathElement ;
import org . jboss . as . network . SocketBinding ;
import org . jboss . dmr . ModelNode ;
import org . jboss . msc . service . ServiceBuilder ;
import org . jboss . msc . service . ServiceName ;
import org . jboss . msc . value . InjectedValue ;
import com . redhat . datagrid . DataGridConstants ;
public class EndpointUtils {
private static final String INFINISPAN_SERVICE_NAME = " ;
public static ServiceName getCacheContainerServiceName ( String cacheContainerName ) {
ServiceName cacheContainerServiceName = ServiceName . JBOSS . append ( INFINISPAN_SERVICE_NAME ) ;
if ( cacheContainerName != null ) {
cacheContainerServiceName = cacheContainerServiceName . append ( cacheContainerName ) ;
}
return cacheContainerServiceName ;
}
public static ServiceName getServiceName ( final ModelNode node , final String . . . prefix ) {
final PathAddress address = PathAddress . pathAddress ( node . require ( OP_ADDR ) ) ;
final String name = address . getLastElement ( ) . getValue ( ) ;
if ( prefix . length > <num> )
return DataGridConstants . SN_ENDPOINT . append ( prefix ) . append ( name ) ;
else
return DataGridConstants . SN_ENDPOINT . append ( name ) ;
}
public static void addCacheContainerDependency ( OperationContext context , ServiceBuilder < ? > builder , String cacheContainerName , InjectedValue < EmbeddedCacheManager > target ) {
ServiceName cacheContainerServiceName = getCacheContainerServiceName ( cacheContainerName ) ;
builder . addDependency ( ServiceBuilder . <unk> . REQUIRED , cacheContainerServiceName , EmbeddedCacheManager . class , target ) ;
}
public static void addSocketBindingDependency ( ServiceBuilder < ? > builder , String socketBindingName , InjectedValue < SocketBinding > target ) {
final ServiceName socketName = SocketBinding . <unk> . append ( socketBindingName ) ;
builder . addDependency ( socketName , SocketBinding . class , target ) ;
}
public static ModelNode pathAddress ( PathElement . . . elements ) {
return PathAddress . pathAddress ( elements ) . toModelNode ( ) ;
}
public static void copyIfSet ( String name , ModelNode source , ModelNode target ) {
if ( source . hasDefined ( name ) ) {
target . get ( name ) . set ( source . get ( name ) ) ;
}
}
}
package com . redhat . datagrid . endpoint ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . ADD ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . OP ;
import static org . jboss . as . controller . descriptions . ModelDescriptionConstants . OP_ADDR ;
import java . util . Locale ;
import org . jboss . as . controller . OperationContext ;
import org . jboss . as . controller . OperationFailedException ;
import org . jboss . as . controller . OperationStepHandler ;
import org . jboss . as . controller . PathAddress ;
import org . jboss . as . controller . descriptions . DescriptionProvider ;
import org . jboss . as . controller . descriptions . common . CommonDescriptions ;
import org . jboss . as . controller . operations . common . Util ;
import org . jboss . dmr . ModelNode ;
import org . jboss . dmr . Property ;
class EndpointSubsystemDescribe implements OperationStepHandler , DescriptionProvider {
static final EndpointSubsystemDescribe INSTANCE = new EndpointSubsystemDescribe ( ) ;
@Override
public ModelNode getModelDescription ( Locale locale ) {
return CommonDescriptions . <unk> ( locale ) ;
}
@Override
public void execute ( OperationContext context , ModelNode operation )
throws OperationFailedException {
final ModelNode result = context . getResult ( ) ;
final PathAddress rootAddress = PathAddress . pathAddress ( PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) . getLastElement ( ) ) ;
final ModelNode subModel = context . readModel ( PathAddress . <unk> ) ;
final ModelNode subsystemAdd = new ModelNode ( ) ;
subsystemAdd . get ( OP ) . set ( ADD ) ;
subsystemAdd . get ( OP_ADDR ) . set ( rootAddress . toModelNode ( ) ) ;
result . add ( subsystemAdd ) ;
for ( String connectorType : ModelKeys . CONNECTORS ) {
if ( subModel . hasDefined ( connectorType ) ) {
for ( final Property connector : subModel . get ( connectorType ) . asPropertyList ( ) ) {
final ModelNode address = rootAddress . toModelNode ( ) ;
address . add ( connectorType , connector . getName ( ) ) ;
final ModelNode addOperation = Util . getEmptyOperation ( ADD , address ) ;
for ( String connectorAttribute : ModelKeys . CONNECTOR_ATTRIBUTES ) {
if ( connector . getValue ( ) . hasDefined ( connectorAttribute ) ) {
addOperation . get ( connectorAttribute ) . set ( connector . getValue ( ) . get ( connectorAttribute ) ) ;
}
}
result . add ( addOperation ) ;
}
}
}
context . <unk> ( ) ;
}
}
package com . redhat . datagrid ;
import org . jboss . msc . service . ServiceName ;
public class DataGridConstants {
private static final ServiceName REDHAT = ServiceName . of ( " ) ;
public static final ServiceName DATAGRID = REDHAT . append ( " ) ;
public static final ServiceName SN_ENDPOINT = DATAGRID . append ( " ) ;
public static final String NS_ENDPOINT_1_0 = " ;
public static String VERSION = DataGridConstants . class . getPackage ( ) . getImplementationVersion ( ) ;
private DataGridConstants ( ) {
}
}
package com . redhat . datagrid . endpoint ;
import java . net . InetSocketAddress ;
import java . util . Properties ;
import org . infinispan . manager . EmbeddedCacheManager ;
import org . infinispan . server . core . Main ;
import org . infinispan . server . core . ProtocolServer ;
import org . jboss . as . network . SocketBinding ;
import org . jboss . dmr . ModelNode ;
import org . jboss . logging . Logger ;
import org . jboss . msc . service . Service ;
import org . jboss . msc . service . StartContext ;
import org . jboss . msc . service . StartException ;
import org . jboss . msc . service . StopContext ;
import org . jboss . msc . value . InjectedValue ;
import com . redhat . datagrid . SecurityActions ;
class ProtocolServerService implements Service < ProtocolServer > {
private static final Logger log = Logger . getLogger ( ProtocolServerService . class ) ;
private final InjectedValue < EmbeddedCacheManager > cacheManager = new InjectedValue < EmbeddedCacheManager > ( ) ;
private final InjectedValue < SocketBinding > socketBinding = new InjectedValue < SocketBinding > ( ) ;
private final ModelNode config ;
private final Properties connectorProperties = new Properties ( ) ;
private final Properties topologyStateTransferProperties = new Properties ( ) ;
private Class < ? extends ProtocolServer > serverClass ;
private ProtocolServer protocolServer ;
private String serverName ;
ProtocolServerService ( ModelNode config , Class < ? extends ProtocolServer > serverClass ) {
this . config = config . clone ( ) ;
this . serverClass = serverClass ;
String serverTypeName = serverClass . getSimpleName ( ) ;
this . serverName = config . hasDefined ( ModelKeys . NAME ) ? serverTypeName + " + config . get ( ModelKeys . NAME ) . asString ( ) : serverTypeName ;
}
@Override
public synchronized void start ( final StartContext context ) throws StartException {
long startTime = System . currentTimeMillis ( ) ;
log . infof ( " , serverName ) ;
assert connectorProperties . isEmpty ( ) ;
assert topologyStateTransferProperties . isEmpty ( ) ;
ClassLoader origTCCL = SecurityActions . getContextClassLoader ( ) ;
boolean done = false ;
try {
loadConnectorProperties ( config ) ;
loadTopologyStateTransferProperties ( config ) ;
validateConfiguration ( ) ;
log . debugf ( " , connectorProperties ) ;
log . debugf ( " , topologyStateTransferProperties ) ;
startProtocolServer ( ) ;
long elapsedTime = Math . max ( System . currentTimeMillis ( )  startTime , <num> ) ;
log . infof ( " , serverName , Long . valueOf ( elapsedTime ) ) ;
done = true ;
} catch ( StartException e ) {
throw e ;
} catch ( Exception e ) {
throw new StartException ( " + serverName , e ) ;
} finally {
if ( ! done ) {
doStop ( ) ;
}
SecurityActions . setContextClassLoader ( origTCCL ) ;
}
}
private void validateConfiguration ( ) throws StartException {
if ( connectorProperties . isEmpty ( ) ) {
throw new StartException ( " ) ;
}
}
private void startProtocolServer ( ) throws StartException {
Properties props = copy ( connectorProperties ) ;
if ( props == null ) {
return ;
}
props . putAll ( topologyStateTransferProperties ) ;
SecurityActions . setContextClassLoader ( serverClass . getClassLoader ( ) ) ;
ProtocolServer server ;
try {
server = serverClass . newInstance ( ) ;
} catch ( Exception e ) {
throw new StartException ( " + serverName , e ) ;
}
log . debugf ( " , serverName ) ;
server . start ( props , getCacheManager ( ) . getValue ( ) ) ;
protocolServer = server ;
}
@Override
public synchronized void stop ( final StopContext context ) {
doStop ( ) ;
}
private void doStop ( ) {
long stopTime = System . currentTimeMillis ( ) ;
try {
if ( protocolServer != null ) {
log . debugf ( " , serverName ) ;
try {
protocolServer . stop ( ) ;
} catch ( Exception e ) {
log . <unk> ( e , " , serverName ) ;
}
}
} finally {
connectorProperties . clear ( ) ;
topologyStateTransferProperties . clear ( ) ;
long elapsedTime = Math . max ( System . currentTimeMillis ( )  stopTime , <num> ) ;
log . infof ( " , serverName , Long . valueOf ( elapsedTime ) ) ;
}
}
@Override
public synchronized ProtocolServer getValue ( ) throws IllegalStateException {
if ( protocolServer == null ) {
throw new IllegalStateException ( ) ;
}
return protocolServer ;
}
InjectedValue < EmbeddedCacheManager > getCacheManager ( ) {
return cacheManager ;
}
String getCacheContainerName ( ) {
if ( ! config . hasDefined ( ModelKeys . CACHE_CONTAINER ) ) {
return null ;
}
return config . get ( ModelKeys . CACHE_CONTAINER ) . asString ( ) ;
}
String getRequiredSocketBindingName ( ) {
return config . hasDefined ( ModelKeys . SOCKET_BINDING ) ? config . get ( ModelKeys . SOCKET_BINDING ) . asString ( ) : null ;
}
InjectedValue < SocketBinding > getSocketBinding ( ) {
return socketBinding ;
}
private void loadConnectorProperties ( ModelNode config ) {
if ( config . hasDefined ( ModelKeys . SOCKET_BINDING ) ) {
SocketBinding socketBinding = getSocketBinding ( ) . getValue ( ) ;
InetSocketAddress socketAddress = socketBinding . <unk> ( ) ;
connectorProperties . setProperty ( Main . <unk> ( ) , socketAddress . getAddress ( ) . getHostAddress ( ) ) ;
connectorProperties . setProperty ( Main . <unk> ( ) , String . valueOf ( socketAddress . getPort ( ) ) ) ;
}
if ( config . hasDefined ( ModelKeys . WORKER_THREADS ) ) {
connectorProperties . setProperty ( Main . <unk> ( ) , config . get ( ModelKeys . WORKER_THREADS ) . asString ( ) ) ;
}
if ( config . hasDefined ( ModelKeys . IDLE_TIMEOUT ) ) {
connectorProperties . setProperty ( Main . <unk> ( ) , config . get ( ModelKeys . IDLE_TIMEOUT ) . asString ( ) ) ;
}
if ( config . hasDefined ( ModelKeys . TCP_NODELAY ) ) {
connectorProperties . setProperty ( Main . <unk> ( ) , config . get ( ModelKeys . TCP_NODELAY ) . asString ( ) ) ;
}
if ( config . hasDefined ( ModelKeys . SEND_BUFFER_SIZE ) ) {
connectorProperties . setProperty ( Main . <unk> ( ) , config . get ( ModelKeys . SEND_BUFFER_SIZE ) . asString ( ) ) ;
}
if ( config . hasDefined ( ModelKeys . RECEIVE_BUFFER_SIZE ) ) {
connectorProperties . setProperty ( Main . <unk> ( ) , config . get ( ModelKeys . RECEIVE_BUFFER_SIZE ) . asString ( ) ) ;
}
}
private void loadTopologyStateTransferProperties ( ModelNode config ) {
if ( ! config . hasDefined ( ModelKeys . TOPOLOGY_STATE_TRANSFER ) ) {
return ;
}
config = config . get ( ModelKeys . TOPOLOGY_STATE_TRANSFER ) ;
if ( config . hasDefined ( ModelKeys . LOCK_TIMEOUT ) ) {
topologyStateTransferProperties . setProperty ( Main . <unk> ( ) , config . get ( ModelKeys . LOCK_TIMEOUT ) . asString ( ) ) ;
}
if ( config . hasDefined ( ModelKeys . REPLICATION_TIMEOUT ) ) {
topologyStateTransferProperties . setProperty ( Main . <unk> ( ) , config . get ( ModelKeys . REPLICATION_TIMEOUT ) . asString ( ) ) ;
}
if ( config . hasDefined ( ModelKeys . UPDATE_TIMEOUT ) ) {
topologyStateTransferProperties . setProperty ( Main . <unk> ( ) , config . get ( ModelKeys . UPDATE_TIMEOUT ) . asString ( ) ) ;
}
if ( config . hasDefined ( ModelKeys . EXTERNAL_HOST ) ) {
topologyStateTransferProperties . setProperty ( Main . <unk> ( ) , config . get ( ModelKeys . EXTERNAL_HOST ) . asString ( ) ) ;
}
if ( config . hasDefined ( ModelKeys . EXTERNAL_PORT ) ) {
topologyStateTransferProperties . setProperty ( Main . <unk> ( ) , config . get ( ModelKeys . EXTERNAL_PORT ) . asString ( ) ) ;
}
if ( config . hasDefined ( ModelKeys . LAZY_RETRIEVAL ) ) {
topologyStateTransferProperties . setProperty ( Main . <unk> ( ) , Boolean . toString ( ! config . get ( ModelKeys . LAZY_RETRIEVAL ) . <unk> ( false ) ) ) ;
}
}
private static Properties copy ( Properties p ) {
if ( p == null ) {
return null ;
}
Properties newProps = new Properties ( ) ;
newProps . putAll ( p ) ;
return newProps ;
}
}
import java . io . IOException ;
import javax . servlet . ServletException ;
import javax . servlet . http . * ;
import org . eclipse . jetty . server . Server ;
import org . eclipse . jetty . servlet . * ;
import java . util . * ;
import com . twilio . sdk . * ;
import com . twilio . sdk . resource . factory . * ;
import com . twilio . sdk . resource . instance . * ;
public class TwilioServer extends HttpServlet {
private static TwilioRestClient tclient ;
private static Account mainAccount ;
private static <unk> smsFactory ;
private final static String ACCOUNT_SID = " ;
private final static String AUTH_TOKEN = " ;
@Override
protected void doGet ( HttpServletRequest req , HttpServletResponse resp )
throws ServletException , IOException {
String incomingMessage = req . getParameter ( " ) ;
if ( incomingMessage == null ) {
resp . getWriter ( ) . print ( " ) ;
return ;
}
String fromNum = req . getParameter ( " ) ;
Map < String , String > smsParams = new HashMap < String , String > ( ) ;
smsParams . put ( " , fromNum ) ;
smsParams . put ( " , " ) ;
String messageBody = req . getParameter ( " ) ;
int commandIndex = messageBody . indexOf ( " ) ;
String command = messageBody . substring ( <num> , commandIndex ) ;
String [ ] args = messageBody . substring ( commandIndex + <num> ) . split ( " ) ;
String responseBody = " ;
if ( command . equals ( " ) ) {
responseBody = randomlyDecide ( args ) ;
}
smsParams . put ( " , responseBody ) ;
try {
smsFactory . create ( smsParams ) ;
} catch ( <unk> e ) {
e . printStackTrace ( ) ;
}
}
private String randomlyDecide ( String [ ] command ) {
Random generator = new Random ( ) ;
return ( " + command [ generator . nextInt ( command . length ) ] ) ;
}
public static void main ( String [ ] args ) throws Exception {
Server server = new Server ( Integer . valueOf ( System . getenv ( " ) ) ) ;
ServletContextHandler context = new ServletContextHandler ( ServletContextHandler . SESSIONS ) ;
context . setContextPath ( " ) ;
server . setHandler ( context ) ;
context . addServlet ( new ServletHolder ( new TwilioServer ( ) ) , " ) ;
initTwilio ( ) ;
server . start ( ) ;
server . join ( ) ;
}
public static void initTwilio ( ) {
tclient = new TwilioRestClient ( ACCOUNT_SID , AUTH_TOKEN ) ;
mainAccount = tclient . getAccount ( ) ;
smsFactory = mainAccount . <unk> ( ) ;
}
}
package engine . renderer ;
import java . awt . Canvas ;
import java . io . IOException ;
import org . lwjgl . LWJGLException ;
import org . lwjgl . opengl . Display ;
import org . newdawn . slick . opengl . Texture ;
import org . newdawn . slick . opengl . TextureLoader ;
import org . newdawn . slick . util . ResourceLoader ;
import engine . classes . GameObject ;
import static org . lwjgl . opengl . GL11 . * ;
public class GraphicsControl {
static int <unk> ;
static int <unk> ;
final static int screenWidth = <num> ;
final static int screenHeight = <num> ;
public final static float mouseMultiplier = ( <num> / <num> ) * screenWidth ;
public static Texture whiteTex ;
public static Sprite whiteSprite ;
static Canvas display_parent ;
static public int returnScrWidth ( ) { return screenWidth ; }
static public int returnScrHeight ( ) { return screenHeight ; }
public static void startLWJGL ( ) {
try {
Display . setParent ( display_parent ) ;
Display . create ( ) ;
} catch ( LWJGLException e ) {
e . printStackTrace ( ) ;
}
}
@SuppressWarnings("unused")
private static void stopLWJGL ( ) {
Display . destroy ( ) ;
}
static public void Init ( ) {
glClearColor ( <num> , <num> / <num> , <num> / <num> , <num> ) ;
glMatrixMode ( GL_PROJECTION ) ;
glOrtho ( <num> , screenWidth , screenHeight , <num> ,  <num> , <num> ) ;
glShadeModel ( GL_SMOOTH ) ;
glHint ( GL_PERSPECTIVE_CORRECTION_HINT , GL_NICEST ) ;
glViewport ( <num> , <num> , screenWidth , screenHeight ) ;
glMatrixMode ( GL_MODELVIEW ) ;
glLoadIdentity ( ) ;
glEnable ( GL_TEXTURE_2D ) ;
<unk> ( <num> ) ;
glEnable ( <unk> ) ;
<unk> ( <unk> , <num> ) ;
glEnable ( <unk> ) ;
Display . <unk> ( true ) ;
whiteTex = LoadTexture ( " ) ;
new Sprite ( " ) ;
}
static public Texture LoadTexture ( String fileName ) {
Texture rettexture = null ;
try {
rettexture = TextureLoader . getTexture (
" ,
ResourceLoader . getResourceAsStream ( "
+ fileName + " ) ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
return rettexture ;
}
static public void ApplySprite ( Sprite sprite , float imX1 , float imY1 ,
float imZ , int frameNum , int animNum , float [ ] objColour , float zoomX ,
float rotationX ) {
int frameWidth = sprite . frameWidth ;
int frameHeight = sprite . frameHeight ;
float imX2 = imX1 + frameWidth ;
float imY2 = imY1 + frameHeight ;
glPushMatrix ( ) ;
{
glTranslatef ( imX2 , imY2 , imZ ) ;
glScalef ( zoomX , zoomX , <num> ) ;
glRotatef ( rotationX , <num> , <num> , <num> ) ;
glTranslatef (  imX2 ,  imY2 ,  imZ ) ;
glTranslatef ( <num> , <num> , imZ ) ;
double highX = ( ( double ) sprite . texture . getImageWidth ( ) / sprite . texture
. getTextureWidth ( ) ) ;
double highY = ( ( double ) sprite . texture . getImageHeight ( ) / sprite . texture
. getTextureHeight ( ) ) ;
double frX1 = ( highX / ( ( double ) sprite . texture . getImageWidth ( ) / frameWidth ) )
* frameNum ;
double frX2 = frX1
+ ( highX / ( ( double ) sprite . texture . getImageWidth ( ) / frameWidth ) ) ;
double frY1 = ( highY / ( ( double ) sprite . texture . getImageHeight ( ) / frameHeight ) )
* animNum ;
double frY2 = frY1
+ ( highY / ( ( double ) sprite . texture . getImageHeight ( ) / frameHeight ) ) ;
glEnable ( GL_BLEND ) ;
glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) ;
glColor4f ( objColour [ <num> ] , objColour [ <num> ] , objColour [ <num> ] , objColour [ <num> ] ) ;
sprite . texture . bind ( ) ;
glBegin ( GL_QUADS ) ;
glTexCoord2d ( frX1 , frY1 ) ;
glVertex2f ( imX1 , imY1 ) ;
glTexCoord2d ( frX2 , frY1 ) ;
glVertex2f ( imX2 , imY1 ) ;
glTexCoord2d ( frX2 , frY2 ) ;
glVertex2f ( imX2 , imY2 ) ;
glTexCoord2d ( frX1 , frY2 ) ;
glVertex2f ( imX1 , imY2 ) ;
glEnd ( ) ;
glDisable ( GL_BLEND ) ;
glColor4f ( <num> , <num> , <num> , <num> ) ;
}
glPopMatrix ( ) ;
}
static public void ApplySprite ( GameObject object , int frameNumber , int animNumber ) {
ApplySprite ( object . GetSprite ( ) , object . GetX ( ) , object . GetY ( ) , object . GetZ ( ) , frameNumber , animNumber , object . GetColour ( ) , object . GetZoom ( ) , object . GetRotation ( ) ) ;
}
static public void ApplySprite ( Sprite sprite , float xx , float yy ) {
float [ ] tempColour = { <num> , <num> , <num> , <num> } ;
ApplySprite ( sprite , xx , yy , <num> , <num> , <num> , tempColour , <num> , <num> ) ;
}
static public void ApplySprite ( Sprite sprite , float xx , float yy , float zz ) {
float [ ] tempColour = { <num> , <num> , <num> , <num> } ;
ApplySprite ( sprite , xx , yy , zz , <num> , <num> , tempColour , <num> , <num> ) ;
}
static public void ApplySprite ( Sprite sprite , float xx , float yy , float zz , float zoom ) {
float [ ] tempColour = { <num> , <num> , <num> , <num> } ;
ApplySprite ( sprite , xx , yy , zz , <num> , <num> , tempColour , zoom , <num> ) ;
}
static public void DrawBox2D_withDepth ( float x1 , float x2 , float y1 , float y2 , float z1 , Texture TextureX , boolean hollow )
{
TextureX . bind ( ) ;
glTranslatef ( <num> , <num> , z1 ) ;
if ( hollow == false )
{ glBegin ( GL_QUADS ) ; }
else
{ glBegin ( GL_LINE_LOOP ) ; } ;
glTexCoord2f ( <num> , <num> ) ; glVertex3f ( x1 , y1 , <num> ) ;
glTexCoord2f ( <num> , <num> ) ; glVertex3f ( x2 , y1 , <num> ) ;
glTexCoord2f ( <num> , <num> ) ; glVertex3f ( x2 , y2 , <num> ) ;
glTexCoord2f ( <num> , <num> ) ; glVertex3f ( x1 , y2 , <num> ) ;
glEnd ( ) ;
glTranslatef ( <num> , <num> ,  z1 ) ;
} ;
static public void DrawBox2D ( float x1 , float x2 , float y1 , float y2 , Texture TextureX , boolean hollow )
{
DrawBox2D_withDepth ( x1 , x2 , y1 , y2 , <num> , TextureX , hollow ) ;
} ;
static public void DrawBox2D ( float x1 , float x2 , float y1 , float y2 , Texture TextureX )
{
DrawBox2D_withDepth ( x1 , x2 , y1 , y2 , <num> , TextureX , false ) ;
} ;
static public void DrawBox2D ( float x1 , float x2 , float y1 , float y2 )
{
DrawBox2D_withDepth ( x1 , x2 , y1 , y2 , <num> , getWhiteTex ( ) , false ) ;
} ;
static public Texture getWhiteTex ( ) {
return whiteTex ;
}
static public void pixelStretchTexture ( Texture tempTex ) {
tempTex . bind ( ) ;
glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) ;
glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_NEAREST ) ;
}
static public void <unk> ( Texture tempTex ) {
tempTex . bind ( ) ;
glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR ) ;
glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_LINEAR ) ;
}
package engine . renderer ;
import java . io . IOException ;
import java . util . HashMap ;
import org . newdawn . slick . opengl . Texture ;
import org . newdawn . slick . opengl . TextureLoader ;
import org . newdawn . slick . util . ResourceLoader ;
public class Sprite {
static HashMap < String , Sprite > listSprites ;
static public void createList ( ) { listSprites = new HashMap < String , Sprite > ( ) ; } ;
static public Sprite findSprite ( String spriteName ) {
Sprite tempReturn = listSprites . get ( spriteName ) ;
if ( tempReturn == null ) {
return GraphicsControl . whiteSprite ;
} else {
return tempReturn ;
}
}
static public Texture getTexture ( String spriteName ) {
return findSprite ( spriteName ) . texture ;
}
public int frameWidth , frameHeight ;
public Texture texture ;
public String spriteLocation ;
public Sprite ( String fileName ) {
spriteLocation = fileName ;
if ( ! listSprites . containsKey ( fileName ) ) {
try {
texture = TextureLoader . getTexture (
" ,
ResourceLoader . getResourceAsStream ( "
+ fileName + " ) ) ;
frameWidth = texture . getImageWidth ( ) ;
frameHeight = texture . getImageHeight ( ) ;
listSprites . put ( fileName , this ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
texture = GraphicsControl . whiteTex ;
frameWidth = <num> ;
frameHeight = <num> ;
}
System . out . println ( " + fileName ) ;
} else {
Sprite tempSprite = listSprites . get ( fileName ) ;
this . frameHeight = tempSprite . frameHeight ;
this . frameWidth = tempSprite . frameWidth ;
this . texture = tempSprite . texture ;
}
GraphicsControl . pixelStretchTexture ( this . texture ) ;
}
public Sprite ( String fileName , int frameWidthX , int frameHeightX ) {
this ( fileName ) ;
spriteLocation = fileName ;
frameWidth = frameWidthX ;
frameHeight = frameHeightX ;
}
public void Draw ( float xx , float yy , float zz ) {
GraphicsControl . ApplySprite ( this , xx , yy , zz ) ; ;
}
package engine . classes ;
public class Cube {
public float x1 , y1 , z1 , width , height , depth ;
public Cube ( float X1 , float widthX , float Y1 , float heightX , float Z1 , float depthX ) {
x1 = X1 ;
width = widthX ;
y1 = Y1 ;
height = heightX ;
z1 = Z1 ;
depth = depthX ;
}
public boolean intersects ( Cube otherCube ) {
boolean XIntersect = (
( ( x1 >= otherCube . x1 ) && ( x1 <= otherCube . x1 + otherCube . width ) ) || ( ( x1 + width >= otherCube . x1 ) && ( x1 + width <= otherCube . x1 + otherCube . width ) )
||
( ( otherCube . x1 >= x1 ) && ( otherCube . x1 <= x1 + width ) ) || ( ( otherCube . x1 + otherCube . width >= x1 ) && ( otherCube . x1 + otherCube . width <= x1 + width ) )
) ;
boolean YIntersect = (
( ( y1 >= otherCube . y1 ) && ( y1 <= otherCube . y1 + otherCube . height ) ) || ( ( y1 + height >= otherCube . y1 ) && ( y1 + height <= otherCube . y1 + otherCube . height ) )
||
( ( otherCube . y1 >= y1 ) && ( otherCube . y1 <= y1 + height ) ) || ( ( otherCube . y1 + otherCube . height >= y1 ) && ( otherCube . y1 + otherCube . height <= y1 + height ) )
) ;
boolean ZIntersect = (
( ( z1 >= otherCube . z1 ) && ( z1 <= otherCube . z1 + otherCube . depth ) ) || ( ( z1 + depth >= otherCube . z1 ) && ( z1 + depth <= otherCube . z1 + otherCube . depth ) )
||
( ( otherCube . z1 >= z1 ) && ( otherCube . z1 <= z1 + depth ) ) || ( ( otherCube . z1 + otherCube . depth >= z1 ) && ( otherCube . z1 + otherCube . depth <= z1 + depth ) )
) ;
return XIntersect && YIntersect && ZIntersect ;
}
package engine ;
import game . LoadGameSounds_thread ;
import java . io . IOException ;
import java . util . ArrayList ;
import org . newdawn . slick . openal . Audio ;
import org . newdawn . slick . openal . AudioLoader ;
import org . newdawn . slick . util . ResourceLoader ;
public class AudioControl {
static ArrayList < Audio > audioList = new ArrayList < Audio > ( ) ;
static ArrayList < String > audioList_names = new ArrayList < String > ( ) ;
static public boolean loadedAllSounds = false ;
static public boolean useSounds = false ;
public static void LoadSounds ( ) {
LoadGameSounds_thread loadSoundsThread = new LoadGameSounds_thread ( ) ;
loadSoundsThread . start ( ) ;
}
public static void AddAudioDir ( String fileLocation , String type ) {
Audio newAudio = null ;
try {
newAudio = AudioLoader . <unk> ( type ,
ResourceLoader . getResourceAsStream ( fileLocation ) ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
audioList . add ( newAudio ) ;
audioList_names . add ( fileLocation ) ;
}
public static void AddAudio ( String filename , String type ) {
if ( type == " || type == " ) {
AddAudioDir ( " + filename + " + type , type ) ;
}
}
public static int findAudioPositionDir ( String filename ) {
return audioList_names . indexOf ( filename ) ;
}
public static int findAudioPosition ( String filename , String type ) {
return findAudioPositionDir ( " + filename + " + type ) ;
}
public static Audio findAudio ( String filename , String type ) {
if ( findAudioPosition ( filename , type ) !=  <num> )
return audioList . get ( findAudioPosition ( filename , type ) ) ;
return null ;
}
public static void playAudio ( String filename , String type ) {
int audioPos = findAudioPosition ( filename , type ) ;
if ( audioPos >= <num> ) {
audioList . get ( audioPos ) . playAsSoundEffect ( <num> , <num> , false ) ;
}
}
public static void playAudio ( String filename , String type , float pitch , float gain , boolean loop ) {
int audioPos = findAudioPosition ( filename , type ) ;
if ( audioPos >= <num> ) {
audioList . get ( audioPos ) . playAsSoundEffect ( pitch , gain , loop ) ;
}
}
public static void <unk> ( String filename , String type , float newVolume ) {
float currentPos = findAudio ( filename , type ) . getPosition ( ) ;
findAudio ( filename , type ) . stop ( ) ;
findAudio ( filename , type ) . playAsSoundEffect ( <num> , newVolume , false ) ;
findAudio ( filename , type ) . setPosition ( currentPos ) ;
}
package game ;
import java . applet . Applet ;
import java . awt . BorderLayout ;
import java . awt . Canvas ;
import org . lwjgl . LWJGLException ;
import org . lwjgl . opengl . Display ;
import org . lwjgl . input . Keyboard ;
import engine . AudioControl ;
import engine . Debug ;
import engine . Input ;
import engine . classes . GameObject ;
import engine . renderer . FontControl ;
import engine . renderer . GraphicsControl ;
import engine . renderer . Sprite ;
import game . classes . basePlayer ;
import static engine . Input . keyEvent ;
import static engine . Debug . * ;
import static org . lwjgl . opengl . GL11 . * ;
public class <unk> extends Applet {
private static final long serialVersionUID = <num> ;
public static Canvas display_parent ;
Thread gameThread ;
boolean running ;
boolean keyDown ;
public void startLWJGL ( ) {
gameThread = new Thread ( ) {
public void run ( ) {
running = true ;
try {
Display . setParent ( display_parent ) ;
Display . create ( ) ;
} catch ( LWJGLException e ) {
e . printStackTrace ( ) ;
}
runGame ( ) ;
System . exit ( <num> ) ;
}
} ;
gameThread . start ( ) ;
}
private void stopLWJGL ( ) {
running = false ;
try {
gameThread . join ( ) ;
} catch ( InterruptedException e ) {
e . printStackTrace ( ) ;
}
}
public void start ( ) { }
public void stop ( ) { }
public void destroy ( ) {
remove ( display_parent ) ;
super . destroy ( ) ;
System . out . println ( " ) ;
}
public void init ( ) {
setLayout ( new BorderLayout ( ) ) ;
try {
display_parent = new Canvas ( ) {
private static final long serialVersionUID = <num> ;
public void addNotify ( ) {
super . addNotify ( ) ;
startLWJGL ( ) ;
}
public void removeNotify ( ) {
stopLWJGL ( ) ;
super . removeNotify ( ) ;
}
} ;
display_parent . setSize ( GraphicsControl . returnScrWidth ( ) , GraphicsControl . returnScrHeight ( ) ) ;
add ( display_parent ) ;
display_parent . setFocusable ( true ) ;
display_parent . requestFocus ( ) ;
display_parent . setIgnoreRepaint ( true ) ;
setSize ( GraphicsControl . returnScrWidth ( ) , GraphicsControl . returnScrHeight ( ) ) ;
setVisible ( true ) ;
} catch ( Exception e ) {
System . err . println ( e ) ;
throw new RuntimeException ( " ) ;
}
}
public void runGame ( ) {
Debug . setDebugs ( ) ;
Sprite . createList ( ) ;
GraphicsControl . Init ( ) ;
Display . setTitle ( " ) ;
Input . setupKeys ( ) ;
AudioControl . LoadSounds ( ) ;
FontControl . InitFonts ( ) ;
GameObject . createAllObjs ( ) ;
basePlayer <unk> = new basePlayer ( ) ;
while ( running ) {
Input . pollEvents ( ) ;
if ( Input . getKey ( Keyboard . KEY_ESCAPE ) == keyEvent . KeyDown ) { running = false ; break ; } ;
GameObject . updateAllObjs ( ) ;
glClearColor ( <num> , <num> / <num> , <num> / <num> , <num> ) ;
glLoadIdentity ( ) ;
glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ) ;
glPushMatrix ( ) ;
GameObject . drawAllObjs ( ) ;
Display . sync ( <num> ) ;
Display . update ( ) ;
glPopMatrix ( ) ;
String DebugString = " + String . valueOf ( Input . getMouseX ( ) ) + " + String . valueOf ( Input . getMouseY ( ) ) ;
debugPrintln ( DebugString , dbgMOUSEPOS ) ;
}
Display . destroy ( ) ;
}
}
package engine . renderer ;
import static org . lwjgl . opengl . GL11 . * ;
import org . newdawn . slick . Color ;
import org . newdawn . slick . SlickException ;
import org . newdawn . slick . font . effects . ColorEffect ;
import org . newdawn . slick . opengl . Texture ;
import org . newdawn . slick . UnicodeFont ;
public class FontControl {
static Texture fontTexture = GraphicsControl . LoadTexture ( " ) ;
static float epsilon = <num> / <num> ;
static public UnicodeFont wFont ;
static public UnicodeFont bFont ;
@SuppressWarnings("unchecked")
static public void InitFonts ( ) {
fontTexture . bind ( ) ;
glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) ;
glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_NEAREST ) ;
String fontPath = " ;
int fontSize = <num> ;
try {
wFont = new UnicodeFont ( fontPath , fontSize , false , false ) ;
wFont . addAsciiGlyphs ( ) ;
wFont . addGlyphs ( <num> , <num> ) ;
wFont . getEffects ( ) . add ( new ColorEffect ( java . awt . Color . WHITE ) ) ;
wFont . loadGlyphs ( ) ;
bFont = new UnicodeFont ( fontPath , fontSize , false , false ) ;
bFont . addAsciiGlyphs ( ) ;
bFont . addGlyphs ( <num> , <num> ) ;
bFont . getEffects ( ) . add ( new ColorEffect ( java . awt . Color . BLACK ) ) ;
bFont . loadGlyphs ( ) ;
} catch ( SlickException e ) {
e . printStackTrace ( ) ;
}
}
static public void printStringShadow ( String stringToPrint , float xx , float yy ) {
printStringShadow ( stringToPrint , xx , yy , <num> , <num> ) ;
}
static public void printStringShadow ( String stringToPrint , float xx , float yy , float scaleX , float scaleY ) {
glPushMatrix ( ) ;
glTranslatef ( xx , yy , <num> ) ;
glScalef ( <num> , <num> , <num> ) ;
glTranslatef (  xx ,  yy , <num> ) ;
glScalef ( scaleX , scaleY , <num> ) ;
bFont . drawString ( xx + <num> , yy + <num> , stringToPrint , Color . white ) ;
wFont . drawString ( xx , yy , stringToPrint , Color . white ) ;
glPopMatrix ( ) ;
}
static public void <unk> ( String stringToPrint , float xx , float yy ) {
glPushMatrix ( ) ;
glTranslatef ( xx , yy , <num> ) ;
glScalef ( <num> , <num> , <num> ) ;
glTranslatef (  xx ,  yy , <num> ) ;
wFont . drawString ( xx , yy , stringToPrint ) ;
glPopMatrix ( ) ;
}
package engine . classes ;
import org . lwjgl . Sys ;
public class Timer {
int startTicks , pausedTicks ;
boolean paused , started ;
public Timer ( ) {
startTicks = <num> ;
pausedTicks = <num> ;
paused = false ;
started = false ;
}
public void start ( ) {
started = true ;
paused = false ;
startTicks = ( int ) Sys . getTime ( ) ;
}
public void stop ( )
{
started = false ;
paused = false ;
startTicks = <num> ;
}
public void pause ( )
{
if ( ( started == true ) && ( paused == false ) )
{
paused = true ;
pausedTicks = ( int ) ( Sys . getTime ( )  startTicks ) ;
}
}
public void unpause ( )
{
if ( ( started == true ) && ( paused == true ) )
{
paused = false ;
startTicks = ( int ) ( Sys . getTime ( )  pausedTicks ) ;
pausedTicks = <num> ;
}
}
public int getTicks ( )
{
if ( started == true )
{
if ( paused == true )
{
return pausedTicks ;
}
else
{
return ( int ) ( Sys . getTime ( )  startTicks ) ;
}
}
return <num> ;
}
package game . classes ;
import java . util . ArrayList ;
import org . lwjgl . input . Keyboard ;
import static org . lwjgl . opengl . GL11 . * ;
import engine . Input ;
import engine . Input . keyEvent ;
import engine . classes . GameObject ;
public class basePlayer extends GameObject {
static ArrayList < GameObject > listThisObj ;
public static void CreateList ( ) {
listThisObj = new ArrayList < GameObject > ( ) ;
} ;
public static void UpdateList ( ) {
int count = <num> ;
int deleted = <num> ;
while ( ( count  deleted ) < listThisObj . size ( ) ) {
listThisObj . get ( count  deleted ) . doUpdate ( ) ;
if ( listThisObj . get ( count  deleted ) . GetDeleted ( ) == true ) {
listThisObj . remove ( count  deleted ) ;
deleted ++ ;
}
count ++ ;
}
}
public static void DrawList ( ) {
for ( int i = <num> ; i != listThisObj . size ( ) ; i ++ ) {
listThisObj . get ( i ) . doDraw ( ) ;
}
}
public boolean isJumping = false ;
public basePlayer ( ) {
super ( ) ;
listThisObj . add ( this ) ;
SetSprite ( " , <num> , <num> ) ;
SetXY ( <num> , <num> ) ;
updateBoundingBox ( ) ;
}
void keyInput ( ) {
if ( Input . getKey ( Keyboard . KEY_UP ) == keyEvent . KeyPressed ) {
}
if ( Input . getKey ( Keyboard . KEY_DOWN ) == keyEvent . KeyPressed ) {
}
}
void collideWithGameObjects ( ) {
ArrayList < GameObject > <unk> ;
}
public void doUpdate ( ) {
keyInput ( ) ;
if ( isJumping ) {
}
collideWithGameObjects ( ) ;
doMotion ( ) ;
updateBoundingBox ( ) ;
}
public void doDraw ( ) {
super . doDraw ( ) ;
}
package game ;
import static engine . AudioControl . AddAudio ;
import engine . AudioControl ;
public class LoadGameSounds_thread extends Thread {
public void run ( ) {
if ( engine . AudioControl . useSounds ) {
AddAudio ( " , " ) ;
}
AudioControl . loadedAllSounds = true ;
}
}
package engine . classes ;
import java . util . ArrayList ;
import engine . renderer . GraphicsControl ;
import engine . renderer . Sprite ;
import game . classes . basePlayer ;
public class GameObject {
public static ArrayList < GameObject > listGameObjects ;
static public void createAllObjs ( ) {
listGameObjects = new ArrayList < GameObject > ( ) ;
basePlayer . CreateList ( ) ;
} ;
static public void updateAllObjs ( ) {
basePlayer . UpdateList ( ) ;
}
static public void drawAllObjs ( ) {
basePlayer . DrawList ( ) ;
}
boolean enabled = false ;
float x , y , z , xSpeed , ySpeed , zSpeed , rotation ;
float <unk> = <num> ;
float zoom = <num> ;
float zoomSpeed = <num> ;
protected Sprite sprite ;
float [ ] objColour = { <num> , <num> , <num> , <num> } ;
protected Cube boundingBox = new Cube ( <num> , <num> , <num> , <num> , <num> , <num> ) ;
protected boolean removeMe ;
public GameObject ( ) { listGameObjects . add ( this ) ; } ;
public GameObject ( boolean addMe ) { if ( addMe == true ) listGameObjects . add ( this ) ; } ;
public void Init ( ) { } ;
public void addToList ( ) { listGameObjects . add ( this ) ; } ;
public void <unk> ( float newX ) { x = newX ; } ;
public void <unk> ( float newY ) { y = newY ; } ;
public void <unk> ( float newZ ) { z = newZ ; } ;
public void <unk> ( float newXSpeed ) { xSpeed = newXSpeed ; } ;
public void <unk> ( float newYSpeed ) { ySpeed = newYSpeed ; } ;
public void <unk> ( float newZSpeed ) { zSpeed = newZSpeed ; } ;
public void SetXY ( float newX , float newY ) { x = newX ; y = newY ; } ;
public void <unk> ( float newX , float newY , float newZ ) { x = newX ; y = newY ; z = newZ ; } ;
public void <unk> ( float newX ) { x += newX ; } ;
public void <unk> ( float newY ) { y += newY ; } ;
public void <unk> ( float newZ ) { z += newZ ; } ;
public void <unk> ( float newXSpeed ) { xSpeed += newXSpeed ; } ;
public void <unk> ( float newYSpeed ) { ySpeed += newYSpeed ; } ;
public void <unk> ( float newZSpeed ) { zSpeed += newZSpeed ; } ;
public void <unk> ( boolean newEnabled ) { enabled = newEnabled ; } ;
public boolean <unk> ( ) { return enabled ; } ;
public void <unk> ( float newZoom ) { zoom = newZoom ; } ;
public void <unk> ( float newZoom ) { zoom += newZoom ; } ;
public float GetZoom ( ) { return zoom ; } ;
public void <unk> ( float newZoomSpeed ) { zoomSpeed = newZoomSpeed ; } ;
public void <unk> ( float newZoomSpeed ) { zoomSpeed += newZoomSpeed ; } ;
public float <unk> ( ) { return zoomSpeed ; } ;
public void <unk> ( float newRotation ) { rotation = newRotation ; } ;
public void <unk> ( float newRotation ) { rotation += newRotation ; } ;
public float GetRotation ( ) { return rotation ; } ;
public float GetX ( ) { return x ; } ;
public float GetY ( ) { return y ; } ;
public float GetZ ( ) { return z ; } ;
public float <unk> ( ) { return xSpeed ; } ;
public float <unk> ( ) { return ySpeed ; } ;
public float <unk> ( ) { return zSpeed ; } ;
public void SetColour ( float r , float g , float b ) { objColour [ <num> ] = r ; objColour [ <num> ] = g ; objColour [ <num> ] = b ; } ;
public void SetColour ( float r , float g , float b , float a ) { objColour [ <num> ] = r ; objColour [ <num> ] = g ; objColour [ <num> ] = b ; objColour [ <num> ] = a ; } ;
public void <unk> ( float a ) { objColour [ <num> ] = a ; } ;
public float [ ] GetColour ( ) { return objColour ; } ;
public Sprite GetSprite ( ) { return sprite ; } ;
public boolean GetDeleted ( ) { return removeMe ; }
public void <unk> ( boolean removeMe ) { this . removeMe = removeMe ; } ;
public Cube getBoundingBox ( ) { return boundingBox ; } ;
public boolean collidesWith ( Cube otherCube ) { return boundingBox . intersects ( otherCube ) ; } ;
public void SetSprite ( String spriteLocation ) {
sprite = new Sprite ( spriteLocation ) ;
}
public void SetSprite ( String spriteLocation , int frameWidthX , int frameWidthY ) {
sprite = new Sprite ( spriteLocation , frameWidthX , frameWidthY ) ;
}
protected void updateBoundingBox ( ) {
boundingBox . x1 = this . GetX ( )  ( sprite . frameWidth * GetZoom ( ) ) + sprite . frameWidth ;
boundingBox . width = sprite . frameWidth * GetZoom ( ) ;
boundingBox . y1 = this . GetY ( )  ( sprite . frameHeight * GetZoom ( ) ) + sprite . frameHeight ;
boundingBox . height = sprite . frameHeight * GetZoom ( ) ;
boundingBox . z1 = this . GetZ ( )  <num> * GetZoom ( ) ;
boundingBox . depth = <num> * GetZoom ( ) ;
}
public void doMotion ( ) {
if ( ( xSpeed < <num> ) && ( xSpeed >  <num> ) ) { xSpeed = <num> ; } ;
if ( ( ySpeed < <num> ) && ( ySpeed >  <num> ) ) { ySpeed = <num> ; } ;
if ( ( zSpeed < <num> ) && ( zSpeed >  <num> ) ) { zSpeed = <num> ; } ;
x += xSpeed ;
y += ySpeed ;
z += zSpeed ;
zoom += zoomSpeed ;
}
public void doUpdate ( ) { } ;
public void doDraw ( ) {
GraphicsControl . ApplySprite ( sprite , x , y , z , <num> , <num> , objColour , zoom , rotation ) ;
}
public void <unk> ( ) { }
public void <unk> ( ) {
GraphicsControl . DrawBox2D_withDepth ( boundingBox . x1 , boundingBox . x1 + boundingBox . width , boundingBox . y1 , boundingBox . y1 + boundingBox . height , boundingBox . z1 , GraphicsControl . getWhiteTex ( ) , true ) ;
GraphicsControl . DrawBox2D_withDepth ( boundingBox . x1 , boundingBox . x1 + boundingBox . width , boundingBox . y1 , boundingBox . y1 + boundingBox . height , boundingBox . z1 + boundingBox . depth , GraphicsControl . getWhiteTex ( ) , true ) ;
}
package engine ;
import engine . classes . Cube ;
import engine . renderer . GraphicsControl ;
import org . lwjgl . input . Keyboard ;
import org . lwjgl . input . Mouse ;
public class Input {
final static int numberOfKeys = <num> ;
final static int numberOfMouseButtons = <num> ;
static Cube mouseCube ;
public static enum keyEvent { KeyNoEvent , KeyPressed , KeyReleased , KeyDown , KeyUp } ;
static keyEvent [ ] keyValues = new keyEvent [ numberOfKeys ] ;
static keyEvent [ ] mouseValues = new keyEvent [ numberOfMouseButtons ] ;
static public void setupKeys ( ) {
for ( int i = <num> ; i != numberOfKeys ; i ++ ) {
keyValues [ i ] = keyEvent . KeyNoEvent ;
}
for ( int i = <num> ; i != numberOfMouseButtons ; i ++ ) {
mouseValues [ i ] = keyEvent . KeyNoEvent ;
}
mouseCube = new Cube ( <num> , <num> ,  <num> , <num> , <num> , <num> ) ;
}
static public void pollEvents ( ) {
for ( int keyNum = <num> ; keyNum != numberOfKeys ; keyNum ++ ) {
if ( keyValues [ keyNum ] == keyEvent . KeyPressed )
keyValues [ keyNum ] = keyEvent . KeyDown ;
else if ( keyValues [ keyNum ] == keyEvent . KeyReleased )
keyValues [ keyNum ] = keyEvent . KeyUp ;
}
for ( int mouseNum = <num> ; mouseNum != numberOfMouseButtons ; mouseNum ++ ) {
if ( mouseValues [ mouseNum ] == keyEvent . KeyPressed )
mouseValues [ mouseNum ] = keyEvent . KeyDown ;
else if ( mouseValues [ mouseNum ] == keyEvent . KeyReleased )
mouseValues [ mouseNum ] = keyEvent . KeyUp ;
}
while ( Keyboard . next ( ) ) {
int keyNum = Keyboard . getEventKey ( ) ;
if ( Keyboard . getEventKeyState ( ) )
keyValues [ keyNum ] = keyEvent . KeyPressed ;
else
keyValues [ keyNum ] = keyEvent . KeyReleased ;
}
while ( Mouse . next ( ) ) {
int mouseNum = Mouse . getEventButton ( ) + <num> ;
if ( Mouse . getEventButtonState ( ) )
mouseValues [ mouseNum ] = keyEvent . KeyPressed ;
else
mouseValues [ mouseNum ] = keyEvent . KeyReleased ;
}
mouseCube . x1 = Mouse . getX ( ) ;
mouseCube . width = <num> ;
mouseCube . y1 = GraphicsControl . returnScrHeight ( )  Mouse . getY ( ) ;
mouseCube . height = <num> ;
mouseCube . x1 *= GraphicsControl . mouseMultiplier ;
mouseCube . y1 *= GraphicsControl . mouseMultiplier ;
}
static public keyEvent getKey ( int keyNum ) { return keyValues [ keyNum ] ; } ;
static public keyEvent <unk> ( int mouseNum ) { return mouseValues [ mouseNum ] ; } ;
static public Cube <unk> ( ) { return mouseCube ; } ;
static public int getMouseX ( ) { return Mouse . getX ( ) ; } ;
static public int getMouseY ( ) { return GraphicsControl . returnScrHeight ( )  Mouse . getY ( ) ; } ;
package engine ;
public class Debug {
public final static int dbgGENERIC = <num> ;
public final static int dbgMOUSEPOS = <num> ;
final static boolean isDebug = true ;
public static boolean [ ] debugs = new boolean [ <num> ] ;
public static void setDebugs ( ) {
debugs [ dbgGENERIC ] = true ;
debugs [ dbgMOUSEPOS ] = false ;
}
static public void debugPrintln ( String input , int msgType ) {
if ( isDebug ) {
if ( debugs [ msgType ] ) {
System . out . println ( input ) ;
}
}
}
}
package ske . dojo . tennis ;
import static org . hamcrest . core . Is . is ;
import static org . junit . Assert . assertEquals ;
import static org . junit . Assert . assertThat ;
import org . junit . Test ;
public class <unk> {
@Test
public void testVinner ( ) {
TennisMatch match = new TennisMatch ( ) ;
assertEquals ( new Player ( " ) , match . vinner ( ) ) ;
assertThat ( match . vinner ( ) , is ( new Player ( " ) ) ) ;
}
}
package ske . dojo . tennis ;
import static org . fest . assertions . Assertions . assertThat ;
import static org . junit . Assert . assertEquals ;
import org . junit . Test ;
public class <unk> {
@Test
public void testVinner ( ) {
TennisMatch match = new TennisMatch ( ) ;
assertEquals ( new Player ( " ) , match . vinner ( ) ) ;
assertThat ( match . vinner ( ) ) . isEqualTo ( new Player ( " ) ) ;
assertThat ( match . vinner ( ) ) . <unk> ( new Object [ ] { new Player ( " ) , new Player ( " ) } ) ;
}
}
package ske . dojo . tennis ;
public class Player {
private final String name ;
public Player ( String name ) {
this . name = name ;
}
public String getName ( ) {
return name ;
}
@Override
public int hashCode ( ) {
final int prime = <num> ;
int result = <num> ;
result = prime * result + ( ( name == null ) ? <num> : name . hashCode ( ) ) ;
return result ;
}
@Override
public boolean equals ( Object obj ) {
if ( this == obj ) {
return true ;
}
if ( obj == null ) {
return false ;
}
if ( getClass ( ) != obj . getClass ( ) ) {
return false ;
}
Player other = ( Player ) obj ;
if ( name == null ) {
if ( other . name != null ) {
return false ;
}
} else if ( ! name . equals ( other . name ) ) {
return false ;
}
return true ;
}
}
package ske . dojo . tennis ;
public class TennisMatch {
public void <unk> ( ) {
}
public void <unk> ( ) {
}
public String scores ( ) {
return null ;
}
public Player vinner ( ) {
return new Player ( " ) ;
}
}
package in . shick . roboderpremote ;
import java . util . ArrayList ;
import java . util . concurrent . Executors ;
import java . util . concurrent . ScheduledExecutorService ;
import java . util . concurrent . TimeUnit ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . app . Dialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . graphics . Point ;
import android . net . ConnectivityManager ;
import android . net . NetworkInfo ;
import android . net . wifi . WifiManager ;
import android . os . Bundle ;
import android . os . Handler ;
import android . util . Log ;
import android . view . MotionEvent ;
import android . view . Window ;
import android . view . WindowManager ;
import android . widget . Toast ;
public class RemoteActivity extends Activity implements RoboderpClient ,
SeekerResponder
{
public static final String ACTIVITY_TAG = " ;
public static final int FPS = <num> ;
public static final TimeUnit TIME_UNIT = TimeUnit . MILLISECONDS ;
public static final int TIMEUNITS_PER_SECOND = <num> ;
public static final float SPLASH_DURATION = <num> ;
public static final float SPLASH_TIME_WINDOW = <num> ;
public static final float SPINNER_REVOLUTION = <num> ;
public static final int DIALOG_SCAN_FAILED = <num> , DIALOG_NO_WIFI = <num> ,
DIALOG_NO_NETWORK = <num> , DIALOG_CONNECT_FAILED = <num> ,
DIALOG_SERVER_CLOSED = <num> ;
public static final String USE_DEMO_PROMPT = " +
" ;
public static final String NO_WIFI_PROMPT = " +
" ;
public static final String NO_NETWORK_PROMPT = " +
" +
" ;
public static final String CONNECT_FAILED_PROMPT = " +
" ;
public static final String SERVER_CLOSED_PROMPT = " +
" ;
public static final String DIALOG_YES = " , DIALOG_NO = " ,
DIALOG_ENTER_ADDRESS = " ,
DIALOG_START_DEMO = " , DIALOG_OK = " ;
private final ScheduledExecutorService scheduler =
Executors . newScheduledThreadPool ( <num> ) ;
private Handler handler ;
private EnvironmentLayerView environmentLayer ;
private ObjectLayerView objectLayer ;
private UiLayerView uiLayer ;
private RoboderpServer activeServer ;
private Seeker seeker ;
private int timerTick , splashTime , splashRemaining , splashWindow ,
splashWindowRemaining , serverCount , uiWidth , uiHeight ,
uiHalfWidth , uiHalfHeight , spinnerSteps , spinnerTick ,
spinnerThreshold , lastSpinnerStep ;
private float splashCompletion , splashDelta ;
private Point downPoint ;
private boolean touchEnabled ;
private ConnectivityManager connectivity ;
private enum ScanStatus {
INACTIVE , ACTIVE , SUCCEEDED , FAILED
} ;
private enum ServerStatus {
CONNECTED , DISCONNECTED , CLOSED
} ;
private ScanStatus scanStatus ;
private ServerStatus serverStatus ;
private ArrayList < Point > remoteMarks ;
public void onCreate ( Bundle savedInstanceState )
{
super . onCreate ( savedInstanceState ) ;
this . requestWindowFeature ( Window . FEATURE_NO_TITLE ) ;
getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_FULLSCREEN ,
WindowManager . LayoutParams . FLAG_FULLSCREEN ) ;
setContentView ( R . layout . <unk> ) ;
environmentLayer = ( EnvironmentLayerView )
findViewById ( R . id . <unk> ) ;
objectLayer = ( ObjectLayerView )
findViewById ( R . id . <unk> ) ;
uiLayer = ( UiLayerView )
findViewById ( R . id . <unk> ) ;
Object layers [ ] = {
environmentLayer , objectLayer , uiLayer
} ;
for ( Object e : layers )
{
if ( e == null )
{
Log . e ( ACTIVITY_TAG ,
" ) ;
Toast . makeText ( this , getString ( R . string . <unk> ) ,
Toast . LENGTH_LONG ) . show ( ) ;
finish ( ) ;
}
}
uiLayer . setParent ( this ) ;
touchEnabled = false ;
scanStatus = ScanStatus . INACTIVE ;
serverStatus = ServerStatus . DISCONNECTED ;
timerTick = ( int ) ( ( double ) TIMEUNITS_PER_SECOND / ( double ) FPS ) ;
splashTime = ( int ) ( ( SPLASH_DURATION * TIMEUNITS_PER_SECOND ) /
( float ) timerTick ) ;
splashDelta = <num> / splashTime ;
splashCompletion = <num> ;
splashRemaining =  <num> ;
splashWindow = ( int ) ( ( SPLASH_TIME_WINDOW * TIMEUNITS_PER_SECOND ) /
( float ) timerTick ) ;
splashWindowRemaining = <num> ;
spinnerSteps = ( int ) ( <num> / UiLayerView . SPINNER_PIP_ANGLE ) ;
spinnerThreshold = ( int ) ( ( ( SPINNER_REVOLUTION * TIMEUNITS_PER_SECOND ) /
( float ) timerTick ) / spinnerSteps ) ;
spinnerTick = <num> ;
lastSpinnerStep = <num> ;
handler = new Handler ( ) ;
scheduler . <unk> ( new Runnable ( ) {
public void run ( ) {
handler . post ( new Runnable ( ) {
public void run ( ) {
tick ( ) ;
}
} ) ;
}
} , timerTick , timerTick , TIME_UNIT ) ;
connectivity = ( ConnectivityManager )
getSystemService ( Context . CONNECTIVITY_SERVICE ) ;
scan ( ) ;
remoteMarks = new ArrayList < Point > ( ) ;
activeServer = null ;
serverCount = <num> ;
uiWidth = <num> ;
uiHeight = <num> ;
uiHalfWidth = <num> ;
uiHalfHeight = <num> ;
}
private void scan ( )
{
touchEnabled = false ;
NetworkInfo . State wifiState =
connectivity . getNetworkInfo ( ConnectivityManager . TYPE_WIFI )
. getState ( ) ;
boolean connected = true ;
NetworkInfo activeNetwork = connectivity . getActiveNetworkInfo ( ) ;
if ( activeNetwork == null )
{
connected = false ;
}
else
{
connected = connectivity . getActiveNetworkInfo ( )
. isConnectedOrConnecting ( ) ;
}
if ( ! connected )
{
touchEnabled = true ;
loadDemoServer ( ) ;
showDialog ( DIALOG_NO_NETWORK ) ;
return ;
}
if ( wifiState != NetworkInfo . State . CONNECTED &&
wifiState != NetworkInfo . State . CONNECTING )
{
showDialog ( DIALOG_NO_WIFI ) ;
return ;
}
touchEnabled = true ;
seeker = new Seeker ( this , ( WifiManager ) getSystemService ( WIFI_SERVICE ) ) ;
synchronized ( scanStatus )
{
scanStatus = ScanStatus . ACTIVE ;
}
seeker . launchWorker ( ) ;
uiLayer . setSpinnerAnimationState ( UiLayerView . SPINNER_START ) ;
}
public void notifyScanFailed ( )
{
synchronized ( scanStatus )
{
scanStatus = ScanStatus . FAILED ;
}
}
public void notifyScanSucceeded ( )
{
synchronized ( scanStatus )
{
scanStatus = ScanStatus . SUCCEEDED ;
}
}
public void notifyDisconnect ( )
{
synchronized ( serverStatus )
{
serverStatus = ServerStatus . CLOSED ;
}
}
public void touch ( MotionEvent event )
{
if ( ! touchEnabled )
{
return ;
}
int x = ( int ) event . getX ( ) ;
int y = ( int ) event . getY ( ) ;
Point location = new Point ( x , y ) ;
boolean scanningActive = false ;
synchronized ( scanStatus )
{
scanningActive = scanStatus == ScanStatus . ACTIVE ;
}
switch ( event . getAction ( ) )
{
case MotionEvent . ACTION_DOWN :
downPoint = new Point ( x , y ) ;
if ( scanningActive )
{
}
else
{
splashWindowRemaining = splashWindow ;
}
break ;
case MotionEvent . ACTION_MOVE :
if ( scanningActive )
{
}
else
{
if ( splashWindowRemaining <= <num> )
{
uiLayer . setFloatingLocation ( location ) ;
}
}
break ;
case MotionEvent . ACTION_UP :
if ( scanningActive )
{
int spinnerHalf = <num> ;
spinnerHalf = ( int )
( uiLayer . getSpinnerBoxWidth ( ) / <num> ) ;
if ( x >= uiHalfWidth  spinnerHalf &&
x <= uiHalfWidth + spinnerHalf &&
y >= uiHalfHeight  spinnerHalf &&
y <= uiHalfHeight + spinnerHalf &&
downPoint . x >= uiHalfWidth  spinnerHalf &&
downPoint . x <= uiHalfWidth + spinnerHalf &&
downPoint . y >= uiHalfHeight  spinnerHalf &&
downPoint . y <= uiHalfHeight + spinnerHalf )
{
}
}
else
{
uiLayer . unsetFloatingLocation ( ) ;
int offset = <num> ;
if ( splashWindowRemaining <= <num> )
{
offset = uiLayer . getFloatingOffset ( ) ;
}
placeLocalMark ( new Point ( x , y  offset ) ) ;
if ( activeServer != null )
{
int relativeX = ( int ) ( ( ( ( float ) x / ( float )
objectLayer . getWidth ( ) ) * <num> )  <num> ) ;
int relativeY =
( int ) ( ( ( ( float ) ( y  offset ) / ( float )
objectLayer . getHeight ( ) ) * <num> )
<unk> ) ;
activeServer . sendMark ( new Point ( relativeX , relativeY ) ) ;
}
if ( splashWindowRemaining > <num> )
{
uiLayer . setSplashLocation ( location ) ;
splashRemaining = splashTime ;
splashCompletion = <num> ;
uiLayer . setSplashCompletion ( splashCompletion ) ;
}
}
break ;
}
uiLayer . invalidate ( ) ;
}
private void selectServer ( )
{
ArrayList < RoboderpServer > servers = seeker . getServerList ( ) ;
if ( servers . size ( ) > <num> )
{
}
else
{
showDialog ( DIALOG_SCAN_FAILED ) ;
}
}
private void loadServer ( RoboderpServer server )
{
activeServer = server ;
server . setClient ( this ) ;
uiLayer . setSpinnerAnimationState ( UiLayerView . SPINNER_OFF ) ;
uiLayer . invalidate ( ) ;
if ( server . status ( ) != RoboderpServer . CONNECTED )
{
showDialog ( DIALOG_CONNECT_FAILED ) ;
}
}
private void unloadServer ( )
{
activeServer = null ;
uiLayer . invalidate ( ) ;
}
private void placeLocalMark ( Point p )
{
objectLayer . setLocalMarkLocation ( new Point ( p ) ) ;
}
public void placeRemoteMark ( int id , Point p )
{
objectLayer . addRemoteMark ( id , p ) ;
handler . post ( new Runnable ( ) {
public void run ( ) {
objectLayer . invalidate ( ) ;
}
} ) ;
}
public void removeRemoteMark ( int id )
{
objectLayer . removeRemoteMark ( id ) ;
handler . post ( new Runnable ( ) {
public void run ( ) {
objectLayer . invalidate ( ) ;
}
} ) ;
}
private void loadDemoServer ( )
{
unloadServer ( ) ;
uiLayer . setSpinnerAnimationState ( UiLayerView . SPINNER_OFF ) ;
uiLayer . invalidate ( ) ;
}
public void setUiDimensions ( int w , int h )
{
uiWidth = w ;
uiHalfWidth = ( int ) ( w / <num> ) ;
uiHeight = w ;
uiHalfHeight = ( int ) ( h / <num> ) ;
}
@Override
protected Dialog onCreateDialog ( int id ) {
final Context context = ( Context ) this ;
Dialog dialog ;
AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ;
switch ( id ) {
case DIALOG_SERVER_CLOSED :
builder . setMessage ( SERVER_CLOSED_PROMPT ) . setCancelable ( true )
. setPositiveButton ( DIALOG_OK ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int id )
{
}
} ) ;
dialog = builder . create ( ) ;
break ;
case DIALOG_CONNECT_FAILED :
builder . setMessage ( CONNECT_FAILED_PROMPT ) . setCancelable ( false )
. setPositiveButton ( DIALOG_YES ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int id )
{
scan ( ) ;
}
} ) . setNegativeButton ( DIALOG_NO ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int id )
{
synchronized ( scanStatus )
{
scanStatus = ScanStatus . INACTIVE ;
}
touchEnabled = true ;
loadDemoServer ( ) ;
}
} ) ;
dialog = builder . create ( ) ;
break ;
case DIALOG_SCAN_FAILED :
builder . setMessage ( USE_DEMO_PROMPT ) . setCancelable ( false )
. setPositiveButton ( DIALOG_YES ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int id )
{
scan ( ) ;
}
} ) . setNegativeButton ( DIALOG_NO ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int id )
{
synchronized ( scanStatus )
{
scanStatus = ScanStatus . INACTIVE ;
}
touchEnabled = true ;
loadDemoServer ( ) ;
}
} ) ;
dialog = builder . create ( ) ;
break ;
case DIALOG_NO_WIFI :
builder . setMessage ( NO_WIFI_PROMPT ) . setCancelable ( false )
. setPositiveButton ( DIALOG_ENTER_ADDRESS ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int id )
{
}
} ) . setNegativeButton ( DIALOG_START_DEMO ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int id )
{
touchEnabled = true ;
loadDemoServer ( ) ;
}
} ) ;
dialog = builder . create ( ) ;
break ;
case DIALOG_NO_NETWORK :
builder . setMessage ( NO_NETWORK_PROMPT ) . setCancelable ( false )
. setPositiveButton ( DIALOG_OK ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int id )
{
touchEnabled = true ;
loadDemoServer ( ) ;
}
} ) ;
dialog = builder . create ( ) ;
break ;
default :
dialog = null ;
}
return dialog ;
}
public void tick ( )
{
boolean scanningActive = false , scanningFailed = false ,
scanningComplete = false , serverClosed = false ;
synchronized ( serverStatus )
{
serverClosed = serverStatus == ServerStatus . CLOSED ;
if ( serverClosed )
{
serverStatus = ServerStatus . DISCONNECTED ;
}
}
synchronized ( scanStatus )
{
scanningActive = scanStatus == ScanStatus . ACTIVE ;
scanningComplete = scanStatus == ScanStatus . SUCCEEDED ;
scanningFailed = scanStatus == ScanStatus . FAILED ;
if ( scanningComplete || scanningFailed )
{
scanStatus = ScanStatus . INACTIVE ;
}
}
if ( scanningActive )
{
int currentSpinnerStep = spinnerTick / spinnerThreshold ;
if ( currentSpinnerStep >= spinnerSteps )
{
spinnerTick = <num> ;
}
uiLayer . setSpinnerAnimationState ( spinnerSteps
currentSpinnerStep ) ;
if ( currentSpinnerStep > lastSpinnerStep )
{
uiLayer . invalidate ( ) ;
}
lastSpinnerStep = currentSpinnerStep ;
spinnerTick ++ ;
}
if ( scanningComplete )
{
ArrayList < RoboderpServer > servers = seeker . getServerList ( ) ;
if ( servers . size ( ) > <num> )
{
loadServer ( servers . get ( <num> ) ) ;
}
else
{
showDialog ( DIALOG_SCAN_FAILED ) ;
}
}
if ( scanningFailed )
{
showDialog ( DIALOG_SCAN_FAILED ) ;
}
if ( serverClosed )
{
unloadServer ( ) ;
showDialog ( DIALOG_SERVER_CLOSED ) ;
}
if ( splashWindowRemaining > <num> )
{
splashWindowRemaining  ;
}
if ( splashRemaining > <num> )
{
splashCompletion += splashDelta ;
splashRemaining  ;
uiLayer . setSplashCompletion ( splashCompletion ) ;
uiLayer . invalidate ( ) ;
}
else if ( splashRemaining == <num> )
{
uiLayer . unsetSplashLocation ( ) ;
splashRemaining =  <num> ;
uiLayer . invalidate ( ) ;
}
}
protected void onPause ( )
{
super . onPause ( ) ;
finish ( ) ;
}
protected void onDestroy ( )
{
super . onDestroy ( ) ;
synchronized ( scanStatus )
{
scanStatus = ScanStatus . INACTIVE ;
}
scheduler . shutdownNow ( ) ;
if ( activeServer != null )
{
activeServer . disconnect ( ) ;
activeServer = null ;
}
}
private class <unk>
{
public double heading ;
public int x ;
public int y ;
}
}
package in . shick . roboderpremote ;
import android . content . Context ;
import android . graphics . Canvas ;
import android . graphics . Paint ;
import android . graphics . Path ;
import android . graphics . Point ;
import android . util . AttributeSet ;
import android . view . View ;
public class EnvironmentLayerView extends View
{
public static final float BASE_TO_BRACKET_SIDE = <num> ;
public static final float BASE_TO_OFFSET_X = <num> ;
public static final float BASE_TO_OFFSET_Y = <num> ;
public static final float BRACKET_TO_LINE_WIDTH = <num> ;
public static final int NUM_BRACKETS = <num> ;
public static final int UL_BRACKET = <num> , UR_BRACKET = <num> , LL_BRACKET = <num> ,
LR_BRACKET = <num> ;
public static final int BRACKET_COLORS [ ] = {
<num> , <num> , <num> , <num> ,
} ;
private int width , height , baseDimension ;
private float bracketSideLength , bracketLineWidth ,
bracketXOffset , bracketYOffset ;
private Paint bracketPaint ;
public EnvironmentLayerView ( Context context , AttributeSet attrs )
{
super ( context , attrs ) ;
bracketPaint = new Paint ( ) ;
bracketPaint . setStyle ( Paint . Style . STROKE ) ;
bracketPaint . setStrokeJoin ( Paint . Join . MITER ) ;
}
@Override
public void onDraw ( Canvas g )
{
Point a = null , b = null , c = null ;
Path path = null ;
for ( int ii = <num> ; ii < NUM_BRACKETS ; ii ++ )
{
bracketPaint . setColor ( BRACKET_COLORS [ ii ] ) ;
switch ( ii )
{
case UL_BRACKET :
a = new Point (
( int ) bracketXOffset ,
( int ) ( bracketYOffset + bracketSideLength ) ) ;
b = new Point (
( int ) bracketXOffset ,
( int ) bracketYOffset ) ;
c = new Point (
( int ) ( bracketXOffset + bracketSideLength ) ,
( int ) bracketYOffset ) ;
break ;
case UR_BRACKET :
a = new Point (
( int ) ( width
( bracketXOffset + bracketSideLength ) ) ,
( int ) bracketYOffset ) ;
b = new Point (
( int ) ( width  bracketXOffset ) ,
( int ) bracketYOffset ) ;
c = new Point (
( int ) ( width  bracketXOffset ) ,
( int ) ( bracketYOffset + bracketSideLength ) ) ;
break ;
case LL_BRACKET :
a = new Point (
( int ) ( bracketXOffset + bracketSideLength ) ,
( int ) ( height  bracketYOffset ) ) ;
b = new Point (
( int ) bracketXOffset ,
( int ) ( height  bracketYOffset ) ) ;
c = new Point (
( int ) bracketXOffset ,
( int ) ( height
( bracketYOffset + bracketSideLength ) ) ) ;
break ;
case LR_BRACKET :
a = new Point (
( int ) ( width  bracketXOffset ) ,
( int ) ( height
( bracketYOffset + bracketSideLength ) ) ) ;
b = new Point (
( int ) ( width  bracketXOffset ) ,
( int ) ( height  bracketYOffset ) ) ;
c = new Point (
( int ) ( width
( bracketXOffset + bracketSideLength ) ) ,
( int ) ( height  bracketYOffset ) ) ;
break ;
default :
a = new Point ( <num> , <num> ) ;
b = new Point ( <num> , <num> ) ;
c = new Point ( <num> , <num> ) ;
}
path = new Path ( ) ;
path . moveTo ( a . x , a . y ) ;
path . lineTo ( b . x , b . y ) ;
path . lineTo ( c . x , c . y ) ;
g . drawPath ( path , bracketPaint ) ;
}
}
@Override
protected void onSizeChanged ( int w , int h , int oldw , int oldh )
{
width = w ;
height = h ;
baseDimension = Math . min ( width , height ) ;
bracketSideLength = BASE_TO_BRACKET_SIDE * baseDimension ;
bracketLineWidth = BRACKET_TO_LINE_WIDTH * bracketSideLength ;
bracketXOffset = BASE_TO_OFFSET_X * width ;
bracketYOffset = BASE_TO_OFFSET_Y * height ;
bracketPaint . setStrokeWidth ( bracketLineWidth ) ;
}
@Override
public void onMeasure ( int widthMeasureSpec , int heightMeasureSpec )
{
setMeasuredDimension ( View . MeasureSpec . getSize ( widthMeasureSpec ) ,
View . MeasureSpec . getSize ( heightMeasureSpec ) ) ;
}
}
package in . shick . roboderpremote ;
public interface SeekerResponder
{
public void notifyScanSucceeded ( ) ;
public void notifyScanFailed ( ) ;
}
package in . shick . roboderpremote ;
import android . graphics . Point ;
public interface RoboderpClient
{
public void placeRemoteMark ( int id , Point p ) ;
public void removeRemoteMark ( int id ) ;
public void notifyDisconnect ( ) ;
}
package in . shick . roboderpremote ;
import android . graphics . Point ;
public interface RoboderpServer
{
public static final int DISCONNECTED = <num> , CONNECTED = <num> ;
public void setClient ( RoboderpClient client ) ;
public void sendMark ( Point p ) ;
public int connect ( ) ;
public int disconnect ( ) ;
public int status ( ) ;
public String identifier ( ) ;
}
package in . shick . roboderpremote ;
import android . content . Context ;
import android . graphics . Canvas ;
import android . graphics . Paint ;
import android . graphics . Path ;
import android . graphics . Point ;
import android . util . AttributeSet ;
import android . view . View ;
import java . util . ArrayList ;
import java . util . HashMap ;
public class ObjectLayerView extends View
{
public static final int LOCAL_MARK_COLOR = <num> ;
public static final int REMOTE_MARK_COLOR = <num> ;
public static final float BASE_TO_MARK_SIDE = <num> ;
public static final float MARK_SIDE_TO_STROKE = <num> ;
private int width , height , baseDimension ;
private float markSideWidth , markSideHalf , markStrokeWidth ;
private Point localMarkLocation ;
private HashMap < Integer , Point > remoteMarkLocations ;
private Paint markPaint ;
public ObjectLayerView ( Context context , AttributeSet attrs )
{
super ( context , attrs ) ;
localMarkLocation = null ;
remoteMarkLocations = new HashMap < Integer , Point > ( ) ;
markPaint = new Paint ( ) ;
markPaint . setColor ( LOCAL_MARK_COLOR ) ;
markPaint . setStrokeJoin ( Paint . Join . MITER ) ;
markPaint . setStyle ( Paint . Style . STROKE ) ;
}
public void setLocalMarkLocation ( Point p )
{
localMarkLocation = new Point ( p ) ;
}
public void <unk> ( )
{
localMarkLocation = null ;
}
public void addRemoteMark ( int id , Point p )
{
int x = ( int ) ( ( ( float ) ( p . x + <num> ) / <num> ) * ( float ) getWidth ( ) ) ;
int y = ( int ) ( ( ( float ) ( p . y + <num> ) / <num> ) * ( float ) getHeight ( ) ) ;
synchronized ( remoteMarkLocations )
{
remoteMarkLocations . put ( new Integer ( id ) , new Point ( x , y ) ) ;
}
}
public void removeRemoteMark ( int id )
{
synchronized ( remoteMarkLocations )
{
remoteMarkLocations . remove ( new Integer ( id ) ) ;
}
}
@Override
protected void onDraw ( Canvas g )
{
if ( localMarkLocation != null )
{
markPaint . setColor ( LOCAL_MARK_COLOR ) ;
drawMark ( g , localMarkLocation . x , localMarkLocation . y ) ;
}
ArrayList < Point > drawList = new ArrayList < Point > ( ) ;
synchronized ( remoteMarkLocations )
{
drawList = new ArrayList < Point > ( remoteMarkLocations . values ( ) ) ;
}
for ( Point e : drawList )
{
markPaint . setColor ( REMOTE_MARK_COLOR ) ;
drawMark ( g , e . x , e . y ) ;
}
}
private void drawMark ( Canvas g , int x , int y )
{
Path p = new Path ( ) ;
p . moveTo ( ( int ) ( x  markSideHalf ) , ( int ) ( y  markSideHalf ) ) ;
p . lineTo ( ( int ) ( x + markSideHalf ) , ( int ) ( y + markSideHalf ) ) ;
p . moveTo ( ( int ) ( x  markSideHalf ) , ( int ) ( y + markSideHalf ) ) ;
p . lineTo ( ( int ) ( x + markSideHalf ) , ( int ) ( y  markSideHalf ) ) ;
g . drawPath ( p , markPaint ) ;
}
@Override
protected void onSizeChanged ( int w , int h , int oldw , int oldh )
{
width = w ;
height = h ;
baseDimension = Math . min ( width , height ) ;
markSideWidth = BASE_TO_MARK_SIDE * baseDimension ;
markSideHalf = markSideWidth * <num> ;
markStrokeWidth = MARK_SIDE_TO_STROKE * markSideWidth ;
markPaint . setStrokeWidth ( ( int ) markStrokeWidth ) ;
}
@Override
public void onMeasure ( int widthMeasureSpec , int heightMeasureSpec )
{
setMeasuredDimension ( View . MeasureSpec . getSize ( widthMeasureSpec ) ,
View . MeasureSpec . getSize ( heightMeasureSpec ) ) ;
}
}
package in . shick . roboderpremote ;
import android . content . Context ;
import android . graphics . Canvas ;
import android . graphics . Paint ;
import android . graphics . Path ;
import android . graphics . Point ;
import android . graphics . RectF ;
import android . util . AttributeSet ;
import android . view . MotionEvent ;
import android . view . View ;
public class UiLayerView extends View
{
public static final int UI_COLOR = <num> ;
public static final int <unk> = <num> ;
public static final int PIP_COLOR = <num> ;
public static final int SPINNER_COLOR = <num> ;
public static final int MASK_COLOR = <num> ;
public static final float BASE_TO_MARK_SIDE = <num> ;
public static final float MARK_SIDE_TO_STROKE = <num> ;
public static final float MARK_SIDE_TO_SPLASH_WIDTH = <num> ;
public static final float SPLASH_SIDE_TO_STROKE_WIDTH = <num> ;
public static final float BASE_TO_FLOATING_OFFSET = <num> ;
public static final float BASE_TO_SPINNER_BOX = <num> ;
public static final float SPINNER_PIP_ANGLE = <num> ;
public static final float SPINNER_BOX_TO_BEVEL = <num> ;
public static final float SPINNER_BOX_TO_WHEEL = <num> ;
public static final float SPINNER_WHEEL_TO_PIP_LEN = <num> ;
public static final float SPINNER_PIP_LEN_TO_STROKE = <num> ;
public static final int PIP_ALPHA_FLOOR = <num> ;
public static final float RADIAL_OFFSET = <num> ;
public static final int SPINNER_OFF =  <num> ;
public static final int SPINNER_START = <num> ;
private RemoteActivity parent ;
private Point floatingLocation , splashLocation ;
private int width , height , baseDimension , spinnerAnimationState , halfWidth ,
halfHeight , spinnerSteps ;
private float markSideWidth , markSideHalf , markStrokeWidth , splashWidth ,
splashStrokeWidth , splashCompletion , floatingOffset ,
spinnerBoxWidth , spinnerBoxBevel , spinnerWheelHeight ,
spinnerWheelHalf , spinnerPipLength , spinnerPipStroke ,
spinnerPipStartRadius , spinnerPipEndRadius ;
private Paint markPaint , splashPaint , spinnerBoxPaint , spinnerPipPaint ,
maskPaint ;
private RectF spinnerRect ;
public UiLayerView ( Context context , AttributeSet attrs )
{
super ( context , attrs ) ;
parent = null ;
floatingLocation = null ;
splashLocation = null ;
spinnerAnimationState = SPINNER_OFF ;
markPaint = new Paint ( ) ;
markPaint . setColor ( UI_COLOR ) ;
markPaint . setStrokeJoin ( Paint . Join . MITER ) ;
markPaint . setStyle ( Paint . Style . STROKE ) ;
splashPaint = new Paint ( ) ;
splashPaint . setColor ( UI_COLOR ) ;
splashPaint . setStyle ( Paint . Style . STROKE ) ;
spinnerBoxPaint = new Paint ( ) ;
spinnerBoxPaint . setColor ( SPINNER_COLOR ) ;
spinnerBoxPaint . setStyle ( Paint . Style . FILL ) ;
spinnerPipPaint = new Paint ( ) ;
spinnerPipPaint . setColor ( PIP_COLOR ) ;
spinnerPipPaint . setStyle ( Paint . Style . STROKE ) ;
spinnerPipPaint . setStrokeCap ( Paint . Cap . ROUND ) ;
maskPaint = new Paint ( ) ;
maskPaint . setColor ( MASK_COLOR ) ;
maskPaint . setStrokeJoin ( Paint . Join . MITER ) ;
maskPaint . setStyle ( Paint . Style . STROKE ) ;
spinnerSteps = ( int ) ( <num> / SPINNER_PIP_ANGLE ) ;
}
public void setParent ( RemoteActivity parent )
{
this . parent = parent ;
}
public void setFloatingLocation ( Point p )
{
floatingLocation = new Point ( p ) ;
}
public void unsetFloatingLocation ( )
{
floatingLocation = null ;
}
public void setSplashLocation ( Point p )
{
splashLocation = new Point ( p ) ;
}
public void unsetSplashLocation ( )
{
splashLocation = null ;
}
public void setSplashCompletion ( float n )
{
splashCompletion = n ;
}
public void setSpinnerAnimationState ( int n )
{
spinnerAnimationState = n ;
}
@Override
protected void onDraw ( Canvas g )
{
Path p ;
if ( spinnerAnimationState > SPINNER_OFF )
{
g . drawRoundRect ( spinnerRect ,
spinnerBoxBevel , spinnerBoxBevel , spinnerBoxPaint ) ;
for ( int ii = <num> ; ii < spinnerSteps ; ii ++ )
{
int step = ( ii + spinnerAnimationState ) % spinnerSteps ;
float angle = ( <num> * ( float ) Math . PI ) *
( ( SPINNER_PIP_ANGLE * ii + RADIAL_OFFSET ) / <num> ) ;
int alpha = ( int ) ( ( ( <num>  PIP_ALPHA_FLOOR ) *
( ( ( float ) step / ( float ) spinnerSteps ) ) )
+ PIP_ALPHA_FLOOR ) ;
int aX = ( int ) ( halfWidth  ( Math . cos ( angle ) *
spinnerPipStartRadius ) ) ;
int aY = ( int ) ( halfHeight  ( Math . sin ( angle ) *
spinnerPipStartRadius ) ) ;
int bX = ( int ) ( halfWidth  ( Math . cos ( angle ) *
spinnerPipEndRadius ) ) ;
int bY = ( int ) ( halfHeight  ( Math . sin ( angle ) *
spinnerPipEndRadius ) ) ;
p = new Path ( ) ;
p . moveTo ( aX , aY ) ;
p . lineTo ( bX , bY ) ;
spinnerPipPaint . setAlpha ( alpha ) ;
g . drawPath ( p , spinnerPipPaint ) ;
}
}
if ( splashLocation != null )
{
splashPaint . setStrokeWidth ( splashStrokeWidth *
( <num>  splashCompletion ) ) ;
g . drawCircle ( splashLocation . x , splashLocation . y ,
splashWidth * splashCompletion , splashPaint ) ;
}
if ( floatingLocation != null )
{
markPaint . setColor ( UI_COLOR ) ;
p = new Path ( ) ;
p . moveTo (
( int ) ( floatingLocation . x  markSideHalf ) ,
( int ) ( floatingLocation . y
( markSideHalf + floatingOffset ) ) ) ;
p . lineTo (
( int ) ( floatingLocation . x + markSideHalf ) ,
( int ) ( floatingLocation . y +
( markSideHalf  floatingOffset ) ) ) ;
p . moveTo (
( int ) ( floatingLocation . x  markSideHalf ) ,
( int ) ( floatingLocation . y +
( markSideHalf  floatingOffset ) ) ) ;
p . lineTo (
( int ) ( floatingLocation . x + markSideHalf ) ,
( int ) ( floatingLocation . y
( markSideHalf + floatingOffset ) ) ) ;
g . drawPath ( p , markPaint ) ;
}
}
@Override
protected void onSizeChanged ( int w , int h , int oldw , int oldh )
{
width = w ;
height = h ;
halfWidth = ( int ) ( w * <num> ) ;
halfHeight = ( int ) ( h * <num> ) ;
baseDimension = Math . min ( width , height ) ;
markSideWidth = BASE_TO_MARK_SIDE * baseDimension ;
markSideHalf = markSideWidth * <num> ;
markStrokeWidth = MARK_SIDE_TO_STROKE * markSideWidth ;
splashWidth = markSideWidth * MARK_SIDE_TO_SPLASH_WIDTH ;
splashStrokeWidth = splashWidth * SPLASH_SIDE_TO_STROKE_WIDTH ;
floatingOffset = BASE_TO_FLOATING_OFFSET * baseDimension ;
spinnerBoxWidth = BASE_TO_SPINNER_BOX * baseDimension ;
spinnerBoxBevel = SPINNER_BOX_TO_BEVEL * spinnerBoxWidth ;
spinnerRect = new RectF (
halfWidth  ( spinnerBoxWidth * <num> ) ,
halfHeight  ( spinnerBoxWidth * <num> ) ,
halfWidth + ( spinnerBoxWidth * <num> ) ,
halfHeight + ( spinnerBoxWidth * <num> ) ) ;
spinnerWheelHeight = SPINNER_BOX_TO_WHEEL * spinnerBoxWidth ;
spinnerWheelHalf = spinnerWheelHeight * <num> ;
spinnerPipLength = SPINNER_WHEEL_TO_PIP_LEN * spinnerWheelHeight ;
spinnerPipStroke = SPINNER_PIP_LEN_TO_STROKE * spinnerPipLength ;
float pipDiff = ( spinnerWheelHalf  spinnerPipLength ) * <num> ;
spinnerPipStartRadius = pipDiff ;
spinnerPipEndRadius = spinnerWheelHalf  pipDiff ;
spinnerPipPaint . setStrokeWidth ( ( int ) spinnerPipStroke ) ;
markPaint . setStrokeWidth ( ( int ) markStrokeWidth ) ;
if ( parent != null )
{
parent . setUiDimensions ( w , h ) ;
}
}
public int getFloatingOffset ( )
{
return ( int ) floatingOffset ;
}
public int getSpinnerBoxWidth ( )
{
return ( int ) spinnerBoxWidth ;
}
@Override
public boolean onTouchEvent ( MotionEvent event )
{
if ( parent != null )
{
parent . touch ( event ) ;
return true ;
}
return false ;
}
@Override
public void onMeasure ( int widthMeasureSpec , int heightMeasureSpec )
{
setMeasuredDimension ( View . MeasureSpec . getSize ( widthMeasureSpec ) ,
View . MeasureSpec . getSize ( heightMeasureSpec ) ) ;
}
}
package in . shick . roboderpremote ;
public class Packet
{
public static final byte SEEKER = <num> , SEEKER_RESPONSE = <num> , HANDSHAKE = <num> ,
<unk> = <num> , CLOSE = <num> , ADD_POINT = <num> , REMOVE_POINT = <num> ,
SEND_POINT = <num> ;
public static final byte ROBODERP_MAGIC = <num> ;
public static final int BYTE_CEILING = <num> ;
public static final int MINIMUM_LENGTH = <num> ;
public static final int OK = <num> , BAD_LENGTH = <num> , BAD_MAGIC = <num> ,
BAD_CHECKSUM = <num> ;
public static final int MAGIC_LENGTH = <num> , TYPE_LENGTH = <num> ,
ARGLEN_LENGTH = <num> , CHECKSUM_LENGTH = <num> , SIGNATURE_LENGTH = <num> ;
public static final int MAGIC_OFFSET = <num> , TYPE_OFFSET = <num> ,
<unk> = <num> , ARGS_OFFSET = <num> , CHECKSUM_OFFSET = <num> ,
<unk> = <num> ;
private byte data [ ] ;
public Packet ( byte type , byte payload [ ] )
{
int totalLength = MAGIC_LENGTH + TYPE_LENGTH + ARGLEN_LENGTH +
payload . length + CHECKSUM_LENGTH + SIGNATURE_LENGTH ;
data = new byte [ totalLength ] ;
int offset = <num> ;
data [ offset ] = ROBODERP_MAGIC ;
offset += MAGIC_LENGTH ;
data [ offset ] = type ;
offset += TYPE_LENGTH ;
data [ offset ] = ( byte ) payload . length ;
offset += ARGLEN_LENGTH ;
for ( int ii = <num> ; ii < payload . length ; ii ++ )
{
data [ offset ] = payload [ ii ] ;
offset ++ ;
}
data [ offset ] = calculateChecksum ( data , MAGIC_OFFSET , offset ) ;
offset += CHECKSUM_LENGTH ;
data [ offset ] = <num> ;
}
public static int verifyPacket ( byte data [ ] , int length )
{
if ( length < MINIMUM_LENGTH )
{
return BAD_LENGTH ;
}
if ( data [ MAGIC_OFFSET ] != ROBODERP_MAGIC )
{
return BAD_MAGIC ;
}
byte checksum = calculateChecksum ( data , MAGIC_OFFSET ,
length  CHECKSUM_OFFSET ) ;
if ( data [ length  CHECKSUM_OFFSET ] != checksum )
{
return BAD_CHECKSUM ;
}
return OK ;
}
public static byte calculateChecksum ( byte data [ ] , int index , int length )
{
int sum = <num> ;
for ( int ii = index ; ii < index + length ; ii ++ )
{
sum = ( sum + data [ ii ] ) % BYTE_CEILING ;
}
return ( byte ) ( ~ sum + <num> ) ;
}
public static Packet seekerPacket ( )
{
return new Packet ( SEEKER , new byte [ <num> ] ) ;
}
public byte [ ] getBytes ( )
{
return data ;
}
public int size ( )
{
return data . length ;
}
}
package in . shick . roboderpremote ;
import java . net . DatagramPacket ;
import java . net . DatagramSocket ;
import java . net . InetAddress ;
import java . net . InetSocketAddress ;
import java . nio . channels . DatagramChannel ;
import java . util . ArrayList ;
import java . util . HashSet ;
import android . content . Context ;
import android . net . DhcpInfo ;
import android . net . wifi . WifiInfo ;
import android . net . wifi . WifiManager ;
import android . util . Log ;
public class Seeker
{
public static final int MAX_PACKET_LENGTH = <num> ;
public static final int MAX_SERVERS = <num> ;
public static final float SCAN_TIMEOUT = <num> ;
public static final float LISTEN_TIMEOUT = <num> ;
public static final int MSEC_PER_TIMEUNIT = <num> ;
public static final float RETRY_CYCLES = <num> ;
public static final int ROBODERP_PORT = <num> ;
public static final String LOG_TAG = " ;
private ArrayList < RoboderpServer > servers ;
private HashSet < RoboderpServer > serverPool ;
private SeekerResponder responder ;
private DatagramSocket datagramSocket ;
private WifiManager networkInfo ;
public Seeker ( RemoteActivity responder , WifiManager networkInfo )
{
this . responder = responder ;
this . networkInfo = networkInfo ;
datagramSocket = null ;
servers = new ArrayList < RoboderpServer > ( ) ;
serverPool = new HashSet < RoboderpServer > ( ) ;
}
public void launchWorker ( )
{
new Thread (
new Runnable ( ) {
public void run ( )
{
worker ( ) ;
}
} ) . start ( ) ;
}
private void worker ( )
{
WifiInfo wifiInfo = networkInfo . getConnectionInfo ( ) ;
if ( wifiInfo == null )
{
Log . e ( LOG_TAG , " ) ;
responder . notifyScanFailed ( ) ;
return ;
}
DhcpInfo dhcpInfo = networkInfo . getDhcpInfo ( ) ;
if ( dhcpInfo == null )
{
Log . e ( LOG_TAG , " ) ;
responder . notifyScanFailed ( ) ;
return ;
}
int localAddressInt = wifiInfo . getIpAddress ( ) ;
int subnetMask = dhcpInfo . netmask ;
int broadcastAddressInt = localAddressInt | ~ subnetMask ;
byte localAddressBytes [ ] = {
( byte ) ( localAddressInt ) ,
( byte ) ( localAddressInt >>> <num> ) ,
( byte ) ( localAddressInt >>> <num> ) ,
( byte ) ( localAddressInt >>> <num> )
} ;
byte broadcastAddressBytes [ ] = {
( byte ) ( broadcastAddressInt ) ,
( byte ) ( broadcastAddressInt >>> <num> ) ,
( byte ) ( broadcastAddressInt >>> <num> ) ,
( byte ) ( broadcastAddressInt >>> <num> )
} ;
try
{
InetAddress localAddress = InetAddress
. getByAddress ( localAddressBytes ) ;
InetAddress broadcastAddress = InetAddress
. getByAddress ( broadcastAddressBytes ) ;
datagramSocket = DatagramChannel . open ( ) . socket ( ) ;
System . out . println ( ( new InetSocketAddress ( localAddress ,
ROBODERP_PORT ) ) . toString ( ) ) ;
datagramSocket . bind ( new InetSocketAddress ( localAddress ,
ROBODERP_PORT ) ) ;
datagramSocket . setSoTimeout ( ( int ) ( LISTEN_TIMEOUT *
MSEC_PER_TIMEUNIT ) ) ;
Packet pkt = Packet . seekerPacket ( ) ;
DatagramPacket broadcastPacket = new DatagramPacket (
pkt . getBytes ( ) , pkt . size ( ) , broadcastAddress ,
ROBODERP_PORT ) ;
DatagramPacket responsePacket = new DatagramPacket ( new
byte [ MAX_PACKET_LENGTH ] , MAX_PACKET_LENGTH ) ;
boolean receivedPacket = false ;
int cycle_cap = ( int ) ( SCAN_TIMEOUT / LISTEN_TIMEOUT ) ;
for ( int cycle = <num> ; cycle < cycle_cap ; cycle ++ )
{
if ( cycle % RETRY_CYCLES == <num> )
{
datagramSocket . send ( broadcastPacket ) ;
}
try
{
datagramSocket . receive ( responsePacket ) ;
receivedPacket = true ;
}
catch ( java . net . SocketTimeoutException e )
{
receivedPacket = false ;
}
if ( receivedPacket )
{
System . out . print ( " ) ;
for ( int ii = <num> ; ii < responsePacket . getLength ( ) ; ii ++ )
{
System . out . printf ( " ,
responsePacket . getData ( ) [ ii ] ) ;
}
System . out . println ( ) ;
int packetStatus = Packet . verifyPacket (
responsePacket . getData ( ) ,
responsePacket . getLength ( ) ) ;
int packetType =
responsePacket . getData ( ) [ Packet . TYPE_OFFSET ] ;
if ( packetStatus == Packet . OK && packetType ==
Packet . SEEKER_RESPONSE )
{
synchronized ( serverPool )
{
serverPool . add ( new IpRoboderpServer (
responsePacket . getAddress ( ) ,
responsePacket . getPort ( ) ) ) ;
}
}
}
synchronized ( serverPool )
{
if ( serverPool . size ( ) >= MAX_SERVERS )
{
break ;
}
}
}
datagramSocket . close ( ) ;
datagramSocket = null ;
}
catch ( java . net . SocketException e )
{
Log . e ( LOG_TAG , " + e ) ;
fail ( ) ;
return ;
}
catch ( java . net . UnknownHostException e )
{
Log . e ( LOG_TAG , " + e ) ;
fail ( ) ;
return ;
}
catch ( java . io . IOException e )
{
Log . e ( LOG_TAG , " + e ) ;
fail ( ) ;
return ;
}
boolean foundServer = false ;
RoboderpServer server = null ;
synchronized ( serverPool )
{
foundServer = serverPool . size ( ) > <num> ;
}
if ( foundServer )
{
server = getServerList ( ) . get ( <num> ) ;
server . connect ( ) ;
}
if ( foundServer )
{
responder . notifyScanSucceeded ( ) ;
}
else
{
responder . notifyScanFailed ( ) ;
}
}
private void fail ( )
{
if ( datagramSocket != null )
{
datagramSocket . close ( ) ;
datagramSocket = null ;
}
responder . notifyScanFailed ( ) ;
}
public ArrayList < RoboderpServer > getServerList ( )
{
synchronized ( serverPool )
{
return new ArrayList ( serverPool ) ;
}
}
}
package in . shick . roboderpremote ;
import android . graphics . Point ;
import java . io . DataInputStream ;
import java . io . DataOutputStream ;
import java . io . InputStream ;
import java . io . OutputStream ;
import java . net . InetAddress ;
import java . net . InetSocketAddress ;
import java . net . Socket ;
import java . util . concurrent . locks . Condition ;
import java . util . concurrent . locks . Lock ;
import java . util . concurrent . locks . ReentrantLock ;
import java . util . LinkedList ;
import java . util . Queue ;
public class IpRoboderpServer implements RoboderpServer
{
public static final int BUFFER_SIZE = <num> ;
public static final int STREAM_TIMEOUT = <num> ;
private InetAddress address ;
private int port , status ;
private InetSocketAddress streamSocketAddress ;
private RoboderpClient client ;
private Socket streamSocket ;
private Object workersEnabledLock ;
private boolean workersEnabled ;
private Thread txWorkerThread , rxWorkerThread ;
private DataOutputStream out ;
private DataInputStream in ;
private Lock outputLock , statusLock ;
private Condition outputWaiting ;
private Queue < Packet > outputQueue ;
public IpRoboderpServer ( InetAddress address , int port )
{
this . address = address ;
this . port = port ;
workersEnabledLock = new Object ( ) ;
workersEnabled = false ;
status = DISCONNECTED ;
client = null ;
streamSocket = new Socket ( ) ;
streamSocketAddress = new InetSocketAddress ( address , port ) ;
in = null ;
out = null ;
outputLock = new ReentrantLock ( ) ;
statusLock = new ReentrantLock ( ) ;
outputWaiting = outputLock . newCondition ( ) ;
outputQueue = new LinkedList < Packet > ( ) ;
rxWorkerThread = new Thread (
new Runnable ( ) {
public void run ( )
{
rxWorker ( ) ;
}
} ) ;
txWorkerThread = new Thread (
new Runnable ( ) {
public void run ( )
{
txWorker ( ) ;
}
} ) ;
}
private void txWorker ( )
{
boolean enabled = false ;
synchronized ( workersEnabledLock )
{
enabled = workersEnabled ;
}
while ( enabled )
{
outputLock . lock ( ) ;
try
{
outputWaiting . await ( ) ;
while ( ! outputQueue . isEmpty ( ) )
{
send ( outputQueue . poll ( ) ) ;
}
}
catch ( Throwable e )
{
}
outputLock . unlock ( ) ;
synchronized ( workersEnabledLock )
{
enabled = workersEnabled ;
}
}
}
private void rxWorker ( )
{
boolean enabled = false ;
byte buffer [ ] = new byte [ BUFFER_SIZE ] ;
int bytes_received ;
synchronized ( workersEnabledLock )
{
enabled = workersEnabled ;
}
while ( enabled )
{
bytes_received = <num> ;
try
{
bytes_received = in . read ( buffer , <num> , BUFFER_SIZE ) ;
}
catch ( java . net . SocketTimeoutException e )
{
}
catch ( java . io . IOException e )
{
}
if ( bytes_received < <num> )
{
}
else if ( Packet . verifyPacket ( buffer , bytes_received ) != Packet . OK )
{
}
else
{
switch ( buffer [ Packet . TYPE_OFFSET ] )
{
case Packet . CLOSE :
if ( client != null )
{
client . notifyDisconnect ( ) ;
}
disconnect ( ) ;
break ;
case Packet . ADD_POINT :
int remote_id = buffer [ Packet . ARGS_OFFSET ] ;
int remote_x = buffer [ Packet . ARGS_OFFSET + <num> ] ;
int remote_y = buffer [ Packet . ARGS_OFFSET + <num> ] ;
if ( client != null )
{
client . placeRemoteMark ( remote_id ,
new Point ( remote_x , remote_y ) ) ;
}
break ;
case Packet . REMOVE_POINT :
if ( client != null )
{
client . removeRemoteMark ( buffer [ Packet . ARGS_OFFSET ] ) ;
}
break ;
}
}
synchronized ( workersEnabledLock )
{
enabled = workersEnabled ;
}
}
}
public void setClient ( RoboderpClient client )
{
this . client = client ;
}
public int connect ( )
{
byte input_buffer [ ] = new byte [ BUFFER_SIZE ] ;
int bytes_received = <num> ;
try
{
streamSocket . setSoTimeout ( STREAM_TIMEOUT ) ;
}
catch ( Throwable e )
{
status = DISCONNECTED ;
return DISCONNECTED ;
}
Packet handshakePacket = new Packet ( Packet . HANDSHAKE , new byte [ <num> ] ) ;
try
{
streamSocket . connect ( streamSocketAddress , STREAM_TIMEOUT ) ;
out = new DataOutputStream ( streamSocket . getOutputStream ( ) ) ;
in = new DataInputStream ( streamSocket . getInputStream ( ) ) ;
out . write ( handshakePacket . getBytes ( ) , <num> , handshakePacket . size ( ) ) ;
try
{
bytes_received = in . read ( input_buffer , <num> , BUFFER_SIZE ) ;
}
catch ( java . net . SocketTimeoutException e )
{
status = DISCONNECTED ;
streamSocket . close ( ) ;
return DISCONNECTED ;
}
if ( bytes_received < <num> )
{
status = DISCONNECTED ;
streamSocket . close ( ) ;
return DISCONNECTED ;
}
status = CONNECTED ;
synchronized ( workersEnabledLock )
{
workersEnabled = true ;
}
txWorkerThread . start ( ) ;
rxWorkerThread . start ( ) ;
return CONNECTED ;
}
catch ( java . io . IOException e )
{
status = DISCONNECTED ;
return DISCONNECTED ;
}
}
public void sendMark ( Point p )
{
byte payload [ ] = {
( byte ) p . x ,
( byte ) p . y
} ;
enqueue ( new Packet ( Packet . SEND_POINT , payload ) ) ;
}
public int disconnect ( )
{
statusLock . lock ( ) ;
synchronized ( workersEnabledLock )
{
workersEnabled = false ;
}
outputLock . lock ( ) ;
outputWaiting . signalAll ( ) ;
outputLock . unlock ( ) ;
try
{
txWorkerThread . join ( ) ;
rxWorkerThread . join ( ) ;
Packet closePacket = new Packet ( Packet . CLOSE , new byte [ <num> ] ) ;
out . write ( closePacket . getBytes ( ) , <num> , closePacket . size ( ) ) ;
streamSocket . close ( ) ;
}
catch ( Throwable e )
{
}
status = DISCONNECTED ;
statusLock . unlock ( ) ;
return DISCONNECTED ;
}
public int status ( )
{
return status ;
}
public String identifier ( )
{
return address + " + port ;
}
@Override
public String toString ( )
{
return identifier ( ) ;
}
@Override
public boolean equals ( Object o )
{
return identifier ( ) . equals ( o . toString ( ) ) ;
}
@Override
public int hashCode ( )
{
return identifier ( ) . hashCode ( ) ;
}
private void enqueue ( Packet p )
{
outputLock . lock ( ) ;
try
{
outputQueue . offer ( p ) ;
outputWaiting . signal ( ) ;
}
catch ( Throwable e )
{
}
finally
{
outputLock . unlock ( ) ;
}
}
private void send ( Packet p )
{
try
{
out . write ( p . getBytes ( ) , <num> , p . size ( ) ) ;
}
catch ( Throwable e )
{
}
}
}
package se . edument . roman ;
import java . util . Arrays ;
import java . util . List ;
import java . util . Map ;
import java . util . HashMap ;
public class RomanConverter {
Map < Integer , List < String >> letters = new HashMap < Integer , List < String >> ( ) ;
{
letters . put ( <num> , Arrays . asList ( " , " , " ) ) ;
letters . put ( <num> , Arrays . asList ( " , " , " ) ) ;
letters . put ( <num> , Arrays . asList ( " , " , " ) ) ;
}
public String toRoman ( int number ) {
return hundreds ( number / <num> ) + tens ( ( number / <num> ) % <num> ) + units ( number % <num> ) ;
}
private String generic ( int number , int factor ) {
List < String > l = letters . get ( factor ) ;
String i = l . get ( <num> ) ,
v = l . get ( <num> ) ,
x = l . get ( <num> ) ;
switch ( number ) {
case <num> :
case <num> :
case <num> :
return times ( number , i ) ;
case <num> :
return i + v ;
case <num> :
case <num> :
case <num> :
case <num> :
return v + times ( number  <num> , i ) ;
case <num> :
return i + x ;
}
return " ;
}
private String units ( int number ) {
return generic ( number , <num> ) ;
}
private String tens ( int number ) {
return generic ( number , <num> ) ;
}
private String hundreds ( int number ) {
return generic ( number , <num> ) ;
}
private String times ( int number , String string ) {
StringBuffer sb = new StringBuffer ( ) ;
for ( int i = <num> ; i < number ; i ++ )
sb . append ( string ) ;
return sb . toString ( ) ;
}
}
package se . edument . walkdetector ;
public class Location {
private float latitude ;
private float longitude ;
public Location ( float latitude , float longitude ) {
this . latitude = latitude ;
this . longitude = longitude ;
}
public float distanceTo ( Location other ) {
float dLat = this . latitude  other . latitude ;
float dLong = this . longitude  other . longitude ;
return ( float ) Math . sqrt ( dLat * dLat + dLong * dLong ) ;
}
public float getLatitude ( ) {
return latitude ;
}
public float getLongitude ( ) {
return longitude ;
}
}
package se . edument . recipebook ;
import android . app . ListActivity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . ArrayAdapter ;
import android . widget . ListView ;
import android . widget . TextView ;
public class RecipeListActivity extends ListActivity {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setListAdapter ( new ArrayAdapter < String > ( this , R . layout . recipe_list_item , RECIPES ) ) ;
ListView lv = getListView ( ) ;
lv . setTextFilterEnabled ( true ) ;
lv . setOnItemClickListener ( new OnItemClickListener ( ) {
public void onItemClick ( AdapterView < ? > parent , View view ,
int position , long id ) {
Intent intent = new Intent ( RecipeListActivity . this , RecipeActivity . class ) ;
intent . putExtra ( " , ( ( TextView ) view ) . getText ( ) ) ;
startActivity ( intent ) ;
}
} ) ;
}
static final String [ ] RECIPES = new String [ ] {
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
"
} ;
package se . edument . walkdetector ;
public interface GPS {
public Location getCurrentLocation ( ) ;
package se . edument . walkdetector ;
public class MockGPS implements GPS {
private Location location = new Location ( <num> , <num> ) ;
public void moveNorth ( int km ) {
location = new Location ( location . getLatitude ( ) + km ,
location . getLongitude ( ) ) ;
}
public Location getCurrentLocation ( ) {
return location ;
}
}
package se . edument . recipebook ;
import android . app . Activity ;
import android . os . Bundle ;
public class RecipeActivity extends Activity {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setTitle ( getIntent ( ) . getStringExtra ( " ) ) ;
setContentView ( R . layout . recipe ) ;
}
}
package se . edument . walkdetector ;
public class WalkDetector {
private Location startLocation ;
private boolean isWalking = false ;
private GPS gps ;
public WalkDetector ( GPS gps ) {
this . gps = gps ;
}
public void startWalking ( ) {
isWalking = true ;
startLocation = gps . getCurrentLocation ( ) ;
}
public float getWalkingDistance ( ) {
if ( ! isWalking )
throw new IllegalStateException ( " ) ;
Location currentLocation = gps . getCurrentLocation ( ) ;
return currentLocation . distanceTo ( startLocation ) ;
}
public void <unk> ( ) {
isWalking = false ;
}
}
package se . edument . walkdetector ;
import junit . framework . Assert ;
import org . junit . Before ;
import org . junit . Test ;
public class <unk> {
private WalkDetector detector ;
private MockGPS gps ;
@Before
public void setUp ( ) {
gps = new MockGPS ( ) ;
detector = new WalkDetector ( gps ) ;
}
@Test
public void <unk> ( ) {
detector . startWalking ( ) ;
Assert . assertEquals ( ( float ) <num> , detector . getWalkingDistance ( ) ) ;
}
@Test
public void <unk> ( ) {
detector . startWalking ( ) ;
gps . moveNorth ( <num> ) ;
Assert . assertEquals ( ( float ) <num> , detector . getWalkingDistance ( ) ) ;
}
}
package se . edument . roman ;
import junit . framework . Assert ;
import junit . framework . TestCase ;
public class <unk> extends TestCase {
private RomanConverter converter ;
public void setUp ( ) {
converter = new RomanConverter ( ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
public void <unk> ( ) {
Assert . assertEquals ( " , converter . toRoman ( <num> ) ) ;
}
}
package se . edument . walkdetector ;
public class <unk> implements GPS {
public Location getCurrentLocation ( ) {
return null ;
}
}
package ru . <unk> . <unk> . <unk> ;
import org . eclipse . ui . plugin . AbstractUIPlugin ;
import org . osgi . framework . BundleContext ;
public class WTPSugarPlugin extends AbstractUIPlugin {
public static final String PLUGIN_ID = " ;
private static WTPSugarPlugin plugin ;
public WTPSugarPlugin ( ) {
}
public void start ( BundleContext context ) throws Exception {
super . start ( context ) ;
plugin = this ;
}
public void stop ( BundleContext context ) throws Exception {
plugin = null ;
super . stop ( context ) ;
}
public static WTPSugarPlugin getDefault ( ) {
return plugin ;
}
}
package com . rhizomatiks . bvh ;
import java . util . ArrayList ;
import java . util . List ;
import processing . core . PMatrix3D ;
import processing . core . PVector ;
public class BvhBone {
private String _name ;
public PVector absPos = new PVector ( ) ;
public PVector absEndPos = new PVector ( ) ;
private float _offsetX = <num> ;
private float _offsetY = <num> ;
private float _offsetZ = <num> ;
private int _nbChannels ;
private List < String > _channels ;
private float _endOffsetX = <num> ;
private float _endOffsetY = <num> ;
private float _endOffsetZ = <num> ;
private BvhBone _parent ;
private List < BvhBone > _children ;
private float _Xposition = <num> ;
private float _Yposition = <num> ;
private float _Zposition = <num> ;
private float _Xrotation = <num> ;
private float _Yrotation = <num> ;
private float _Zrotation = <num> ;
public PMatrix3D global_matrix ;
public BvhBone ( BvhBone __parent )
{
_parent = __parent ;
_channels = new ArrayList < String > ( ) ;
_children = new ArrayList < BvhBone > ( ) ;
}
public BvhBone ( )
{
_parent = null ;
_channels = new ArrayList < String > ( ) ;
_children = new ArrayList < BvhBone > ( ) ;
}
public String toString ( )
{
return " + _name ;
}
public String structureToString ( )
{
return structureToString ( <num> ) ;
}
public String structureToString ( int __indent )
{
String res = " ;
for ( int i = <num> ; i < __indent ; i ++ )
res += " ;
res = res + " + _name + " + _offsetX + " + _offsetY + " + _offsetZ + " ;
for ( BvhBone child : _children )
res += child . structureToString ( __indent + <num> ) ;
return res ;
}
public String getName ( )
{
return _name ;
}
public void setName ( String value )
{
_name = value ;
}
public Boolean <unk> ( )
{
return ( _parent == null ) ;
}
public Boolean hasChildren ( )
{
return _children . size ( ) > <num> ;
}
public List < BvhBone > getChildren ( )
{
return _children ;
}
public void setChildren ( List < BvhBone > value )
{
_children = value ;
}
public BvhBone getParent ( )
{
return _parent ;
}
public void setParent ( BvhBone value )
{
_parent = value ;
}
public List < String > getChannels ( )
{
return _channels ;
}
public void setChannels ( List < String > value )
{
_channels = value ;
}
public int getNbChannels ( )
{
return _nbChannels ;
}
public void setnbChannels ( int value )
{
_nbChannels = value ;
}
public float getZrotation ( )
{
return _Zrotation ;
}
public void <unk> ( float value )
{
_Zrotation = value ;
}
public float getYrotation ( )
{
return _Yrotation ;
}
public void <unk> ( float value )
{
_Yrotation = value ;
}
public float getXrotation ( )
{
return _Xrotation ;
}
public void <unk> ( float value )
{
_Xrotation = value ;
}
public float getZposition ( )
{
return _Zposition ;
}
public void <unk> ( float value )
{
_Zposition = value ;
}
public float getYposition ( )
{
return _Yposition ;
}
public void <unk> ( float value )
{
_Yposition = value ;
}
public float getXposition ( )
{
return _Xposition ;
}
public void <unk> ( float value )
{
_Xposition = value ;
}
public float getEndOffsetZ ( )
{
return _endOffsetZ ;
}
public void setEndOffsetZ ( float value )
{
_endOffsetZ = value ;
}
public float getEndOffsetY ( )
{
return _endOffsetY ;
}
public void setEndOffsetY ( float value )
{
_endOffsetY = value ;
}
public float getEndOffsetX ( )
{
return _endOffsetX ;
}
public void setEndOffsetX ( float value )
{
_endOffsetX = value ;
}
public float getOffsetZ ( )
{
return _offsetZ ;
}
public void setOffsetZ ( float value )
{
_offsetZ = value ;
}
public float getOffsetY ( )
{
return _offsetY ;
}
public void setOffsetY ( float value )
{
_offsetY = value ;
}
public float getOffsetX ( )
{
return _offsetX ;
}
public void setOffsetX ( float value )
{
_offsetX = value ;
}
public void <unk> ( PVector pos ) {
absPos = pos ;
}
public PVector getAbsPosition ( )
{
return absPos ;
}
public void <unk> ( PVector pos )
{
absEndPos = pos ;
}
public PVector getAbsEndPosition ( )
{
return absEndPos ;
}
import processing . core . * ;
import processing . xml . * ;
import <unk> . minim . * ;
import com . rhizomatiks . bvh . * ;
import java . applet . * ;
import java . awt . Dimension ;
import java . awt . Frame ;
import java . awt . event . MouseEvent ;
import java . awt . event . KeyEvent ;
import java . awt . event . FocusEvent ;
import java . awt . Image ;
import java . io . * ;
import java . net . * ;
import java . text . * ;
import java . util . * ;
import java . util . zip . * ;
import java . util . regex . * ;
public class <unk> extends PApplet {
Minim minim ;
AudioPlayer player ;
BvhParser <unk> = new BvhParser ( ) ;
PBvh bvh1 , bvh2 , bvh3 ;
public void setup ( )
{
size ( <num> , <num> , P3D ) ;
background ( <num> ) ;
noStroke ( ) ;
frameRate ( <num> ) ;
bvh1 = new PBvh ( loadStrings ( " ) ) ;
bvh2 = new PBvh ( loadStrings ( " ) ) ;
bvh3 = new PBvh ( loadStrings ( " ) ) ;
minim = new Minim ( this ) ;
player = minim . loadFile ( " ) ;
player . play ( ) ;
loop ( ) ;
}
public void draw ( )
{
background ( <num> ) ;
camera ( ( float ) mouseX , ( float ) mouseY , <num> , ( float ) ( width / <num> ) , ( float ) ( height / <num> ) , <num> , <num> , <num> , <num> ) ;
fill ( color ( <num> ) ) ;
stroke ( <num> ) ;
line ( width / <num> , height / <num> ,  <num> , width / <num> , height / <num> , <num> ) ;
stroke ( <num> ) ;
line ( width / <num>  <num> , height / <num> , <num> , width / <num> + <num> , height / <num> , <num> ) ;
stroke ( <num> ) ;
pushMatrix ( ) ;
translate ( width / <num> , height / <num>  <num> , <num> ) ;
scale (  <num> ,  <num> ,  <num> ) ;
bvh1 . update ( millis ( ) ) ;
bvh2 . update ( millis ( ) ) ;
bvh3 . update ( millis ( ) ) ;
bvh1 . draw ( ) ;
bvh2 . draw ( ) ;
bvh3 . draw ( ) ;
popMatrix ( ) ;
}
public class PBvh
{
public BvhParser parser ;
public PBvh ( String [ ] data )
{
parser = new BvhParser ( ) ;
parser . init ( ) ;
parser . parse ( data ) ;
}
public void update ( int ms )
{
parser . moveMsTo ( ms ) ;
parser . update ( ) ;
}
public void draw ( )
{
fill ( color ( random ( <num> , <num> ) , random ( <num> , <num> ) , random ( <num> , <num> ) ) ) ;
for ( BvhBone b : parser . getBones ( ) )
{
pushMatrix ( ) ;
translate ( b . absPos . x , b . absPos . y , b . absPos . z ) ;
rect ( <num> , <num> , <num> , <num> ) ;
popMatrix ( ) ;
if ( ! b . hasChildren ( ) )
{
pushMatrix ( ) ;
translate ( b . absEndPos . x , b . absEndPos . y , b . absEndPos . z ) ;
rect ( <num> , <num> , <num> , <num> ) ;
popMatrix ( ) ;
}
}
}
}
static public void main ( String args [ ] ) {
PApplet . main ( new String [ ] { " , " } ) ;
}
}
package com . rhizomatiks . bvh ;
import java . lang . reflect . InvocationTargetException ;
import java . lang . reflect . Method ;
import java . util . ArrayList ;
import java . util . List ;
import processing . core . PApplet ;
import processing . core . PMatrix3D ;
import processing . core . PVector ;
public class BvhParser {
private Boolean _motionLoop ;
private int _currentFrame = <num> ;
private List < BvhLine > _lines ;
private int _currentLine ;
private BvhBone _currentBone ;
private BvhBone _rootBone ;
private List < List < Float >> _frames ;
private int _nbFrames ;
private float _frameTime ;
private List < BvhBone > _bones ;
public BvhParser ( )
{
_motionLoop = true ;
}
public Boolean <unk> ( )
{
return _motionLoop ;
}
public void <unk> ( Boolean value )
{
_motionLoop = value ;
}
public String <unk> ( )
{
return _rootBone . structureToString ( ) ;
}
public int getNbFrames ( )
{
return _nbFrames ;
}
public List < BvhBone > getBones ( )
{
return _bones ;
}
public void init ( )
{
_bones = new ArrayList < BvhBone > ( ) ;
_motionLoop = true ;
}
public void moveFrameTo ( int __index )
{
if ( ! _motionLoop )
{
if ( __index >= _nbFrames )
_currentFrame = _nbFrames  <num> ;
} else {
while ( __index >= _nbFrames )
__index -= _nbFrames ;
_currentFrame = __index ;
}
_updateFrame ( ) ;
}
public void moveMsTo ( int mills )
{
float frameTime = _frameTime * <num> ;
int curFrame = ( int ) ( mills / frameTime ) ;
moveFrameTo ( curFrame ) ;
}
public void update ( )
{
update ( getBones ( ) . get ( <num> ) ) ;
}
protected void update ( BvhBone bone )
{
PMatrix3D m = new PMatrix3D ( ) ;
m . translate ( bone . getXposition ( ) , bone . getYposition ( ) , bone . getZposition ( ) ) ;
m . translate ( bone . getOffsetX ( ) , bone . getOffsetY ( ) , bone . getOffsetZ ( ) ) ;
m . rotateY ( PApplet . radians ( bone . getYrotation ( ) ) ) ;
m . rotateX ( PApplet . radians ( bone . getXrotation ( ) ) ) ;
m . rotateZ ( PApplet . radians ( bone . getZrotation ( ) ) ) ;
bone . global_matrix = m ;
if ( bone . getParent ( ) != null && bone . getParent ( ) . global_matrix != null )
m . <unk> ( bone . getParent ( ) . global_matrix ) ;
m . mult ( new PVector ( ) , bone . getAbsPosition ( ) ) ;
if ( bone . getChildren ( ) . size ( ) > <num> )
{
for ( BvhBone child : bone . getChildren ( ) )
{
update ( child ) ;
}
}
else
{
m . translate ( bone . getEndOffsetX ( ) , bone . getEndOffsetY ( ) , bone . getEndOffsetZ ( ) ) ;
m . mult ( new PVector ( ) , bone . getAbsEndPosition ( ) ) ;
}
}
private void _updateFrame ( )
{
if ( _currentFrame >= _frames . size ( ) ) return ;
List < Float > frame = _frames . get ( _currentFrame ) ;
int count = <num> ;
for ( float n : frame )
{
BvhBone bone = _getBoneInFrameAt ( count ) ;
String prop = _getBonePropInFrameAt ( count ) ;
if ( bone != null ) {
Method getterMethod ;
try {
getterMethod = bone . getClass ( ) . getDeclaredMethod ( " . concat ( prop ) , new Class [ ] { float . class } ) ;
getterMethod . invoke ( bone , n ) ;
} catch ( SecurityException e ) {
e . printStackTrace ( ) ;
System . err . println ( " ) ;
} catch ( NoSuchMethodException e ) {
e . printStackTrace ( ) ;
System . err . println ( " ) ;
} catch ( IllegalArgumentException e ) {
e . printStackTrace ( ) ;
System . err . println ( " ) ;
} catch ( IllegalAccessException e ) {
e . printStackTrace ( ) ;
System . err . println ( " ) ;
} catch ( InvocationTargetException e ) {
e . printStackTrace ( ) ;
System . err . println ( " ) ;
}
}
count ++ ;
}
}
private String _getBonePropInFrameAt ( int n )
{
int c = <num> ;
for ( BvhBone bone : _bones )
{
if ( c + bone . getNbChannels ( ) > n )
{
n -= c ;
return bone . getChannels ( ) . get ( n ) ;
} else {
c += bone . getNbChannels ( ) ;
}
}
return null ;
}
private BvhBone _getBoneInFrameAt ( int n )
{
int c = <num> ;
for ( BvhBone bone : _bones )
{
c += bone . getNbChannels ( ) ;
if ( c > n )
return bone ;
}
return null ;
}
public void parse ( String [ ] srces )
{
String [ ] linesStr = srces ;
_lines = new ArrayList < BvhLine > ( ) ;
for ( String lineStr : linesStr )
_lines . add ( new BvhLine ( lineStr ) ) ;
_currentLine = <num> ;
_rootBone = _parseBone ( ) ;
_parseFrames ( ) ;
}
private void _parseFrames ( )
{
int currentLine = _currentLine ;
for ( ; currentLine < _lines . size ( ) ; currentLine ++ )
if ( _lines . get ( currentLine ) . getLineType ( ) == BvhLine . MOTION ) break ;
if ( _lines . size ( ) > currentLine )
{
currentLine ++ ;
_nbFrames = _lines . get ( currentLine ) . getNbFrames ( ) ;
currentLine ++ ;
_frameTime = _lines . get ( currentLine ) . getFrameTime ( ) ;
currentLine ++ ;
_frames = new ArrayList < List < Float >> ( ) ;
for ( ; currentLine < _lines . size ( ) ; currentLine ++ )
{
_frames . add ( _lines . get ( currentLine ) . getFrames ( ) ) ;
}
}
}
private BvhBone _parseBone ( )
{
BvhBone bone = new BvhBone ( _currentBone ) ;
_bones . add ( bone ) ;
bone . setName ( _lines . get ( _currentLine ) . _boneName ) ;
_currentLine ++ ;
_currentLine ++ ;
bone . setOffsetX ( _lines . get ( _currentLine ) . getOffsetX ( ) ) ;
bone . setOffsetY ( _lines . get ( _currentLine ) . getOffsetY ( ) ) ;
bone . setOffsetZ ( _lines . get ( _currentLine ) . getOffsetZ ( ) ) ;
_currentLine ++ ;
bone . setnbChannels ( _lines . get ( _currentLine ) . getNbChannels ( ) ) ;
bone . setChannels ( _lines . get ( _currentLine ) . getChannelsProps ( ) ) ;
_currentLine ++ ;
while ( _currentLine < _lines . size ( ) )
{
String lineType = _lines . get ( _currentLine ) . getLineType ( ) ;
if ( BvhLine . BONE . equals ( lineType ) )
{
BvhBone child = _parseBone ( ) ;
child . setParent ( bone ) ;
bone . getChildren ( ) . add ( child ) ;
}
else if ( BvhLine . END_SITE . equals ( lineType ) )
{
_currentLine ++ ;
_currentLine ++ ;
bone . setEndOffsetX ( _lines . get ( _currentLine ) . getOffsetX ( ) ) ;
bone . setEndOffsetY ( _lines . get ( _currentLine ) . getOffsetY ( ) ) ;
bone . setEndOffsetZ ( _lines . get ( _currentLine ) . getOffsetZ ( ) ) ;
_currentLine ++ ;
_currentLine ++ ;
return bone ;
}
else if ( BvhLine . BRACE_CLOSED . equals ( lineType ) )
{
return bone ;
}
_currentLine ++ ;
}
System . out . println ( " ) ;
return bone ;
}
private class BvhLine
{
public static final String HIERARCHY = " ;
public static final String BONE = " ;
public static final String BRACE_OPEN = " ;
public static final String BRACE_CLOSED = " ;
public static final String OFFSET = " ;
public static final String CHANNELS = " ;
public static final String END_SITE = " ;
public static final String MOTION = " ;
public static final String FRAMES = " ;
public static final String FRAME_TIME = " ;
public static final String FRAME = " ;
public static final String BONE_TYPE_ROOT = " ;
public static final String BONE_TYPE_JOINT = " ;
private String _lineStr ;
private String _lineType ;
private String _boneType ;
private String _boneName ;
private float _offsetX ;
private float _offsetY ;
private float _offsetZ ;
private int _nbChannels ;
private List < String > _channelsProps ;
private int _nbFrames ;
private float _frameTime ;
private List < Float > _frames ;
public String toString ( )
{
return _lineStr ;
}
private void _parse ( String __lineStr )
{
_lineStr = __lineStr ;
_lineStr = _lineStr . trim ( ) ;
_lineStr = _lineStr . replace ( " , " ) ;
_lineStr = _lineStr . replace ( " , " ) ;
_lineStr = _lineStr . replace ( " , " ) ;
String [ ] words = _lineStr . split ( " ) ;
_lineType = _parseLineType ( words ) ;
if ( HIERARCHY . equals ( _lineType ) )
{
return ;
} else if ( BONE . equals ( _lineType ) ) {
_boneType = ( words [ <num> ] == " ) ? BONE_TYPE_ROOT : BONE_TYPE_JOINT ;
_boneName = words [ <num> ] ;
return ;
} else if ( OFFSET . equals ( _lineType ) ) {
_offsetX = Float . valueOf ( words [ <num> ] ) ;
_offsetY = Float . valueOf ( words [ <num> ] ) ;
_offsetZ = Float . valueOf ( words [ <num> ] ) ;
return ;
} else if ( CHANNELS . equals ( _lineType ) ) {
_nbChannels = Integer . valueOf ( words [ <num> ] ) ;
_channelsProps = new ArrayList < String > ( ) ;
for ( int i = <num> ; i < _nbChannels ; i ++ )
_channelsProps . add ( words [ i + <num> ] ) ;
return ;
} else if ( FRAMES . equals ( _lineType ) ) {
_nbFrames = Integer . valueOf ( words [ <num> ] ) ;
return ;
} else if ( FRAME_TIME . equals ( _lineType ) ) {
_frameTime = Float . valueOf ( words [ <num> ] ) ;
return ;
} else if ( FRAME . equals ( _lineType ) ) {
_frames = new ArrayList < Float > ( ) ;
for ( String word : words ) _frames . add ( Float . valueOf ( word ) ) ;
return ;
} else if ( END_SITE . equals ( _lineType ) ||
BRACE_OPEN . equals ( _lineType ) ||
BRACE_CLOSED . equals ( _lineType ) ||
MOTION . equals ( _lineType ) ) {
return ;
}
}
private String _parseLineType ( String [ ] __words ) {
if ( " . equals ( __words [ <num> ] ) )
return HIERARCHY ;
if ( " . equals ( __words [ <num> ] ) ||
" . equals ( __words [ <num> ] ) )
return BONE ;
if ( " . equals ( __words [ <num> ] ) )
return BRACE_OPEN ;
if ( " . equals ( __words [ <num> ] ) )
return BRACE_CLOSED ;
if ( " . equals ( __words [ <num> ] ) )
return OFFSET ;
if ( " . equals ( __words [ <num> ] ) )
return CHANNELS ;
if ( " . equals ( __words [ <num> ] ) )
return END_SITE ;
if ( " . equals ( __words [ <num> ] ) )
return MOTION ;
if ( " . equals ( __words [ <num> ] ) )
return FRAMES ;
if ( " . equals ( __words [ <num> ] ) )
return FRAME_TIME ;
try {
Float . parseFloat ( __words [ <num> ] ) ;
return FRAME ;
} catch ( NumberFormatException e ) {
e . printStackTrace ( ) ;
}
return null ;
}
public BvhLine ( String __lineStr )
{
_parse ( __lineStr ) ;
}
public List < Float > getFrames ( )
{
return _frames ;
}
public float getFrameTime ( )
{
return _frameTime ;
}
public int getNbFrames ( )
{
return _nbFrames ;
}
public List < String > getChannelsProps ( )
{
return _channelsProps ;
}
public int getNbChannels ( )
{
return _nbChannels ;
}
public float getOffsetZ ( )
{
return _offsetZ ;
}
public float getOffsetY ( )
{
return _offsetY ;
}
public float getOffsetX ( )
{
return _offsetX ;
}
public String <unk> ( )
{
return _boneName ;
}
public String <unk> ( )
{
return _boneType ;
}
public String getLineType ( )
{
return _lineType ;
}
}
}
package org . <unk> . <unk> ;
import java . util . HashSet ;
import org . bukkit . ChatColor ;
import org . bukkit . entity . Player ;
import org . bukkit . event . EventHandler ;
import org . bukkit . event . EventPriority ;
import org . bukkit . event . Listener ;
import org . bukkit . event . entity . EntityDeathEvent ;
import org . bukkit . event . player . PlayerPreLoginEvent ;
import org . bukkit . event . player . PlayerPreLoginEvent . Result ;
import org . bukkit . plugin . java . JavaPlugin ;
public class DeathLockout extends JavaPlugin implements Listener {
private HashSet < String > lockedOut ;
private int timeout ;
private int minutes ;
@Override
public void onEnable ( ) {
this . lockedOut = new HashSet < String > ( ) ;
this . getConfig ( ) . options ( ) . copyDefaults ( true ) ;
this . saveConfig ( ) ;
this . minutes = this . getConfig ( ) . getInt ( " ) ;
this . timeout = this . minutes * <num> * <num> ;
this . getServer ( ) . getPluginManager ( ) . registerEvents ( this , this ) ;
}
@EventHandler
public void onDeath ( EntityDeathEvent event ) {
if ( event . getEntity ( ) instanceof Player ) {
final Player died = ( Player ) event . getEntity ( ) ;
if ( died . hasPermission ( " ) ) {
this . getServer ( ) . getScheduler ( ) . scheduleSyncDelayedTask ( this , new Notify ( died . getName ( ) ) , this . timeout ) ;
died . sendMessage ( ChatColor . YELLOW + " ) ;
died . sendMessage ( ChatColor . YELLOW + " ) ;
return ;
}
this . lockedOut . add ( died . getName ( ) ) ;
this . getServer ( ) . getScheduler ( ) . scheduleSyncDelayedTask ( this , new Unlock ( died . getName ( ) ) , this . timeout ) ;
died . kickPlayer ( ChatColor . WHITE + " + ChatColor . RED + this . minutes + ChatColor . WHITE + " ) ;
}
}
<unk>
public void <unk> ( PlayerPreLoginEvent event ) {
if ( this . lockedOut . contains ( event . getName ( ) ) ) {
event . disallow ( Result . KICK_OTHER , ChatColor . RED . toString ( ) + this . minutes + ChatColor . WHITE + " ) ;
}
}
private class Unlock implements Runnable {
private final String name ;
public Unlock ( String name ) {
this . name = name ;
}
@Override
public void run ( ) {
DeathLockout . this . lockedOut . remove ( this . name ) ;
}
}
private class Notify implements Runnable {
private final String name ;
public Notify ( String name ) {
this . name = name ;
}
@Override
public void run ( ) {
final Player target = DeathLockout . this . getServer ( ) . getPlayerExact ( this . name ) ;
if ( ( target != null ) && target . isOnline ( ) ) {
target . sendMessage ( ChatColor . YELLOW + " ) ;
}
}
}
}
package com . example . android . styledactionbar ;
import android . app . Fragment ;
import android . graphics . drawable . GradientDrawable ;
import android . os . Bundle ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . view . ViewGroup . LayoutParams ;
import android . widget . LinearLayout ;
public class RoundedColourFragment extends Fragment {
private View mView ;
private int mColour ;
private float mWeight ;
private int marginLeft , marginRight , marginTop , marginBottom ;
public RoundedColourFragment ( ) {
}
public RoundedColourFragment ( int colour , float weight , int margin_left ,
int margin_right , int margin_top , int margin_bottom ) {
mColour = colour ;
mWeight = weight ;
marginLeft = margin_left ;
marginRight = margin_right ;
marginTop = margin_top ;
marginBottom = margin_bottom ;
}
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
mView = new View ( getActivity ( ) ) ;
GradientDrawable background = ( GradientDrawable ) getResources ( )
. getDrawable ( R . drawable . rounded_rect ) ;
background . setColor ( mColour ) ;
mView . setBackgroundDrawable ( background ) ;
LinearLayout . LayoutParams lp = new LinearLayout . LayoutParams ( <num> ,
LayoutParams . FILL_PARENT , mWeight ) ;
lp . setMargins ( marginLeft , marginTop , marginRight , marginBottom ) ;
mView . setLayoutParams ( lp ) ;
}
@Override
public View onCreateView ( LayoutInflater inflater , ViewGroup container ,
Bundle savedInstanceState ) {
return mView ;
}
}
package com . example . android . styledactionbar ;
public final class R {
public static final class array {
public static final int sections = <num> ;
}
public static final class attr {
}
public static final class color {
public static final int android_green = <num> ;
public static final int background = <num> ;
public static final int honeycombish_blue = <num> ;
public static final int <unk> = <num> ;
}
public static final class dimen {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
}
public static final class drawable {
public static final int <unk> = <num> ;
public static final int ad_action_bar_gradient_bak = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int ic_launcher = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int rounded_rect = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
}
public static final class id {
public static final int <unk> = <num> ;
public static final int menu_bak_gradient = <num> ;
public static final int <unk> = <num> ;
public static final int menu_bak_none = <num> ;
public static final int menu_both = <num> ;
public static final int menu_logo = <num> ;
public static final int <unk> = <num> ;
public static final int menu_nav_drop_down = <num> ;
public static final int <unk> = <num> ;
public static final int menu_nav_label = <num> ;
public static final int menu_nav_tabs = <num> ;
public static final int menu_refresh = <num> ;
public static final int menu_search = <num> ;
public static final int menu_text = <num> ;
public static final int menu_up = <num> ;
public static final int root = <num> ;
}
public static final class layout {
public static final int indeterminate_progress_action = <num> ;
public static final int main = <num> ;
}
public static final class menu {
public static final int main_menu = <num> ;
}
public static final class string {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int app_name = <num> ;
}
public static final class style {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int Theme = <num> ;
public static final int <unk> = <num> ;
}
}
package com . example . android . styledactionbar ;
import android . animation . ObjectAnimator ;
import android . app . ActionBar ;
import android . app . Activity ;
import android . app . FragmentTransaction ;
import android . app . ActionBar . OnNavigationListener ;
import android . os . Bundle ;
import android . os . Handler ;
import android . view . Menu ;
import android . view . MenuItem ;
import android . view . MenuItem . OnMenuItemClickListener ;
import android . widget . ArrayAdapter ;
public class MainActivity extends Activity implements ActionBar . TabListener {
private final Handler handler = new Handler ( ) ;
private RoundedColourFragment leftFrag ;
private RoundedColourFragment rightFrag ;
private boolean useLogo = false ;
private boolean showHomeUp = false ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
final ActionBar ab = getActionBar ( ) ;
ab . setDisplayHomeAsUpEnabled ( showHomeUp ) ;
ab . setDisplayUseLogoEnabled ( useLogo ) ;
for ( int i = <num> ; i < <num> ; i ++ ) {
ab . addTab ( ab . newTab ( ) . setText ( " + i ) . setTabListener ( this ) ) ;
}
ab . setListNavigationCallbacks ( ArrayAdapter
. createFromResource ( this , R . array . sections ,
android . R . layout . simple_spinner_dropdown_item ) ,
new OnNavigationListener ( ) {
public boolean onNavigationItemSelected ( int itemPosition ,
long itemId ) {
rotateLeftFrag ( ) ;
return false ;
}
} ) ;
showTabsNav ( ) ;
final int MARGIN = <num> ;
leftFrag = new RoundedColourFragment ( getResources ( ) . getColor (
R . color . android_green ) , <num> , MARGIN , MARGIN / <num> , MARGIN , MARGIN ) ;
rightFrag = new RoundedColourFragment ( getResources ( ) . getColor (
R . color . honeycombish_blue ) , <num> , MARGIN / <num> , MARGIN , MARGIN ,
MARGIN ) ;
FragmentTransaction ft = getFragmentManager ( ) . beginTransaction ( ) ;
ft . add ( R . id . root , leftFrag ) ;
ft . add ( R . id . root , rightFrag ) ;
ft . commit ( ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
getMenuInflater ( ) . inflate ( R . menu . main_menu , menu ) ;
final MenuItem refresh = ( MenuItem ) menu . findItem ( R . id . menu_refresh ) ;
refresh . setOnMenuItemClickListener ( new OnMenuItemClickListener ( ) {
public boolean onMenuItemClick ( MenuItem item ) {
handler . postDelayed ( new Runnable ( ) {
public void run ( ) {
refresh . setActionView ( null ) ;
}
} , <num> ) ;
return false ;
}
} ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
return false ;
case R . id . menu_refresh :
item . setActionView ( R . layout . indeterminate_progress_action ) ;
return true ;
case R . id . menu_both :
rotateLeftFrag ( ) ;
return true ;
case R . id . menu_text :
ObjectAnimator alpha = ObjectAnimator . ofFloat ( rightFrag . getView ( ) ,
" , <num> , <num> ) ;
alpha . setRepeatMode ( ObjectAnimator . REVERSE ) ;
alpha . setRepeatCount ( <num> ) ;
alpha . setDuration ( <num> ) ;
alpha . start ( ) ;
return true ;
case R . id . menu_logo :
useLogo = ! useLogo ;
item . setChecked ( useLogo ) ;
getActionBar ( ) . setDisplayUseLogoEnabled ( useLogo ) ;
return true ;
case R . id . menu_up :
showHomeUp = ! showHomeUp ;
item . setChecked ( showHomeUp ) ;
getActionBar ( ) . setDisplayHomeAsUpEnabled ( showHomeUp ) ;
return true ;
case R . id . menu_nav_tabs :
item . setChecked ( true ) ;
showTabsNav ( ) ;
return true ;
case R . id . menu_nav_label :
item . setChecked ( true ) ;
showStandardNav ( ) ;
return true ;
case R . id . menu_nav_drop_down :
item . setChecked ( true ) ;
showDropDownNav ( ) ;
return true ;
case R . id . menu_bak_none :
item . setChecked ( true ) ;
getActionBar ( ) . setBackgroundDrawable ( null ) ;
return true ;
case R . id . menu_bak_gradient :
item . setChecked ( true ) ;
getActionBar ( ) . setBackgroundDrawable ( getResources ( ) . getDrawable ( R . drawable . ad_action_bar_gradient_bak ) ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
private void rotateLeftFrag ( ) {
if ( leftFrag != null ) {
ObjectAnimator . ofFloat ( leftFrag . getView ( ) , " , <num> , <num> )
. setDuration ( <num> ) . start ( ) ;
}
}
private void showStandardNav ( ) {
ActionBar ab = getActionBar ( ) ;
if ( ab . getNavigationMode ( ) != ActionBar . NAVIGATION_MODE_STANDARD ) {
ab . setDisplayShowTitleEnabled ( true ) ;
ab . setNavigationMode ( ActionBar . NAVIGATION_MODE_STANDARD ) ;
}
}
private void showDropDownNav ( ) {
ActionBar ab = getActionBar ( ) ;
if ( ab . getNavigationMode ( ) != ActionBar . NAVIGATION_MODE_LIST ) {
ab . setDisplayShowTitleEnabled ( false ) ;
ab . setNavigationMode ( ActionBar . NAVIGATION_MODE_LIST ) ;
}
}
private void showTabsNav ( ) {
ActionBar ab = getActionBar ( ) ;
if ( ab . getNavigationMode ( ) != ActionBar . NAVIGATION_MODE_TABS ) {
ab . setDisplayShowTitleEnabled ( false ) ;
ab . setNavigationMode ( ActionBar . NAVIGATION_MODE_TABS ) ;
}
}
public void onTabSelected ( ActionBar . Tab tab , FragmentTransaction ft ) {
rotateLeftFrag ( ) ;
}
public void onTabUnselected ( ActionBar . Tab tab , FragmentTransaction ft ) {
}
public void onTabReselected ( ActionBar . Tab tab , FragmentTransaction ft ) {
}
package org . ligi . gobandroid_hd . ui . application ;
import org . ligi . gobandroid_hd . ui . gobandroid ;
import org . ligi . tracedroid . TraceDroid ;
import org . ligi . tracedroid . logging . Log ;
import org . ligi . tracedroid . <unk> . TraceDroidEmailSender ;
import com . google . android . apps . analytics . GoogleAnalyticsTracker ;
import android . content . Intent ;
import android . os . Bundle ;
import android . support . v4 . app . FragmentActivity ;
import android . support . v4 . view . MenuItem ;
import android . view . KeyEvent ;
import android . view . WindowManager ;
public class GobandroidFragmentActivity extends FragmentActivity {
private GoogleAnalyticsTracker tracker = null ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
TraceDroid . init ( this ) ;
Log . <unk> ( " ) ;
TraceDroidEmailSender . <unk> ( " , this ) ;
if ( doFullScreen ( ) )
this . getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_FULLSCREEN , WindowManager . LayoutParams . FLAG_FULLSCREEN ) ;
else
this . getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_FULLSCREEN ) ;
if ( ( this . getSupportActionBar ( ) != null ) && ( this . getSupportActionBar ( ) . getCustomView ( ) != null ) )
this . getSupportActionBar ( ) . getCustomView ( ) . setFocusable ( false ) ;
}
public boolean doFullScreen ( ) {
return false ;
}
public GoogleAnalyticsTracker getTracker ( ) {
if ( tracker == null ) {
tracker = GoogleAnalyticsTracker . getInstance ( ) ;
tracker . startNewSession ( " , this ) ;
}
return tracker ;
}
@Override
protected void onDestroy ( ) {
super . onDestroy ( ) ;
if ( tracker != null ) {
tracker . dispatch ( ) ;
tracker . stopSession ( ) ;
}
}
public GobandroidSettings getSettings ( ) {
return new GobandroidSettings ( this ) ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
Intent intent = new Intent ( this , gobandroid . class ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
startActivity ( intent ) ;
return true ;
}
return super . onContextItemSelected ( item ) ;
}
@Override
public boolean onKeyDown ( int keyCode , KeyEvent event ) {
if ( keyCode == KeyEvent . KEYCODE_WINDOW )
return false ;
return super . onKeyDown ( keyCode , event ) ;
}
}
package org . ligi . gobandroid_hd . ui . recording ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame . GoGameChangeListener ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import android . os . Bundle ;
import android . os . Handler ;
import android . support . v4 . app . Fragment ;
import android . text . Editable ;
import android . text . TextWatcher ;
import android . view . Gravity ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . view . ViewGroup . LayoutParams ;
import android . widget . EditText ;
import android . widget . LinearLayout ;
public class RecordingGameExtrasFragment extends Fragment implements GoGameChangeListener {
private EditText et ;
private Handler hndl = new Handler ( ) ;
@Override
public View onCreateView ( LayoutInflater inflater , ViewGroup container ,
Bundle savedInstanceState ) {
LinearLayout . LayoutParams lp = new LinearLayout . LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . FILL_PARENT ) ;
et = new EditText ( this . getActivity ( ) ) ;
GoGameProvider . getGame ( ) . addGoGameChangeListener ( this ) ;
et . setText ( GoGameProvider . getGame ( ) . getActMove ( ) . getComment ( ) ) ;
et . setHint ( R . string . <unk> ) ;
et . setGravity ( Gravity . TOP ) ;
et . setTextColor ( this . getResources ( ) . getColor ( R . color . <unk> ) ) ;
et . addTextChangedListener ( new TextWatcher ( ) {
@Override
public void afterTextChanged ( Editable s ) {
GoGameProvider . getGame ( ) . getActMove ( ) . setComment ( s . toString ( ) ) ;
}
@Override
public void beforeTextChanged ( CharSequence s , int start , int count ,
int after ) {
}
@Override
public void onTextChanged ( CharSequence s , int start , int before ,
int count ) {
} } ) ;
et . setLayoutParams ( lp ) ;
return et ;
}
@Override
public void onGoGameChange ( ) {
hndl . post ( new Runnable ( ) {
@Override
public void run ( ) {
if ( et != null )
et . setText ( GoGameProvider . getGame ( ) . getActMove ( ) . getComment ( ) ) ;
}
} ) ;
}
}
package org . ligi . gobandroid_hd . ui . recording ;
import java . util . Vector ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GnuGoMover ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGame . GoGameChangeListener ;
import org . ligi . gobandroid_hd . logic . GoMove ;
import org . ligi . gobandroid_hd . ui . GoActivity ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . support . v4 . view . Menu ;
import android . view . WindowManager ;
public class PlayAgainstGnugoActivity extends GoActivity implements GoGameChangeListener {
private Vector < GoMove > on_path_moves ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_STATE_ALWAYS_HIDDEN ) ;
game . setGoMover ( new GnuGoMover ( this , game , false , true , ( byte ) <num> ) ) ;
}
public boolean isOnPath ( ) {
return on_path_moves . contains ( game . getActMove ( ) ) ;
}
public byte doMoveWithUIFeedback ( byte x , byte y ) {
byte res = super . doMoveWithUIFeedback ( x , y ) ;
if ( res == GoGame . MOVE_VALID )
if ( game . getActMove ( ) . hasNextMove ( ) )
game . jump ( game . getActMove ( ) . getnextMove ( <num> ) ) ;
game . notifyGameChange ( ) ;
return res ;
}
public GoMove getCorrectMove ( GoMove act_mve ) {
if ( act_mve . getComment ( ) . equals ( " ) )
return act_mve ;
for ( GoMove next_moves : act_mve . getNextMoveVariations ( ) ) {
GoMove res = getCorrectMove ( next_moves ) ;
if ( res != null )
return res ;
}
return null ;
}
@Override
public boolean onPrepareOptionsMenu ( Menu menu ) {
super . onPrepareOptionsMenu ( menu ) ;
menu . findItem ( R . id . menu_game_pass ) . setVisible ( ! game . isFinished ( ) ) ;
menu . findItem ( R . id . menu_game_results ) . setVisible ( game . isFinished ( ) ) ;
return true ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
this . getMenuInflater ( ) . inflate ( R . menu . ingame_record , menu ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
@Override
public void onGoGameChange ( ) {
this . invalidateOptionsMenu ( ) ;
}
public Fragment getGameExtraFragment ( ) {
return new RecordingGameExtrasFragment ( ) ;
}
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . gobandroid_hd . R ;
import android . app . Activity ;
import android . content . Context ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . ArrayAdapter ;
import android . widget . ImageView ;
import android . widget . TextView ;
public class IconicAdapter extends ArrayAdapter < Object > {
private Activity context ;
private Object [ ] items ;
public IconicAdapter ( Activity context , Object [ ] items ) {
super ( context , R . layout . icon_and_text , items ) ;
this . items = items ;
this . context = context ;
}
public View getView ( int position , View convertView , ViewGroup parent ) {
LayoutInflater vi = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ;
View row = vi . inflate ( R . layout . icon_and_text , null ) ;
TextView label = ( TextView ) row . findViewById ( R . id . TextView01 ) ;
IconicMenuItem item = ( IconicMenuItem ) items [ position ] ;
if ( item . label != null )
label . setText ( item . label ) ;
else
label . setText ( item . label_resId ) ;
if ( ( items . length > position ) && ( item . drawable !=  <num> ) ) {
ImageView icon = ( ImageView ) row . findViewById ( R . id . ImageView01 ) ;
icon . setImageResource ( item . drawable ) ;
}
return ( row ) ;
}
}
package org . ligi . gobandroid_hd . ui ;
import java . io . File ;
import java . io . IOException ;
import org . ligi . android . common . dialogs . DialogDiscarder ;
import org . ligi . android . common . files . FileHelper ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . logic . SGFHelper ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . gobandroid_hd . ui . tsumego . TsumegoActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . app . AlertDialog ;
import android . os . AsyncTask ;
import android . view . View ;
import android . widget . TextView ;
public class AutoScreenShotTask extends AsyncTask < String , String , Integer > {
private GobandroidFragmentActivity activity ;
private AlertDialog progress_dialog ;
GoBoardViewHD gbv ;
public AutoScreenShotTask ( GobandroidFragmentActivity activity ) {
this . activity = activity ;
}
protected void onPostExecute ( Integer result ) {
progress_dialog . dismiss ( ) ;
String msg = " ;
if ( result > <num> )
msg = " + result + " ;
new AlertDialog . Builder ( activity ) . setMessage ( msg )
. setTitle ( R . string . <unk> )
. setPositiveButton ( android . R . string . ok , new DialogDiscarder ( ) ) . show ( ) ;
}
protected void onProgressUpdate ( String . . . progress ) {
progress_dialog . setMessage ( progress [ <num> ] ) ;
gbv . invalidate ( ) ;
}
@Override
protected void onPreExecute ( ) {
View v = activity . getLayoutInflater ( ) . inflate ( R . layout . <unk> , null ) ;
gbv = ( GoBoardViewHD ) v . findViewById ( R . id . <unk> ) ;
gbv . setBackgroundResource ( R . drawable . <unk> ) ;
gbv . grid_embos = false ;
gbv . do_legend = false ;
gbv . do_line_highlight = false ;
TextView descr_tv = ( TextView ) v . findViewById ( R . id . desc ) ;
descr_tv . setText ( R . string . <unk> ) ;
progress_dialog = new AlertDialog . Builder ( activity ) . setView ( v ) . show ( ) ;
super . onPreExecute ( ) ;
}
@Override
protected Integer doInBackground ( String . . . params ) {
processPath ( params [ <num> ] ) ;
return <num> ;
}
public void processPath ( String path ) {
Log . i ( " + path ) ;
File dir = new File ( path ) ;
File [ ] files = dir . listFiles ( ) ;
Log . i ( " + ( dir == null ) + " + ( files == null ) ) ;
if ( files != null ) for ( File file : files ) {
if ( file != null ) {
if ( file . isDirectory ( ) ) {
processPath ( file . getPath ( ) ) ;
} else if ( file . getName ( ) . endsWith ( " ) ) {
try {
String sgf_content = FileHelper . file2String ( file ) ;
if ( ( sgf_content != null ) && ( ! sgf_content . equals ( " ) ) ) {
GoGameProvider . setGame ( SGFHelper . sgf2game ( FileHelper . file2String ( file ) , null ) ) ;
if ( file . getPath ( ) . contains ( " ) ) {
gbv . setZoom ( TsumegoActivity . calcZoom ( GoGameProvider . getGame ( ) ) ) ;
gbv . setZoomPOI ( TsumegoActivity . calcPOI ( GoGameProvider . getGame ( ) ) ) ;
} else {
for ( int i = <num> ; i < <num> ; i ++ )
try {
GoGameProvider . getGame ( ) . jump ( GoGameProvider . getGame ( ) . getActMove ( ) . getnextMove ( <num> ) ) ;
} catch ( Exception e ) { }
}
Log . i ( " + file . getName ( ) ) ;
gbv . screenshot ( file . getPath ( ) + " ) ;
this . publishProgress ( " ) ;
}
}
catch ( IOException e ) {
Log . w ( " ) ;
}
}
}
}
}
package org . ligi . gobandroid_hd . ui ;
import java . io . File ;
import java . net . URLEncoder ;
import java . util . Vector ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import android . content . Intent ;
import android . net . Uri ;
import android . os . Bundle ;
public class GobanDroidTVActivity extends GobandroidFragmentActivity {
private Vector < String > avail_file_list ;
private File path_to_play_from ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
GoInteractionProvider . setMode ( GoInteractionProvider . MODE_TELEVIZE ) ;
path_to_play_from = new File ( getSettings ( ) . getReviewPath ( ) + " ) ;
getTracker ( ) . trackPageView ( " ) ;
if ( path_to_play_from . listFiles ( ) == null ) {
getTracker ( ) . trackPageView ( " ) ;
UnzipSGFsDialog . show ( this , new Intent ( this , GobanDroidTVActivity . class ) . addFlags ( Intent . FLAG_ACTIVITY_SINGLE_TOP ) ) ;
} else {
startTV ( ) ;
}
}
private void startTV ( ) {
Intent start_review_intent = new Intent ( this , SGFLoadActivity . class ) ;
avail_file_list = new Vector < String > ( ) ;
String choosen ;
for ( File act : path_to_play_from . listFiles ( ) ) {
if ( act . getAbsolutePath ( ) . endsWith ( " ) )
avail_file_list . add ( act . getAbsolutePath ( ) ) ;
}
choosen = avail_file_list . get ( ( int ) ( Math . random ( ) * avail_file_list . size ( ) ) ) ;
start_review_intent . setData ( Uri . parse ( " + choosen ) ) ;
getTracker ( ) . trackPageView ( " + URLEncoder . encode ( choosen ) ) ;
this . startActivity ( start_review_intent ) ;
finish ( ) ;
}
@Override
protected void onNewIntent ( Intent intent ) {
startTV ( ) ;
super . onNewIntent ( intent ) ;
}
}
package org . ligi . gobandroid_hd . ui ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
public class ZoomGameExtrasFragment extends Fragment {
private GoBoardViewHD board ;
@Override
public View onCreateView ( LayoutInflater inflater , ViewGroup container ,
Bundle savedInstanceState ) {
board = new GoBoardViewHD ( this . getActivity ( ) , false , <num> ) ;
return board ;
}
public GoBoardViewHD getBoard ( ) {
return board ;
}
}
package org . ligi . gobandroid_hd . ui . tsumego . fetch ;
public class TsumegoSource {
public String remote_path , local_path , fname ;
public TsumegoSource ( String local_path , String remote_path , String fname ) {
this . remote_path = remote_path ;
this . local_path = local_path ;
this . fname = fname ;
}
public String getFnameByPos ( int pos ) {
return String . format ( fname , pos ) ;
}
package org . ligi . gobandroid_hd . ui . sgf_listing ;
import java . io . File ;
import java . io . IOException ;
import org . ligi . android . common . files . FileHelper ;
import org . ligi . gobandroid_hd . ui . GoInteractionProvider ;
import org . ligi . gobandroid_hd . ui . SGFLoadActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . content . Intent ;
import android . net . Uri ;
import android . os . Bundle ;
import android . support . v4 . app . ListFragment ;
import android . view . View ;
import android . widget . BaseAdapter ;
import android . widget . ListView ;
public class SGFListFragment extends ListFragment {
private String [ ] menu_items ;
private String dir ;
private BaseAdapter adapter ;
public SGFListFragment ( ) {
}
public SGFListFragment ( String [ ] menu_items , File dir ) {
this . menu_items = menu_items ;
this . dir = dir . getAbsolutePath ( ) ;
}
public void refresh ( ) {
adapter . notifyDataSetChanged ( ) ;
}
@Override
public void onActivityCreated ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
if ( menu_items == null )
menu_items = savedInstanceState . getStringArray ( " ) ;
if ( dir == null )
dir = savedInstanceState . getString ( " ) ;
if ( GoInteractionProvider . getMode ( ) == GoInteractionProvider . MODE_TSUMEGO )
adapter = new TsumegoPathViewAdapter ( this . getActivity ( ) , menu_items , dir ) ;
else if ( GoInteractionProvider . getMode ( ) == GoInteractionProvider . MODE_REVIEW )
adapter = new ReviewPathViewAdapter ( this . getActivity ( ) , menu_items , dir ) ;
this . setListAdapter ( adapter ) ;
this . getListView ( ) . setCacheColorHint ( <num> ) ;
}
@Override
public void onListItemClick ( ListView l , View v , int position , long id ) {
super . onListItemClick ( l , v , position , id ) ;
Intent intent2start = new Intent ( this . getActivity ( ) , SGFLoadActivity . class ) ;
String fname = dir + " + menu_items [ position ] ;
if ( fname . endsWith ( " ) ) {
try {
fname = FileHelper . file2String ( new File ( fname ) ) ;
} catch ( IOException e ) {
Log . w ( " + fname . toString ( ) ) ;
}
}
if ( fname . contains ( " ) ) {
String [ ] arr_content = fname . split ( " ) ;
int move_id = Integer . parseInt ( arr_content [ <num> ] ) ;
fname = arr_content [ <num> ] ;
intent2start . putExtra ( " , move_id ) ;
}
if ( ! fname . endsWith ( " ) ) {
intent2start = new Intent ( this . getActivity ( ) , SGFSDCardListActivity . class ) ;
}
if ( ! fname . contains ( " ) )
fname = " + fname ;
intent2start . setData ( Uri . parse ( fname ) ) ;
startActivity ( intent2start ) ;
}
@Override
public void onSaveInstanceState ( Bundle outState ) {
super . onSaveInstanceState ( outState ) ;
outState . putStringArray ( " , menu_items ) ;
outState . putString ( " , dir ) ;
}
package org . ligi . gobandroid_hd . ui . review ;
import java . io . BufferedWriter ;
import java . io . File ;
import java . io . FileWriter ;
import java . io . IOException ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
import android . content . DialogInterface . OnClickListener ;
import android . widget . EditText ;
public class BookmarkDialog {
public static void show ( final GobandroidFragmentActivity ctx ) {
final EditText fname_edit = new EditText ( ctx ) ;
String fname = GoGameProvider . getGame ( ) . getMetaData ( ) . getFileName ( ) ;
if ( ( fname == null ) || ( fname . equals ( " ) ) )
return ;
String [ ] path_components = fname . split ( " ) ;
String inner_fname = path_components [ path_components . length  <num> ] . replace ( " , " ) ;
fname_edit . setText ( inner_fname ) ;
new AlertDialog . Builder ( ctx ) . setTitle ( R . string . menu_bookmark )
. setMessage ( R . string . <unk> + " + ctx . getSettings ( ) . getBookmarkPath ( ) )
. setView ( fname_edit )
. setPositiveButton ( android . R . string . ok , new OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialog , int which ) {
int move_pos = GoGameProvider . getGame ( ) . getActMove ( ) . getMovePos ( ) ;
File f = new File ( ctx . getSettings ( ) . getBookmarkPath ( ) ) ;
if ( ! f . isDirectory ( ) )
f . mkdirs ( ) ;
try {
f = new File ( ctx . getSettings ( ) . getBookmarkPath ( ) + " + fname_edit . getText ( ) . toString ( ) + " ) ;
f . createNewFile ( ) ;
FileWriter sgf_writer = new FileWriter ( f ) ;
BufferedWriter out = new BufferedWriter ( sgf_writer ) ;
out . write ( GoGameProvider . getGame ( ) . getMetaData ( ) . getFileName ( ) + " + move_pos ) ;
out . close ( ) ;
sgf_writer . close ( ) ;
}
catch ( IOException e ) {
Log . i ( " + e ) ;
}
}
} )
. show ( ) ;
}
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGame . GoGameChangeListener ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . ui . alerts . GameForwardAlert ;
import android . app . Dialog ;
import android . os . Bundle ;
import android . os . Handler ;
import android . support . v4 . app . Fragment ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . view . ViewGroup ;
import android . widget . Button ;
import android . widget . LinearLayout ;
import android . widget . TextView ;
public class NavigationFragment extends Fragment implements GoGameChangeListener {
private Button next_btn , prev_btn , first_btn , last_btn ;
private GoGame game ;
@Override
public View onCreateView ( LayoutInflater inflater , ViewGroup container ,
Bundle savedInstanceState ) {
View res = inflater . inflate ( R . layout . <unk> , container , false ) ;
first_btn = ( Button ) res . findViewById ( R . id . <unk> ) ;
last_btn = ( Button ) res . findViewById ( R . id . <unk> ) ;
next_btn = ( Button ) res . findViewById ( R . id . <unk> ) ;
prev_btn = ( Button ) res . findViewById ( R . id . <unk> ) ;
game = GoGameProvider . getGame ( ) ;
game . addGoGameChangeListener ( this ) ;
first_btn . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
game . jumpFirst ( ) ;
}
} ) ;
last_btn . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
game . jumpLast ( ) ;
}
} ) ;
next_btn . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
gameNavNext ( ) ;
}
} ) ;
prev_btn . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
gameNavPrev ( ) ;
}
} ) ;
updateButtonStates ( ) ;
return res ;
}
private Handler gameChangeHandler = new Handler ( ) ;
@Override
public void onGoGameChange ( ) {
gameChangeHandler . post ( new Runnable ( ) {
@Override
public void run ( ) {
updateButtonStates ( ) ;
}
} ) ;
}
private void updateButtonStates ( ) {
first_btn . setVisibility ( game . canUndo ( ) ? View . VISIBLE : View . INVISIBLE ) ;
prev_btn . setVisibility ( game . canUndo ( ) ? View . VISIBLE : View . INVISIBLE ) ;
next_btn . setVisibility ( game . canRedo ( ) ? View . VISIBLE : View . INVISIBLE ) ;
last_btn . setVisibility ( game . canRedo ( ) ? View . VISIBLE : View . INVISIBLE ) ;
}
@Override
public void onDestroyView ( ) {
game . removeGoGameChangeListener ( this ) ;
super . onDestroyView ( ) ;
}
public void gameNavNext ( ) {
GameForwardAlert . show ( this . getActivity ( ) , game ) ;
}
public void gameNavPrev ( ) {
if ( ! game . canUndo ( ) )
return ;
if ( game . getGoMover ( ) . isMoversMove ( ) )
return ;
game . getGoMover ( ) . paused = true ;
game . undo ( ) ;
if ( game . canUndo ( ) && ( game . getGoMover ( ) . isMoversMove ( ) ) )
game . undo ( ) ;
game . getGoMover ( ) . paused = false ;
}
}
package org . ligi . gobandroid_hd . ui ;
import java . util . regex . Matcher ;
import java . util . regex . Pattern ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGame . GoGameChangeListener ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import android . os . Bundle ;
import android . os . Handler ;
import android . support . v4 . app . Fragment ;
import android . text . util . Linkify ;
import android . text . util . Linkify . TransformFilter ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . TextView ;
public class NavigationAndCommentFragment extends Fragment implements GoGameChangeListener {
private TextView myTextView ;
private GoGame game ;
@Override
public View onCreateView ( LayoutInflater inflater , ViewGroup container ,
Bundle savedInstanceState ) {
View res = inflater . inflate ( R . layout . game_extra_review , container , false ) ;
myTextView = ( TextView ) res . findViewById ( R . id . comments_textview ) ;
game = GoGameProvider . getGame ( ) ;
game . addGoGameChangeListener ( this ) ;
getFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . <unk> , new NavigationFragment ( ) ) . commit ( ) ;
onGoGameChange ( ) ;
return res ;
}
@Override
public void onGoGameChange ( ) {
gameChangeHandler . post ( new Runnable ( ) {
@Override
public void run ( ) {
if ( myTextView != null ) {
myTextView . setText ( game . getActMove ( ) . getComment ( ) ) ;
Linkify . addLinks ( myTextView , Linkify . ALL ) ;
TransformFilter mentionFilter = new TransformFilter ( ) {
public final String transformUrl ( final Matcher match , String url ) {
return match . group ( <num> ) . toLowerCase ( ) ;
}
} ;
for ( String key : GoTermsViewActivity . getTerm2resHashMap ( ) . keySet ( ) ) {
Pattern wikiWordMatcher = Pattern . compile ( " + key + " , Pattern . CASE_INSENSITIVE ) ;
String wikiViewURL = " ;
Linkify . addLinks ( myTextView , wikiWordMatcher , wikiViewURL , null , mentionFilter ) ;
}
}
}
} ) ;
}
private Handler gameChangeHandler = new Handler ( ) ;
@Override
public void onDestroyView ( ) {
game . removeGoGameChangeListener ( this ) ;
super . onDestroyView ( ) ;
}
}
package org . ligi . gobandroid_hd . ui . sgf_listing ;
import java . io . File ;
import java . util . Vector ;
import java . util . Arrays ;
import org . ligi . android . common . <unk> . ActivityFinishOnCancelListener ;
import org . ligi . android . common . dialogs . ActivityFinishOnDialogClickListener ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . ui . GoInteractionProvider ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . gobandroid_hd . ui . tsumego . fetch . DownloadProblemsDialog ;
import android . app . AlertDialog ;
import android . os . Bundle ;
import android . support . v4 . view . Menu ;
import android . support . v4 . view . MenuItem ;
public class SGFSDCardListActivity extends GobandroidFragmentActivity {
private String [ ] menu_items ;
private File [ ] files ;
private File dir ;
private SGFListFragment list_fragment ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . list ) ;
String sgf_path = getSettings ( ) . getSGFBasePath ( ) ;
if ( this . getIntent ( ) . getData ( ) != null )
dir = new File ( this . getIntent ( ) . getData ( ) . getPath ( ) ) ;
else
dir = new File ( sgf_path ) ;
AlertDialog . Builder alert = new AlertDialog . Builder ( this ) . setTitle ( R . string . <unk> ) ;
alert . setPositiveButton ( R . string . ok , new ActivityFinishOnDialogClickListener ( this ) ) ;
alert . setOnCancelListener ( new ActivityFinishOnCancelListener ( this ) ) ;
if ( dir == null ) {
alert . setMessage ( getResources ( ) . getString ( R . string . <unk> ) + " + sgf_path ) . show ( ) ;
return ;
}
files = dir . listFiles ( ) ;
if ( files == null ) {
alert . setMessage ( getResources ( ) . getString ( R . string . there_are_no_files_in ) + " + dir . getAbsolutePath ( ) ) . show ( ) ;
return ;
}
Vector < String > fnames = new Vector < String > ( ) ;
for ( File file : files )
if ( ( file . getName ( ) . endsWith ( " ) ) || ( file . isDirectory ( ) ) || ( file . getName ( ) . endsWith ( " ) ) ) {
fnames . add ( file . getName ( ) ) ;
}
if ( fnames . size ( ) == <num> ) {
alert . setMessage ( getResources ( ) . getString ( R . string . there_are_no_files_in ) + " + dir . getAbsolutePath ( ) ) . show ( ) ;
return ;
}
this . getSupportActionBar ( ) . setSubtitle ( dir . getAbsolutePath ( ) ) ;
if ( GoInteractionProvider . getMode ( ) == GoInteractionProvider . MODE_TSUMEGO )
this . setTitle ( R . string . <unk> ) ;
else if ( GoInteractionProvider . getMode ( ) == GoInteractionProvider . MODE_REVIEW )
this . setTitle ( R . string . <unk> ) ;
menu_items = ( String [ ] ) fnames . toArray ( new String [ fnames . size ( ) ] ) ;
Arrays . sort ( menu_items ) ;
list_fragment = new SGFListFragment ( menu_items , dir ) ;
this . getSupportFragmentManager ( ) . beginTransaction ( ) . add ( R . id . list_fragment , list_fragment ) . commit ( ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
if ( GoInteractionProvider . getMode ( ) == GoInteractionProvider . MODE_TSUMEGO )
this . getMenuInflater ( ) . inflate ( R . menu . <unk> , menu ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case R . id . menu_refresh :
DownloadProblemsDialog . show ( this ) ;
return true ;
}
return super . onOptionsItemSelected ( item ) ;
}
@Override
protected void onResume ( ) {
if ( list_fragment != null )
list_fragment . refresh ( ) ;
super . onResume ( ) ;
}
}
package org . ligi . gobandroid_hd . ui ;
import java . util . Vector ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . tracedroid . logging . Log ;
import android . app . AlertDialog ;
import android . app . Dialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . view . Gravity ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . ImageButton ;
import android . widget . LinearLayout ;
import android . widget . FrameLayout ;
import android . widget . ScrollView ;
import android . widget . TextView ;
import android . widget . FrameLayout . LayoutParams ;
public class GoBoardOverlay implements OnClickListener {
private TextView comment_tv ;
private ScrollView comment_sv ;
private LinearLayout outer_lin ;
public ImageButton next , back , first , last , comments ;
private LinearLayout button_container ;
private Context context ;
private GoBoardView board_view ;
public GoBoardOverlay ( Context context , GoBoardView board_view , boolean horizontal ) {
this . context = context ;
this . board_view = board_view ;
comment_tv = new TextView ( context ) ;
comment_tv . setTextColor ( <num> ) ;
comment_tv . setPadding ( <num> , <num> , <num> , <num> ) ;
comment_tv . setText ( " ) ;
comment_tv . setBackgroundColor ( <num> ) ;
comment_sv = new ScrollView ( context ) ;
comment_sv . addView ( comment_tv ) ;
Vector < ImageButton > control_buttons = new Vector < ImageButton > ( ) ;
first = new ImageButton ( context ) ;
first . setImageResource ( android . R . drawable . <unk> ) ;
control_buttons . add ( first ) ;
first . setOnClickListener ( this ) ;
back = new ImageButton ( context ) ;
back . setImageResource ( android . R . drawable . <unk> ) ;
control_buttons . add ( back ) ;
back . setOnClickListener ( this ) ;
comments = new ImageButton ( context ) ;
comments . setImageResource ( android . R . drawable . <unk> ) ;
control_buttons . add ( comments ) ;
comments . setOnClickListener ( this ) ;
next = new ImageButton ( context ) ;
next . setImageResource ( android . R . drawable . <unk> ) ;
control_buttons . add ( next ) ;
next . setOnClickListener ( this ) ;
last = new ImageButton ( context ) ;
last . setImageResource ( android . R . drawable . <unk> ) ;
last . setOnClickListener ( this ) ;
control_buttons . add ( last ) ;
outer_lin = new LinearLayout ( context ) ;
button_container = new LinearLayout ( context ) ;
for ( ImageButton btn : control_buttons ) {
btn . setLayoutParams ( new LinearLayout . LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT , <num> ) ) ;
button_container . addView ( btn ) ;
}
if ( horizontal ) {
button_container . setOrientation ( LinearLayout . VERTICAL ) ;
button_container . setLayoutParams ( new LinearLayout . LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . FILL_PARENT ) ) ;
FrameLayout . LayoutParams bottom_nav_params = new FrameLayout . LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . FILL_PARENT ) ;
bottom_nav_params . gravity = Gravity . RIGHT ;
outer_lin . setOrientation ( LinearLayout . HORIZONTAL ) ;
outer_lin . setLayoutParams ( bottom_nav_params ) ;
}
else {
button_container . setOrientation ( LinearLayout . HORIZONTAL ) ;
button_container . setLayoutParams ( new LinearLayout . LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . WRAP_CONTENT ) ) ;
FrameLayout . LayoutParams bottom_nav_params = new FrameLayout . LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . WRAP_CONTENT ) ;
bottom_nav_params . gravity = Gravity . BOTTOM | Gravity . CENTER_HORIZONTAL ;
outer_lin . setLayoutParams ( bottom_nav_params ) ;
outer_lin . setOrientation ( LinearLayout . VERTICAL ) ;
}
comment_sv . setVisibility ( View . VISIBLE ) ;
outer_lin . addView ( comment_sv ) ;
outer_lin . addView ( button_container ) ;
updateButtonState ( ) ;
updateCommentText ( ) ;
}
private String getGameComment ( ) {
if ( GoGameProvider . getGame ( ) == null )
return " ;
else
return GoGameProvider . getGame ( ) . getActMove ( ) . getComment ( ) ;
}
public void <unk> ( int w , int h , boolean horizontal ) {
Log . i ( " + w + " + h + " + ( horizontal ? " : " ) + " + back . getHeight ( ) ) ;
if ( horizontal )
comment_tv . setWidth ( w  h  <num>  back . getWidth ( ) ) ;
else
comment_sv . setLayoutParams ( new LinearLayout . LayoutParams ( w , h  w  back . getHeight ( ) ) ) ;
comment_sv . requestLayout ( ) ;
}
public void updateCommentText ( ) {
Log . i ( " + getGameComment ( ) + " ) ;
comment_tv . setText ( getGameComment ( ) ) ;
comment_tv . requestLayout ( ) ;
}
public View getView ( ) {
return outer_lin ;
}
@Override
public void onClick ( View btn ) {
final GoGame game = GoGameProvider . getGame ( ) ;
if ( btn == back ) {
if ( game . getGoMover ( ) . isMoversMove ( ) )
return ;
game . getGoMover ( ) . paused = true ;
game . undo ( ) ;
if ( game . canUndo ( ) && ( game . getGoMover ( ) . isMoversMove ( ) ) )
game . undo ( ) ;
game . getGoMover ( ) . paused = false ;
}
else if ( btn == next ) {
if ( game . getPossibleVariationCount ( ) > <num> ) {
LinearLayout lin = new LinearLayout ( context ) ;
LinearLayout li = new LinearLayout ( context ) ;
TextView txt = new TextView ( context ) ;
if ( game . getActMove ( ) . hasComment ( ) )
txt . setText ( game . getActMove ( ) . getComment ( ) ) ;
else
txt . setText ( " + ( game . getPossibleVariationCount ( ) + <num> ) + " ) ;
txt . setPadding ( <num> , <num> , <num> , <num> ) ;
lin . addView ( txt ) ;
lin . addView ( li ) ;
lin . setOrientation ( LinearLayout . VERTICAL ) ;
final Dialog select_dlg = new Dialog ( context ) ;
final Boolean redoing = false ;
View . OnClickListener var_select_listener = new View . OnClickListener ( ) {
@Override
public void onClick ( View v ) {
if ( redoing )
return ;
select_dlg . hide ( ) ;
if ( ! v . isEnabled ( ) ) return ;
v . setEnabled ( false ) ;
game . redo ( ( Integer ) ( v . getTag ( ) ) ) ;
updateButtonState ( ) ;
board_view . invalidate ( ) ;
}
} ;
li . setWeightSum ( <num> * ( game . getPossibleVariationCount ( ) + <num> ) ) ;
li . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . FILL_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ) ;
for ( Integer i = <num> ; i < game . getPossibleVariationCount ( ) + <num> ; i ++ )
{
Button var_btn = new Button ( context ) ;
var_btn . setTag ( i ) ;
var_btn . setOnClickListener ( var_select_listener ) ;
if ( game . getActMove ( ) . getnextMove ( i ) . isMarked ( ) )
var_btn . setText ( game . getActMove ( ) . getnextMove ( i ) . getMarkText ( ) ) ;
else
var_btn . setText ( " + ( i + <num> ) ) ;
li . addView ( var_btn ) ;
var_btn . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT , <num> ) ) ;
}
select_dlg . setTitle ( R . string . variations ) ;
select_dlg . setContentView ( lin ) ;
select_dlg . show ( ) ;
}
else
game . redo ( <num> ) ;
}
else if ( btn == first )
game . jumpFirst ( ) ;
else if ( btn == last )
game . jumpLast ( ) ;
else if ( btn == comments ) {
new AlertDialog . Builder ( context ) . setTitle ( R . string . comments )
. setMessage ( getGameComment ( ) )
. setPositiveButton ( R . string . ok , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) { }
} )
. setNeutralButton ( " , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
final EditText comment_edit = new EditText ( context ) ;
comment_edit . setText ( getGameComment ( ) ) ;
new AlertDialog . Builder ( context ) . setTitle ( R . string . comments )
. setView ( comment_edit )
. setPositiveButton ( R . string . ok , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
game . getActMove ( ) . setComment ( comment_edit . getText ( ) . toString ( ) ) ;
updateCommentText ( ) ;
}
} )
. setNegativeButton ( R . string . cancel , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) { }
} ) . show ( ) ;
}
} )
. show ( ) ;
}
updateCommentText ( ) ;
updateButtonState ( ) ;
board_view . invalidate ( ) ;
}
public void updateButtonState ( ) {
GoGame game = GoGameProvider . getGame ( ) ;
if ( game == null ) {
Log . w ( " ) ;
return ;
}
back . setEnabled ( game . canUndo ( ) && ( ! game . getGoMover ( ) . isMoversMove ( ) ) ) ;
first . setEnabled ( game . canUndo ( ) && ( ! game . getGoMover ( ) . isPlayingInThisGame ( ) ) ) ;
next . setEnabled ( game . canRedo ( ) && ( ! game . getGoMover ( ) . isPlayingInThisGame ( ) ) ) ;
last . setEnabled ( game . canRedo ( ) && ( ! game . getGoMover ( ) . isPlayingInThisGame ( ) ) ) ;
}
package org . ligi . gobandroid_hd . ui . tsumego . fetch ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
public class DownloadProblemsDialog {
private final static String BASE_URL = " ;
public static void show ( GobandroidFragmentActivity activity ) {
activity . getTracker ( ) . trackPageView ( " ) ;
new DownloadTask ( activity ) . execute (
new TsumegoSource ( activity . getSettings ( ) . getTsumegoPath ( ) + " , BASE_URL , " ) ,
new TsumegoSource ( activity . getSettings ( ) . getTsumegoPath ( ) + " , BASE_URL , " ) ,
new TsumegoSource ( activity . getSettings ( ) . getTsumegoPath ( ) + " , BASE_URL , " )
) ;
}
}
package org . ligi . gobandroid_hd . logic ;
public class GoGameProvider {
private static GoGame game ;
public static void setGame ( GoGame p_game ) {
game = p_game ;
}
public static GoGame getGame ( ) {
return game ;
}
}
package org . ligi . gobandroid_hd . logic ;
public class GoGameMetadata {
private String name = " ;
private String result = " ;
private String source = " ;
private String filename = " ;
private String black_name = " ;
private String black_rank = " ;
private String white_name = " ;
private String white_rank = " ;
public void setName ( String name ) {
this . name = name ;
}
public String getName ( ) {
return name ;
}
public void setWhiteRank ( String white_rank ) {
this . white_rank = white_rank ;
}
public String getWhiteRank ( ) {
return white_rank ;
}
public void setWhiteName ( String white_name ) {
this . white_name = white_name ;
}
public String getWhiteName ( ) {
return white_name ;
}
public void setBlackName ( String black_name ) {
this . black_name = black_name ;
}
public String getBlackName ( ) {
return black_name ;
}
public void setBlackRank ( String black_rank ) {
this . black_rank = black_rank ;
}
public String getBlackRank ( ) {
return black_rank ;
}
public void setResult ( String result ) {
this . result = result ;
}
public String getResult ( ) {
return result ;
}
public String getSource ( ) {
return source ;
}
public void setSource ( String source ) {
this . source = source ;
}
public String getFileName ( ) {
return filename ;
}
public void setFileName ( String filename ) {
this . filename = filename ;
}
package org . ligi . gobandroid_hd . ui ;
import java . io . BufferedWriter ;
import java . io . File ;
import java . io . FileWriter ;
import java . io . IOException ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . logic . SGFHelper ;
import org . ligi . gobandroid_hd . ui . alerts . GameInfoAlert ;
import org . ligi . gobandroid_hd . ui . alerts . GameResultsAlert ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . gobandroid_hd . ui . ingame_common . SwitchModeHelper ;
import org . ligi . gobandroid_hd . ui . recording . SaveSGFDialog ;
import org . ligi . tracedroid . logging . Log ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . support . v4 . app . FragmentTransaction ;
import android . support . v4 . view . Menu ;
import android . support . v4 . view . MenuItem ;
import android . view . KeyEvent ;
import android . view . MotionEvent ;
import android . view . View ;
import android . view . View . OnKeyListener ;
import android . view . View . OnTouchListener ;
import android . view . WindowManager ;
import android . widget . Toast ;
public class GoActivity
extends GobandroidFragmentActivity implements OnTouchListener , OnKeyListener {
private GoBoardViewHD go_board = null ;
public GoGame game ;
private Toast info_toast = null ;
private ZoomGameExtrasFragment myZoomFragment ;
private Fragment actFragment ;
public GoSoundManager sound_man ;
public Fragment getGameExtraFragment ( ) {
return new DefaultGameExtrasFragment ( ) ;
}
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
if ( getSettings ( ) . isWakeLockEnabled ( ) ) {
getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_KEEP_SCREEN_ON ) ;
}
game = GoGameProvider . getGame ( ) ;
if ( game == null ) {
finish ( ) ;
return ;
}
if ( sound_man == null )
sound_man = new GoSoundManager ( this ) ;
View customNav = new InGameActionBarView ( this ) ;
FragmentTransaction fragmentTransAction = this . getSupportFragmentManager ( ) . beginTransaction ( ) ;
fragmentTransAction . add ( R . id . game_extra_container , getGameExtraFragment ( ) ) . commit ( ) ;
this . setContentView ( R . layout . game ) ;
getSupportActionBar ( ) . <unk> ( customNav ) ;
getSupportActionBar ( ) . <unk> ( true ) ;
customNav . setFocusable ( false ) ;
info_toast = Toast . makeText ( this . getBaseContext ( ) , " , Toast . LENGTH_LONG ) ;
setupBoard ( ) ;
game2ui ( ) ;
}
private void setupBoard ( ) {
go_board = ( GoBoardViewHD ) findViewById ( R . id . go_board ) ;
go_board . setOnTouchListener ( this ) ;
go_board . setOnKeyListener ( this ) ;
go_board . do_legend = getSettings ( ) . isLegendEnabled ( ) ;
go_board . legend_sgf_mode = getSettings ( ) . isSGFLegendEnabled ( ) ;
go_board . grid_embos = getSettings ( ) . isGridEmbossEnabled ( ) ;
game . addGoGameChangeListener ( new GoGame . GoGameChangeListener ( ) {
@Override
public void onGoGameChange ( ) {
game2ui ( ) ;
}
} ) ;
}
@Override
protected void onResume ( ) {
super . onResume ( ) ;
sound_man . playGameIntro ( ) ;
Log . i ( " ) ;
myZoomFragment = new ZoomGameExtrasFragment ( ) ;
}
@Override
public boolean doFullScreen ( ) {
return getSettings ( ) . isFullscreenEnabled ( ) | getResources ( ) . getBoolean ( R . bool . force_fullscreen ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
this . getMenuInflater ( ) . inflate ( R . menu . ingame_common , menu ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case R . id . <unk> :
SwitchModeHelper . show ( this ) ;
break ;
case R . id . <unk> :
GameInfoAlert . show ( this , game ) ;
getBoard ( ) . screenshot ( game . getMetaData ( ) . getFileName ( ) + " ) ;
break ;
case R . id . <unk> :
if ( ! game . canUndo ( ) )
break ;
requestUndo ( ) ;
break ;
case R . id . menu_game_pass :
game . pass ( ) ;
game . notifyGameChange ( ) ;
break ;
case R . id . menu_game_results :
GameResultsAlert . show ( this , game ) ;
break ;
case R . id . <unk> :
SaveSGFDialog . show ( this ) ;
break ;
}
return false ;
}
public boolean isAsk4QuitEnabled ( ) {
return true ;
}
public void shutdown ( ) {
sound_man . playSound ( GoSoundManager . SOUND_END ) ;
game . getGoMover ( ) . stop ( ) ;
finish ( ) ;
}
public void ask4quit ( ) {
if ( ! isAsk4QuitEnabled ( ) ) {
shutdown ( ) ;
return ;
}
new AlertDialog . Builder ( this ) . setTitle ( R . string . <unk> )
. setMessage ( R . string . <unk>
) . setPositiveButton ( R . string . yes , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
shutdown ( ) ;
}
} ) . setCancelable ( true ) . setNegativeButton ( R . string . no , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
}
} ) . show ( ) ;
}
@Override
public boolean onKeyDown ( int keyCode , KeyEvent event ) {
switch ( keyCode ) {
case KeyEvent . KEYCODE_BACK :
ask4quit ( ) ;
return true ;
}
return super . onKeyDown ( keyCode , event ) ;
}
public void showInfoToast ( int resId ) {
info_toast . setText ( resId ) ;
info_toast . show ( ) ;
}
public byte doMoveWithUIFeedback ( byte x , byte y ) {
info_toast . cancel ( ) ;
byte res = game . do_move ( x , y ) ;
switch ( res ) {
case GoGame . MOVE_INVALID_IS_KO :
showInfoToast ( R . string . <unk> ) ;
break ;
case GoGame . MOVE_INVALID_CELL_NO_LIBERTIES :
showInfoToast ( R . string . <unk> ) ;
break ;
}
return res ;
}
public void game2ui ( ) {
go_board . postInvalidate ( ) ;
refreshZoomFragment ( ) ;
}
public void setFragment ( Fragment newFragment ) {
if ( actFragment == newFragment ) {
Log . i ( " ) ;
return ;
}
Log . i ( " + newFragment ) ;
actFragment = newFragment ;
FragmentTransaction fragmentTransAction = this . getSupportFragmentManager ( ) . beginTransaction ( ) ;
fragmentTransAction . replace ( R . id . game_extra_container , actFragment ) . commit ( ) ;
}
public boolean onTouch ( View v , MotionEvent event ) {
if ( event . getAction ( ) == MotionEvent . ACTION_UP ) {
setFragment ( getGameExtraFragment ( ) ) ;
if ( getResources ( ) . getBoolean ( R . bool . small ) )
this . getSupportActionBar ( ) . show ( ) ;
if ( game . isBlackToMove ( ) )
sound_man . playSound ( GoSoundManager . SOUND_PLACE1 ) ;
else
sound_man . playSound ( GoSoundManager . SOUND_PLACE2 ) ;
} else if ( event . getAction ( ) == MotionEvent . ACTION_DOWN )
{
setFragment ( myZoomFragment ) ;
if ( getResources ( ) . getBoolean ( R . bool . small ) )
this . getSupportActionBar ( ) . hide ( ) ;
if ( game . isBlackToMove ( ) )
sound_man . playSound ( GoSoundManager . SOUND_PICKUP1 ) ;
else
sound_man . playSound ( GoSoundManager . SOUND_PICKUP2 ) ;
}
Log . i ( " ) ;
if ( ! game . getGoMover ( ) . isReady ( ) )
showInfoToast ( R . string . <unk> ) ;
else if ( game . getGoMover ( ) . isMoversMove ( ) )
showInfoToast ( R . string . <unk> ) ;
else
doTouch ( event ) ;
return true ;
}
@Override
public void onPause ( ) {
super . onPause ( ) ;
try {
File f = new File ( getSettings ( ) . getReviewPath ( ) + " ) ;
f . createNewFile ( ) ;
FileWriter sgf_writer = new FileWriter ( f ) ;
BufferedWriter out = new BufferedWriter ( sgf_writer ) ;
out . write ( SGFHelper . game2sgf ( game ) ) ;
out . close ( ) ;
sgf_writer . close ( ) ;
} catch ( IOException e ) {
Log . i ( " + e ) ;
}
}
public void doTouch ( MotionEvent event ) {
GoInteractionProvider . setTouchPosition ( getBoard ( ) . pixel2boardPos ( event . getX ( ) , event . getY ( ) ) ) ;
if ( event . getAction ( ) == MotionEvent . ACTION_UP ) {
if ( go_board . move_stone_mode ) {
game . getActMove ( ) . setXY ( ( byte ) GoInteractionProvider . getTouchX ( ) , ( byte ) GoInteractionProvider . getTouchY ( ) ) ;
game . refreshBoards ( ) ;
go_board . move_stone_mode = false ;
}
else if ( ( game . getActMove ( ) . getX ( ) == GoInteractionProvider . getTouchX ( ) ) && ( game . getActMove ( ) . getY ( ) == GoInteractionProvider . getTouchY ( ) ) )
go_board . initializeStoneMove ( ) ;
else
doMoveWithUIFeedback ( ( byte ) GoInteractionProvider . getTouchX ( ) , ( byte ) GoInteractionProvider . getTouchY ( ) ) ;
GoInteractionProvider . setTouchPosition (  <num> ) ;
}
game . notifyGameChange ( ) ;
}
public boolean doAskToKeepVariant ( ) {
return GoPrefs . isAskVariantEnabled ( ) ;
}
@Override
public boolean onKey ( View v , int keyCode , KeyEvent event ) {
Log . i ( " ) ;
if ( event . getAction ( ) == KeyEvent . ACTION_DOWN )
switch ( keyCode ) {
case KeyEvent . KEYCODE_DPAD_UP :
go_board . prepare_keyinput ( ) ;
if ( GoInteractionProvider . getTouchY ( ) > <num> )
GoInteractionProvider . touch_position -= game . getSize ( ) ;
else
return false ;
break ;
case KeyEvent . KEYCODE_DPAD_LEFT :
go_board . prepare_keyinput ( ) ;
if ( GoInteractionProvider . getTouchX ( ) > <num> )
GoInteractionProvider . touch_position  ;
else
return false ;
break ;
case KeyEvent . KEYCODE_DPAD_DOWN :
go_board . prepare_keyinput ( ) ;
if ( GoInteractionProvider . getTouchY ( ) < game . getVisualBoard ( ) . getSize ( )  <num> )
GoInteractionProvider . touch_position += game . getSize ( ) ;
else
return false ;
break ;
case KeyEvent . KEYCODE_DPAD_RIGHT :
go_board . prepare_keyinput ( ) ;
if ( GoInteractionProvider . getTouchX ( ) < game . getVisualBoard ( ) . getSize ( )  <num> )
GoInteractionProvider . touch_position ++ ;
else
return false ;
break ;
case KeyEvent . KEYCODE_DPAD_CENTER :
doMoveWithUIFeedback ( ( byte ) GoInteractionProvider . getTouchX ( ) , ( byte ) GoInteractionProvider . getTouchY ( ) ) ;
break ;
}
go_board . postInvalidate ( ) ;
refreshZoomFragment ( ) ;
return true ;
}
public void refreshZoomFragment ( ) {
if ( myZoomFragment == null )
return ;
if ( myZoomFragment . getBoard ( ) != null )
myZoomFragment . getBoard ( ) . postInvalidate ( ) ;
}
public GoBoardViewHD getBoard ( ) {
return go_board ;
}
public void requestUndo ( ) {
if ( doAskToKeepVariant ( ) ) {
new AlertDialog . Builder ( this ) . setTitle ( R . string . <unk> ) . setMessage ( R . string . <unk> )
. setPositiveButton ( R . string . yes , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
game . undo ( true ) ;
}
} ) . setNegativeButton ( R . string . no , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
game . undo ( false ) ;
}
} ) . show ( ) ;
}
else
game . undo ( GoPrefs . isKeepVariantEnabled ( ) ) ;
}
@Override
public void onBackPressed ( ) {
super . onBackPressed ( ) ;
}
package org . ligi . gobandroid_hd . ui . tsumego ;
import java . util . Vector ;
import org . ligi . android . common . dialogs . ActivityFinishOnDialogClickListener ;
import org . ligi . android . common . dialogs . DialogDiscarder ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGame . GoGameChangeListener ;
import org . ligi . gobandroid_hd . logic . GoMove ;
import org . ligi . gobandroid_hd . ui . GoActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . support . v4 . view . Menu ;
import android . support . v4 . view . MenuItem ;
public class TsumegoActivity extends GoActivity implements GoGameChangeListener {
private GoMove finishing_move ;
private TsumegoGameExtrasFragment myTsumegoExtrasFragment ;
private Vector < GoMove > on_path_moves ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . setTitle ( R . string . tsumego ) ;
on_path_moves = new Vector < GoMove > ( ) ;
recursive_add_on_path_moves ( game . getFirstMove ( ) ) ;
if ( ! isFinishingMoveKnown ( ) )
new AlertDialog . Builder ( this ) . setMessage ( R . string . <unk> )
. setNegativeButton ( " , new DialogDiscarder ( ) )
. setPositiveButton ( " , new ActivityFinishOnDialogClickListener ( this ) )
. show ( ) ;
game . addGoGameChangeListener ( this ) ;
float myZoom = calcZoom ( game ) ;
getBoard ( ) . setZoom ( myZoom ) ;
int poi = game . getSize ( )  ( int ) ( game . getSize ( ) / <num> / myZoom ) ;
getBoard ( ) . setZoomPOI ( poi + poi * game . getSize ( ) ) ;
}
private GoMove getFinishingMove ( ) {
if ( finishing_move == null )
finishing_move = getCorrectMove ( game . getFirstMove ( ) ) ;
return finishing_move ;
}
private boolean isFinishingMoveKnown ( ) {
return getFinishingMove ( ) != null ;
}
public static int calcPOI ( GoGame game ) {
int poi = game . getSize ( )  ( int ) ( game . getSize ( ) / <num> / calcZoom ( game ) ) ;
return poi + poi * game . getSize ( ) ;
}
public static float calcZoom ( GoGame game ) {
int min_x = game . getSize ( ) ;
int min_y = game . getSize ( ) ;
for ( int x = <num> ; x < game . getSize ( ) ; x ++ )
for ( int y = <num> ; y < game . getSize ( ) ; y ++ ) {
if ( ( x < min_x ) && ! game . getHandicapBoard ( ) . isCellFree ( x , y ) )
min_x = x ;
if ( ( y < min_y ) && ! game . getHandicapBoard ( ) . isCellFree ( x , y ) )
min_y = y ;
}
int max_span_size = Math . max ( game . getSize ( )  min_x , game . getSize ( )  min_y ) ;
float res = ( float ) game . getSize ( ) / ( max_span_size + <num> ) ;
if ( res < <num> )
return <num> ;
else
return res ;
}
private void recursive_add_on_path_moves ( GoMove act ) {
on_path_moves . add ( act ) ;
if ( act . hasNextMove ( ) )
for ( GoMove child : act . getNextMoveVariations ( ) )
recursive_add_on_path_moves ( child ) ;
}
@Override
protected void onDestroy ( ) {
game . removeGoGameChangeListener ( this ) ;
super . onDestroy ( ) ;
}
public boolean isOnPath ( ) {
return on_path_moves . contains ( game . getActMove ( ) ) ;
}
public byte doMoveWithUIFeedback ( byte x , byte y ) {
byte res = super . doMoveWithUIFeedback ( x , y ) ;
if ( res == GoGame . MOVE_VALID )
if ( game . getActMove ( ) . hasNextMove ( ) )
game . jump ( game . getActMove ( ) . getnextMove ( <num> ) ) ;
game . notifyGameChange ( ) ;
return res ;
}
public GoMove getCorrectMove ( GoMove act_mve ) {
if ( act_mve . getComment ( ) . equals ( " ) )
return act_mve ;
for ( GoMove next_moves : act_mve . getNextMoveVariations ( ) ) {
GoMove res = getCorrectMove ( next_moves ) ;
if ( res != null )
return res ;
}
return null ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
this . getMenuInflater ( ) . inflate ( R . menu . <unk> , menu ) ;
menu . findItem ( R . id . menu_game_hint ) . setVisible ( isFinishingMoveKnown ( ) ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
public boolean onOptionsItemSelected ( MenuItem item ) {
if ( ! super . onOptionsItemSelected ( item ) )
switch ( item . getItemId ( ) ) {
case R . id . menu_game_hint :
TsumegoHintAlert . show ( this , getFinishingMove ( ) ) ;
break ;
}
return false ;
}
@Override
public void requestUndo ( ) {
game . undo ( isOnPath ( ) ) ;
if ( ! game . isBlackToMove ( ) )
game . undo ( isOnPath ( ) ) ;
}
@Override
public Fragment getGameExtraFragment ( ) {
myTsumegoExtrasFragment = new TsumegoGameExtrasFragment ( ) ;
return myTsumegoExtrasFragment ;
}
@Override
public void onGoGameChange ( ) {
if ( myTsumegoExtrasFragment != null ) {
myTsumegoExtrasFragment . setOffPathVisibility ( ! isOnPath ( ) ) ;
myTsumegoExtrasFragment . setCorrectVisibility ( game . getActMove ( ) . equals ( getFinishingMove ( ) ) ) ;
}
if ( game . getActMove ( ) . equals ( getFinishingMove ( ) ) ) {
this . getBaseContext ( ) . getSharedPreferences ( " , Activity . MODE_PRIVATE )
. edit ( ) . putInt ( game . getMetaData ( ) . getFileName ( ) , <num> ) . commit ( ) ;
Log . i ( " + game . getMetaData ( ) . getFileName ( ) ) ;
}
}
@Override
public boolean isAsk4QuitEnabled ( ) {
return false ;
}
}
package org . ligi . gobandroid_hd . ui . application ;
import android . content . Context ;
import android . content . SharedPreferences ;
import android . os . Environment ;
import android . preference . PreferenceManager ;
public class GobandroidSettings {
public final static String KEY_FULLSCREEN = " ;
public final static String KEY_SOUND = " ;
public final static String KEY_DO_LEGEND = " ;
public final static String KEY_SGF_LEGEND = " ;
public static final String KEY_WAKE_LOCK = " ;
public static final String KEY_GRID_EMBOSS = " ;
private Context ctx ;
public GobandroidSettings ( Context ctx ) {
this . ctx = ctx ;
}
public SharedPreferences getPreferences ( ) {
return PreferenceManager . getDefaultSharedPreferences ( ctx ) ;
}
public String getSGFBasePath ( ) {
return Environment . getExternalStorageDirectory ( ) + " ;
}
public String getTsumegoPath ( ) {
return getSGFBasePath ( ) + " ;
}
public String getBookmarkPath ( ) {
return getReviewPath ( ) + " ;
}
public String getReviewPath ( ) {
return getSGFBasePath ( ) + " ;
}
public String getSGFSavePath ( ) {
return getSGFBasePath ( ) + " ;
}
public boolean isFullscreenEnabled ( ) {
return getPreferences ( ) . getBoolean ( KEY_FULLSCREEN , false ) ;
}
public boolean isSoundEnabled ( ) {
return getPreferences ( ) . getBoolean ( KEY_SOUND , false ) ;
}
public boolean isLegendEnabled ( ) {
return getPreferences ( ) . getBoolean ( KEY_DO_LEGEND , false ) ;
}
public boolean isSGFLegendEnabled ( ) {
return getPreferences ( ) . getBoolean ( KEY_SGF_LEGEND , false ) ;
}
public boolean isWakeLockEnabled ( ) {
return getPreferences ( ) . getBoolean ( KEY_WAKE_LOCK , true ) ;
}
public boolean isGridEmbossEnabled ( ) {
return getPreferences ( ) . getBoolean ( KEY_GRID_EMBOSS , true ) ;
}
package org . ligi . gobandroid_hd . ui . tsumego . fetch ;
import java . io . BufferedInputStream ;
import java . io . File ;
import java . io . FileOutputStream ;
import java . net . URL ;
import java . net . URLConnection ;
import org . apache . http . util . ByteArrayBuffer ;
import org . ligi . android . common . dialogs . DialogDiscarder ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . app . AlertDialog ;
import android . app . ProgressDialog ;
import android . os . AsyncTask ;
public class DownloadTask extends AsyncTask < TsumegoSource , String , Integer > {
private final static int LIMITER = <num> ;
private GobandroidFragmentActivity activity ;
private ProgressDialog progress_dialog ;
public DownloadTask ( GobandroidFragmentActivity activity ) {
this . activity = activity ;
}
@Override
protected void onPreExecute ( ) {
progress_dialog = ProgressDialog . show ( activity , " , " , true ) ;
super . onPreExecute ( ) ;
}
@Override
protected Integer doInBackground ( TsumegoSource . . . params ) {
int download_count = <num> ;
for ( TsumegoSource src : params ) {
boolean finished = false ;
int pos = <num> ;
while ( ! finished ) {
while ( new File ( src . local_path + src . getFnameByPos ( pos ) ) . exists ( ) ) {
this . publishProgress ( " + src . getFnameByPos ( pos ) ) ;
pos ++ ;
}
if ( pos >= LIMITER ) {
finished = true ;
}
else try {
URL url = new URL ( src . remote_path + src . getFnameByPos ( pos ) ) ;
URLConnection ucon = url . openConnection ( ) ;
BufferedInputStream bis = new BufferedInputStream ( ucon . getInputStream ( ) ) ;
ByteArrayBuffer baf = new ByteArrayBuffer ( <num> ) ;
int current = <num> ;
while ( ( current = bis . read ( ) ) !=  <num> )
baf . append ( ( byte ) current ) ;
FileOutputStream fos = new FileOutputStream ( new File ( src . local_path + src . getFnameByPos ( pos ) ) ) ;
fos . write ( baf . toByteArray ( ) ) ;
fos . close ( ) ;
download_count ++ ;
} catch ( Exception e ) { Log . i ( " , e ) ; finished = true ; }
}
try {
Thread . sleep ( <num> ) ;
} catch ( InterruptedException e ) { }
}
return download_count ;
}
@Override
protected void onProgressUpdate ( String . . . progress ) {
progress_dialog . setMessage ( progress [ <num> ] ) ;
}
@Override
protected void onPostExecute ( Integer result ) {
progress_dialog . dismiss ( ) ;
String msg = " ;
if ( result > <num> )
msg = " + result + " ;
new AlertDialog . Builder ( activity ) . setMessage ( msg )
. setTitle ( " )
. setPositiveButton ( " , new DialogDiscarder ( ) ) . show ( ) ;
}
package com . google . android . apps . <unk> . ui . widget ;
import android . content . Context ;
import android . util . AttributeSet ;
import android . view . View ;
import android . view . ViewGroup ;
public class DashboardLayout extends ViewGroup {
private static final int UNEVEN_GRID_PENALTY_MULTIPLIER = <num> ;
private int mMaxChildWidth = <num> ;
private int mMaxChildHeight = <num> ;
public DashboardLayout ( Context context ) {
super ( context , null ) ;
}
public DashboardLayout ( Context context , AttributeSet attrs ) {
super ( context , attrs , <num> ) ;
}
public DashboardLayout ( Context context , AttributeSet attrs , int defStyle ) {
super ( context , attrs , defStyle ) ;
}
@Override
protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) {
mMaxChildWidth = <num> ;
mMaxChildHeight = <num> ;
int childWidthMeasureSpec = MeasureSpec . makeMeasureSpec (
MeasureSpec . getSize ( widthMeasureSpec ) , MeasureSpec . AT_MOST ) ;
int childHeightMeasureSpec = MeasureSpec . makeMeasureSpec (
MeasureSpec . getSize ( widthMeasureSpec ) , MeasureSpec . AT_MOST ) ;
final int count = getChildCount ( ) ;
for ( int i = <num> ; i < count ; i ++ ) {
final View child = getChildAt ( i ) ;
if ( child . getVisibility ( ) == GONE ) {
continue ;
}
child . measure ( childWidthMeasureSpec , childHeightMeasureSpec ) ;
mMaxChildWidth = Math . max ( mMaxChildWidth , child . getMeasuredWidth ( ) ) ;
mMaxChildHeight = Math . max ( mMaxChildHeight , child . getMeasuredHeight ( ) ) ;
}
childWidthMeasureSpec = MeasureSpec . makeMeasureSpec (
mMaxChildWidth , MeasureSpec . EXACTLY ) ;
childHeightMeasureSpec = MeasureSpec . makeMeasureSpec (
mMaxChildHeight , MeasureSpec . EXACTLY ) ;
for ( int i = <num> ; i < count ; i ++ ) {
final View child = getChildAt ( i ) ;
if ( child . getVisibility ( ) == GONE ) {
continue ;
}
child . measure ( childWidthMeasureSpec , childHeightMeasureSpec ) ;
}
setMeasuredDimension (
resolveSize ( mMaxChildWidth , widthMeasureSpec ) ,
resolveSize ( mMaxChildHeight , heightMeasureSpec ) ) ;
}
@Override
protected void onLayout ( boolean changed , int l , int t , int r , int b ) {
int width = r  l ;
int height = b  t ;
final int count = getChildCount ( ) ;
int visibleCount = <num> ;
for ( int i = <num> ; i < count ; i ++ ) {
final View child = getChildAt ( i ) ;
if ( child . getVisibility ( ) == GONE ) {
continue ;
}
++ visibleCount ;
}
if ( visibleCount == <num> ) {
return ;
}
int bestSpaceDifference = Integer . MAX_VALUE ;
int spaceDifference ;
int hSpace = <num> ;
int vSpace = <num> ;
int cols = <num> ;
int rows ;
while ( true ) {
rows = ( visibleCount  <num> ) / cols + <num> ;
hSpace = ( ( width  mMaxChildWidth * cols ) / ( cols + <num> ) ) ;
vSpace = ( ( height  mMaxChildHeight * rows ) / ( rows + <num> ) ) ;
spaceDifference = Math . abs ( vSpace  hSpace ) ;
if ( rows * cols != visibleCount ) {
spaceDifference *= UNEVEN_GRID_PENALTY_MULTIPLIER ;
}
if ( spaceDifference < bestSpaceDifference ) {
bestSpaceDifference = spaceDifference ;
if ( rows == <num> ) {
break ;
}
} else {
cols ;
rows = ( visibleCount  <num> ) / cols + <num> ;
hSpace = ( ( width  mMaxChildWidth * cols ) / ( cols + <num> ) ) ;
vSpace = ( ( height  mMaxChildHeight * rows ) / ( rows + <num> ) ) ;
break ;
}
++ cols ;
}
hSpace = Math . max ( <num> , hSpace ) ;
vSpace = Math . max ( <num> , vSpace ) ;
width = ( width  hSpace * ( cols + <num> ) ) / cols ;
height = ( height  vSpace * ( rows + <num> ) ) / rows ;
int left , top ;
int col , row ;
int visibleIndex = <num> ;
for ( int i = <num> ; i < count ; i ++ ) {
final View child = getChildAt ( i ) ;
if ( child . getVisibility ( ) == GONE ) {
continue ;
}
row = visibleIndex / cols ;
col = visibleIndex % cols ;
left = hSpace * ( col + <num> ) + width * col ;
top = vSpace * ( row + <num> ) + height * row ;
child . layout ( left , top ,
( hSpace == <num> && col == cols  <num> ) ? r : ( left + width ) ,
( vSpace == <num> && row == rows  <num> ) ? b : ( top + height ) ) ;
++ visibleIndex ;
}
}
}
package org . ligi . gobandroid_hd . ui . review ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . ui . GoActivity ;
import org . ligi . gobandroid_hd . ui . NavigationAndCommentFragment ;
import org . ligi . gobandroid_hd . ui . alerts . GameForwardAlert ;
import org . ligi . tracedroid . logging . Log ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . support . v4 . view . Menu ;
import android . support . v4 . view . MenuItem ;
import android . view . KeyEvent ;
import android . view . View ;
public class GameReviewActivity extends GoActivity {
private boolean autoplay_active = false ;
class autoPlayRunnable implements Runnable {
GoGame game ;
@Override
public void run ( ) {
game = GoGameProvider . getGame ( ) ;
Log . i ( " , " + game . getActMove ( ) . getNextMoveVariations ( ) . size ( ) ) ;
while ( autoplay_active && ( game . getActMove ( ) . getNextMoveVariations ( ) . size ( ) > <num> ) ) {
Log . i ( " , " + game . getActMove ( ) . getNextMoveVariationCount ( ) ) ;
game . jump ( game . getActMove ( ) . getnextMove ( <num> ) ) ;
try {
Thread . sleep ( <num> ) ;
} catch ( InterruptedException e ) {
e . printStackTrace ( ) ;
}
}
}
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
this . getMenuInflater ( ) . inflate ( R . menu . ingame_review , menu ) ;
menu . findItem ( R . id . menu_autoplay ) . setTitle ( autoplay_active ? R . string . <unk> : R . string . <unk> ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case R . id . menu_bookmark :
BookmarkDialog . show ( this ) ;
return true ;
case R . id . menu_autoplay :
Log . i ( " , " ) ;
if ( autoplay_active ) {
autoplay_active = false ;
} else {
autoplay_active = true ;
new Thread ( new autoPlayRunnable ( ) ) . start ( ) ; ;
}
this . invalidateOptionsMenu ( ) ;
break ;
}
return super . onOptionsItemSelected ( item ) ;
}
@Override
protected void onStop ( ) {
autoplay_active = false ;
super . onStop ( ) ;
}
public Fragment getGameExtraFragment ( ) {
return new NavigationAndCommentFragment ( ) ;
}
@Override
public byte doMoveWithUIFeedback ( byte x , byte y ) {
return GoGame . MOVE_VALID ;
}
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
getBoard ( ) . setOnKeyListener ( this ) ;
getBoard ( ) . do_mark_act = false ;
}
@Override
public boolean onKey ( View v , int keyCode , KeyEvent event ) {
if ( event . getAction ( ) == KeyEvent . ACTION_DOWN )
switch ( keyCode ) {
case KeyEvent . KEYCODE_MEDIA_PREVIOUS :
case KeyEvent . KEYCODE_DPAD_LEFT :
if ( ! game . canUndo ( ) )
return true ;
game . undo ( ) ;
return true ;
case KeyEvent . KEYCODE_DPAD_RIGHT :
case KeyEvent . KEYCODE_MEDIA_NEXT :
GameForwardAlert . show ( this , game ) ;
return true ;
case KeyEvent . KEYCODE_DPAD_UP :
case KeyEvent . KEYCODE_DPAD_DOWN :
return false ;
}
return super . onKey ( v , keyCode , event ) ;
}
@Override
public boolean isAsk4QuitEnabled ( ) {
return false ;
}
}
package org . ligi . gobandroid_hd . logic ;
import java . util . Vector ;
import java . util . Stack ;
import org . ligi . tracedroid . logging . Log ;
import android . graphics . Point ;
public class GoGame {
public interface GoGameChangeListener {
public void onGoGameChange ( ) ;
}
private Vector < GoGameChangeListener > change_listeners = new Vector < GoGameChangeListener > ( ) ;
public void addGoGameChangeListener ( GoGameChangeListener new_l ) {
change_listeners . add ( new_l ) ;
}
public void removeGoGameChangeListener ( GoGameChangeListener l ) {
change_listeners . remove ( l ) ;
}
public void notifyGameChange ( ) {
for ( GoGameChangeListener l : change_listeners )
if ( l != null ) l . onGoGameChange ( ) ;
}
private byte act_player = GoDefinitions . PLAYER_BLACK ;
private GoBoard visual_board ;
private GoBoard calc_board ;
private GoBoard last_board ;
private GoBoard pre_last_board ;
private GoBoard handicap_board ;
private boolean last_action_was_pass = false ;
private boolean game_finished = false ;
private int [ ] [ ] groups ;
public int [ ] [ ] area_groups ;
public byte [ ] [ ] area_assign ;
private int group_count =  <num> ;
private int captures_white ;
private int captures_black ;
private int dead_white ;
private int dead_black ;
public int territory_white ;
public int territory_black ;
private byte handicap = <num> ;
private float komi = <num> ;
private GoMove act_move = null ;
private GnuGoMover go_mover = null ;
private GoGameMetadata metadata = null ;
private int area_group_count = <num> ;
public final static byte MOVE_VALID = <num> ;
public final static byte MOVE_INVALID_NOT_ON_BOARD = <num> ;
public final static byte MOVE_INVALID_CELL_NOT_FREE = <num> ;
public final static byte MOVE_INVALID_CELL_NO_LIBERTIES = <num> ;
public final static byte MOVE_INVALID_IS_KO = <num> ;
public byte start_player = GoDefinitions . PLAYER_BLACK ;
private boolean [ ] [ ] all_handicap_positions ;
private int local_captures = <num> ;
public GoGame ( byte size ) {
construct ( size ) ;
}
public GoGame ( byte size , byte handicap ) {
this . handicap = handicap ;
construct ( size ) ;
}
public float getKomi ( ) {
return komi ;
}
public void setKomi ( float newKomi ) {
komi = newKomi ;
}
public float getPointsWhite ( ) {
return komi + getCapturesWhite ( ) + territory_white ;
}
public float getPointsBlack ( ) {
return getCapturesBlack ( ) + territory_black ;
}
public void apply_handicap ( ) {
calc_board = handicap_board . clone ( ) ;
}
private void construct ( byte size ) {
metadata = new GoGameMetadata ( ) ;
calc_board = new GoBoard ( size ) ;
handicap_board = calc_board . clone ( ) ;
all_handicap_positions = new boolean [ size ] [ size ] ;
if ( GoDefinitions . getHandicapArray ( size ) != null )
for ( int i = <num> ; i < <num> ; i ++ ) {
if ( i < handicap )
handicap_board . setCellBlack ( GoDefinitions . getHandicapArray ( size ) [ i ] [ <num> ] , GoDefinitions . getHandicapArray ( size ) [ i ] [ <num> ] ) ;
all_handicap_positions [ GoDefinitions . getHandicapArray ( size ) [ i ] [ <num> ] ] [ GoDefinitions . getHandicapArray ( size ) [ i ] [ <num> ] ] = true ;
}
apply_handicap ( ) ;
visual_board = calc_board . clone ( ) ;
last_board = calc_board . clone ( ) ;
pre_last_board = null ;
groups = new int [ size ] [ size ] ;
area_groups = new int [ size ] [ size ] ;
area_assign = new byte [ size ] [ size ] ;
act_move = new GoMove ( null ) ;
act_move . setIsFirstMove ( ) ;
reset ( ) ;
}
public void reset ( ) {
if ( handicap != <num> )
start_player = GoDefinitions . PLAYER_WHITE ;
act_player = start_player ;
pre_last_board = null ;
captures_black = <num> ;
captures_white = <num> ;
}
public void pass ( ) {
if ( last_action_was_pass ) {
game_finished = true ;
buildGroups ( ) ;
buildAreaGroups ( ) ;
}
else {
last_action_was_pass = true ;
act_move = new GoMove ( act_move ) ;
act_move . setToPassMove ( ) ;
setNextPlayer ( ) ;
}
}
public byte do_move ( byte x , byte y ) {
Log . i ( " + x + " + y ) ;
if ( ( x < <num> ) || ( x >= calc_board . getSize ( ) ) || ( y < <num> ) || ( y >= calc_board . getSize ( ) ) )
return MOVE_INVALID_NOT_ON_BOARD ;
GoMove matching_move = null ;
for ( GoMove move_matcher : act_move . getNextMoveVariations ( ) )
if ( ( move_matcher . getX ( ) == x ) && ( move_matcher . getY ( ) == y ) )
matching_move = move_matcher ;
if ( matching_move != null ) {
jump ( matching_move ) ;
return MOVE_VALID ;
}
if ( game_finished ) {
for ( int xg = <num> ; xg < calc_board . getSize ( ) ; xg ++ )
for ( int yg = <num> ; yg < calc_board . getSize ( ) ; yg ++ )
if ( groups [ xg ] [ yg ] == groups [ x ] [ y ] )
calc_board . toggleCellDead ( xg , yg ) ;
buildAreaGroups ( ) ;
int _dead_white = <num> ;
int _dead_black = <num> ;
for ( int xg = <num> ; xg < calc_board . getSize ( ) ; xg ++ )
for ( int yg = <num> ; yg < calc_board . getSize ( ) ; yg ++ )
if ( calc_board . isCellDead ( xg , yg ) ) {
if ( calc_board . isCellDeadBlack ( xg , yg ) )
_dead_black ++ ;
if ( calc_board . isCellDeadWhite ( xg , yg ) )
_dead_white ++ ;
}
dead_white = _dead_white ;
dead_black = _dead_black ;
return MOVE_VALID ;
}
if ( ! calc_board . isCellFree ( x , y ) )
return MOVE_INVALID_CELL_NOT_FREE ;
GoBoard bak_board = calc_board . clone ( ) ;
if ( isBlackToMove ( ) )
calc_board . setCellBlack ( x , y ) ;
else
calc_board . setCellWhite ( x , y ) ;
remove_dead ( x , y ) ;
if ( calc_board . equals ( pre_last_board ) ) {
Log . i ( " ) ;
calc_board = bak_board . clone ( ) ;
return MOVE_INVALID_IS_KO ;
}
if ( ! hasGroupLiberties ( x , y ) ) {
Log . i ( " ) ;
calc_board = bak_board . clone ( ) ;
return MOVE_INVALID_CELL_NO_LIBERTIES ;
}
if ( isBlackToMove ( ) )
getGoMover ( ) . processBlackMove ( x , y ) ;
else
getGoMover ( ) . processWhiteMove ( x , y ) ;
setNextPlayer ( ) ;
pre_last_board = last_board . clone ( ) ;
last_board = calc_board . clone ( ) ;
visual_board = calc_board . clone ( ) ;
last_action_was_pass = false ;
act_move = new GoMove ( x , y , act_move ) ;
if ( ! calc_board . isCellWhite ( x , y ) )
captures_black += local_captures ;
else
captures_white += local_captures ;
act_move . setDidCaptures ( local_captures > <num> ) ;
notifyGameChange ( ) ;
return MOVE_VALID ;
}
public GoMove getActMove ( ) {
return act_move ;
}
public boolean canRedo ( ) {
return ( act_move != null ) && ( act_move . hasNextMove ( ) ) ;
}
public int getPossibleVariationCount ( ) {
if ( act_move == null )
return <num> ;
return ( act_move . getNextMoveVariationCount ( ) ) ;
}
public void do_internal_move ( GoMove move ) {
act_move = move ;
if ( move . isFirstMove ( ) )
return ;
if ( move . isPassMove ( ) ) {
setNextPlayer ( ) ;
return ;
}
if ( isBlackToMove ( ) )
calc_board . setCellBlack ( move . getX ( ) , move . getY ( ) ) ;
else
calc_board . setCellWhite ( move . getX ( ) , move . getY ( ) ) ;
setNextPlayer ( ) ;
if ( move . didCaptures ( ) ) {
buildGroups ( ) ;
remove_dead ( move . getX ( ) , move . getY ( ) ) ;
if ( ! calc_board . isCellWhite ( move . getX ( ) , move . getY ( ) ) )
captures_black += local_captures ;
else
captures_white += local_captures ;
}
}
public boolean canUndo ( ) {
return ( ! act_move . isFirstMove ( ) ) ;
}
public void undo ( ) {
_undo ( true ) ;
}
private void _undo ( boolean keep_move ) {
getGoMover ( ) . paused = true ;
GoMove mLastMove = act_move ;
jump ( mLastMove . getParent ( ) ) ;
if ( ! keep_move )
mLastMove . destroy ( ) ;
getGoMover ( ) . undo ( ) ;
game_finished = false ;
getGoMover ( ) . paused = false ;
}
public void undo ( boolean keep_move ) {
_undo ( keep_move ) ;
if ( canUndo ( ) && ( getGoMover ( ) . isMoversMove ( ) ) )
_undo ( keep_move ) ;
}
public void redo ( int var ) {
Log . i ( " + act_move . getnextMove ( var ) . toString ( ) ) ;
jump ( act_move . getnextMove ( var ) ) ;
}
public GoMove getFirstMove ( ) {
GoMove move = act_move ;
while ( true ) {
if ( move . isFirstMove ( ) )
return move ;
move = move . getParent ( ) ;
}
}
public void refreshBoards ( ) {
jump ( getActMove ( ) ) ;
}
public void jumpFirst ( ) {
jump ( getFirstMove ( ) ) ;
}
public GoMove getLastMove ( ) {
GoMove move = act_move ;
while ( true ) {
if ( ! move . hasNextMove ( ) )
return move ;
move = move . getnextMove ( <num> ) ;
}
}
public void jumpLast ( ) {
jump ( getLastMove ( ) ) ;
}
public void jump ( GoMove move ) {
if ( move == null ) {
Log . w ( " ) ;
return ;
}
last_action_was_pass = false ;
clear_calc_board ( ) ;
Vector < GoMove > replay_moves = new Vector < GoMove > ( ) ;
replay_moves . add ( move ) ;
GoMove tmp_move ;
while ( true ) {
tmp_move = replay_moves . lastElement ( ) ;
if ( tmp_move . isFirstMove ( ) || ( tmp_move . getParent ( ) == null ) )
break ;
replay_moves . add ( tmp_move . getParent ( ) ) ;
}
reset ( ) ;
act_move = getFirstMove ( ) ;
for ( int step = replay_moves . size ( )  <num> ; step >= <num> ; step  )
do_internal_move ( replay_moves . get ( step ) ) ;
visual_board = calc_board . clone ( ) ;
notifyGameChange ( ) ;
}
public boolean cell_has_libertie ( int x , int y ) {
return ( ( ( x != <num> ) && ( calc_board . isCellFree ( x  <num> , y ) ) )
||
( ( y != <num> ) && ( calc_board . isCellFree ( x , y  <num> ) ) )
||
( ( x != ( calc_board . getSize ( )  <num> ) ) && ( calc_board . isCellFree ( x + <num> , y ) ) )
||
( ( y != ( calc_board . getSize ( )  <num> ) ) && ( calc_board . isCellFree ( x , y + <num> ) ) )
) ;
}
public boolean cell_has_white_neighbours ( int x , int y ) {
return ( ( ( x != <num> ) && ( calc_board . isCellWhite ( x  <num> , y ) ) )
||
( ( y != <num> ) && ( calc_board . isCellWhite ( x , y  <num> ) ) )
||
( ( x != ( calc_board . getSize ( )  <num> ) ) && ( calc_board . isCellWhite ( x + <num> , y ) ) )
||
( ( y != ( calc_board . getSize ( )  <num> ) ) && ( calc_board . isCellWhite ( x , y + <num> ) ) )
) ;
}
public boolean cell_has_black_neighbours ( int x , int y ) {
return ( ( ( x != <num> ) && ( calc_board . isCellBlack ( x  <num> , y ) ) )
||
( ( y != <num> ) && ( calc_board . isCellBlack ( x , y  <num> ) ) )
||
( ( x != ( calc_board . getSize ( )  <num> ) ) && ( calc_board . isCellBlack ( x + <num> , y ) ) )
||
( ( y != ( calc_board . getSize ( )  <num> ) ) && ( calc_board . isCellBlack ( x , y + <num> ) ) )
) ;
}
public boolean hasGroupLiberties ( int x , int y ) {
boolean checked_pos [ ] [ ] = new boolean [ calc_board . getSize ( ) ] [ calc_board . getSize ( ) ] ;
Stack < Integer > ptStackX = new Stack < Integer > ( ) ;
Stack < Integer > ptStackY = new Stack < Integer > ( ) ;
ptStackX . push ( x ) ;
ptStackY . push ( y ) ;
while ( ! ptStackX . empty ( ) ) {
int newx = ptStackX . pop ( ) ;
int newy = ptStackY . pop ( ) ;
if ( cell_has_libertie ( newx , newy ) ) return true ;
else checked_pos [ newx ] [ newy ] = true ;
if ( newx > <num> )
if ( calc_board . areCellsEqual ( newx  <num> , newy , newx , newy ) && ( checked_pos [ newx  <num> ] [ newy ] == false ) ) {
ptStackX . push ( newx  <num> ) ;
ptStackY . push ( newy ) ;
}
if ( newx < calc_board . getSize ( )  <num> )
if ( calc_board . areCellsEqual ( newx + <num> , newy , newx , newy ) && ( checked_pos [ newx + <num> ] [ newy ] == false ) ) {
ptStackX . push ( newx + <num> ) ;
ptStackY . push ( newy ) ;
}
if ( newy > <num> )
if ( calc_board . areCellsEqual ( newx , newy  <num> , newx , newy ) && ( checked_pos [ newx ] [ newy  <num> ] == false ) ) {
ptStackX . push ( newx ) ;
ptStackY . push ( newy  <num> ) ;
}
if ( newy < calc_board . getSize ( )  <num> )
if ( calc_board . areCellsEqual ( newx , newy + <num> , newx , newy ) && ( checked_pos [ newx ] [ newy + <num> ] == false ) ) {
ptStackX . push ( newx ) ;
ptStackY . push ( newy + <num> ) ;
}
}
return false ;
}
public boolean isAreaGroupBlacks ( int group2check ) {
if ( group2check ==  <num> ) return false ;
boolean res = false ;
for ( int xg = <num> ; xg < getBoardSize ( ) ; xg ++ )
for ( int yg = <num> ; yg < getBoardSize ( ) ; yg ++ )
if ( area_groups [ xg ] [ yg ] == group2check )
if ( cell_has_white_neighbours ( xg , yg ) )
return false ;
else
res |= ( cell_has_black_neighbours ( xg , yg ) ) ;
return res ;
}
public boolean isAreaGroupWhites ( int group2check ) {
if ( group2check ==  <num> ) return false ;
boolean res = false ;
for ( int xg = <num> ; xg < getBoardSize ( ) ; xg ++ )
for ( int yg = <num> ; yg < getBoardSize ( ) ; yg ++ )
if ( area_groups [ xg ] [ yg ] == group2check )
if ( cell_has_black_neighbours ( xg , yg ) )
return false ;
else
res |= ( cell_has_white_neighbours ( xg , yg ) ) ;
return res ;
}
public void clear_calc_board ( ) {
apply_handicap ( ) ;
}
public void buildGroups ( ) {
group_count = <num> ;
for ( int x = <num> ; x < calc_board . getSize ( ) ; x ++ )
for ( int y = <num> ; y < calc_board . getSize ( ) ; y ++ )
groups [ x ] [ y ] =  <num> ;
Stack < Integer > ptStackX = new Stack < Integer > ( ) ;
Stack < Integer > ptStackY = new Stack < Integer > ( ) ;
for ( int x = <num> ; x < calc_board . getSize ( ) ; x ++ )
for ( int y = <num> ; y < calc_board . getSize ( ) ; y ++ ) {
if ( groups [ x ] [ y ] ==  <num> ) {
ptStackX . push ( x ) ;
ptStackY . push ( y ) ;
while ( ! ptStackX . empty ( ) ) {
int newx = ptStackX . pop ( ) ;
int newy = ptStackY . pop ( ) ;
groups [ newx ] [ newy ] = group_count ;
if ( newx > <num> )
if ( calc_board . areCellsEqual ( newx  <num> , newy , newx , newy ) && ( groups [ newx  <num> ] [ newy ] ==  <num> ) ) {
ptStackX . push ( newx  <num> ) ;
ptStackY . push ( newy ) ;
}
if ( newx < calc_board . getSize ( )  <num> )
if ( calc_board . areCellsEqual ( newx + <num> , newy , newx , newy ) && ( groups [ newx + <num> ] [ newy ] ==  <num> ) ) {
ptStackX . push ( newx + <num> ) ;
ptStackY . push ( newy ) ;
}
if ( newy > <num> )
if ( calc_board . areCellsEqual ( newx , newy  <num> , newx , newy ) && ( groups [ newx ] [ newy  <num> ] ==  <num> ) ) {
ptStackX . push ( newx ) ;
ptStackY . push ( newy  <num> ) ;
}
if ( newy < calc_board . getSize ( )  <num> )
if ( calc_board . areCellsEqual ( newx , newy + <num> , newx , newy ) && ( groups [ newx ] [ newy + <num> ] ==  <num> ) ) {
ptStackX . push ( newx ) ;
ptStackY . push ( newy + <num> ) ;
}
}
group_count ++ ;
}
}
}
public void buildAreaGroups ( ) {
area_group_count = <num> ;
for ( int x = <num> ; x < calc_board . getSize ( ) ; x ++ )
for ( int y = <num> ; y < calc_board . getSize ( ) ; y ++ ) {
area_groups [ x ] [ y ] =  <num> ;
area_assign [ x ] [ y ] = <num> ;
}
for ( byte x = <num> ; x < calc_board . getSize ( ) ; x ++ )
for ( byte y = <num> ; y < calc_board . getSize ( ) ; y ++ ) {
if ( calc_board . isCellFree ( x , y ) ) {
if ( x > <num> ) {
if ( ! calc_board . areCellsEqual ( x , y , ( byte ) ( x  <num> ) , y ) ) {
area_group_count ++ ;
area_groups [ x ] [ y ] = area_group_count ;
}
else
area_groups [ x ] [ y ] = area_groups [ x  <num> ] [ y ] ;
}
else {
area_group_count ++ ;
area_groups [ x ] [ y ] = area_group_count ;
}
if ( y > <num> ) {
if ( calc_board . areCellsEqual ( x , y , x , ( byte ) ( y  <num> ) ) ) {
int from_grp = area_groups [ x ] [ y ] ;
for ( int xg = <num> ; xg < calc_board . getSize ( ) ; xg ++ )
for ( int yg = <num> ; yg < calc_board . getSize ( ) ; yg ++ )
if ( area_groups [ xg ] [ yg ] == from_grp )
area_groups [ xg ] [ yg ] = area_groups [ x ] [ y  <num> ] ;
}
}
}
}
territory_black = <num> ;
territory_white = <num> ;
for ( int x = <num> ; x < calc_board . getSize ( ) ; x ++ )
for ( int y = <num> ; y < calc_board . getSize ( ) ; y ++ )
if ( isAreaGroupWhites ( area_groups [ x ] [ y ] ) ) {
area_assign [ x ] [ y ] = GoDefinitions . PLAYER_WHITE ;
territory_white ++ ;
}
else if ( isAreaGroupBlacks ( area_groups [ x ] [ y ] ) ) {
territory_black ++ ;
area_assign [ x ] [ y ] = GoDefinitions . PLAYER_BLACK ;
}
}
private void remove_dead ( byte ignore_x , byte ignore_y ) {
local_captures = <num> ;
if ( ignore_x > <num> )
if ( ( ! hasGroupLiberties ( ignore_x  <num> , ignore_y ) ) && ( ! calc_board . areCellsEqual ( ignore_x , ignore_y , ignore_x  <num> , ignore_y ) ) )
remove_group ( ignore_x  <num> , ( int ) ignore_y ) ;
if ( ignore_x < calc_board . getSize ( )  <num> )
if ( ( ! hasGroupLiberties ( ignore_x + <num> , ignore_y ) ) && ( ! calc_board . areCellsEqual ( ignore_x , ignore_y , ignore_x + <num> , ignore_y ) ) )
remove_group ( ignore_x + <num> , ( int ) ignore_y ) ;
if ( ignore_y > <num> ) {
if ( ( ! hasGroupLiberties ( ignore_x , ignore_y  <num> ) ) && ( ! calc_board . areCellsEqual ( ignore_x , ignore_y , ignore_x , ignore_y  <num> ) ) )
remove_group ( ( int ) ignore_x , ignore_y  <num> ) ;
}
if ( ignore_y < calc_board . getSize ( )  <num> ) {
if ( ( ! hasGroupLiberties ( ignore_x , ignore_y + <num> ) ) && ( ! calc_board . areCellsEqual ( ignore_x , ignore_y , ignore_x , ignore_y + <num> ) ) )
remove_group ( ( int ) ignore_x , ignore_y + <num> ) ;
}
}
private void remove_group ( int x , int y ) {
if ( calc_board . isCellFree ( x , y ) )
return ;
boolean checked_pos [ ] [ ] = new boolean [ calc_board . getSize ( ) ] [ calc_board . getSize ( ) ] ;
Stack < Integer > ptStackX = new Stack < Integer > ( ) ;
Stack < Integer > ptStackY = new Stack < Integer > ( ) ;
ptStackX . push ( x ) ;
ptStackY . push ( y ) ;
checked_pos [ x ] [ y ] = true ;
while ( ! ptStackX . empty ( ) ) {
int newx = ptStackX . pop ( ) ;
int newy = ptStackY . pop ( ) ;
if ( newx > <num> )
if ( calc_board . areCellsEqual ( newx  <num> , newy , newx , newy ) && ( checked_pos [ newx  <num> ] [ newy ] == false ) ) {
ptStackX . push ( newx  <num> ) ;
ptStackY . push ( newy ) ;
checked_pos [ newx  <num> ] [ newy ] = true ;
}
if ( newx < calc_board . getSize ( )  <num> )
if ( calc_board . areCellsEqual ( newx + <num> , newy , newx , newy ) && ( checked_pos [ newx + <num> ] [ newy ] == false ) ) {
ptStackX . push ( newx + <num> ) ;
ptStackY . push ( newy ) ;
checked_pos [ newx + <num> ] [ newy ] = true ;
}
if ( newy > <num> )
if ( calc_board . areCellsEqual ( newx , newy  <num> , newx , newy ) && ( checked_pos [ newx ] [ newy  <num> ] == false ) ) {
ptStackX . push ( newx ) ;
ptStackY . push ( newy  <num> ) ;
checked_pos [ newx ] [ newy  <num> ] = true ;
}
if ( newy < calc_board . getSize ( )  <num> )
if ( calc_board . areCellsEqual ( newx , newy + <num> , newx , newy ) && ( checked_pos [ newx ] [ newy + <num> ] == false ) ) {
ptStackX . push ( newx ) ;
ptStackY . push ( newy + <num> ) ;
checked_pos [ newx ] [ newy + <num> ] = true ;
}
local_captures ++ ;
calc_board . setCellFree ( newx , newy ) ;
}
}
public boolean isPosHoschi ( byte x , byte y ) {
return all_handicap_positions [ x ] [ y ] ;
}
public GoBoard getVisualBoard ( ) {
return visual_board ;
}
public GoBoard getCalcBoard ( ) {
return calc_board ;
}
public boolean <unk> ( ) {
return last_action_was_pass ;
}
public boolean isFinished ( ) {
return game_finished ;
}
public boolean isBlackToMove ( ) {
return ( act_player == GoDefinitions . PLAYER_BLACK ) ;
}
public int getCapturesBlack ( ) {
return captures_black + dead_white ;
}
public int getCapturesWhite ( ) {
return captures_white + dead_black ;
}
public int getBoardSize ( ) {
return calc_board . getSize ( ) ;
}
public int getGroup ( byte x , byte y ) {
return groups [ x ] [ y ] ;
}
public void setNextPlayer ( ) {
act_player = ( act_player == GoDefinitions . PLAYER_BLACK ) ? GoDefinitions . PLAYER_WHITE : GoDefinitions . PLAYER_BLACK ;
}
public byte getHandicap ( ) {
return handicap ;
}
public GoBoard getHandicapBoard ( ) {
return handicap_board ;
}
public void setGoMover ( GnuGoMover go_mover ) {
this . go_mover = go_mover ;
}
public GnuGoMover getGoMover ( ) {
if ( go_mover == null )
return new GnuGoMover ( ) ;
return go_mover ;
}
public GoGameMetadata getMetaData ( ) {
return metadata ;
}
public void setMetadata ( GoGameMetadata metadata ) {
this . metadata = metadata ;
}
public int getSize ( ) {
return getVisualBoard ( ) . getSize ( ) ;
}
public Point linear_coordinate2Point ( int lin ) {
return new Point ( lin % getSize ( ) , lin / getSize ( ) ) ;
}
package org . ligi . gobandroid_hd . ui . links ;
import org . ligi . android . common . adapter . LinkAndDescriptionAdapter ;
import org . ligi . android . common . adapter . LinkWithDescription ;
import org . ligi . gobandroid_hd . R ;
import android . content . Intent ;
import android . net . Uri ;
import android . os . Bundle ;
import android . support . v4 . app . ListFragment ;
import android . view . View ;
import android . widget . ListView ;
public class LinkListFragment extends ListFragment {
public LinkWithDescription [ ] links ;
public LinkListFragment ( ) {
}
public LinkListFragment ( LinkWithDescription [ ] links ) {
this . links = links ;
}
@Override
public void onActivityCreated ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
if ( links != null ) {
this . setListAdapter ( LinkAndDescriptionAdapter . createByArray ( this . getActivity ( ) , links , R . layout . two_line_list_item ) ) ;
this . getListView ( ) . setCacheColorHint ( <num> ) ;
}
}
@Override
public void onListItemClick ( ListView l , View v , int position , long id ) {
super . onListItemClick ( l , v , position , id ) ;
startActivity ( new Intent ( " , Uri . parse ( links [ position ] . getURL ( ) ) ) ) ;
}
}
package org . ligi . gobandroid_hd . logic ;
import java . util . Vector ;
import org . ligi . tracedroid . logging . Log ;
public class SGFHelper {
private static String moves2string ( GoMove move , boolean black_to_move ) {
String res = " ;
GoMove act_move = move ;
while ( act_move != null ) {
if ( ! act_move . isFirstMove ( ) ) {
res += " + ( black_to_move ? " : " ) ;
if ( act_move . isPassMove ( ) )
res += " ;
else
res += " + ( char ) ( a' + act_move . getX ( ) ) + ( char ) ( a' + act_move . getY ( ) ) + " ;
black_to_move = ! black_to_move ;
}
if ( ! act_move . getComment ( ) . equals ( " ) )
res += " + act_move . getComment ( ) + " ;
GoMove next_move = null ;
if ( act_move . hasNextMove ( ) ) {
if ( act_move . hasNextMoveVariations ( ) )
for ( GoMove var : act_move . getNextMoveVariations ( ) )
res += " + moves2string ( var , black_to_move ) + " ;
else
next_move = act_move . getnextMove ( <num> ) ;
}
act_move = next_move ;
}
return res ;
}
public static String escapeSGF ( String txt ) {
txt . replace ( " , " ) ;
txt . replace ( " , " ) ;
txt . replace ( " , " ) ;
return txt ;
}
private static String getSGFSnippet ( String cmd , String param ) {
if ( ( param == null ) || ( param . equals ( " ) ) || ( cmd == null ) || ( cmd . equals ( " ) ) )
return " ;
return cmd + " + escapeSGF ( param ) + " ;
}
public static String game2sgf ( GoGame game ) {
String res = " ;
res = " ;
res += getSGFSnippet ( " , " + game . getBoardSize ( ) ) ;
res += getSGFSnippet ( " , escapeSGF ( game . getMetaData ( ) . getName ( ) ) ) ;
res += getSGFSnippet ( " , escapeSGF ( game . getMetaData ( ) . getBlackName ( ) ) ) ;
res += getSGFSnippet ( " , escapeSGF ( game . getMetaData ( ) . getWhiteName ( ) ) ) ;
res += getSGFSnippet ( " , escapeSGF ( game . getMetaData ( ) . getBlackRank ( ) ) ) ;
res += getSGFSnippet ( " , escapeSGF ( game . getMetaData ( ) . getWhiteRank ( ) ) ) ;
res += getSGFSnippet ( " , escapeSGF ( Float . toString ( game . getKomi ( ) ) ) ) ;
res += getSGFSnippet ( " , escapeSGF ( game . getMetaData ( ) . getResult ( ) ) ) ;
res += getSGFSnippet ( " , escapeSGF ( game . getMetaData ( ) . getSource ( ) ) ) ;
res += " ;
boolean black_to_move = true ;
if ( game . getHandicap ( ) > <num> ) {
black_to_move = false ;
res += " ;
byte [ ] [ ] handicap_arr = GoDefinitions . getHandicapArray ( game . getBoardSize ( ) ) ;
if ( handicap_arr != null )
for ( int handicap = <num> ; handicap < game . getHandicap ( ) ; handicap ++ )
res += " + ( char ) ( a' + handicap_arr [ handicap ] [ <num> ] ) + ( char ) ( a' + handicap_arr [ handicap ] [ <num> ] ) + " ;
res += " ;
}
res += moves2string ( game . getFirstMove ( ) , black_to_move ) + " ;
return res ;
}
public final static int BREAKON_NOTHING = <num> ;
public final static int BREAKON_FIRSTMOVE = <num> ;
public static GoGame sgf2game ( String sgf , ISGFLoadProgressCallback callback ) {
return sgf2game ( sgf , callback , BREAKON_NOTHING ) ;
}
public static GoGame sgf2game ( String sgf , ISGFLoadProgressCallback callback , int breakon ) {
Log . i ( " + sgf ) ;
byte size =  <num> ;
GoGame game = null ;
byte opener = <num> ;
boolean escape = false ;
Vector < GoMove > var_vect = new Vector < GoMove > ( ) ;
boolean consuming_param = false ;
String act_param = " ;
String act_cmd = " ;
String last_cmd = " ;
GoGameMetadata metadata = new GoGameMetadata ( ) ;
boolean break_pulled = false ;
for ( int p = <num> ; ( ( p < sgf . length ( ) ) && ( ! break_pulled ) ) ; p ++ ) {
char act_char = sgf . charAt ( p ) ;
if ( ! consuming_param )
switch ( act_char ) {
case \r' :
case \n' :
case ;' :
case \t' :
case  ' :
if ( ! act_cmd . equals ( " ) )
last_cmd = act_cmd ;
act_cmd = " ;
break ;
case [' :
if ( act_cmd . equals ( " ) )
act_cmd = last_cmd ;
consuming_param = true ;
act_param = " ;
break ;
case (' :
if ( ! consuming_param ) {
if ( ( opener == <num> ) && ( game == null ) )
{
game = new GoGame ( ( byte ) <num> ) ;
var_vect . add ( game . getActMove ( ) ) ;
}
opener ++ ;
Log . i ( " + game ) ;
if ( game != null ) {
var_vect . add ( game . getActMove ( ) ) ;
}
last_cmd = " ;
act_cmd = " ;
}
break ;
case )' :
if ( var_vect . size ( ) > <num> ) {
game . jump ( var_vect . lastElement ( ) ) ;
var_vect . remove ( var_vect . lastElement ( ) ) ;
Log . w ( " ) ;
}
else
Log . w ( " ) ;
last_cmd = " ;
act_cmd = " ;
break ;
default :
act_cmd += sgf . charAt ( p ) ;
}
else
switch ( act_char ) {
case ]' :
if ( ( game != null ) && ( callback != null ) )
callback . progress ( p , sgf . length ( ) , " + game . getActMove ( ) . getMovePos ( ) ) ;
if ( ! escape ) {
consuming_param = false ;
byte param_x = <num> , param_y = <num> ;
if ( act_param . length ( ) >= <num> ) {
param_x = ( byte ) ( act_param . charAt ( <num> )  a' ) ;
param_y = ( byte ) ( act_param . charAt ( <num> )  a' ) ;
}
if ( act_cmd . length ( ) == <num> )
act_cmd = last_cmd ;
Log . i ( " + act_cmd + " + act_param ) ;
if ( act_cmd . equals ( " ) ) {
String [ ] inner = act_param . split ( " ) ;
String txt = " ;
if ( inner . length > <num> )
txt = inner [ <num> ] ;
game . getActMove ( ) . addMarker ( new GoMarker ( param_x , param_y , txt ) ) ;
}
if ( act_cmd . equals ( " ) | act_cmd . equals ( " ) )
game . getActMove ( ) . addMarker ( new GoMarker ( param_x , param_y , " ) ) ;
if ( act_cmd . equals ( " ) ) {
String mark = " ;
game . getActMove ( ) . addMarker ( new GoMarker ( param_x , param_y , mark ) ) ;
}
if ( act_cmd . equals ( " ) ) {
String mark = " ;
game . getActMove ( ) . addMarker ( new GoMarker ( param_x , param_y , mark ) ) ;
}
if ( act_cmd . equals ( " ) ) {
String mark = " ;
game . getActMove ( ) . addMarker ( new GoMarker ( param_x , param_y , mark ) ) ;
}
if ( act_cmd . equals ( " ) )
metadata . setName ( act_param ) ;
if ( act_cmd . equals ( " ) )
metadata . setWhiteName ( act_param ) ;
if ( act_cmd . equals ( " ) )
metadata . setBlackName ( act_param ) ;
if ( act_cmd . equals ( " ) )
metadata . setWhiteRank ( act_param ) ;
if ( act_cmd . equals ( " ) )
metadata . setBlackRank ( act_param ) ;
if ( act_cmd . equals ( " ) )
metadata . setResult ( act_param ) ;
if ( act_cmd . equals ( " ) )
metadata . setResult ( act_param ) ;
if ( act_cmd . equals ( " ) || act_cmd . equals ( " ) ) {
act_param = act_param . replaceAll ( " , " ) ;
size = Byte . parseByte ( act_param ) ;
if ( ( game == null ) || ( game . getBoardSize ( ) != size ) ) {
game = new GoGame ( size ) ;
var_vect . add ( game . getActMove ( ) ) ;
}
}
if ( act_cmd . equals ( " ) || act_cmd . equals ( " ) ) {
if ( game != null )
game . getActMove ( ) . setComment ( act_param ) ;
}
if ( act_cmd . equals ( " ) || act_cmd . equals ( " ) || act_cmd . equals ( " ) || act_cmd . equals ( " ) ) {
if ( game == null ) {
game = new GoGame ( ( byte ) <num> ) ;
var_vect . add ( game . getActMove ( ) ) ;
}
if ( ( breakon & BREAKON_FIRSTMOVE ) > <num> )
break_pulled = true ;
if ( game . getActMove ( ) . isFirstMove ( ) )
game . apply_handicap ( ) ;
if ( act_param . length ( ) == <num> )
game . pass ( ) ;
else {
if ( game . getActMove ( ) . isFirstMove ( ) && game . isBlackToMove ( ) && ( act_cmd . equals ( " ) || act_cmd . equals ( " ) ) ) {
game . start_player = GoDefinitions . PLAYER_WHITE ;
game . setNextPlayer ( ) ;
}
if ( game . isBlackToMove ( ) && ( ( act_cmd . equals ( " ) || ( act_cmd . equals ( " ) ) ) ) )
game . pass ( ) ;
else if ( ( ! game . isBlackToMove ( ) ) && ( ( act_cmd . equals ( " ) || ( act_cmd . equals ( " ) ) ) ) )
game . pass ( ) ;
game . do_move ( param_x , param_y ) ;
}
}
if ( act_cmd . equals ( " ) || act_cmd . equals ( " )
|| act_cmd . equals ( " ) || act_cmd . equals ( " ) ) {
if ( game == null ) {
game = new GoGame ( ( byte ) <num> ) ;
var_vect . add ( game . getActMove ( ) ) ;
}
if ( act_param . length ( ) != <num> ) {
if ( game . isBlackToMove ( ) && ( act_cmd . equals ( " ) || act_cmd . equals ( " ) ) )
game . getHandicapBoard ( ) . setCellBlack ( param_x , param_y ) ;
if ( game . isBlackToMove ( ) && ( act_cmd . equals ( " ) || act_cmd . equals ( " ) ) )
game . getHandicapBoard ( ) . setCellWhite ( param_x , param_y ) ;
}
else
Log . w ( " ) ;
}
last_cmd = act_cmd ;
act_cmd = " ;
act_param = " ;
}
case \\' :
if ( escape ) {
act_param += ( char ) act_char ;
escape = false ;
}
else
escape = true ;
break ;
default :
act_param += ( char ) act_char ;
escape = false ;
break ;
}
}
if ( game != null )
game . setMetadata ( metadata ) ;
return game ;
}
public interface ISGFLoadProgressCallback {
public void progress ( int act , int max , String Message ) ;
}
}
package org . ligi . gobandroid_hd . ui . sgf_listing ;
import java . io . File ;
import java . io . IOException ;
import org . ligi . android . common . files . FileHelper ;
public class GoLink {
public static boolean isGoLink ( String fname ) {
return fname . endsWith ( " ) ;
}
private String fname = " ;
private int move_pos = <num> ;
public GoLink ( String fname ) {
this ( new File ( fname ) ) ;
}
public GoLink ( File file ) {
try {
String go_lnk = FileHelper . file2String ( file ) ;
fname = go_lnk ;
String [ ] arr_content = go_lnk . split ( " ) ;
fname = arr_content [ <num> ] ;
fname = fname . replace ( " , " ) ;
move_pos = Integer . parseInt ( arr_content [ <num> ] ) ;
} catch ( Exception e ) { }
}
public int getMoveDepth ( ) {
return move_pos ;
}
public String getSGFString ( ) {
try {
return FileHelper . file2String ( new File ( fname ) ) ;
} catch ( IOException e ) {
return " ;
}
}
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . android . common . preferences . SetPreferenceEnabledByCheckBoxPreferenceState ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . ui . application . GobandroidSettings ;
import android . content . Intent ;
import android . net . Uri ;
import android . os . Bundle ;
import android . preference . CheckBoxPreference ;
import android . preference . ListPreference ;
import android . preference . Preference ;
import android . preference . PreferenceActivity ;
import android . preference . PreferenceCategory ;
import android . preference . PreferenceScreen ;
import android . preference . EditTextPreference ;
import android . preference . Preference . OnPreferenceChangeListener ;
import android . support . v4 . app . SherlockPreferenceActivity ;
public class GoPrefsActivity extends SherlockPreferenceActivity implements OnPreferenceChangeListener {
private ListPreference <unk> ;
private ListPreference <unk> ;
private ListPreference <unk> ;
private EditTextPreference <unk> ;
private EditTextPreference <unk> ;
private ListPreference <unk> ;
private CheckBoxPreference SGFLegendCheckBoxPref ;
private CheckBoxPreference doLegendCheckBoxPref ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setPreferenceScreen ( createPreferenceHierarchy ( ) ) ;
}
private PreferenceScreen createPreferenceHierarchy ( ) {
GobandroidSettings settings = new GobandroidSettings ( this ) ;
PreferenceScreen root = getPreferenceManager ( ) . createPreferenceScreen ( this ) ;
root . setPersistent ( true ) ;
PreferenceCategory uiPrefCat = new PreferenceCategory ( this ) ;
uiPrefCat . setTitle ( R . string . screen ) ;
root . addPreference ( uiPrefCat ) ;
if ( ! getResources ( ) . getBoolean ( R . bool . force_fullscreen ) ) {
CheckBoxPreference fullscreenCheckBoxPref = new CheckBoxPreference ( this ) ;
fullscreenCheckBoxPref . setKey ( GobandroidSettings . KEY_FULLSCREEN ) ;
fullscreenCheckBoxPref . setTitle ( R . string . <unk> ) ;
fullscreenCheckBoxPref . setSummary ( R . string . <unk> ) ;
uiPrefCat . addPreference ( fullscreenCheckBoxPref ) ;
}
doLegendCheckBoxPref = new CheckBoxPreference ( this ) ;
doLegendCheckBoxPref . setKey ( GobandroidSettings . KEY_DO_LEGEND ) ;
doLegendCheckBoxPref . setTitle ( R . string . <unk> ) ;
doLegendCheckBoxPref . setSummary ( R . string . <unk> ) ;
doLegendCheckBoxPref . setDefaultValue ( settings . isLegendEnabled ( ) ) ;
doLegendCheckBoxPref . setOnPreferenceChangeListener ( this ) ;
uiPrefCat . addPreference ( doLegendCheckBoxPref ) ;
SGFLegendCheckBoxPref = new CheckBoxPreference ( this ) ;
SGFLegendCheckBoxPref . setKey ( GobandroidSettings . KEY_SGF_LEGEND ) ;
SGFLegendCheckBoxPref . setTitle ( R . string . <unk> ) ;
SGFLegendCheckBoxPref . setSummary ( R . string . <unk> ) ;
SGFLegendCheckBoxPref . setDefaultValue ( settings . isSGFLegendEnabled ( ) ) ;
uiPrefCat . addPreference ( SGFLegendCheckBoxPref ) ;
CheckBoxPreference doEmbossCheckBoxPref = new CheckBoxPreference ( this ) ;
doEmbossCheckBoxPref . setKey ( GobandroidSettings . KEY_GRID_EMBOSS ) ;
doEmbossCheckBoxPref . setTitle ( R . string . <unk> ) ;
doEmbossCheckBoxPref . setDefaultValue ( settings . isGridEmbossEnabled ( ) ) ;
doEmbossCheckBoxPref . setSummary ( R . string . <unk> ) ;
uiPrefCat . addPreference ( doEmbossCheckBoxPref ) ;
CheckBoxPreference keepScreenAwakeCheckBoxPref = new CheckBoxPreference ( this ) ;
keepScreenAwakeCheckBoxPref . setKey ( GobandroidSettings . KEY_WAKE_LOCK ) ;
keepScreenAwakeCheckBoxPref . setTitle ( R . string . <unk> ) ;
keepScreenAwakeCheckBoxPref . setSummary ( R . string . <unk> ) ;
keepScreenAwakeCheckBoxPref . setDefaultValue ( settings . isWakeLockEnabled ( ) ) ;
uiPrefCat . addPreference ( keepScreenAwakeCheckBoxPref ) ;
new SetPreferenceEnabledByCheckBoxPreferenceState ( doLegendCheckBoxPref ) . <unk> ( SGFLegendCheckBoxPref ) ;
PreferenceCategory soundPrefCat = new PreferenceCategory ( this ) ;
soundPrefCat . setTitle ( R . string . sound ) ;
root . addPreference ( soundPrefCat ) ;
CheckBoxPreference soundCheckBoxPref = new CheckBoxPreference ( this ) ;
soundCheckBoxPref . setKey ( GobandroidSettings . KEY_SOUND ) ;
soundCheckBoxPref . setTitle ( R . string . <unk> ) ;
soundCheckBoxPref . setSummary ( R . string . <unk> ) ;
soundPrefCat . addPreference ( soundCheckBoxPref ) ;
return root ;
}
@Override
public boolean onPreferenceChange ( Preference preference , Object newValue ) {
return true ;
}
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
public class GoInteractionProvider {
public final static byte MODE_RECORD = <num> ;
public final static byte MODE_TSUMEGO = <num> ;
public final static byte MODE_REVIEW = <num> ;
public final static byte MODE_GNUGO = <num> ;
public final static byte MODE_TELEVIZE = <num> ;
public static int touch_position =  <num> ;
private static byte mode ;
public static void setTouchPosition ( int pos ) {
touch_position = pos ;
}
public static int getTouchPosition ( ) {
return touch_position ;
}
public static int getTouchX ( ) {
return touch_position % GoGameProvider . getGame ( ) . getSize ( ) ;
}
public static int getTouchY ( ) {
return touch_position / GoGameProvider . getGame ( ) . getSize ( ) ;
}
public static boolean hasValidTouchCoord ( ) {
return ( ( touch_position >= <num> ) && ( touch_position < GoGameProvider . getGame ( ) . getSize ( ) * GoGameProvider . getGame ( ) . getSize ( ) ) ) ;
}
public static byte getMode ( ) {
return mode ;
}
public static void setMode ( byte mode ) {
GoInteractionProvider . mode = mode ;
}
}
package org . ligi . gobandroid_hd . ui . sgf_listing ;
import java . io . File ;
import java . io . IOException ;
import org . ligi . android . common . files . FileHelper ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . MetaDataFormater ;
import org . ligi . gobandroid_hd . logic . SGFHelper ;
import android . app . Activity ;
import android . content . Context ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . BaseAdapter ;
import android . widget . ImageView ;
import android . widget . LinearLayout ;
import android . widget . TextView ;
class ReviewPathViewAdapter extends BaseAdapter {
private Activity activity ;
private String [ ] menu_items ;
private String path ;
public ReviewPathViewAdapter ( Activity activity , String [ ] menu_items , String path ) {
this . activity = activity ;
this . menu_items = menu_items ;
this . path = path ;
}
@Override
public int getCount ( ) {
return menu_items . length ;
}
@Override
public Object getItem ( int position ) {
return null ;
}
@Override
public long getItemId ( int position ) {
return <num> ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
LayoutInflater inflater = ( LayoutInflater ) activity
. getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ;
String base_fname = path + " + menu_items [ position ] ;
View v ;
if ( new File ( base_fname ) . isDirectory ( ) ) {
v = inflater . inflate ( R . layout . sgf_dir_list_item , null ) ;
LinearLayout container = ( LinearLayout ) v . findViewById ( R . id . thumb_container ) ;
container . setVisibility ( View . GONE ) ;
}
else {
v = inflater . inflate ( R . layout . <unk> , null ) ;
GoGame game = null ;
try {
String sgf_str ;
if ( GoLink . isGoLink ( base_fname ) ) {
GoLink gl = new GoLink ( base_fname ) ;
sgf_str = gl . getSGFString ( ) ;
( ( TextView ) v . findViewById ( R . id . game_link_extra_infos ) ) . setText ( " + gl . getMoveDepth ( ) ) ;
} else {
( ( TextView ) v . findViewById ( R . id . game_link_extra_infos ) ) . setVisibility ( View . GONE ) ;
sgf_str = FileHelper . file2String ( new File ( base_fname ) ) ;
}
game = SGFHelper . sgf2game ( sgf_str , null , SGFHelper . BREAKON_FIRSTMOVE ) ;
if ( game != null ) {
MetaDataFormater meta = new MetaDataFormater ( game ) ;
TextView player_white_tv = ( TextView ) v . findViewById ( R . id . <unk> ) ;
if ( player_white_tv != null ) {
if ( meta . getWhitePlayerString ( ) . equals ( " ) ) {
( ( ImageView ) v . findViewById ( R . id . <unk> ) ) . setVisibility ( View . GONE ) ;
player_white_tv . setVisibility ( View . GONE ) ;
}
else
player_white_tv . setText ( meta . getWhitePlayerString ( ) ) ;
}
TextView player_black_tv = ( TextView ) v . findViewById ( R . id . <unk> ) ;
if ( player_black_tv != null ) {
if ( meta . getBlackPlayerString ( ) . equals ( " ) ) {
( ( ImageView ) v . findViewById ( R . id . <unk> ) ) . setVisibility ( View . GONE ) ;
player_black_tv . setVisibility ( View . GONE ) ;
}
else
player_black_tv . setText ( meta . getBlackPlayerString ( ) ) ;
}
TextView title_tv = ( TextView ) v . findViewById ( R . id . <unk> ) ;
if ( title_tv != null ) {
title_tv . setText ( meta . getExtrasString ( ) ) ;
}
}
} catch ( IOException e ) {
}
}
TextView title_tv = ( TextView ) v . findViewById ( R . id . filename ) ;
if ( title_tv != null ) {
title_tv . setText ( menu_items [ position ] ) ;
}
return v ;
}
package org . ligi . gobandroid_hd . ui ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . net . Uri ;
import android . os . Bundle ;
import android . os . Handler ;
import android . os . Looper ;
import android . view . ViewGroup . LayoutParams ;
import android . widget . FrameLayout ;
import android . widget . ImageView ;
import android . widget . LinearLayout ;
import android . widget . ProgressBar ;
import android . widget . TextView ;
import java . io . BufferedInputStream ;
import java . io . File ;
import java . io . FileOutputStream ;
import java . io . InputStream ;
import java . net . URL ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GnuGoMover ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . logic . SGFHelper ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . gobandroid_hd . ui . ingame_common . SwitchModeHelper ;
import org . ligi . tracedroid . logging . Log ;
public class SGFLoadActivity
extends GobandroidFragmentActivity
implements Runnable , SGFHelper . ISGFLoadProgressCallback
{
private GoGame game = null ;
private Uri intent_uri ;
private String sgf ;
private ProgressBar progress ;
private int act_progress ;
private int max_progress ;
private Handler handler = new Handler ( ) ;
private AlertDialog alert_dlg ;
private TextView message_tv ;
private String act_message ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
GoPrefs . init ( this ) ;
progress = new ProgressBar ( this , null , android . R . attr . <unk> ) ;
progress . setMax ( <num> ) ;
progress . setProgress ( <num> ) ;
LinearLayout lin = new LinearLayout ( this ) ;
ImageView img = new ImageView ( this ) ;
img . setImageResource ( R . drawable . icon ) ;
img . setLayoutParams ( new LinearLayout . LayoutParams ( LayoutParams . FILL_PARENT , LayoutParams . WRAP_CONTENT ) ) ;
lin . setOrientation ( LinearLayout . VERTICAL ) ;
lin . addView ( img ) ;
FrameLayout frame = new FrameLayout ( this ) ;
frame . addView ( progress ) ;
message_tv = new TextView ( this ) ;
message_tv . setText ( " ) ;
message_tv . setTextColor ( <num> ) ;
message_tv . setPadding ( <num> , <num> , <num> , <num> ) ;
frame . addView ( message_tv ) ;
lin . addView ( frame ) ;
alert_dlg = new AlertDialog . Builder ( this ) . setCancelable ( false ) . setTitle ( R . string . <unk> ) . setView ( lin ) . show ( ) ;
getTracker ( ) . trackPageView ( " + getIntent ( ) . getData ( ) . toString ( ) . replace ( " , " ) . replace ( " , " ) ) ;
getTracker ( ) . trackEvent ( " , " , getIntent ( ) . getData ( ) . toString ( ) ,  <num> ) ;
new Thread ( this ) . start ( ) ;
}
@Override
public void onResume ( ) {
super . onResume ( ) ;
}
@Override
public void run ( ) {
Looper . prepare ( ) ;
String src = " ;
if ( game == null ) {
if ( getLastNonConfigurationInstance ( ) != null )
game = ( GoGame ) getLastNonConfigurationInstance ( ) ;
else {
intent_uri = getIntent ( ) . getData ( ) ;
if ( intent_uri != null ) {
try {
InputStream in ;
Log . i ( " + intent_uri ) ;
if ( intent_uri . toString ( ) . startsWith ( " ) )
in = getContentResolver ( ) . openInputStream ( intent_uri ) ;
else
in = new BufferedInputStream ( new URL ( " + intent_uri ) . openStream ( ) , <num> ) ;
FileOutputStream file_writer = null ;
if ( intent_uri . toString ( ) . startsWith ( " ) ) {
new File ( GoPrefs . getSGFPath ( ) + " ) . mkdirs ( ) ;
File f = new File ( GoPrefs . getSGFPath ( ) + " + intent_uri . getLastPathSegment ( ) ) ;
f . createNewFile ( ) ;
file_writer = new FileOutputStream ( f ) ;
}
src = intent_uri . toString ( ) ;
StringBuffer out = new StringBuffer ( ) ;
byte [ ] b = new byte [ <num> ] ;
for ( int n ; ( n = in . read ( b ) ) !=  <num> ; ) {
out . append ( new String ( b , <num> , n ) ) ;
if ( file_writer != null )
file_writer . write ( b , <num> , n ) ;
}
if ( file_writer != null )
file_writer . close ( ) ;
sgf = out . toString ( ) ;
Log . i ( " + sgf ) ;
game = SGFHelper . sgf2game ( sgf , this ) ;
if ( ! src . startsWith ( " ) )
GoInteractionProvider . setMode ( GoInteractionProvider . MODE_REVIEW ) ;
} catch ( Exception e ) {
Log . w ( " , e ) ;
handler . post ( new Runnable ( ) {
@Override
public void run ( ) {
alert_dlg . hide ( ) ;
new AlertDialog . Builder ( SGFLoadActivity . this ) . setTitle ( R . string . results )
. setMessage (
"
) . setPositiveButton ( R . string . yes , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
final Intent emailIntent = new Intent ( android . content . Intent . ACTION_SEND ) ;
emailIntent . setType ( " ) ;
emailIntent . putExtra ( android . content . Intent . EXTRA_EMAIL , new String [ ] { " } ) ;
emailIntent . putExtra ( android . content . Intent . EXTRA_SUBJECT , " ) ;
emailIntent . putExtra ( android . content . Intent . EXTRA_TEXT , " + intent_uri + " + sgf + " + Log . <unk> ( ) ) ;
SGFLoadActivity . this . startActivity ( Intent . createChooser ( emailIntent , " ) ) ;
finish ( ) ;
}
} ) . setNegativeButton ( R . string . no , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
finish ( ) ;
}
} ) . show ( ) ;
} }
) ;
return ;
}
}
else {
byte size = getIntent ( ) . getByteExtra ( " , ( byte ) <num> ) ;
byte handicap = getIntent ( ) . getByteExtra ( " , ( byte ) <num> ) ;
int white_player = getIntent ( ) . getIntExtra ( " , <num> ) ;
int black_player = getIntent ( ) . getIntExtra ( " , <num> ) ;
game = new GoGame ( size , handicap ) ;
game . setGoMover ( new GnuGoMover ( this , game , black_player != <num> , white_player != <num> , GoPrefs . getAILevel ( ) ) ) ;
}
}
}
int move_num = getIntent ( ) . getIntExtra ( " ,  <num> ) ;
if ( move_num !=  <num> )
for ( int i = <num> ; i < move_num ; i ++ )
game . jump ( game . getActMove ( ) . getnextMove ( <num> ) ) ;
GoGameProvider . setGame ( game ) ;
game . getMetaData ( ) . setFileName ( src ) ;
handler . post ( new Runnable ( ) {
@Override
public void run ( ) {
alert_dlg . hide ( ) ;
finish ( ) ;
} }
) ;
SwitchModeHelper . startGameWithCorrectMode ( this ) ;
}
@Override
public void progress ( int act , int max , String Message ) {
act_progress = act ;
max_progress = max ;
act_message = Message ;
handler . post ( new Runnable ( ) {
@Override
public void run ( ) {
progress . setProgress ( act_progress ) ;
progress . setMax ( max_progress ) ;
message_tv . setText ( act_message ) ;
} } ) ;
}
package org . ligi . gobandroid_hd . ui ;
import java . util . HashMap ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . content . Context ;
import android . media . AudioManager ;
import android . media . MediaPlayer ;
import android . media . MediaPlayer . OnErrorListener ;
import android . media . MediaPlayer . OnPreparedListener ;
import android . media . SoundPool ;
import android . media . MediaPlayer . OnCompletionListener ;
public class GoSoundManager {
private SoundPool mSoundPool ;
private HashMap < Integer , Integer > mSoundPoolMap ;
private AudioManager mAudioManager ;
private GobandroidFragmentActivity mContext ;
private boolean intro_sound_played = false ;
public final static int SOUND_START = <num> ;
public final static int SOUND_END = <num> ;
public final static int SOUND_PLACE1 = <num> ;
public final static int SOUND_PLACE2 = <num> ;
public final static int SOUND_PICKUP1 = <num> ;
public final static int SOUND_PICKUP2 = <num> ;
public GoSoundManager ( GobandroidFragmentActivity theContext ) {
Log . i ( " ) ;
mContext = theContext ;
mSoundPool = new SoundPool ( <num> , AudioManager . STREAM_MUSIC , <num> ) ;
mSoundPoolMap = new HashMap < Integer , Integer > ( ) ;
mAudioManager = ( AudioManager ) mContext . getSystemService ( Context . AUDIO_SERVICE ) ;
addSound ( SOUND_START , R . raw . go_start ) ;
addSound ( SOUND_END , R . raw . <unk> ) ;
addSound ( SOUND_PLACE1 , R . raw . <unk> ) ;
addSound ( SOUND_PLACE2 , R . raw . <unk> ) ;
addSound ( SOUND_PICKUP1 , R . raw . <unk> ) ;
addSound ( SOUND_PICKUP2 , R . raw . <unk> ) ;
}
public void addSound ( int index , int SoundID ) {
mSoundPoolMap . put ( index , mSoundPool . load ( mContext , SoundID , <num> ) ) ;
}
public void playSound ( int index ) {
if ( ( ! mContext . getSettings ( ) . isSoundEnabled ( ) ) || ( ! intro_sound_played ) )
return ;
Log . i ( " + index ) ;
float streamVolume = mAudioManager . getStreamVolume ( AudioManager . STREAM_MUSIC ) ;
streamVolume = streamVolume / mAudioManager . getStreamMaxVolume ( AudioManager . STREAM_MUSIC ) ;
mSoundPool . play ( mSoundPoolMap . get ( index ) , streamVolume , streamVolume , <num> , <num> , <num> ) ;
}
public void playGameIntro ( ) {
if ( ! mContext . getSettings ( ) . isSoundEnabled ( ) )
return ;
if ( intro_sound_played )
return ;
MediaPlayer mp = MediaPlayer . create ( mContext , R . raw . go_start ) ;
mp . setOnCompletionListener ( new OnCompletionListener ( ) {
@Override
public void onCompletion ( MediaPlayer mp ) {
mp . release ( ) ;
intro_sound_played = true ;
}
} ) ;
mp . setOnErrorListener ( new OnErrorListener ( ) {
@Override
public boolean onError ( MediaPlayer mp , int what , int extra ) {
Log . i ( " ) ;
return false ;
}
} ) ;
mp . setOnPreparedListener ( new OnPreparedListener ( ) {
@Override
public void onPrepared ( MediaPlayer mp ) {
mp . start ( ) ;
}
} ) ;
try {
mp . prepareAsync ( ) ;
} catch ( IllegalStateException e ) {
Log . i ( " + e ) ;
intro_sound_played = true ;
}
}
}
package org . ligi . gobandroid_hd . ui ;
import java . io . File ;
import java . io . FileOutputStream ;
import java . io . InputStream ;
import java . util . zip . ZipEntry ;
import java . util . zip . ZipInputStream ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . app . ProgressDialog ;
import android . content . Intent ;
import android . content . res . Resources ;
public class UnzipSGFsDialog {
public static class Decompress {
private InputStream _zipFile ;
private String _location ;
public Decompress ( InputStream zipFile , String location ) {
_zipFile = zipFile ;
_location = location ;
_dirChecker ( " ) ;
}
public void unzip ( ) {
try {
InputStream fin = _zipFile ;
ZipInputStream zin = new ZipInputStream ( fin ) ;
ZipEntry ze = null ;
while ( ( ze = zin . getNextEntry ( ) ) != null ) {
Log . i ( " + " + ze . getName ( ) ) ;
if ( ze . isDirectory ( ) ) {
_dirChecker ( ze . getName ( ) ) ;
} else {
FileOutputStream fout = new FileOutputStream ( _location + ze . getName ( ) ) ;
for ( int c = zin . read ( ) ; c !=  <num> ; c = zin . read ( ) ) {
fout . write ( c ) ;
}
zin . closeEntry ( ) ;
fout . close ( ) ;
}
}
zin . close ( ) ;
} catch ( Exception e ) {
Log . e ( " , " , e ) ;
}
}
private void _dirChecker ( String dir ) {
File f = new File ( _location + dir ) ;
if ( ! f . isDirectory ( ) ) {
f . mkdirs ( ) ;
}
}
}
public static void show ( GobandroidFragmentActivity activity , Intent intent_after_finish ) {
ProgressDialog dialog = ProgressDialog . show ( activity , " ,
" , true ) ;
class AlertDialogUpdater implements Runnable {
private ProgressDialog myProgress ;
private GobandroidFragmentActivity activity ;
private Intent intent_after_finish ;
public AlertDialogUpdater ( GobandroidFragmentActivity activity , ProgressDialog progress , Intent intent_after_finish ) {
this . activity = activity ;
this . intent_after_finish = intent_after_finish ;
myProgress = progress ;
}
public void run ( ) {
Resources resources = activity . getResources ( ) ;
InputStream is = resources . openRawResource ( R . raw . <unk> ) ;
new Decompress ( is , activity . getSettings ( ) . getSGFBasePath ( ) ) . unzip ( ) ;
myProgress . dismiss ( ) ;
activity . startActivity ( intent_after_finish ) ;
}
}
new Thread ( new AlertDialogUpdater ( activity , dialog , intent_after_finish ) ) . start ( ) ;
}
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
public class <unk> {
public static void <unk> ( GobandroidFragmentActivity ctx ) {
new AutoScreenShotTask ( ctx ) . execute ( ctx . getSettings ( ) . getTsumegoPath ( ) ) ;
}
public static void <unk> ( GobandroidFragmentActivity ctx ) {
new AutoScreenShotTask ( ctx ) . execute ( ctx . getSettings ( ) . getReviewPath ( ) ) ;
}
}
package org . ligi . gobandroid_hd . logic ;
public class MetaDataFormater {
private GoGameMetadata meta ;
private GoGame game ;
public MetaDataFormater ( GoGame game ) {
this . meta = game . getMetaData ( ) ;
this . game = game ;
}
public String getBlackPlayerString ( ) {
StringBuilder res = new StringBuilder ( ) ;
res . append ( meta . getBlackName ( ) ) ;
if ( ! meta . getBlackRank ( ) . equals ( " ) )
res . append ( " + meta . getBlackRank ( ) + " ) ;
return res . toString ( ) ;
}
public String getWhitePlayerString ( ) {
StringBuilder res = new StringBuilder ( ) ;
res . append ( meta . getWhiteName ( ) ) ;
if ( ! meta . getWhiteRank ( ) . equals ( " ) )
res . append ( " + meta . getWhiteRank ( ) + " ) ;
return res . toString ( ) ;
}
public String getExtrasString ( ) {
StringBuilder res = new StringBuilder ( " + game . getKomi ( ) ) ;
if ( ! meta . getResult ( ) . equals ( " ) )
res . append ( " + meta . getResult ( ) ) ;
return res . toString ( ) ;
}
package org . ligi . gobandroid_hd . ui . tsumego ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . logic . GoMarker ;
import org . ligi . gobandroid_hd . logic . GoMove ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
public class TsumegoHintAlert {
public static void show ( Activity activity , final GoMove finishing_move ) {
new AlertDialog . Builder ( activity )
. setTitle ( R . string . hint )
. setItems ( R . array . <unk> , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int item ) {
switch ( item ) {
case <num> :
mark_path ( finishing_move , true ) ;
break ;
case <num> :
mark_path ( finishing_move , true ) ;
break ;
case <num> :
show_numbered_solution ( finishing_move ) ;
break ;
}
}
} )
. show ( ) ;
}
private static void show_numbered_solution ( GoMove finishing_move ) {
GoMove myActMove = finishing_move ;
int p = myActMove . getMovePos ( ) ;
while ( true ) {
if ( myActMove . isFirstMove ( ) )
break ;
finishing_move . addMarker ( new GoMarker ( myActMove . getX ( ) , myActMove . getY ( ) , " + p ) ) ;
p  ;
myActMove = myActMove . getParent ( ) ;
}
GoGameProvider . getGame ( ) . jump ( finishing_move ) ;
}
private static void mark_path ( GoMove finishing_move , boolean complete ) {
GoMove myActMove = finishing_move ;
while ( true ) {
if ( myActMove . isFirstMove ( ) )
break ;
if ( complete || ( myActMove . getParent ( ) == GoGameProvider . getGame ( ) . getActMove ( ) ) )
myActMove . getParent ( ) . addMarker ( new GoMarker ( myActMove . getX ( ) , myActMove . getY ( ) , " ) ) ;
myActMove = myActMove . getParent ( ) ;
}
GoGameProvider . getGame ( ) . notifyGameChange ( ) ;
}
}
package org . ligi . gobandroid_hd . ui ;
import java . io . File ;
import org . ligi . android . common . dialogs . DialogDiscarder ;
import org . ligi . android . common . intents . IntentHelper ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GnuGoMover ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . gobandroid_hd . ui . links . LinksActivity ;
import org . ligi . gobandroid_hd . ui . sgf_listing . SGFSDCardListActivity ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
import android . content . DialogInterface . OnClickListener ;
import android . content . Intent ;
import android . net . Uri ;
import android . os . Bundle ;
import android . os . Environment ;
import android . support . v4 . view . MenuItem ;
import android . view . View ;
public class gobandroid extends GobandroidFragmentActivity {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main_menu ) ;
new GoSoundManager ( this ) ;
}
public void <unk> ( View target ) {
getTracker ( ) . trackPageView ( " ) ;
GoInteractionProvider . setMode ( GoInteractionProvider . MODE_RECORD ) ;
this . startActivity ( new Intent ( this , GoSetupActivity . class ) ) ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
return true ;
}
return super . onOptionsItemSelected ( item ) ;
}
private Intent startLoad ( String path , byte mode ) {
Intent i = new Intent ( this , SGFSDCardListActivity . class ) ;
i . setData ( ( Uri . parse ( " + path ) ) ) ;
GoInteractionProvider . setMode ( mode ) ;
return i ;
}
public void <unk> ( View target ) {
getTracker ( ) . trackPageView ( " ) ;
Intent next = startLoad ( getSettings ( ) . getTsumegoPath ( ) , GoInteractionProvider . MODE_TSUMEGO ) ;
if ( ! unzipSGFifNeeded ( next ) )
startActivity ( next ) ;
}
public void <unk> ( View target ) {
getTracker ( ) . trackPageView ( " ) ;
Intent next = startLoad ( getSettings ( ) . getReviewPath ( ) , GoInteractionProvider . MODE_REVIEW ) ;
if ( ! unzipSGFifNeeded ( next ) )
startActivity ( next ) ;
}
public boolean unzipSGFifNeeded ( Intent intent_after ) {
String storrage_state = Environment . getExternalStorageState ( ) ;
if ( ( storrage_state . equals ( Environment . MEDIA_MOUNTED ) && ( ! ( new File ( getSettings ( ) . getTsumegoPath ( ) ) ) . isDirectory ( ) ) ) ) {
UnzipSGFsDialog . show ( this , intent_after ) ;
return true ;
}
return false ;
}
public void <unk> ( View target ) {
getTracker ( ) . trackPageView ( " ) ;
this . startActivity ( new Intent ( this , LinksActivity . class ) ) ;
}
public void <unk> ( View target ) {
if ( ! IntentHelper . <unk> ( new Intent ( GnuGoMover . intent_action_name ) , this . getPackageManager ( ) , <num> ) ) {
getTracker ( ) . trackPageView ( " ) ;
new AlertDialog . Builder ( this )
. setMessage ( R . string . <unk> )
. setTitle ( R . string . problem )
. setNegativeButton ( android . R . string . cancel , new DialogDiscarder ( ) )
. setPositiveButton ( R . string . <unk> , new OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialog , int which ) {
try {
IntentHelper . <unk> ( gobandroid . this , " ) ;
} catch ( Exception e ) {
Intent fail_intent = new Intent ( ) ;
fail_intent . setAction ( Intent . ACTION_VIEW ) ;
fail_intent . setData ( Uri . parse ( " ) ) ;
gobandroid . this . startActivity ( fail_intent ) ;
}
}
} )
. show ( ) ;
return ;
}
getTracker ( ) . trackPageView ( " ) ;
GoInteractionProvider . setMode ( GoInteractionProvider . MODE_GNUGO ) ;
this . startActivity ( new Intent ( this , GoSetupActivity . class ) ) ;
}
public void <unk> ( View target ) {
this . startActivity ( new Intent ( this , GoPrefsActivity . class ) ) ;
}
package org . ligi . gobandroid_hd . ui ;
import java . util . HashMap ;
import org . ligi . android . common . views . ActivityFinishOnViewClickListener ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . os . Bundle ;
import android . text . util . Linkify ;
import android . widget . Button ;
import android . widget . TextView ;
public class GoTermsViewActivity extends GobandroidFragmentActivity {
public final static HashMap < String , Integer > getTerm2resHashMap ( ) {
HashMap < String , Integer > res = new HashMap < String , Integer > ( ) ;
res . put ( " , R . string . <unk> ) ;
res . put ( " , R . string . <unk> ) ;
res . put ( " , R . string . <unk> ) ;
res . put ( " , R . string . <unk> ) ;
return res ;
}
@Override
public void onCreate ( Bundle savedInstanceState ) {
String term = this . getIntent ( ) . getData ( ) . getLastPathSegment ( ) ;
this . setTitle ( term ) ;
this . setContentView ( R . layout . <unk> ) ;
TextView tv = ( TextView ) this . findViewById ( R . id . <unk> ) ;
if ( getTerm2resHashMap ( ) . containsKey ( term ) )
tv . setText ( getTerm2resHashMap ( ) . get ( term ) ) ;
else {
tv . setText ( " ) ;
Log . w ( " + term ) ;
}
Linkify . addLinks ( tv , Linkify . ALL ) ;
( ( Button ) this . findViewById ( R . id . <unk> ) ) . setOnClickListener ( new ActivityFinishOnViewClickListener ( this ) ) ;
super . onCreate ( savedInstanceState ) ;
}
}
package org . ligi . gobandroid_hd . ui . alerts ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import android . app . AlertDialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . widget . EditText ;
import android . widget . ScrollView ;
import android . widget . TableLayout ;
import android . widget . TableRow ;
import android . widget . TextView ;
public class GameInfoAlert {
public static void show ( Context ctx , final GoGame game ) {
ScrollView scroll_view = new ScrollView ( ctx ) ;
TableLayout table_gameinfo = new TableLayout ( ctx ) ;
TableRow row_gameinfo = new TableRow ( ctx ) ;
table_gameinfo . <unk> ( <num> , true ) ;
final EditText game_name_et = new EditText ( ctx ) ;
game_name_et . setText ( game . getMetaData ( ) . getName ( ) ) ;
game_name_et . setPadding ( <num> , <num> , <num> , <num> ) ;
TextView game_name_tv = new TextView ( ctx ) ;
game_name_tv . setText ( R . string . <unk> ) ;
row_gameinfo . addView ( game_name_tv ) ;
row_gameinfo . addView ( game_name_et ) ;
table_gameinfo . addView ( row_gameinfo ) ;
TableRow row_black_name = new TableRow ( ctx ) ;
final EditText black_name_et = new EditText ( ctx ) ;
black_name_et . setText ( game . getMetaData ( ) . getBlackName ( ) ) ;
black_name_et . setPadding ( <num> , <num> , <num> , <num> ) ;
TextView black_name_tv = new TextView ( ctx ) ;
black_name_tv . setPadding ( <num> , <num> , <num> , <num> ) ;
black_name_tv . setText ( R . string . black_name ) ;
row_black_name . addView ( black_name_tv ) ;
row_black_name . addView ( black_name_et ) ;
table_gameinfo . addView ( row_black_name ) ;
TableRow row_black_rank = new TableRow ( ctx ) ;
final EditText black_rank_et = new EditText ( ctx ) ;
black_rank_et . setText ( game . getMetaData ( ) . getBlackRank ( ) ) ;
black_rank_et . setPadding ( <num> , <num> , <num> , <num> ) ;
TextView black_rank_tv = new TextView ( ctx ) ;
black_rank_tv . setPadding ( <num> , <num> , <num> , <num> ) ;
black_rank_tv . setText ( R . string . black_rank ) ;
row_black_rank . addView ( black_rank_tv ) ;
row_black_rank . addView ( black_rank_et ) ;
table_gameinfo . addView ( row_black_rank ) ;
TableRow row_white_name = new TableRow ( ctx ) ;
final EditText white_name_et = new EditText ( ctx ) ;
white_name_et . setText ( game . getMetaData ( ) . getWhiteName ( ) ) ;
white_name_et . setPadding ( <num> , <num> , <num> , <num> ) ;
TextView white_name_tv = new TextView ( ctx ) ;
white_name_tv . setPadding ( <num> , <num> , <num> , <num> ) ;
white_name_tv . setText ( R . string . white_name ) ;
row_white_name . addView ( white_name_tv ) ;
row_white_name . addView ( white_name_et ) ;
table_gameinfo . addView ( row_white_name ) ;
TableRow row_white_rank = new TableRow ( ctx ) ;
final EditText white_rank_et = new EditText ( ctx ) ;
white_rank_et . setText ( game . getMetaData ( ) . getWhiteRank ( ) ) ;
white_rank_et . setPadding ( <num> , <num> , <num> , <num> ) ;
TextView white_rank_tv = new TextView ( ctx ) ;
white_rank_tv . setPadding ( <num> , <num> , <num> , <num> ) ;
white_rank_tv . setText ( R . string . white_rank ) ;
row_white_rank . addView ( white_rank_tv ) ;
row_white_rank . addView ( white_rank_et ) ;
table_gameinfo . addView ( row_white_rank ) ;
TableRow game_komi_row = new TableRow ( ctx ) ;
final EditText game_komi_et = new EditText ( ctx ) ;
game_komi_et . setText ( Float . toString ( game . getKomi ( ) ) ) ;
game_komi_et . setPadding ( <num> , <num> , <num> , <num> ) ;
TextView game_komi_tv = new TextView ( ctx ) ;
game_komi_tv . setPadding ( <num> , <num> , <num> , <num> ) ;
game_komi_tv . setText ( R . string . komi ) ;
game_komi_row . addView ( game_komi_tv ) ;
game_komi_row . addView ( game_komi_et ) ;
table_gameinfo . addView ( game_komi_row ) ;
TableRow game_result_row = new TableRow ( ctx ) ;
final EditText game_result_et = new EditText ( ctx ) ;
game_result_et . setText ( game . getMetaData ( ) . getResult ( ) ) ;
game_result_et . setPadding ( <num> , <num> , <num> , <num> ) ;
TextView game_result_tv = new TextView ( ctx ) ;
game_result_tv . setPadding ( <num> , <num> , <num> , <num> ) ;
game_result_tv . setText ( R . string . <unk> ) ;
game_result_row . addView ( game_result_tv ) ;
game_result_row . addView ( game_result_et ) ;
table_gameinfo . addView ( game_result_row ) ;
scroll_view . addView ( table_gameinfo ) ;
new AlertDialog . Builder ( ctx ) . setTitle ( R . string . <unk> ) . setView ( scroll_view )
. setMessage ( " ) . setPositiveButton ( R . string . ok , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
game . getMetaData ( ) . setName ( game_name_et . getText ( ) . toString ( ) ) ;
game . getMetaData ( ) . setBlackName ( black_name_et . getText ( ) . toString ( ) ) ;
game . getMetaData ( ) . setBlackRank ( black_rank_et . getText ( ) . toString ( ) ) ;
game . getMetaData ( ) . setWhiteName ( white_name_et . getText ( ) . toString ( ) ) ;
game . getMetaData ( ) . setWhiteRank ( white_rank_et . getText ( ) . toString ( ) ) ;
game . setKomi ( new Float ( game_komi_et . getText ( ) . toString ( ) ) ) ;
game . getMetaData ( ) . setResult ( game_result_et . getText ( ) . toString ( ) ) ;
}
} ) . show ( ) ;
}
package org . ligi . gobandroid_hd . ui . recording ;
import java . io . BufferedWriter ;
import java . io . File ;
import java . io . FileWriter ;
import java . io . IOException ;
import java . text . SimpleDateFormat ;
import java . util . Date ;
import org . ligi . android . common . dialogs . DialogDiscarder ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGameMetadata ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . logic . SGFHelper ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . net . Uri ;
import android . view . ContextThemeWrapper ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . CheckBox ;
import android . widget . EditText ;
import android . widget . TextView ;
public class SaveSGFDialog {
public static void show ( final GobandroidFragmentActivity ctx ) {
ContextThemeWrapper themed_ctx = new ContextThemeWrapper ( ctx , R . style . <unk> ) ;
View form = LayoutInflater . from ( themed_ctx ) . inflate ( R . layout . <unk> , null ) ;
TextView intro_text = ( TextView ) form . findViewById ( R . id . <unk> ) ;
intro_text . setText ( String . format ( themed_ctx . getResources ( ) . getString ( R . string . <unk> ) , ctx . getSettings ( ) . getSGFSavePath ( ) ) ) ;
final EditText input = ( EditText ) form . findViewById ( R . id . <unk> ) ;
final CheckBox share_checkbox = ( CheckBox ) form . findViewById ( R . id . share_checkbox ) ;
final GoGameMetadata game_meta = GoGameProvider . getGame ( ) . getMetaData ( ) ;
class FileNameAdder implements OnClickListener {
@Override
public void onClick ( View v ) {
switch ( v . getId ( ) ) {
case R . id . button_add_date :
SimpleDateFormat date_formatter = new SimpleDateFormat ( " ) ;
input . setText ( input . getText ( ) + date_formatter . format ( new Date ( ) ) ) ;
break ;
case R . id . button_add_gamename :
input . setText ( input . getText ( ) + game_meta . getName ( ) ) ;
break ;
case R . id . button_add_players :
input . setText ( input . getText ( ) + game_meta . getBlackName ( ) + " + game_meta . getWhiteName ( ) ) ;
break ;
}
}
}
FileNameAdder adder = new FileNameAdder ( ) ;
( ( Button ) ( form . findViewById ( R . id . button_add_date ) ) ) . setOnClickListener ( adder ) ;
Button add_name_btn = ( ( Button ) ( form . findViewById ( R . id . button_add_gamename ) ) ) ;
Button players_name_btn = ( ( Button ) ( form . findViewById ( R . id . button_add_players ) ) ) ;
if ( game_meta . getName ( ) . equals ( " ) )
add_name_btn . setVisibility ( View . GONE ) ;
else
add_name_btn . setOnClickListener ( adder ) ;
if ( game_meta . getBlackName ( ) . equals ( " ) && game_meta . getWhiteName ( ) . equals ( " ) )
players_name_btn . setVisibility ( View . GONE ) ;
else
players_name_btn . setOnClickListener ( adder ) ;
new AlertDialog . Builder ( themed_ctx ) . setTitle ( R . string . <unk> ) . setView ( form )
. setPositiveButton ( R . string . ok , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
String value = input . getText ( ) . toString ( ) ;
File f = new File ( ctx . getSettings ( ) . getSGFSavePath ( ) ) ;
if ( ! f . isDirectory ( ) )
f . mkdirs ( ) ;
try {
f = new File ( ctx . getSettings ( ) . getSGFSavePath ( ) + " + value + " ) ;
f . createNewFile ( ) ;
FileWriter sgf_writer = new FileWriter ( f ) ;
BufferedWriter out = new BufferedWriter ( sgf_writer ) ;
out . write ( SGFHelper . game2sgf ( GoGameProvider . getGame ( ) ) ) ;
out . close ( ) ;
sgf_writer . close ( ) ;
if ( share_checkbox . isChecked ( ) ) {
Intent it = new Intent ( Intent . ACTION_SEND ) ;
it . putExtra ( Intent . EXTRA_SUBJECT , " ) ;
it . putExtra ( Intent . EXTRA_STREAM , Uri . parse ( " + ctx . getSettings ( ) . getSGFSavePath ( ) + " + value + " ) ) ;
it . setType ( " ) ;
ctx . startActivity ( Intent . createChooser ( it , " ) ) ;
}
} catch ( IOException e ) {
Log . i ( " + e ) ;
}
}
} ) . setNegativeButton ( R . string . cancel , new DialogDiscarder ( ) ) . show ( ) ;
}
}
package org . ligi . gobandroid_hd . logic ;
public class GoDefinitions {
public final static byte PLAYER_BLACK = <num> ;
public final static byte PLAYER_WHITE = <num> ;
public final static byte STONE_NONE = <num> ;
public final static byte STONE_BLACK = <num> ;
public final static byte STONE_WHITE = <num> ;
private final static byte [ ] [ ] hoshis19x19 = {
{ <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> }
, { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> }
} ;
private final static byte [ ] [ ] hoshis13x13 = {
{ <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> }
, { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> }
} ;
private final static byte [ ] [ ] hoshis9x9 = {
{ <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> }
, { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> }
} ;
public final static byte [ ] [ ] getHandicapArray ( int board_size ) {
switch ( board_size ) {
case <num> :
return hoshis9x9 ;
case <num> :
return hoshis13x13 ;
case <num> :
return hoshis19x19 ;
}
return null ;
}
}
package org . ligi . gobandroid_hd . ui . alerts ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import android . app . Dialog ;
import android . content . Context ;
import android . view . View ;
import android . widget . Button ;
import android . widget . LinearLayout ;
import android . widget . TextView ;
public class GameForwardAlert {
public static void show ( Context ctx , final GoGame game ) {
if ( ! game . canRedo ( ) )
return ;
if ( game . getPossibleVariationCount ( ) > <num> ) {
LinearLayout lin = new LinearLayout ( ctx ) ;
LinearLayout li = new LinearLayout ( ctx ) ;
TextView txt = new TextView ( ctx ) ;
if ( game . getActMove ( ) . hasComment ( ) )
txt . setText ( game . getActMove ( ) . getComment ( ) ) ;
else
txt . setText ( " + ( game . getPossibleVariationCount ( ) + <num> ) + " ) ;
txt . setPadding ( <num> , <num> , <num> , <num> ) ;
lin . addView ( txt ) ;
lin . addView ( li ) ;
lin . setOrientation ( LinearLayout . VERTICAL ) ;
final Dialog select_dlg = new Dialog ( ctx ) ;
final Boolean redoing = false ;
View . OnClickListener var_select_listener = new View . OnClickListener ( ) {
@Override
public void onClick ( View v ) {
if ( redoing )
return ;
select_dlg . hide ( ) ;
if ( ! v . isEnabled ( ) ) return ;
v . setEnabled ( false ) ;
game . redo ( ( Integer ) ( v . getTag ( ) ) ) ;
}
} ;
li . setWeightSum ( <num> * ( game . getPossibleVariationCount ( ) + <num> ) ) ;
li . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . FILL_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ) ;
for ( Integer i = <num> ; i < game . getPossibleVariationCount ( ) + <num> ; i ++ )
{
Button var_btn = new Button ( ctx ) ;
var_btn . setTag ( i ) ;
var_btn . setOnClickListener ( var_select_listener ) ;
if ( game . getActMove ( ) . getnextMove ( i ) . isMarked ( ) )
var_btn . setText ( game . getActMove ( ) . getnextMove ( i ) . getMarkText ( ) ) ;
else
var_btn . setText ( " + ( i + <num> ) ) ;
li . addView ( var_btn ) ;
var_btn . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT , <num> ) ) ;
}
select_dlg . setTitle ( R . string . variations ) ;
select_dlg . setContentView ( lin ) ;
select_dlg . show ( ) ;
}
else
game . redo ( <num> ) ;
}
package org . ligi . gobandroid_hd . ui . review ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . ui . CommentAndNowPlayingFragment ;
import org . ligi . gobandroid_hd . ui . GoActivity ;
import org . ligi . gobandroid_hd . ui . GobanDroidTVActivity ;
import org . ligi . gobandroid_hd . ui . NavigationAndCommentFragment ;
import org . ligi . gobandroid_hd . ui . alerts . GameForwardAlert ;
import org . ligi . tracedroid . logging . Log ;
import android . content . Intent ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . support . v4 . view . Menu ;
import android . support . v4 . view . MenuItem ;
import android . view . KeyEvent ;
import android . view . View ;
public class GoGamePlayerActivity extends GoActivity {
private boolean autoplay_active = true ;
private int pause_for_last_move = <num> ;
private int pause_between_moves = <num> ;
private int pause_betwen_moves_extra_per_word = <num> ;
class autoPlayRunnable implements Runnable {
@Override
public void run ( ) {
Log . i ( " , " + GoGameProvider . getGame ( ) . getActMove ( ) . getNextMoveVariations ( ) . size ( ) ) ;
while ( autoplay_active && ( GoGameProvider . getGame ( ) . getActMove ( ) . hasNextMove ( ) ) ) {
Log . i ( " , " + GoGameProvider . getGame ( ) . getActMove ( ) . hasNextMove ( ) ) ;
GoGameProvider . getGame ( ) . jump ( GoGameProvider . getGame ( ) . getActMove ( ) . getnextMove ( <num> ) ) ;
Log . i ( " , " + GoGameProvider . getGame ( ) . getActMove ( ) . hasNextMove ( ) ) ;
try {
Thread . sleep ( calcTime ( ) ) ;
} catch ( InterruptedException e ) {
e . printStackTrace ( ) ;
}
}
Log . i ( " , " + autoplay_active ) ;
try {
Thread . sleep ( pause_for_last_move ) ;
} catch ( InterruptedException e ) {
e . printStackTrace ( ) ;
}
Log . i ( " , " ) ;
Intent next_intent = new Intent ( GoGamePlayerActivity . this , GobanDroidTVActivity . class ) ;
if ( autoplay_active ) {
GoGamePlayerActivity . this . startActivity ( next_intent ) ;
GoGamePlayerActivity . this . finish ( ) ;
}
}
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
this . getMenuInflater ( ) . inflate ( R . menu . ingame_review , menu ) ;
menu . findItem ( R . id . menu_autoplay ) . setTitle ( autoplay_active ? " : " ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case R . id . menu_bookmark :
BookmarkDialog . show ( this ) ;
return true ;
case R . id . menu_autoplay :
Log . i ( " , " ) ;
if ( autoplay_active ) {
autoplay_active = false ;
} else {
autoplay_active = true ;
new Thread ( new autoPlayRunnable ( ) ) . start ( ) ; ;
}
this . invalidateOptionsMenu ( ) ;
break ;
}
return super . onOptionsItemSelected ( item ) ;
}
@Override
protected void onStop ( ) {
autoplay_active = false ;
super . onStop ( ) ;
}
public Fragment getGameExtraFragment ( ) {
return new CommentAndNowPlayingFragment ( ) ;
}
@Override
public byte doMoveWithUIFeedback ( byte x , byte y ) {
return GoGame . MOVE_VALID ;
}
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
getBoard ( ) . setOnKeyListener ( this ) ;
getBoard ( ) . do_mark_act = false ;
if ( autoplay_active )
new Thread ( new autoPlayRunnable ( ) ) . start ( ) ;
}
@Override
public boolean onKey ( View v , int keyCode , KeyEvent event ) {
if ( event . getAction ( ) == KeyEvent . ACTION_DOWN )
switch ( keyCode ) {
case KeyEvent . KEYCODE_MEDIA_PREVIOUS :
case KeyEvent . KEYCODE_DPAD_LEFT :
if ( ! game . canUndo ( ) )
return true ;
game . undo ( ) ;
return true ;
case KeyEvent . KEYCODE_DPAD_RIGHT :
case KeyEvent . KEYCODE_MEDIA_NEXT :
GameForwardAlert . show ( this , game ) ;
return true ;
case KeyEvent . KEYCODE_DPAD_UP :
case KeyEvent . KEYCODE_DPAD_DOWN :
return false ;
}
return super . onKey ( v , keyCode , event ) ;
}
@Override
public boolean isAsk4QuitEnabled ( ) {
return false ;
}
public int countWords ( String sentence ) {
int words = <num> ;
for ( int i = <num> ; i < sentence . length ( ) ; i ++ )
if ( sentence . charAt ( i ) ==  ' )
words ++ ;
return words ;
}
public int calcTime ( ) {
int res = pause_between_moves ;
if ( game . getActMove ( ) . hasComment ( ) )
res += pause_betwen_moves_extra_per_word * countWords ( game . getActMove ( ) . getComment ( ) ) ;
return res ;
}
}
package org . ligi . gobandroid_hd . ui ;
import java . io . File ;
import android . content . Context ;
import android . content . SharedPreferences ;
import android . preference . PreferenceManager ;
public class GoPrefs {
private static SharedPreferences shared_prefs ;
public final static String KEY_FATFINGER = " ;
public final static String KEY_VIEWABLESTONE = " ;
public final static String KEY_VIEW_STONE_DISTANCE = " ;
public final static String KEY_KEEPLIGHT = " ;
public final static String KEY_BOARD_SKIN = " ;
public final static String KEY_STONES_SKIN = " ;
public final static String KEY_ANNOUNCE_MOVE = " ;
public final static String KEY_VARIANT_MODE = " ;
public final static String KEY_DO_LEGEND = " ;
public final static String KEY_SGF_LEGEND = " ;
public final static String KEY_MARKLASTSTONE = " ;
public final static String KEY_SGF_PATH = " ;
public final static String KEY_SGF_FNAME = " ;
public final static String KEY_AI_LEVEL = " ;
public final static String KEY_LAST_BOARD_SIZE = " ;
public final static String KEY_LAST_HANDICAP = " ;
public final static String KEY_LAST_PLAYER_BLACK = " ;
public final static String KEY_LAST_PLAYER_WHITE = " ;
public final static String KEY_GRID_EMBOSS = " ;
public final static String DEFAULT_VIEWABLE_DISTANCE = " ;
public final static String DEFAULT_AI_LEVEL = " ;
public final static String DEFAULT_SKIN = " ;
public final static String DEFAULT_SGF_PATH = " ;
public final static String DEFAULT_SGF_FNAME = " ;
public final static int DEFAULT_LAST_BOARD_SIZE = <num> ;
public final static int DEFAULT_LAST_HANDICAP = <num> ;
public final static String DEFAULT_LAST_PLAYER_BLACK = " ;
public final static String DEFAULT_LAST_PLAYER_WHITE = " ;
public static void init ( Context context ) {
shared_prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ;
}
public static boolean isAnnounceMoveActive ( ) {
return shared_prefs . getBoolean ( KEY_ANNOUNCE_MOVE , true ) ;
}
public static void setAnnounceMoveActive ( boolean announce ) {
shared_prefs . edit ( ) . putBoolean ( KEY_ANNOUNCE_MOVE , announce ) . commit ( ) ;
}
public static void setLastBoardSize ( int size ) {
shared_prefs . edit ( ) . putInt ( KEY_LAST_BOARD_SIZE , size ) . commit ( ) ;
}
public static int getLastBoardSize ( ) {
return shared_prefs . getInt ( KEY_LAST_BOARD_SIZE , DEFAULT_LAST_BOARD_SIZE ) ;
}
public static void setLastHandicap ( int size ) {
shared_prefs . edit ( ) . putInt ( KEY_LAST_HANDICAP , size ) . commit ( ) ;
}
public static int getLastHandicap ( ) {
return shared_prefs . getInt ( KEY_LAST_HANDICAP , DEFAULT_LAST_HANDICAP ) ;
}
public static String getLastPlayerBlack ( ) {
return shared_prefs . getString ( KEY_LAST_PLAYER_BLACK , DEFAULT_LAST_PLAYER_BLACK ) ;
}
public static String getLastPlayerWhite ( ) {
return shared_prefs . getString ( KEY_LAST_PLAYER_WHITE , DEFAULT_LAST_PLAYER_WHITE ) ;
}
public static void setLastPlayerWhite ( String last_player ) {
shared_prefs . edit ( ) . putString ( KEY_LAST_PLAYER_WHITE , last_player ) . commit ( ) ;
}
public static void setLastPlayerBlack ( String last_player ) {
shared_prefs . edit ( ) . putString ( KEY_LAST_PLAYER_BLACK , last_player ) . commit ( ) ;
}
public static boolean getGridEmbossEnabled ( ) {
return shared_prefs . getBoolean ( KEY_GRID_EMBOSS , true ) ;
}
public static boolean isAskVariantEnabled ( ) {
return shared_prefs . getString ( KEY_VARIANT_MODE , " ) . equals ( " ) ;
}
public static boolean isKeepVariantEnabled ( ) {
return shared_prefs . getString ( KEY_VARIANT_MODE , " ) . equals ( " ) ;
}
public static boolean <unk> ( ) {
return shared_prefs . getBoolean ( KEY_FATFINGER , false ) ;
}
public static boolean <unk> ( ) {
return shared_prefs . getBoolean ( KEY_VIEWABLESTONE , false ) ;
}
public static String [ ] <unk> ( ) {
return new String [ ] { " , " , " , " , " } ;
}
public static byte <unk> ( ) {
String viewdist_str = shared_prefs . getString (
KEY_VIEW_STONE_DISTANCE ,
DEFAULT_VIEWABLE_DISTANCE ) ;
return Byte . parseByte ( viewdist_str ) ;
}
public static boolean <unk> ( ) {
return shared_prefs . getBoolean ( KEY_KEEPLIGHT , false ) ;
}
public static boolean getMarkLastStone ( ) {
return shared_prefs . getBoolean ( KEY_MARKLASTSTONE , false ) ;
}
public static boolean getLegendEnabled ( ) {
return shared_prefs . getBoolean ( KEY_DO_LEGEND , false ) ;
}
public static boolean getLegendSGFMode ( ) {
return shared_prefs . getBoolean ( KEY_SGF_LEGEND , false ) ;
}
public static String <unk> ( ) {
return shared_prefs . getString ( KEY_BOARD_SKIN , DEFAULT_SKIN ) ;
}
public static String <unk> ( ) {
return shared_prefs . getString ( KEY_STONES_SKIN , DEFAULT_SKIN ) ;
}
public static String getSGFPath ( ) {
return shared_prefs . getString ( KEY_SGF_PATH , DEFAULT_SGF_PATH ) ;
}
public static String <unk> ( ) {
return shared_prefs . getString ( KEY_SGF_FNAME , DEFAULT_SGF_FNAME ) ;
}
public static byte getAILevel ( ) {
String level_str = shared_prefs . getString ( KEY_AI_LEVEL , DEFAULT_AI_LEVEL ) ;
try {
return Byte . parseByte ( level_str . substring ( <num> , <num> ) ) ;
} catch ( Exception e ) {
return Byte . parseByte ( level_str . substring ( <num> , <num> ) ) ;
}
}
public static String [ ] <unk> ( ) {
File f = new File ( GOSkin . skin_base_path ) ;
int pos = <num> ;
File [ ] file_list ;
if ( f . exists ( ) )
file_list = f . listFiles ( ) ;
else
file_list = new File [ <num> ] ;
String [ ] skin_strings = new String [ <num> + file_list . length ] ;
skin_strings [ pos ++ ] = " ;
for ( File skin : file_list )
skin_strings [ pos ++ ] = skin . getName ( ) ;
return skin_strings ;
}
public static String [ ] getAllAILevelStrings ( ) {
return new String [ ] { " , " , " , " , " , " , " , " , " , " } ;
}
public static String <unk> ( ) {
return getAllAILevelStrings ( ) [ getAILevel ( )  <num> ] ;
}
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . ui . sgf_listing . SGFSDCardListActivity ;
import android . app . ListActivity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . ArrayAdapter ;
import android . widget . ListView ;
public class <unk> extends ListActivity {
private String [ ] menu_items = { " , " } ;
private final static int MENU_SDCARD = <num> ;
private final static int MENU_ONLINE = <num> ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
GoPrefs . init ( this ) ;
setContentView ( R . layout . list ) ;
this . setListAdapter ( new ArrayAdapter < String > ( this ,
R . layout . list_item , menu_items ) ) ;
}
@Override
protected void onListItemClick ( ListView l , View v , int position , long id ) {
super . onListItemClick ( l , v , position , id ) ;
Intent go_intent = null ;
switch ( position ) {
case MENU_SDCARD :
go_intent = new Intent ( this , SGFSDCardListActivity . class ) ;
break ;
case MENU_ONLINE :
go_intent = new Intent ( this , SGFOnlineListActivity . class ) ;
break ;
}
startActivity ( go_intent ) ;
}
package org . ligi . gobandroid_hd . ui ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . TextView ;
public class DefaultGameExtrasFragment extends Fragment {
@Override
public View onCreateView ( LayoutInflater inflater , ViewGroup container ,
Bundle savedInstanceState ) {
TextView tv = new TextView ( this . getActivity ( ) ) ;
tv . setText ( " ) ;
return tv ;
}
}
package org . ligi . gobandroid_hd . ui . recording ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGame . GoGameChangeListener ;
import org . ligi . gobandroid_hd . logic . GoMove ;
import org . ligi . gobandroid_hd . ui . GoActivity ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . support . v4 . view . Menu ;
import android . view . WindowManager ;
public class GameRecordActivity extends GoActivity implements GoGameChangeListener {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_STATE_ALWAYS_HIDDEN ) ;
}
public byte doMoveWithUIFeedback ( byte x , byte y ) {
byte res = super . doMoveWithUIFeedback ( x , y ) ;
if ( res == GoGame . MOVE_VALID )
if ( game . getActMove ( ) . hasNextMove ( ) )
game . jump ( game . getActMove ( ) . getnextMove ( <num> ) ) ;
game . notifyGameChange ( ) ;
return res ;
}
public GoMove getCorrectMove ( GoMove act_mve ) {
if ( act_mve . getComment ( ) . equals ( " ) )
return act_mve ;
for ( GoMove next_moves : act_mve . getNextMoveVariations ( ) ) {
GoMove res = getCorrectMove ( next_moves ) ;
if ( res != null )
return res ;
}
return null ;
}
@Override
public boolean onPrepareOptionsMenu ( Menu menu ) {
super . onPrepareOptionsMenu ( menu ) ;
menu . findItem ( R . id . menu_game_pass ) . setVisible ( ! game . isFinished ( ) ) ;
menu . findItem ( R . id . menu_game_results ) . setVisible ( game . isFinished ( ) ) ;
return true ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
this . getMenuInflater ( ) . inflate ( R . menu . ingame_record , menu ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
@Override
public void onGoGameChange ( ) {
this . invalidateOptionsMenu ( ) ;
}
public Fragment getGameExtraFragment ( ) {
return new RecordingGameExtrasFragment ( ) ;
}
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoDefinitions ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoMarker ;
import org . ligi . tracedroid . logging . Log ;
import android . app . AlertDialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . graphics . Bitmap ;
import android . graphics . Canvas ;
import android . graphics . Matrix ;
import android . graphics . Paint ;
import android . graphics . RectF ;
import android . graphics . Paint . FontMetrics ;
import android . view . View ;
public class GoBoardView extends View {
private GoGame game ;
private Paint whitePaint ;
private Paint blackPaint ;
private Paint blackTextPaint ;
private Paint whiteTextPaint ;
private Paint boardPaint ;
private Paint gridPaint ;
private Paint gridPaint_h ;
private Paint textPaint ;
private Paint bitmapPaint ;
private Paint placeStonePaint ;
public float stone_size ;
private float stone_size_zoomed ;
private float stone_size_normal ;
public float offset_x = <num> ;
public float offset_y = <num> ;
public byte touch_x =  <num> ;
public byte touch_y =  <num> ;
private Bitmap bg_bitmap = null ;
private Bitmap white_stone_bitmap = null ;
private Bitmap black_stone_bitmap = null ;
private Bitmap white_stone_bitmap_small = null ;
private Bitmap black_stone_bitmap_small = null ;
public boolean move_stone_mode = false ;
private boolean regenerate_stones_flag = true ;
public GoBoardView ( Context context , GoGame game ) {
super ( context ) ;
this . game = game ;
whitePaint = new Paint ( ) ;
whitePaint . setColor ( <num> ) ;
whitePaint . setAntiAlias ( true ) ;
whiteTextPaint = new Paint ( ) ;
whiteTextPaint . setColor ( <num> ) ;
whiteTextPaint . setAntiAlias ( true ) ;
whiteTextPaint . setTextAlign ( Paint . Align . CENTER ) ;
whiteTextPaint . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
blackTextPaint = new Paint ( ) ;
blackTextPaint . setColor ( <num> ) ;
blackTextPaint . setAntiAlias ( true ) ;
blackTextPaint . setTextAlign ( Paint . Align . CENTER ) ;
blackTextPaint . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
blackPaint = new Paint ( ) ;
blackPaint . setColor ( <num> ) ;
blackPaint . setAntiAlias ( true ) ;
boardPaint = new Paint ( ) ;
boardPaint . setColor ( <num> ) ;
gridPaint = new Paint ( ) ;
gridPaint_h = new Paint ( ) ;
gridPaint_h . setColor ( <num> ) ;
gridPaint_h . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
gridPaint . setColor ( <num> ) ;
gridPaint . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
gridPaint . setTextAlign ( Paint . Align . CENTER ) ;
gridPaint . setTextSize ( <num> ) ;
textPaint = new Paint ( ) ;
textPaint . setColor ( <num> ) ;
textPaint . setAntiAlias ( false ) ;
bitmapPaint = new Paint ( ) ;
placeStonePaint = new Paint ( ) ;
placeStonePaint . setAlpha ( <num> ) ;
setFocusable ( true ) ;
}
public Bitmap resize_to_screen ( Bitmap orig , float x_scale_ , float y_scale_ ) {
Matrix matrix = new Matrix ( ) ;
float x_scale , y_scale ;
if ( y_scale_ != <num> )
y_scale = ( getHeight ( ) * y_scale_ ) / orig . getHeight ( ) ;
else
y_scale = ( getWidth ( ) * x_scale_ ) / orig . getWidth ( ) ;
if ( x_scale_ != <num> )
x_scale = ( getWidth ( ) * x_scale_ ) / orig . getWidth ( ) ;
else
x_scale = ( getHeight ( ) * y_scale_ ) / orig . getHeight ( ) ;
matrix . postScale ( x_scale , y_scale ) ;
return Bitmap . createBitmap ( orig , <num> , <num> , ( int ) ( orig . getWidth ( ) ) ,
( int ) ( orig . getHeight ( ) ) , matrix , true ) ;
}
public void prepare_keyinput ( ) {
if ( touch_x ==  <num> )
touch_x = <num> ;
if ( touch_y ==  <num> )
touch_y = <num> ;
}
public void setZoom ( boolean zoom_flag ) {
if ( zoom_flag ) {
stone_size = stone_size_zoomed ;
if ( touch_x >= ( <num> * game . getVisualBoard ( ) . getSize ( ) ) / <num> )
offset_x =  stone_size * game . getVisualBoard ( ) . getSize ( ) + this . getWidth ( ) ;
else if ( touch_x > ( game . getVisualBoard ( ) . getSize ( ) / <num> ) )
offset_x = (  stone_size * game . getVisualBoard ( ) . getSize ( ) + this . getWidth ( ) ) / <num> ;
if ( touch_y >= ( <num> * game . getVisualBoard ( ) . getSize ( ) ) / <num> )
offset_y =  stone_size * game . getVisualBoard ( ) . getSize ( ) + this . getHeight ( ) ;
else if ( touch_y > ( game . getVisualBoard ( ) . getSize ( ) / <num> ) )
offset_y = (  stone_size * game . getVisualBoard ( ) . getSize ( ) + this . getHeight ( ) ) / <num> ;
}
else {
stone_size = stone_size_normal ;
offset_x = <num> ;
offset_y = <num> ;
}
regenerate_images ( ) ;
invalidate ( ) ;
}
public boolean <unk> ( ) {
return ( stone_size == stone_size_zoomed ) ;
}
@Override
protected void onDraw ( Canvas canvas ) {
Log . i ( " ) ;
if ( regenerate_stones_flag )
regenerate_images ( ) ;
if ( bg_bitmap != null )
canvas . drawBitmap ( bg_bitmap , <num> , <num> , boardPaint ) ;
else
canvas . drawRect ( new RectF ( <num> , <num> , this . getWidth ( ) , this . getHeight ( ) ) , boardPaint ) ;
canvas . translate ( offset_x , offset_y ) ;
if ( game . isBlackToMove ( ) )
canvas . drawBitmap ( black_stone_bitmap , touch_x * stone_size , touch_y * stone_size , placeStonePaint ) ;
else
canvas . drawBitmap ( white_stone_bitmap , touch_x * stone_size , touch_y * stone_size , placeStonePaint ) ;
for ( int x = <num> ; x < game . getVisualBoard ( ) . getSize ( ) ; x ++ )
canvas . drawLine ( stone_size / <num> + x * stone_size , stone_size / <num> , stone_size / <num> + x * stone_size , stone_size * ( float ) ( game . getVisualBoard ( ) . getSize ( )  <num> ) + stone_size / <num> , ( touch_x == x ) ? gridPaint_h : gridPaint ) ;
for ( int x = <num> ; x < game . getVisualBoard ( ) . getSize ( ) ; x ++ )
{
canvas . drawLine ( stone_size / <num> , stone_size / <num> + x * stone_size , stone_size * ( float ) ( game . getVisualBoard ( ) . getSize ( )  <num> ) + stone_size / <num> , stone_size / <num> + x * stone_size , ( touch_y == x ) ? gridPaint_h : gridPaint ) ;
if ( GoPrefs . getLegendEnabled ( ) ) {
canvas . drawText ( " + ( <num> + x ) , <num> + stone_size * ( float ) ( game . getVisualBoard ( ) . getSize ( )  <num> ) + stone_size / <num> , stone_size / <num> + x * stone_size + gridPaint . getTextSize ( ) / <num> , gridPaint ) ;
if ( ( x > <num> ) && GoPrefs . getLegendSGFMode ( ) )
canvas . drawText ( " + ( char ) ( A' + ( x + <num> ) ) , stone_size / <num> + x * stone_size , stone_size * ( float ) ( game . getVisualBoard ( ) . getSize ( )  <num> ) + stone_size / <num> + <num> + gridPaint . getTextSize ( ) , gridPaint ) ;
else
canvas . drawText ( " + ( char ) ( A' + x ) , stone_size / <num> + x * stone_size , stone_size * ( float ) ( game . getVisualBoard ( ) . getSize ( )  <num> ) + stone_size / <num> + <num> + gridPaint . getTextSize ( ) , gridPaint ) ;
}
}
for ( byte x = <num> ; x < game . getVisualBoard ( ) . getSize ( ) ; x ++ )
for ( byte y = <num> ; y < game . getVisualBoard ( ) . getSize ( ) ; y ++ ) {
blackPaint . setColor ( <num> ) ;
blackPaint . setStrokeWidth ( stone_size / <num> ) ;
if ( game . isPosHoschi ( x , y ) )
canvas . drawCircle ( stone_size / <num> + x * stone_size + <num> , stone_size / <num> + y * stone_size + <num> , stone_size / <num> , blackPaint ) ;
if ( game . isFinished ( ) ) {
blackPaint . setColor ( <num> ) ;
whitePaint . setColor ( <num> ) ;
if ( game . area_assign [ x ] [ y ] == GoDefinitions . PLAYER_BLACK )
canvas . drawBitmap ( black_stone_bitmap , x * stone_size , y * stone_size , whitePaint ) ;
if ( game . area_assign [ x ] [ y ] == GoDefinitions . PLAYER_WHITE )
canvas . drawBitmap ( white_stone_bitmap , x * stone_size , y * stone_size , whitePaint ) ;
}
blackPaint . setColor ( <num> ) ;
whitePaint . setColor ( <num> ) ;
if ( game . getCalcBoard ( ) . isCellDead ( x , y ) ) {
if ( game . getVisualBoard ( ) . isCellWhite ( x , y ) )
canvas . drawBitmap ( white_stone_bitmap_small , x * stone_size + ( stone_size  white_stone_bitmap_small . getWidth ( ) ) / <num> , y * stone_size + ( stone_size  white_stone_bitmap_small . getHeight ( ) ) / <num> , whitePaint ) ;
if ( game . getVisualBoard ( ) . isCellBlack ( x , y ) )
canvas . drawBitmap ( black_stone_bitmap_small , x * stone_size + ( stone_size  black_stone_bitmap_small . getWidth ( ) ) / <num> , y * stone_size + ( stone_size  black_stone_bitmap_small . getHeight ( ) ) / <num> , whitePaint ) ;
}
else {
if ( move_stone_mode && ( x == game . getActMove ( ) . getX ( ) ) && ( y == game . getActMove ( ) . getY ( ) ) )
bitmapPaint . setAlpha ( <num> ) ;
else
bitmapPaint . setAlpha ( <num> ) ;
if ( game . getVisualBoard ( ) . isCellWhite ( x , y ) )
canvas . drawBitmap ( white_stone_bitmap , x * stone_size , y * stone_size , bitmapPaint ) ;
if ( game . getVisualBoard ( ) . isCellBlack ( x , y ) )
canvas . drawBitmap ( black_stone_bitmap , x * stone_size , y * stone_size , bitmapPaint ) ;
if ( GoPrefs . getMarkLastStone ( ) ) {
blackPaint . setStyle ( Paint . Style . STROKE ) ;
whitePaint . setStyle ( Paint . Style . STROKE ) ;
whitePaint . setStrokeWidth ( <num> ) ;
blackPaint . setStrokeWidth ( <num> ) ;
if ( ( game . getActMove ( ) . getX ( ) == x ) && ( game . getActMove ( ) . getY ( ) == y ) )
{
if ( game . getVisualBoard ( ) . isCellWhite ( x , y ) )
canvas . drawCircle ( stone_size / <num> + x * stone_size , stone_size / <num> + y * stone_size , stone_size / <num> , blackPaint ) ;
if ( game . getVisualBoard ( ) . isCellBlack ( x , y ) )
canvas . drawCircle ( stone_size / <num> + x * stone_size , stone_size / <num> + y * stone_size , stone_size / <num> , whitePaint ) ;
}
}
}
}
FontMetrics fm = whiteTextPaint . getFontMetrics ( ) ;
for ( GoMarker marker : game . getActMove ( ) . getMarkers ( ) )
if ( game . getVisualBoard ( ) . isCellBlack ( marker . getX ( ) , marker . getY ( ) ) )
canvas . drawText ( marker . getText ( ) , marker . getX ( ) * stone_size + stone_size / <num> , marker . getY ( ) * stone_size  ( fm . top + fm . bottom ) , whiteTextPaint ) ;
else
canvas . drawText ( marker . getText ( ) , marker . getX ( ) * stone_size + stone_size / <num> , marker . getY ( ) * stone_size  ( fm . top + fm . bottom ) , blackTextPaint ) ;
canvas . restore ( ) ;
}
public float getBoardPixels ( ) {
return stone_size * game . getVisualBoard ( ) . getSize ( ) ;
}
public void regenerate_images ( ) {
Log . i ( " + stone_size ) ;
float SMALL_STONE_SCALER = <num> ;
white_stone_bitmap = GOSkin . getWhiteStone ( stone_size ) ;
black_stone_bitmap = GOSkin . getBlackStone ( stone_size ) ;
white_stone_bitmap_small = GOSkin . getWhiteStone ( SMALL_STONE_SCALER * stone_size ) ;
black_stone_bitmap_small = GOSkin . getBlackStone ( SMALL_STONE_SCALER * stone_size ) ;
bg_bitmap = GOSkin . getBoard ( this . getWidth ( ) , this . getHeight ( ) ) ;
regenerate_stones_flag = false ;
whiteTextPaint . setTextSize ( stone_size ) ;
blackTextPaint . setTextSize ( stone_size ) ;
if ( GoPrefs . getGridEmbossEnabled ( ) )
gridPaint . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
else
gridPaint . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
}
@Override
protected void onSizeChanged ( int w , int h , int oldw , int oldh ) {
stone_size_normal = ( ( w < h ) ? w : h ) / ( float ) game . getVisualBoard ( ) . getSize ( ) ;
stone_size = stone_size_normal ;
stone_size_zoomed = stone_size_normal * <num> ;
regenerate_stones_flag = true ;
}
public void initializeStoneMove ( ) {
if ( game . getGoMover ( ) . isPlayingInThisGame ( ) )
return ;
if ( move_stone_mode )
return ;
move_stone_mode = true ;
if ( ! GoPrefs . isAnnounceMoveActive ( ) )
return ;
new AlertDialog . Builder ( this . getContext ( ) ) . setMessage ( R . string . hint_stone_move )
. setPositiveButton ( R . string . ok ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
GoPrefs . setAnnounceMoveActive ( false ) ;
}
} ) . show ( ) ;
}
public void setRegenerataStonesFlag ( boolean new_flag ) {
regenerate_stones_flag = new_flag ;
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . tracedroid . logging . Log ;
import android . content . Context ;
import android . graphics . Bitmap ;
import android . graphics . BitmapFactory ;
import android . graphics . Canvas ;
import android . graphics . Color ;
import android . graphics . Paint ;
import android . graphics . Paint . FontMetrics ;
import android . graphics . Rect ;
import android . util . AttributeSet ;
import android . view . View ;
public class InGameActionBarView extends View implements GoGame . GoGameChangeListener {
private Bitmap white_stone_bitmap = null ;
private Bitmap black_stone_bitmap = null ;
private Paint mPaint = new Paint ( ) ;
private Rect active_player_bg_rect = new Rect ( ) ;
private Paint myActiveBGPaint = new Paint ( ) ;
private FontMetrics fm ;
private float text_offset ;
private Bitmap getScaledRes ( float size , int resID ) {
Bitmap unscaled_bitmap = BitmapFactory . decodeResource ( this . getResources ( ) , resID ) ;
return Bitmap . createScaledBitmap ( unscaled_bitmap , ( int ) size , ( int ) size , true ) ;
}
public InGameActionBarView ( Context context , AttributeSet attrs ) {
super ( context , attrs ) ;
init ( ) ;
}
public InGameActionBarView ( Context context ) {
super ( context ) ;
init ( ) ;
}
@Override
protected void onSizeChanged ( int w , int h , int oldw , int oldh ) {
super . onSizeChanged ( w , h , oldw , oldh ) ;
mPaint . setTextSize ( ( int ) ( h / <num> ) ) ;
mPaint . setAntiAlias ( true ) ;
black_stone_bitmap = getScaledRes ( h / <num> , R . drawable . stone_black ) ;
white_stone_bitmap = getScaledRes ( h / <num> , R . drawable . stone_white ) ;
active_player_bg_rect = new Rect ( <num> , <num> , black_stone_bitmap . getWidth ( ) * <num> , black_stone_bitmap . getHeight ( ) ) ;
fm = mPaint . getFontMetrics ( ) ;
text_offset = ( black_stone_bitmap . getHeight ( )  mPaint . getTextSize ( ) ) / <num>  ( fm . top + fm . bottom ) ;
}
public void init ( ) {
mPaint . setColor ( Color . WHITE ) ;
getGame ( ) . addGoGameChangeListener ( this ) ;
myActiveBGPaint . setColor ( Color . RED ) ;
}
private GoGame getGame ( ) {
return GoGameProvider . getGame ( ) ;
}
@Override
protected void onDraw ( Canvas canvas ) {
active_player_bg_rect . offsetTo ( <num> , getGame ( ) . isBlackToMove ( ) ? <num> : black_stone_bitmap . getHeight ( ) ) ;
if ( this . getWidth ( ) > active_player_bg_rect . width ( ) * <num> ) {
canvas . drawText ( getContext ( ) . getString ( R . string . move ) + " + GoGameProvider . getGame ( ) . getActMove ( ) . getMovePos ( ) , active_player_bg_rect . width ( ) + <num> , text_offset , mPaint ) ;
int mode_str = R . string . <unk> ;
switch ( GoInteractionProvider . getMode ( ) ) {
case GoInteractionProvider . MODE_TSUMEGO :
mode_str = R . string . tsumego ;
break ;
case GoInteractionProvider . MODE_REVIEW :
mode_str = R . string . review ;
break ;
case GoInteractionProvider . MODE_RECORD :
mode_str = R . string . record ;
break ;
}
canvas . drawText ( getContext ( ) . getString ( mode_str ) , active_player_bg_rect . width ( ) + <num> , this . getHeight ( ) / <num> + text_offset , mPaint ) ;
}
canvas . drawRect ( active_player_bg_rect , myActiveBGPaint ) ;
canvas . drawBitmap ( black_stone_bitmap , black_stone_bitmap . getWidth ( ) / <num> , <num> , null ) ;
canvas . drawBitmap ( white_stone_bitmap , black_stone_bitmap . getWidth ( ) / <num> , this . getHeight ( ) / <num> , null ) ;
canvas . drawText ( " + GoGameProvider . getGame ( ) . getCapturesBlack ( ) , ( int ) ( black_stone_bitmap . getWidth ( ) * <num> ) , text_offset , mPaint ) ;
canvas . drawText ( " + GoGameProvider . getGame ( ) . getCapturesWhite ( ) , ( int ) ( black_stone_bitmap . getWidth ( ) * <num> ) , this . getHeight ( ) / <num> + text_offset , mPaint ) ;
super . onDraw ( canvas ) ;
}
@Override
public void onGoGameChange ( ) {
Log . i ( " ) ;
this . postInvalidate ( ) ;
}
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . android . common . adapter . LinkAndDescriptionAdapter ;
import org . ligi . android . common . adapter . LinkWithDescription ;
import org . ligi . gobandroid_hd . R ;
import android . content . Intent ;
import android . net . Uri ;
import android . os . Bundle ;
import android . support . v4 . app . ListFragment ;
import android . view . View ;
import android . widget . ListView ;
public class <unk> extends ListFragment {
public LinkWithDescription [ ] links = new LinkWithDescription [ ] {
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " )
} ;
@Override
public void onActivityCreated ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . setListAdapter ( LinkAndDescriptionAdapter . createByArray ( this . getActivity ( ) , links , R . layout . two_line_list_item ) ) ;
this . getListView ( ) . setCacheColorHint ( <num> ) ;
}
@Override
public void onListItemClick ( ListView l , View v , int position , long id ) {
super . onListItemClick ( l , v , position , id ) ;
startActivity ( new Intent ( " , Uri . parse ( links [ position ] . getURL ( ) ) ) ) ;
}
}
package org . ligi . gobandroid_hd . logic ;
import java . util . Vector ;
import org . ligi . tracedroid . logging . Log ;
public class GoMove {
private byte x , y ;
private String comment = " ;
private boolean did_captures = false ;
private GoMove parent = null ;
private Vector < GoMove > next_move_variations ;
private Vector < GoMarker > markers ;
private int move_pos = <num> ;
public GoMove ( GoMove parent ) {
this . parent = parent ;
init ( ) ;
}
public GoMove ( byte x , byte y , GoMove parent ) {
this . parent = parent ;
this . x = x ;
this . y = y ;
init ( ) ;
}
private void init ( ) {
next_move_variations = new Vector < GoMove > ( ) ;
markers = new Vector < GoMarker > ( ) ;
if ( parent != null ) {
parent . addNextMove ( this ) ;
GoMove act_move = this ;
while ( ( act_move != null ) && ( ! act_move . isFirstMove ( ) ) ) {
move_pos ++ ;
act_move = act_move . parent ;
}
}
}
public void setDidCaptures ( boolean did ) {
did_captures = did ;
}
public boolean <unk> ( ) {
return did_captures ;
}
public int getMovePos ( ) {
return move_pos ;
}
public boolean hasNextMove ( ) {
return ( next_move_variations . size ( ) > <num> ) ;
}
public boolean hasNextMoveVariations ( ) {
return ( next_move_variations . size ( ) > <num> ) ;
}
public int getNextMoveVariationCount ( ) {
return ( next_move_variations . size ( )  <num> ) ;
}
public void addNextMove ( GoMove move ) {
next_move_variations . add ( move ) ;
Log . i ( " + next_move_variations . size ( ) ) ;
}
public void setToPassMove ( ) {
x =  <num> ;
}
public boolean isPassMove ( ) {
return ( x ==  <num> ) ;
}
public void setIsFirstMove ( ) {
x =  <num> ;
}
public boolean isFirstMove ( ) {
return ( x ==  <num> ) ;
}
public void setXY ( byte x , byte y ) {
setX ( x ) ;
setY ( y ) ;
}
public void setX ( byte x ) {
this . x = x ;
}
public void setY ( byte y ) {
this . y = y ;
}
public byte getX ( ) {
return x ;
}
public byte getY ( ) {
return y ;
}
public boolean <unk> ( byte x , byte y ) {
return ( ( getX ( ) == x ) && ( getY ( ) == y ) ) ;
}
public GoMove getParent ( ) {
return parent ;
}
public GoMove getnextMove ( int pos ) {
return next_move_variations . get ( pos ) ;
}
public String toString ( ) {
return " + x + " + y ;
}
public boolean hasComment ( ) {
return ! comment . equals ( " ) ;
}
public String getComment ( ) {
return comment ;
}
public void setComment ( String newComment ) {
comment = newComment ;
}
public void <unk> ( String newComment ) {
comment += newComment ;
}
public boolean didCaptures ( ) {
return did_captures ;
}
public Vector < GoMove > getNextMoveVariations ( ) {
return next_move_variations ;
}
public Vector < GoMarker > getMarkers ( ) {
return markers ;
}
public void addMarker ( GoMarker marker ) {
markers . add ( marker ) ;
}
public GoMarker getGoMarker ( ) {
for ( GoMarker marker : parent . getMarkers ( ) )
if ( ( this . getX ( ) == marker . getX ( ) ) && ( this . getY ( ) == marker . getY ( ) ) )
return marker ;
return null ;
}
public boolean isMarked ( ) {
if ( parent == null )
return false ;
return ( getGoMarker ( ) != null ) ;
}
public String getMarkText ( ) {
if ( parent == null )
return " ;
return ( getGoMarker ( ) . getText ( ) ) ;
}
public void destroy ( ) {
this . getParent ( ) . getNextMoveVariations ( ) . remove ( this ) ;
markers . removeAllElements ( ) ;
next_move_variations . removeAllElements ( ) ;
}
package org . ligi . gobandroid_hd . ui . sgf_listing ;
import java . io . File ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . tracedroid . logging . Log ;
import android . app . Activity ;
import android . content . Context ;
import android . graphics . Bitmap ;
import android . graphics . BitmapFactory ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . BaseAdapter ;
import android . widget . ImageView ;
import android . widget . ImageView . ScaleType ;
import android . widget . LinearLayout ;
import android . widget . TextView ;
class TsumegoPathViewAdapter extends BaseAdapter {
private Activity activity ;
private String [ ] menu_items ;
private String path ;
public TsumegoPathViewAdapter ( Activity activity , String [ ] menu_items , String path ) {
this . activity = activity ;
this . menu_items = menu_items ;
this . path = path ;
}
@Override
public int getCount ( ) {
return menu_items . length ;
}
@Override
public Object getItem ( int position ) {
return null ;
}
@Override
public long getItemId ( int position ) {
return <num> ;
}
public void setImageToGameThumbnail ( ImageView img , String thumbnail_fname ) {
img . setLayoutParams ( new LinearLayout . LayoutParams ( ( int ) activity . getResources ( ) . getDimension ( R . dimen . thumbnail_size ) , ( int ) activity . getResources ( ) . getDimension ( R . dimen . thumbnail_size ) ) ) ;
Log . i ( " + thumbnail_fname ) ;
BitmapFactory . Options options = new BitmapFactory . Options ( ) ;
options . <unk> = true ;
Bitmap img_bmp = null ;
try {
img_bmp = BitmapFactory . decodeFile ( thumbnail_fname , options ) ;
} catch ( OutOfMemoryError e ) {
System . gc ( ) ;
try {
img_bmp = BitmapFactory . decodeFile ( thumbnail_fname , options ) ;
} catch ( OutOfMemoryError e2 ) {
img . setImageResource ( R . drawable . <unk> ) ;
}
}
if ( img_bmp != null ) { img . setImageBitmap ( img_bmp ) ; }
img . setScaleType ( ScaleType . FIT_XY ) ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
LayoutInflater inflater = ( LayoutInflater ) activity
. getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ;
String base_fname = path + " + menu_items [ position ] ;
View v ;
if ( new File ( base_fname ) . isDirectory ( ) ) {
v = inflater . inflate ( R . layout . sgf_dir_list_item , null ) ;
LinearLayout container = ( LinearLayout ) v . findViewById ( R . id . thumb_container ) ;
container . setOrientation ( LinearLayout . HORIZONTAL ) ;
int fcount = <num> ;
for ( File act_file : new File ( base_fname ) . listFiles ( ) )
if ( act_file . getName ( ) . endsWith ( " ) ) {
fcount ++ ;
if ( fcount > <num> )
break ;
ImageView img = new ImageView ( activity ) ;
setImageToGameThumbnail ( img , act_file . getPath ( ) ) ;
container . addView ( img ) ;
}
if ( fcount == <num> )
container . setVisibility ( View . GONE ) ;
}
else
v = inflater . inflate ( R . layout . <unk> , null ) ;
String img_fname = path + " + menu_items [ position ] + " ;
TextView title_tv = ( TextView ) v . findViewById ( R . id . filename ) ;
if ( title_tv != null ) {
title_tv . setText ( menu_items [ position ] . replace ( " , " ) ) ;
}
if ( new File ( img_fname ) . exists ( ) ) {
ImageView img = ( ImageView ) v . findViewById ( R . id . thumbnail ) ;
setImageToGameThumbnail ( img , img_fname ) ;
}
ImageView solve_img = ( ImageView ) v . findViewById ( R . id . <unk> ) ;
if ( ( solve_img != null ) && ( activity . getBaseContext ( ) . getSharedPreferences ( " , Activity . MODE_PRIVATE ) . getInt ( " + base_fname ,  <num> ) > <num> ) ) {
solve_img . setImageResource ( R . drawable . solved ) ;
}
return v ;
}
package org . ligi . gobandroid_hd . ui ;
import java . util . regex . Matcher ;
import java . util . regex . Pattern ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGame . GoGameChangeListener ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import android . os . Bundle ;
import android . os . Handler ;
import android . support . v4 . app . Fragment ;
import android . text . util . Linkify ;
import android . text . util . Linkify . TransformFilter ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . TextView ;
public class CommentAndNowPlayingFragment extends Fragment implements GoGameChangeListener {
private TextView myTextView ;
private GoGame game ;
@Override
public View onCreateView ( LayoutInflater inflater , ViewGroup container ,
Bundle savedInstanceState ) {
View res = inflater . inflate ( R . layout . game_extra_review , container , false ) ;
myTextView = ( TextView ) res . findViewById ( R . id . comments_textview ) ;
game = GoGameProvider . getGame ( ) ;
game . addGoGameChangeListener ( this ) ;
onGoGameChange ( ) ;
return res ;
}
@Override
public void onGoGameChange ( ) {
gameChangeHandler . post ( new Runnable ( ) {
@Override
public void run ( ) {
if ( myTextView != null ) {
myTextView . setText ( game . getActMove ( ) . getComment ( ) ) ;
Linkify . addLinks ( myTextView , Linkify . ALL ) ;
TransformFilter mentionFilter = new TransformFilter ( ) {
public final String transformUrl ( final Matcher match , String url ) {
return match . group ( <num> ) . toLowerCase ( ) ;
}
} ;
for ( String key : GoTermsViewActivity . getTerm2resHashMap ( ) . keySet ( ) ) {
Pattern wikiWordMatcher = Pattern . compile ( " + key + " , Pattern . CASE_INSENSITIVE ) ;
String wikiViewURL = " ;
Linkify . addLinks ( myTextView , wikiWordMatcher , wikiViewURL , null , mentionFilter ) ;
}
}
}
} ) ;
}
private Handler gameChangeHandler = new Handler ( ) ;
@Override
public void onDestroyView ( ) {
game . removeGoGameChangeListener ( this ) ;
super . onDestroyView ( ) ;
}
}
package org . ligi . gobandroid_hd . ui . alerts ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . ui . GOSkin ;
import android . app . AlertDialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . view . Gravity ;
import android . widget . ImageView ;
import android . widget . LinearLayout ;
import android . widget . ScrollView ;
import android . widget . TableLayout ;
import android . widget . TableRow ;
import android . widget . TextView ;
public class GameResultsAlert {
public static void show ( Context context , GoGame game ) {
ScrollView scrollview = new ScrollView ( context ) ;
LinearLayout lin = new LinearLayout ( context ) ;
TableLayout table = new TableLayout ( context ) ;
TableRow row = new TableRow ( context ) ;
row . addView ( filledTextView ( context , " , true , <num> ) ) ;
ImageView img = new ImageView ( context ) ;
img . setImageBitmap ( GOSkin . getBlackStone ( <num> ) ) ;
img . setPadding ( <num> , <num> , <num> , <num> ) ;
row . addView ( img ) ;
img = new ImageView ( context ) ;
img . setImageBitmap ( GOSkin . getWhiteStone ( <num> ) ) ;
row . addView ( img ) ;
table . addView ( row ) ;
row = new TableRow ( context ) ;
float size1 = <num> ;
float size2 = <num> ;
row . addView ( filledTextView ( context , R . string . <unk> , false , size1 ) ) ;
row . addView ( filledTextView ( context , " + game . territory_black , true , size1 ) ) ;
row . addView ( filledTextView ( context , " + game . territory_white , true , size1 ) ) ;
table . addView ( row ) ;
row = new TableRow ( context ) ;
row . addView ( filledTextView ( context , R . string . <unk> , false , size1 ) ) ;
row . addView ( filledTextView ( context , " + game . getCapturesBlack ( ) , true , size1 ) ) ;
row . addView ( filledTextView ( context , " + game . getCapturesWhite ( ) , true , size1 ) ) ;
table . addView ( row ) ;
row = new TableRow ( context ) ;
row . addView ( filledTextView ( context , R . string . komi , false , size1 ) ) ;
row . addView ( filledTextView ( context , " , true , size1 ) ) ;
row . addView ( filledTextView ( context , " + game . getKomi ( ) , true , size1 ) ) ;
table . addView ( row ) ;
row = new TableRow ( context ) ;
row . addView ( filledTextView ( context , R . string . <unk> , false , size2 ) ) ;
row . addView ( filledTextView ( context , " + game . getPointsBlack ( ) , true , size2 ) ) ;
row . addView ( filledTextView ( context , " + game . getPointsWhite ( ) , true , size2 ) ) ;
table . addView ( row ) ;
String game_fin_txt = " ;
if ( game . getPointsBlack ( ) == game . getPointsWhite ( ) )
game_fin_txt = context . getResources ( ) . getString ( R . string . <unk> ) ;
if ( game . getPointsBlack ( ) > game . getPointsWhite ( ) )
game_fin_txt = ( context . getString ( R . string . <unk> ) + ( game . getPointsBlack ( )  game . getPointsWhite ( ) ) + context . getString ( R . string . _points_ ) ) ;
if ( game . getPointsWhite ( ) > game . getPointsBlack ( ) )
game_fin_txt = ( context . getString ( R . string . <unk> ) + ( game . getPointsWhite ( )  game . getPointsBlack ( ) ) + context . getString ( R . string . _points_ ) ) ;
lin . setOrientation ( LinearLayout . VERTICAL ) ;
lin . addView ( table ) ;
lin . addView ( filledTextView ( context , game_fin_txt , false , size2 ) ) ;
scrollview . addView ( lin ) ;
new AlertDialog . Builder ( context ) . setTitle ( R . string . results ) . setView ( scrollview )
. setPositiveButton ( R . string . ok , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) { }
} ) . show ( ) ;
}
private static TextView filledTextView ( Context ctx , String txt , boolean center , float size ) {
TextView res = new TextView ( ctx ) ;
res . setText ( txt ) ;
res . setPadding ( <num> , <num> , <num> , <num> ) ;
if ( center )
res . setGravity ( Gravity . CENTER_HORIZONTAL ) ;
res . setTextSize ( size ) ;
return res ;
}
private static TextView filledTextView ( Context ctx , int txt_id , boolean center , float size ) {
return filledTextView ( ctx , ctx . getResources ( ) . getString ( txt_id ) , center , size ) ;
}
package org . ligi . gobandroid_hd . ui ;
import java . io . File ;
import org . ligi . tracedroid . logging . Log ;
import android . graphics . Bitmap ;
import android . graphics . BitmapFactory ;
import android . graphics . Canvas ;
import android . graphics . Color ;
import android . graphics . Paint ;
public class GOSkin {
private static boolean do_board_skin = false ;
private static String board_skin_name = " ;
private static boolean do_stone_skin = false ;
private static String stone_skin_name = " ;
public final static String skin_base_path = " ;
public static boolean <unk> ( String skin_name ) {
if ( ( new File ( skin_base_path + skin_name ) . exists ( ) ) ) {
board_skin_name = skin_name ;
do_board_skin = true ; }
else
do_board_skin = false ;
return do_board_skin ;
}
public static boolean <unk> ( String skin_name ) {
if ( ( new File ( skin_base_path + skin_name ) . exists ( ) ) ) {
stone_skin_name = skin_name ;
do_stone_skin = true ; }
else
do_stone_skin = false ;
return do_stone_skin ;
}
private static String getBoardFname ( ) {
return skin_base_path + board_skin_name + " ;
}
public static Bitmap getBoard ( ) {
return BitmapFactory . decodeFile ( getBoardFname ( ) ) ;
}
public static Bitmap getBoard ( int width , int height ) {
if ( do_board_skin )
return Bitmap . createScaledBitmap ( getBoard ( ) , width , height , true ) ;
else
return null ;
}
public static Bitmap getWhiteStone ( float size ) {
return getStone ( " , size ) ;
}
public static Bitmap getBlackStone ( float size ) {
return getStone ( " , size ) ;
}
public static Bitmap getStone ( String name , float size ) {
if ( size < <num> )
size = <num> ;
if ( do_stone_skin ) try {
int size_append = <num> ;
if ( size > <num> )
size_append = <num> ;
else if ( size > <num> )
size_append = <num> ;
Log . i ( " + size ) ;
Bitmap unscaled_bitmap = BitmapFactory . decodeFile ( skin_base_path + stone_skin_name + " + name + size_append + " ) ;
return Bitmap . createScaledBitmap ( unscaled_bitmap , ( int ) size , ( int ) size , true ) ;
}
catch ( Exception e ) {
Log . w ( " + name + " + size ) ;
}
Bitmap btm = Bitmap . createBitmap ( ( int ) size , ( int ) size , Bitmap . Config . ARGB_4444 ) ;
Canvas c = new Canvas ( btm ) ;
Paint mPaint = new Paint ( ) ;
mPaint . setAntiAlias ( true ) ;
if ( name . equals ( " ) )
mPaint . setColor ( Color . WHITE ) ;
else
mPaint . setColor ( Color . BLACK ) ;
c . drawCircle ( c . getWidth ( ) / <num> , c . getHeight ( ) / <num> , size / <num> , mPaint ) ;
return btm ;
}
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . android . common . intents . IntentHelper ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GnuGoMover ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . gobandroid_hd . ui . recording . GameRecordActivity ;
import org . ligi . gobandroid_hd . ui . recording . PlayAgainstGnugoActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . net . Uri ;
import android . os . Bundle ;
import android . support . v4 . view . Menu ;
import android . support . v4 . view . MenuItem ;
import android . view . MotionEvent ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . view . View . OnTouchListener ;
import android . widget . AdapterView ;
import android . widget . ArrayAdapter ;
import android . widget . Button ;
import android . widget . SeekBar ;
import android . widget . Spinner ;
import android . widget . TextView ;
import android . widget . AdapterView . OnItemSelectedListener ;
import android . widget . SeekBar . OnSeekBarChangeListener ;
public class GoSetupActivity extends GobandroidFragmentActivity implements OnSeekBarChangeListener , OnClickListener , OnItemSelectedListener {
private byte act_size = <num> ;
private byte act_handicap = <num> ;
private final static int size_offset = <num> ;
private SeekBar size_seek ;
private SeekBar handicap_seek ;
private TextView size_text ;
private Button size_button9x9 ;
private Button size_button13x13 ;
private Button size_button19x19 ;
private Spinner black_player_spinner ;
private Spinner white_player_spinner ;
private GoBoardViewHD board ;
private TextView handicap_text ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
GoPrefs . init ( this ) ;
this . setContentView ( R . layout . game_setup ) ;
this . setTitle ( R . string . <unk> ) ;
this . getSupportActionBar ( ) . setSubtitle ( R . string . <unk> ) ;
}
public void setup_board ( ) {
board = ( GoBoardViewHD ) this . findViewById ( R . id . go_board ) ;
if ( board == null )
return ;
board . setOnTouchListener ( new OnTouchListener ( ) {
@Override
public boolean onTouch ( View v , MotionEvent event ) {
start_game ( ) ;
return false ;
}
} ) ;
board . do_line_highlight = false ;
board . do_legend = false ;
board . legend_sgf_mode = false ;
}
@Override
public void onResume ( ) {
super . onResume ( ) ;
Log . i ( " ) ;
setup_board ( ) ;
size_seek = ( SeekBar ) this . findViewById ( R . id . <unk> ) ;
size_seek . setOnSeekBarChangeListener ( this ) ;
size_text = ( TextView ) this . findViewById ( R . id . <unk> ) ;
size_button9x9 = ( Button ) this . findViewById ( R . id . size_button9x9 ) ;
size_button9x9 . setOnClickListener ( this ) ;
( ( Button ) this . findViewById ( R . id . InstallAIButton ) ) . setOnClickListener ( this ) ;
size_button13x13 = ( Button ) this . findViewById ( R . id . size_button13x13 ) ;
size_button13x13 . setOnClickListener ( this ) ;
size_button19x19 = ( Button ) this . findViewById ( R . id . size_button19x19 ) ;
size_button19x19 . setOnClickListener ( this ) ;
black_player_spinner = ( Spinner ) this . findViewById ( R . id . <unk> ) ;
String [ ] player_strings ;
if ( IntentHelper . <unk> ( this . getPackageManager ( ) , new Intent ( GnuGoMover . intent_action_name ) ) )
player_strings = new String [ ] { " , " } ;
else
player_strings = new String [ ] { " } ;
ArrayAdapter < String > spinner_adapter = new ArrayAdapter < String > ( this ,
android . R . layout . simple_spinner_item , player_strings ) ;
spinner_adapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
white_player_spinner = ( Spinner ) this . findViewById ( R . id . <unk> ) ;
black_player_spinner . setAdapter ( spinner_adapter ) ;
white_player_spinner . setAdapter ( spinner_adapter ) ;
white_player_spinner . setOnItemSelectedListener ( this ) ;
black_player_spinner . setOnItemSelectedListener ( this ) ;
int spinner_pos = spinner_adapter . getPosition ( GoPrefs . getLastPlayerBlack ( ) ) ;
if ( spinner_pos ==  <num> )
spinner_pos = <num> ;
black_player_spinner . setSelection ( spinner_pos , true ) ;
spinner_pos = spinner_adapter . getPosition ( GoPrefs . getLastPlayerWhite ( ) ) ;
if ( spinner_pos ==  <num> )
spinner_pos = <num> ;
white_player_spinner . setSelection ( spinner_pos , true ) ;
handicap_text = ( TextView ) this . findViewById ( R . id . <unk> ) ;
handicap_seek = ( SeekBar ) this . findViewById ( R . id . handicap_seek ) ;
handicap_seek . setOnSeekBarChangeListener ( this ) ;
act_size = ( byte ) GoPrefs . getLastBoardSize ( ) ;
act_handicap = ( byte ) GoPrefs . getLastHandicap ( ) ;
refresh_ui ( ) ;
}
public void refresh_ui ( ) {
size_text . setText ( getString ( R . string . size ) + " + act_size + " + act_size ) ;
handicap_text . setText ( getString ( R . string . handicap ) + " + act_handicap ) ;
if ( ( act_size  size_offset ) != size_seek . getProgress ( ) )
size_seek . setProgress ( act_size  size_offset ) ;
if ( act_handicap != handicap_seek . getProgress ( ) )
handicap_seek . setProgress ( act_handicap ) ;
if ( GoInteractionProvider . getMode ( ) == GoInteractionProvider . MODE_GNUGO )
size_seek . setMax ( <num>  size_offset ) ;
handicap_seek . setEnabled ( ( act_size == <num> ) || ( act_size == <num> ) || ( act_size == <num> ) ) ;
GoPrefs . setLastBoardSize ( act_size ) ;
GoPrefs . setLastHandicap ( act_handicap ) ;
GoGameProvider . setGame ( new GoGame ( act_size , act_handicap ) ) ;
if ( board != null ) {
board . boardSizeChanged ( ) ;
board . invalidate ( ) ;
}
}
public void onProgressChanged ( SeekBar seekBar , int progress ,
boolean fromUser ) {
if ( ( seekBar == size_seek ) && ( act_size != ( byte ) ( progress + size_offset ) ) )
act_size = ( byte ) ( progress + size_offset ) ;
else if ( ( seekBar == handicap_seek ) && ( act_handicap != ( byte ) progress ) )
act_handicap = ( byte ) progress ;
refresh_ui ( ) ;
}
@Override
public void onStartTrackingTouch ( SeekBar seekBar ) {
}
@Override
public void onStopTrackingTouch ( SeekBar seekBar ) {
}
@Override
public void onClick ( View v ) {
if ( v == ( ( Button ) this . findViewById ( R . id . InstallAIButton ) ) ) {
try {
this . startActivity ( new Intent ( ) . setAction ( Intent . ACTION_VIEW )
. setData ( Uri . parse ( " ) ) ) ;
}
catch ( Exception e ) {
new AlertDialog . Builder ( this ) . setTitle ( R . string . problem )
. setMessage (
R . string . <unk>
) . setPositiveButton ( R . string . ok , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
}
} ) . setCancelable ( true ) . show ( ) ;
}
}
else
if ( v == size_button9x9 )
act_size = <num> ;
if ( v == size_button13x13 )
act_size = <num> ;
else if ( v == size_button19x19 )
act_size = <num> ;
refresh_ui ( ) ;
}
private void start_game ( ) {
GoGame new_game = new GoGame ( act_size , act_handicap ) ;
GoGameProvider . setGame ( new_game ) ;
Intent go_intent ;
if ( GoInteractionProvider . getMode ( ) == GoInteractionProvider . MODE_RECORD )
go_intent = new Intent ( this , GameRecordActivity . class ) ;
else
go_intent = new Intent ( this , PlayAgainstGnugoActivity . class ) ;
getTracker ( ) . trackPageView ( " + act_size ) ;
startActivity ( go_intent ) ;
}
@Override
public void onItemSelected ( AdapterView < ? > selected_item , View <unk> , int pos ,
long arg3 ) {
if ( selected_item == white_player_spinner )
GoPrefs . setLastPlayerWhite ( ( String ) selected_item . getAdapter ( ) . getItem ( pos ) ) ;
if ( selected_item == black_player_spinner )
GoPrefs . setLastPlayerBlack ( ( String ) selected_item . getAdapter ( ) . getItem ( pos ) ) ;
}
@Override
public void onNothingSelected ( AdapterView < ? > arg0 ) {
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
this . getMenuInflater ( ) . inflate ( R . menu . game_setup , menu ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
Log . i ( " ) ;
switch ( item . getItemId ( ) ) {
case R . id . <unk> :
start_game ( ) ;
break ;
}
return super . onOptionsItemSelected ( item ) ;
}
package org . ligi . gobandroid_hd . ui ;
import android . content . Intent ;
public class IconicMenuItem {
public int drawable ;
public String label = null ;
public int label_resId ;
public Intent intent = null ;
public int action =  <num> ;
public IconicMenuItem ( String label , int drawable , Intent intent ) {
this . drawable = drawable ;
this . label = label ;
this . intent = intent ;
}
public IconicMenuItem ( String label , int drawable , int action ) {
this . drawable = drawable ;
this . label = label ;
this . action = action ;
}
public IconicMenuItem ( int label_resId , int drawable , Intent intent ) {
this . drawable = drawable ;
this . label_resId = label_resId ;
this . intent = intent ;
}
public IconicMenuItem ( int label_resId , int drawable , int action ) {
this . drawable = drawable ;
this . label_resId = label_resId ;
this . action = action ;
}
package org . ligi . gobandroid_hd . logic ;
public class GoMarker {
private byte x , y ;
private String text ;
public GoMarker ( byte x , byte y , String text ) {
this . x = x ;
this . y = y ;
this . text = text ;
}
public byte getX ( ) {
return x ;
}
public byte getY ( ) {
return y ;
}
public String getText ( ) {
return text ;
}
}
package org . ligi . gobandroid_hd . ui . ingame_common ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . ui . GoActivity ;
import org . ligi . gobandroid_hd . ui . GoInteractionProvider ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . gobandroid_hd . ui . recording . GameRecordActivity ;
import org . ligi . gobandroid_hd . ui . review . GameReviewActivity ;
import org . ligi . gobandroid_hd . ui . review . GoGamePlayerActivity ;
import org . ligi . gobandroid_hd . ui . tsumego . TsumegoActivity ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
public class SwitchModeHelper {
public static void startGame ( GobandroidFragmentActivity activity , byte mode ) {
GoInteractionProvider . setMode ( mode ) ;
Intent go_start_intent = new Intent ( activity , GoActivity . class ) ;
switch ( mode ) {
case GoInteractionProvider . MODE_RECORD :
go_start_intent = new Intent ( activity , GameRecordActivity . class ) ;
break ;
case GoInteractionProvider . MODE_REVIEW :
go_start_intent = new Intent ( activity , GameReviewActivity . class ) ;
break ;
case GoInteractionProvider . MODE_TSUMEGO :
go_start_intent = new Intent ( activity , TsumegoActivity . class ) ;
break ;
case GoInteractionProvider . MODE_TELEVIZE :
go_start_intent = new Intent ( activity , GoGamePlayerActivity . class ) ;
break ;
}
activity . startActivity ( go_start_intent ) ;
}
public static void startGameWithCorrectMode ( GobandroidFragmentActivity activity ) {
startGame ( activity , GoInteractionProvider . getMode ( ) ) ;
}
public static void show ( final GobandroidFragmentActivity activity ) {
new AlertDialog . Builder ( activity )
. setTitle ( R . string . <unk> )
. setItems ( R . array . <unk> , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int item ) {
switch ( item ) {
case <num> :
activity . finish ( ) ;
startGame ( activity , GoInteractionProvider . MODE_RECORD ) ;
break ;
case <num> :
activity . finish ( ) ;
startGame ( activity , GoInteractionProvider . MODE_REVIEW ) ;
break ;
case <num> :
activity . finish ( ) ;
startGame ( activity , GoInteractionProvider . MODE_TSUMEGO ) ;
break ;
}
}
} )
. show ( ) ;
}
}
package org . ligi . gobandroid_hd . ui . links ;
import org . ligi . android . common . adapter . LinkWithDescription ;
import org . ligi . android . common . adapter . LinkWithDescriptionAndTitle ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . ui . application . GobandroidFragmentActivity ;
import org . ligi . tracedroid . logging . Log ;
import android . os . Bundle ;
import android . support . v4 . app . ActionBar . Tab ;
import android . support . v4 . app . Fragment ;
import android . support . v4 . app . ActionBar ;
import android . support . v4 . app . FragmentTransaction ;
public class LinksActivity extends GobandroidFragmentActivity implements ActionBar . TabListener {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . setContentView ( R . layout . list ) ;
this . setTitle ( R . string . <unk> ) ;
getSupportActionBar ( ) . setNavigationMode ( ActionBar . NAVIGATION_MODE_TABS ) ;
int [ ] tabs = new int [ ] { R . string . link_tab_about , R . string . link_tab_help , R . string . link_tab_sgf } ;
for ( int tab_str : tabs ) {
ActionBar . Tab tab = getSupportActionBar ( ) . newTab ( ) ;
tab . setText ( tab_str ) ;
tab . setTag ( tab_str ) ;
tab . setTabListener ( this ) ;
getSupportActionBar ( ) . addTab ( tab ) ;
}
setList ( R . string . link_tab_about ) ;
}
public void changeFragment ( Fragment newFragment ) {
getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . list_fragment , newFragment ) . commit ( ) ;
}
public void setList ( int list ) {
Log . i ( " + list ) ;
LinkWithDescription [ ] links = null ;
switch ( list ) {
case R . string . link_tab_about :
links = new LinkWithDescription [ ] {
new LinkWithDescriptionAndTitle ( " , " , " ) ,
new LinkWithDescriptionAndTitle ( " , " , " ) ,
new LinkWithDescriptionAndTitle ( " , " , " ) ,
new LinkWithDescriptionAndTitle ( " , " , " ) ,
new LinkWithDescriptionAndTitle ( " , " , " ) ,
new LinkWithDescriptionAndTitle ( " , " , " ) ,
new LinkWithDescriptionAndTitle ( " , " , " ) ,
new LinkWithDescriptionAndTitle ( " , " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " )
} ;
break ;
case R . string . link_tab_sgf :
links = new LinkWithDescription [ ] {
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " )
} ;
break ;
case R . string . link_tab_help :
links = new LinkWithDescription [ ] {
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " ) ,
new LinkWithDescription ( " , " )
} ;
break ;
}
changeFragment ( new LinkListFragment ( links ) ) ;
}
@Override
public void onTabReselected ( Tab tab , FragmentTransaction ft ) { }
@Override
public void onTabSelected ( Tab tab , FragmentTransaction ft ) {
getTracker ( ) . trackPageView ( " + tab . getText ( ) ) ;
setList ( ( Integer ) tab . getTag ( ) ) ;
}
@Override
public void onTabUnselected ( Tab tab , FragmentTransaction ft ) { }
}
package org . ligi . gobandroid_hd . ui ;
import org . ligi . gobandroid_hd . R ;
import android . os . Bundle ;
import android . support . v4 . app . FragmentActivity ;
public class SGFOnlineListActivity extends FragmentActivity {
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . list ) ;
}
package org . ligi . gobandroid_hd . logic ;
public class GoBoard {
private byte size ;
public byte [ ] [ ] board ;
public GoBoard ( byte size ) {
this . size = size ;
board = new byte [ size ] [ size ] ;
}
public GoBoard ( byte size , byte [ ] [ ] predefined_board ) {
this . size = size ;
board = new byte [ size ] [ size ] ;
for ( int x = <num> ; x < size ; x ++ )
for ( int y = <num> ; y < size ; y ++ )
board [ x ] [ y ] = predefined_board [ x ] [ y ] ;
}
public GoBoard clone ( ) {
return new GoBoard ( size , board ) ;
}
public boolean equals ( GoBoard other ) {
if ( other == null )
return false ;
if ( size != other . size )
return false ;
for ( int x = <num> ; x < size ; x ++ )
for ( int y = <num> ; y < size ; y ++ )
if ( board [ x ] [ y ] != other . board [ x ] [ y ] )
return false ;
return true ;
}
public String toString ( ) {
String res = " ;
String tmp_str = " ;
for ( int y = <num> ; y < size ; y ++ ) {
for ( int x = <num> ; x < size ; x ++ ) {
if ( board [ x ] [ y ] == GoDefinitions . STONE_NONE )
tmp_str += " ;
else if ( board [ x ] [ y ] == GoDefinitions . STONE_BLACK )
tmp_str += " ;
else if ( board [ x ] [ y ] == GoDefinitions . STONE_WHITE )
tmp_str += " ;
else if ( board [ x ] [ y ] ==  GoDefinitions . STONE_BLACK )
tmp_str += " ;
else if ( board [ x ] [ y ] ==  GoDefinitions . STONE_WHITE )
tmp_str += " ;
}
res += tmp_str + " ;
tmp_str = " ;
}
return res ;
}
public int getSize ( ) {
return size ;
}
public boolean isCellFree ( int x , int y ) {
return ( board [ x ] [ y ] == GoDefinitions . STONE_NONE )
|| ( board [ x ] [ y ] < <num> ) ;
}
public boolean isCellBlack ( int x , int y ) {
return ( board [ x ] [ y ] == GoDefinitions . STONE_BLACK ) ;
}
public boolean isCellWhite ( int x , int y ) {
return ( board [ x ] [ y ] == GoDefinitions . STONE_WHITE ) ;
}
public boolean isCellDeadBlack ( int x , int y ) {
return (  board [ x ] [ y ] == GoDefinitions . STONE_BLACK ) ;
}
public boolean isCellDeadWhite ( int x , int y ) {
return (  board [ x ] [ y ] == GoDefinitions . STONE_WHITE ) ;
}
public boolean areCellsEqual ( int x , int y , int x2 , int y2 ) {
return ( ( board [ x ] [ y ] == board [ x2 ] [ y2 ] ) ||
( isCellFree ( x , y ) && isCellFree ( x2 , y2 ) ) ) ;
}
public void setCellFree ( int x , int y ) {
board [ x ] [ y ] = GoDefinitions . STONE_NONE ;
}
public void setCellBlack ( int x , int y ) {
board [ x ] [ y ] = GoDefinitions . STONE_BLACK ;
}
public void setCellWhite ( int x , int y ) {
board [ x ] [ y ] = GoDefinitions . STONE_WHITE ;
}
public void toggleCellDead ( int x , int y ) {
board [ x ] [ y ] *=  <num> ;
}
public boolean isCellDead ( int x , int y ) {
return ( board [ x ] [ y ] < <num> ) ;
}
package org . ligi . gobandroid_hd . logic ;
import org . ligi . <unk> . ai . <unk> . IGnuGoService ;
import org . ligi . tracedroid . logging . Log ;
import android . app . Activity ;
import android . app . Application ;
import android . content . ComponentName ;
import android . content . Context ;
import android . content . Intent ;
import android . content . ServiceConnection ;
import android . os . IBinder ;
import android . os . RemoteException ;
public class GnuGoMover implements Runnable {
private IGnuGoService gnu_service ;
private GoGame game ;
private boolean gnugo_size_set = false ;
public boolean playing_black = false ;
public boolean playing_white = false ;
public boolean paused = false ;
public boolean thinking = false ;
public final static String intent_action_name = " ;
private byte level ;
private Application application ;
private ServiceConnection conn ;
private Thread mover_thread ;
public GnuGoMover ( ) {
this . playing_black = false ;
this . playing_white = false ;
}
public GnuGoMover ( Activity activity , GoGame game , boolean playing_black , boolean playing_white , byte level ) {
this . application = activity . getApplication ( ) ;
this . level = level ;
this . playing_black = playing_black ;
this . playing_white = playing_white ;
this . game = game ;
if ( playing_black || playing_white )
{
conn = new ServiceConnection ( ) {
@Override
public void onServiceConnected ( ComponentName name , IBinder service ) {
gnu_service = IGnuGoService . Stub . asInterface ( service ) ;
try {
Log . i ( " + gnu_service . processGTP ( " ) ) ;
} catch ( RemoteException e ) { }
}
@Override
public void onServiceDisconnected ( ComponentName name ) {
Log . i ( " ) ;
}
} ;
application . bindService ( new Intent ( intent_action_name ) , conn , Context . BIND_AUTO_CREATE ) ;
mover_thread = new Thread ( this ) ;
mover_thread . start ( ) ;
}
}
public boolean isReady ( ) {
return ( ! isPlayingInThisGame ( ) )
|| ( gnu_service != null ) ;
}
public boolean isPlayingInThisGame ( ) {
return ( playing_black || playing_white ) ;
}
public String coordinates2gtpstr ( byte x , byte y ) {
if ( game == null ) {
Log . w ( " ) ;
return " ;
}
if ( x >= <num> ) x ++ ;
y = ( byte ) ( game . getBoardSize ( )  ( y ) ) ;
return " + ( char ) ( A' + x ) + " + ( y ) ;
}
public void processWhiteMove ( byte x , byte y ) {
try {
gnu_service . processGTP ( " + coordinates2gtpstr ( x , y ) ) ;
} catch ( Exception e ) {
Log . w ( " + coordinates2gtpstr ( x , y ) ) ;
}
}
public void processBlackMove ( byte x , byte y ) {
try {
gnu_service . processGTP ( " + coordinates2gtpstr ( x , y ) ) ;
} catch ( Exception e ) {
Log . w ( " + coordinates2gtpstr ( x , y ) ) ;
}
}
public void stop ( ) {
try {
if ( ! game . isFinished ( ) ) {
game . pass ( ) ;
game . pass ( ) ;
}
Log . i ( " + game . isFinished ( ) ) ;
application . unbindService ( conn ) ;
application . stopService ( new Intent ( intent_action_name ) ) ;
}
catch ( Exception e ) { }
}
@Override
public void run ( ) {
while ( ! game . isFinished ( ) ) {
try {
Thread . sleep ( <num> ) ;
} catch ( InterruptedException e ) {
e . printStackTrace ( ) ;
}
if ( ( gnu_service == null ) || ( paused ) )
continue ;
if ( ! gnugo_size_set )
try {
gnu_service . processGTP ( " + game . getBoardSize ( ) ) ;
for ( byte x = <num> ; x < game . getBoardSize ( ) ; x ++ )
for ( byte y = <num> ; y < game . getBoardSize ( ) ; y ++ )
if ( game . getHandicapBoard ( ) . isCellBlack ( x , y ) )
gnu_service . processGTP ( " + coordinates2gtpstr ( x , y ) ) ;
Log . i ( " + gnu_service . processGTP ( " + level ) ) ;
gnugo_size_set = true ;
} catch ( RemoteException e ) { }
if ( isMoversMove ( ) )
{
thinking = true ;
if ( game . isBlackToMove ( ) ) {
try {
String answer = gnu_service . processGTP ( " ) ;
if ( game . isFinished ( ) )
break ;
GTPHelper . doMoveByGTPString ( answer , game ) ;
Log . i ( " + gnu_service . processGTP ( " ) ) ;
} catch ( RemoteException e ) { }
}
else {
try {
String answer = gnu_service . processGTP ( " ) ;
if ( game . isFinished ( ) )
break ;
GTPHelper . doMoveByGTPString ( answer , game ) ;
Log . i ( " + gnu_service . processGTP ( " ) ) ;
} catch ( RemoteException e ) { }
}
thinking = false ;
}
}
stop ( ) ;
}
public boolean <unk> ( ) {
return thinking ;
}
public void undo ( ) {
try {
gnu_service . processGTP ( " ) ;
} catch ( Exception e ) {
Log . i ( " + e ) ;
}
}
public boolean isMoversMove ( ) {
if ( ! isPlayingInThisGame ( ) )
return false ;
return
( game . isBlackToMove ( ) && ( playing_black ) ) || ( ! game . isBlackToMove ( ) && ( playing_white ) ) ;
}
}
package org . ligi . gobandroid_hd . ui ;
import java . io . File ;
import java . io . FileOutputStream ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . gobandroid_hd . logic . GoDefinitions ;
import org . ligi . gobandroid_hd . logic . GoGame ;
import org . ligi . gobandroid_hd . logic . GoGameProvider ;
import org . ligi . gobandroid_hd . logic . GoMarker ;
import org . ligi . tracedroid . logging . Log ;
import android . app . AlertDialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . graphics . Bitmap ;
import android . graphics . Bitmap . Config ;
import android . graphics . BitmapFactory ;
import android . graphics . Canvas ;
import android . graphics . Matrix ;
import android . graphics . Paint ;
import android . graphics . Paint . FontMetrics ;
import android . graphics . Point ;
import android . graphics . PointF ;
import android . util . AttributeSet ;
import android . view . View ;
public class GoBoardViewHD extends View {
private int zoom_poi =  <num> ;
public boolean grid_embos = true ;
public boolean do_legend = true ;
public boolean do_line_highlight = true ;
public boolean do_mark_act = true ;
public boolean mark_last_stone = true ;
public boolean legend_sgf_mode = true ;
private Paint whitePaint ;
private Paint blackPaint ;
private Paint blackTextPaint ;
private Paint whiteTextPaint ;
private Paint boardPaint ;
private Paint gridPaint ;
private Paint gridPaint_h ;
private Paint textPaint ;
private Paint bitmapPaint ;
private Paint placeStonePaint ;
public float stone_size ;
private float stone_size_normal ;
private Bitmap white_stone_bitmap = null ;
private Bitmap black_stone_bitmap = null ;
private Bitmap white_stone_bitmap_small = null ;
private Bitmap black_stone_bitmap_small = null ;
public boolean move_stone_mode = false ;
private boolean regenerate_stones_flag = true ;
private boolean enforce_square = true ;
private float zoom = <num> ;
public GoBoardViewHD ( Context context ) {
super ( context ) ;
init ( ) ;
}
public GoBoardViewHD ( Context context , boolean square , float zoom ) {
super ( context ) ;
this . zoom = zoom ;
enforce_square = square ;
init ( ) ;
}
public GoBoardViewHD ( Context context , AttributeSet attrs ) {
super ( context , attrs ) ;
init ( ) ;
}
public void init ( ) {
whitePaint = new Paint ( ) ;
whitePaint . setColor ( <num> ) ;
whitePaint . setAntiAlias ( true ) ;
whiteTextPaint = new Paint ( ) ;
whiteTextPaint . setColor ( <num> ) ;
whiteTextPaint . setAntiAlias ( true ) ;
whiteTextPaint . setTextAlign ( Paint . Align . CENTER ) ;
whiteTextPaint . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
blackTextPaint = new Paint ( ) ;
blackTextPaint . setColor ( <num> ) ;
blackTextPaint . setAntiAlias ( true ) ;
blackTextPaint . setTextAlign ( Paint . Align . CENTER ) ;
blackTextPaint . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
blackPaint = new Paint ( ) ;
blackPaint . setColor ( <num> ) ;
blackPaint . setAntiAlias ( true ) ;
boardPaint = new Paint ( ) ;
boardPaint . setColor ( <num> ) ;
gridPaint = new Paint ( ) ;
gridPaint_h = new Paint ( ) ;
gridPaint_h . setColor ( <num> ) ;
gridPaint_h . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
gridPaint . setColor ( <num> ) ;
gridPaint . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
gridPaint . setTextAlign ( Paint . Align . CENTER ) ;
gridPaint . setTextSize ( <num> ) ;
textPaint = new Paint ( ) ;
textPaint . setColor ( <num> ) ;
textPaint . setAntiAlias ( false ) ;
bitmapPaint = new Paint ( ) ;
placeStonePaint = new Paint ( ) ;
placeStonePaint . setAlpha ( <num> ) ;
setFocusable ( true ) ;
if ( getGame ( ) == null )
GoGameProvider . setGame ( new GoGame ( ( byte ) <num> ) ) ;
}
public GoGame getGame ( ) {
return GoGameProvider . getGame ( ) ;
}
public Bitmap resize_to_screen ( Bitmap orig , float x_scale_ , float y_scale_ ) {
Matrix matrix = new Matrix ( ) ;
float x_scale , y_scale ;
if ( y_scale_ != <num> )
y_scale = ( getHeight ( ) * y_scale_ ) / orig . getHeight ( ) ;
else
y_scale = ( getWidth ( ) * x_scale_ ) / orig . getWidth ( ) ;
if ( x_scale_ != <num> )
x_scale = ( getWidth ( ) * x_scale_ ) / orig . getWidth ( ) ;
else
x_scale = ( getHeight ( ) * y_scale_ ) / orig . getHeight ( ) ;
matrix . postScale ( x_scale , y_scale ) ;
return Bitmap . createBitmap ( orig , <num> , <num> , ( int ) ( orig . getWidth ( ) ) ,
( int ) ( orig . getHeight ( ) ) , matrix , true ) ;
}
public void prepare_keyinput ( ) {
if ( GoInteractionProvider . getTouchPosition ( ) < <num> )
GoInteractionProvider . setTouchPosition ( <num> ) ;
}
public void setZoom ( float zoom ) {
this . zoom = zoom ;
setSize ( this . getWidth ( ) , this . getHeight ( ) ) ;
}
public PointF getZoomTranslate ( ) {
if ( zoom <= <num> )
return new PointF ( <num> , <num> ) ;
int act_zoom_poi = <num> ;
if ( zoom_poi >= <num> ) {
act_zoom_poi = zoom_poi ;
} else if ( GoInteractionProvider . getTouchPosition ( ) >= <num> ) {
act_zoom_poi = GoInteractionProvider . getTouchPosition ( ) ;
} else
Log . w ( " ) ;
Point act_zoom_point = getGame ( ) . linear_coordinate2Point ( act_zoom_poi ) ;
PointF res = new PointF (  stone_size * ( act_zoom_point . x  getGame ( ) . getSize ( ) / <num> / zoom )
,  stone_size * ( act_zoom_point . y  getGame ( ) . getSize ( ) / <num> / zoom ) ) ;
return res ;
}
public void screenshot ( String sshot_name ) {
Bitmap bmp = Bitmap . createBitmap ( this . getWidth ( ) , this . getHeight ( ) , Config . ARGB_8888 ) ;
Canvas c = new Canvas ( bmp ) ;
draw2canvas ( c ) ;
try {
if ( sshot_name . indexOf ( " ) > <num> )
sshot_name = sshot_name . substring ( sshot_name . indexOf ( " ) + <num> ) ;
Log . i ( " + sshot_name ) ;
new File ( sshot_name . substring ( <num> , sshot_name . lastIndexOf ( " ) ) ) . mkdirs ( ) ;
new File ( sshot_name ) . createNewFile ( ) ;
FileOutputStream out = new FileOutputStream ( sshot_name ) ;
bmp . compress ( Bitmap . CompressFormat . PNG , <num> , out ) ;
out . close ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
@Override
protected void onDraw ( Canvas canvas ) {
draw2canvas ( canvas ) ;
}
protected void draw2canvas ( Canvas canvas ) {
Log . i ( " ) ;
canvas . save ( ) ;
if ( zoom > <num> ) {
canvas . translate ( getZoomTranslate ( ) . x , getZoomTranslate ( ) . y ) ;
}
if ( regenerate_stones_flag )
regenerate_images ( ) ;
boolean line_highlight_condition = do_line_highlight && GoInteractionProvider . hasValidTouchCoord ( ) ;
if ( ( ! move_stone_mode ) && do_mark_act ) {
if ( getGame ( ) . isBlackToMove ( ) )
canvas . drawBitmap ( black_stone_bitmap , GoInteractionProvider . getTouchX ( ) * stone_size , GoInteractionProvider . getTouchY ( ) * stone_size , placeStonePaint ) ;
else
canvas . drawBitmap ( white_stone_bitmap , GoInteractionProvider . getTouchX ( ) * stone_size , GoInteractionProvider . getTouchY ( ) * stone_size , placeStonePaint ) ;
}
for ( byte x = <num> ; x < getGame ( ) . getVisualBoard ( ) . getSize ( ) ; x ++ )
canvas . drawLine ( stone_size / <num> + x * stone_size , stone_size / <num> , stone_size / <num> + x * stone_size , stone_size * ( float ) ( getGame ( ) . getVisualBoard ( ) . getSize ( )  <num> ) + stone_size / <num> , ( line_highlight_condition && ( GoInteractionProvider . getTouchX ( ) == x ) ) ? gridPaint_h : gridPaint ) ;
for ( byte x = <num> ; x < getGame ( ) . getVisualBoard ( ) . getSize ( ) ; x ++ )
{
canvas . drawLine ( stone_size / <num> , stone_size / <num> + x * stone_size , stone_size * ( float ) ( getGame ( ) . getVisualBoard ( ) . getSize ( )  <num> ) + stone_size / <num> , stone_size / <num> + x * stone_size , ( line_highlight_condition && ( GoInteractionProvider . getTouchY ( ) == x ) ) ? gridPaint_h : gridPaint ) ;
if ( do_legend ) {
canvas . drawText ( " + ( <num> + x ) , <num> + stone_size * ( float ) ( getGame ( ) . getVisualBoard ( ) . getSize ( )  <num> ) + stone_size / <num> , stone_size / <num> + x * stone_size + gridPaint . getTextSize ( ) / <num> , gridPaint ) ;
if ( ( x > <num> ) && legend_sgf_mode )
canvas . drawText ( " + ( char ) ( A' + ( x + <num> ) ) , stone_size / <num> + x * stone_size , stone_size * ( float ) ( getGame ( ) . getVisualBoard ( ) . getSize ( )  <num> ) + stone_size / <num> + <num> + gridPaint . getTextSize ( ) , gridPaint ) ;
else
canvas . drawText ( " + ( char ) ( A' + x ) , stone_size / <num> + x * stone_size , stone_size * ( float ) ( getGame ( ) . getVisualBoard ( ) . getSize ( )  <num> ) + stone_size / <num> + <num> + gridPaint . getTextSize ( ) , gridPaint ) ;
}
}
for ( byte x = <num> ; x < getGame ( ) . getVisualBoard ( ) . getSize ( ) ; x ++ )
for ( byte y = <num> ; y < getGame ( ) . getVisualBoard ( ) . getSize ( ) ; y ++ ) {
blackPaint . setColor ( <num> ) ;
blackPaint . setStrokeWidth ( stone_size / <num> ) ;
if ( getGame ( ) . isPosHoschi ( x , y ) )
canvas . drawCircle ( stone_size / <num> + x * stone_size + <num> , stone_size / <num> + y * stone_size + <num> , stone_size / <num> , blackPaint ) ;
if ( getGame ( ) . isFinished ( ) ) {
blackPaint . setColor ( <num> ) ;
whitePaint . setColor ( <num> ) ;
if ( getGame ( ) . area_assign [ x ] [ y ] == GoDefinitions . PLAYER_BLACK )
canvas . drawBitmap ( black_stone_bitmap , x * stone_size , y * stone_size , whitePaint ) ;
if ( getGame ( ) . area_assign [ x ] [ y ] == GoDefinitions . PLAYER_WHITE )
canvas . drawBitmap ( white_stone_bitmap , x * stone_size , y * stone_size , whitePaint ) ;
}
blackPaint . setColor ( <num> ) ;
whitePaint . setColor ( <num> ) ;
if ( getGame ( ) . getCalcBoard ( ) . isCellDead ( x , y ) ) {
if ( getGame ( ) . getVisualBoard ( ) . isCellWhite ( x , y ) )
canvas . drawBitmap ( white_stone_bitmap_small , x * stone_size + ( stone_size  white_stone_bitmap_small . getWidth ( ) ) / <num> , y * stone_size + ( stone_size  white_stone_bitmap_small . getHeight ( ) ) / <num> , whitePaint ) ;
if ( getGame ( ) . getVisualBoard ( ) . isCellBlack ( x , y ) )
canvas . drawBitmap ( black_stone_bitmap_small , x * stone_size + ( stone_size  black_stone_bitmap_small . getWidth ( ) ) / <num> , y * stone_size + ( stone_size  black_stone_bitmap_small . getHeight ( ) ) / <num> , whitePaint ) ;
}
else {
if ( move_stone_mode && ( x == getGame ( ) . getActMove ( ) . getX ( ) ) && ( y == getGame ( ) . getActMove ( ) . getY ( ) ) )
bitmapPaint . setAlpha ( <num> ) ;
else
bitmapPaint . setAlpha ( <num> ) ;
if ( getGame ( ) . getVisualBoard ( ) . isCellWhite ( x , y ) )
canvas . drawBitmap ( white_stone_bitmap , x * stone_size , y * stone_size , bitmapPaint ) ;
if ( getGame ( ) . getVisualBoard ( ) . isCellBlack ( x , y ) )
canvas . drawBitmap ( black_stone_bitmap , x * stone_size , y * stone_size , bitmapPaint ) ;
if ( mark_last_stone ) {
blackPaint . setStyle ( Paint . Style . STROKE ) ;
whitePaint . setStyle ( Paint . Style . STROKE ) ;
whitePaint . setStrokeWidth ( <num> ) ;
blackPaint . setStrokeWidth ( <num> ) ;
if ( ( getGame ( ) . getActMove ( ) . getX ( ) == x ) && ( getGame ( ) . getActMove ( ) . getY ( ) == y ) ) {
if ( getGame ( ) . getVisualBoard ( ) . isCellWhite ( x , y ) )
canvas . drawCircle ( stone_size / <num> + x * stone_size , stone_size / <num> + y * stone_size , stone_size / <num> , blackPaint ) ;
if ( getGame ( ) . getVisualBoard ( ) . isCellBlack ( x , y ) )
canvas . drawCircle ( stone_size / <num> + x * stone_size , stone_size / <num> + y * stone_size , stone_size / <num> , whitePaint ) ;
}
}
}
}
FontMetrics fm = whiteTextPaint . getFontMetrics ( ) ;
for ( GoMarker marker : getGame ( ) . getActMove ( ) . getMarkers ( ) )
if ( getGame ( ) . getVisualBoard ( ) . isCellBlack ( marker . getX ( ) , marker . getY ( ) ) )
canvas . drawText ( marker . getText ( ) , marker . getX ( ) * stone_size + stone_size / <num> , marker . getY ( ) * stone_size  ( fm . top + fm . bottom ) , whiteTextPaint ) ;
else
canvas . drawText ( marker . getText ( ) , marker . getX ( ) * stone_size + stone_size / <num> , marker . getY ( ) * stone_size  ( fm . top + fm . bottom ) , blackTextPaint ) ;
canvas . restore ( ) ;
}
public float getBoardPixels ( ) {
return stone_size * getGame ( ) . getVisualBoard ( ) . getSize ( ) ;
}
private Bitmap getScaledRes ( float size , int resID ) {
Bitmap unscaled_bitmap = BitmapFactory . decodeResource ( this . getResources ( ) , resID ) ;
return Bitmap . createScaledBitmap ( unscaled_bitmap , ( int ) size , ( int ) size , true ) ;
}
public void regenerate_images ( ) {
Log . i ( " + stone_size ) ;
float SMALL_STONE_SCALER = <num> ;
white_stone_bitmap = getScaledRes ( stone_size , R . drawable . stone_white ) ;
black_stone_bitmap = getScaledRes ( stone_size , R . drawable . stone_black ) ;
white_stone_bitmap_small = getScaledRes ( stone_size * SMALL_STONE_SCALER , R . drawable . stone_white ) ;
black_stone_bitmap_small = getScaledRes ( stone_size * SMALL_STONE_SCALER , R . drawable . stone_black ) ;
regenerate_stones_flag = false ;
whiteTextPaint . setTextSize ( stone_size ) ;
blackTextPaint . setTextSize ( stone_size ) ;
if ( grid_embos )
gridPaint . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
else
gridPaint . setShadowLayer ( <num> , <num> , <num> , <num> ) ;
}
@Override
protected void onSizeChanged ( int w , int h , int oldw , int oldh ) {
setSize ( w , h ) ;
}
private void setSize ( int w , int h ) {
stone_size_normal = zoom * ( ( ( w < h ) ? w : h ) / ( float ) getGame ( ) . getVisualBoard ( ) . getSize ( ) ) ;
stone_size = stone_size_normal ;
regenerate_stones_flag = true ;
}
public void boardSizeChanged ( ) {
setSize ( this . getWidth ( ) , this . getHeight ( ) ) ;
}
public void initializeStoneMove ( ) {
if ( getGame ( ) . getGoMover ( ) . isPlayingInThisGame ( ) )
return ;
if ( move_stone_mode )
return ;
move_stone_mode = true ;
if ( GoPrefs . isAnnounceMoveActive ( ) ) {
new AlertDialog . Builder ( this . getContext ( ) ) . setMessage ( R . string . hint_stone_move )
. setPositiveButton ( R . string . ok ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton ) {
GoPrefs . setAnnounceMoveActive ( false ) ;
}
} ) . show ( ) ;
}
}
public void setRegenerataStonesFlag ( boolean new_flag ) {
regenerate_stones_flag = new_flag ;
}
@Override
protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) {
super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ;
if ( enforce_square ) {
int parentWidth = MeasureSpec . getSize ( widthMeasureSpec ) ;
int parentHeight = MeasureSpec . getSize ( heightMeasureSpec ) ;
int size = Math . min ( parentWidth , parentHeight ) ;
this . setMeasuredDimension ( size , size ) ;
}
}
public void setZoomPOI ( int zoom_poi ) {
this . zoom_poi = zoom_poi ;
}
public int pixel2boardPos ( float x , float y ) {
return ( int ) ( ( x  getZoomTranslate ( ) . x ) / ( stone_size )
+ ( int ) ( ( ( y  getZoomTranslate ( ) . y ) ) / ( stone_size ) ) * getGame ( ) . getSize ( ) ) ;
}
package org . ligi . gobandroid_hd . logic ;
import org . ligi . tracedroid . logging . Log ;
public class GTPHelper {
public static void doMoveByGTPString ( String gtp_str , GoGame game ) {
Log . i ( " + gtp_str ) ;
gtp_str = gtp_str . replace ( " , " ) ;
gtp_str = gtp_str . replace ( " , " ) ;
gtp_str = gtp_str . replace ( " , " ) ;
gtp_str = gtp_str . replace ( " , " ) ;
gtp_str = gtp_str . replace ( " , " ) ;
if ( gtp_str . equals ( " ) )
game . pass ( ) ;
else if ( gtp_str . equals ( " ) )
game . pass ( ) ;
else {
byte x = ( byte ) ( gtp_str . charAt ( <num> )  A' ) ;
if ( x > <num> )
x  ;
gtp_str = gtp_str . substring ( <num> ) ;
byte y = ( byte ) ( game . getBoardSize ( )  ( Byte . parseByte ( gtp_str ) ) ) ;
game . do_move ( x , y ) ;
}
}
}
package org . ligi . gobandroid_hd . ui . tsumego ;
import org . ligi . gobandroid_hd . R ;
import org . ligi . tracedroid . logging . Log ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . TextView ;
public class TsumegoGameExtrasFragment extends Fragment {
private View off_path_view , correct_view , res ;
private boolean off_path_visible = false , correct_visible = false ;
@Override
public View onCreateView ( LayoutInflater inflater , ViewGroup container ,
Bundle savedInstanceState ) {
Log . i ( " ) ;
res = inflater . inflate ( R . layout . <unk> , null ) ;
correct_view = res . findViewById ( R . id . <unk> ) ;
off_path_view = res . findViewById ( R . id . <unk> ) ;
setOffPathVisibility ( off_path_visible ) ;
setCorrectVisibility ( correct_visible ) ;
return res ;
}
public void setOffPathVisibility ( boolean visible ) {
off_path_visible = visible ;
Log . i ( " + visible ) ;
if ( off_path_view != null )
off_path_view . setVisibility ( visible ? TextView . VISIBLE : TextView . GONE ) ;
}
public void setCorrectVisibility ( boolean visible ) {
correct_visible = visible ;
if ( correct_view != null )
correct_view . setVisibility ( visible ? View . VISIBLE : View . GONE ) ;
}
}
public class ThreeByThreeGrid implements Grid {
public boolean hasWinner ( Board board ) {
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> ) ) return true ;
return false ;
}
public String displayString ( ) {
return " +
" +
" +
" +
" ;
}
}
public class FourByFourGrid implements Grid {
public boolean hasWinner ( Board board ) {
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> , <num> ) ) return true ;
if ( board . allOccupiedBySamePlayer ( <num> , <num> , <num> , <num> ) ) return true ;
return false ;
}
public String displayString ( ) {
return " +
" +
" +
" +
" +
" +
" ;
}
}
import java . util . Arrays ;
import java . util . List ;
public class Board {
private List < String > squares ;
private Grid strategy ;
public static Board createFourByFourBoard ( ) {
return new Board ( Arrays . asList ( " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " ) , new FourByFourGrid ( ) ) ;
}
public static Board createBoard ( ) {
return new Board ( Arrays . asList ( " , " , " , " , " , " , " , " , " ) , new ThreeByThreeGrid ( ) ) ;
}
private Board ( List < String > squares , Grid grid ) {
this . squares = squares ;
this . strategy = grid ;
}
public boolean hasWinner ( ) {
return strategy . hasWinner ( this ) ;
}
public void playX ( Integer index ) {
play ( " , index ) ;
}
public void playO ( Integer index ) {
play ( " , index ) ;
}
public boolean allOccupiedBySamePlayer ( Integer . . . squareIndexes ) {
if ( ! occupied ( squareIndexes [ <num> ] ) ) return false ;
String symbol = squares . get ( squareIndexes [ <num> ] ) ;
for ( Integer predicate : squareIndexes ) {
if ( ! symbol . equals ( squares . get ( predicate ) ) )
return false ;
}
return true ;
}
private void play ( String symbol , Integer index ) {
if ( occupied ( index ) )
throw new RuntimeException ( " ) ;
squares . set ( index , symbol ) ;
}
private boolean occupied ( Integer index ) {
return ! squares . get ( index ) . equals ( " ) ;
}
@Override
public String toString ( ) {
return String . format ( strategy . displayString ( ) , squares . toArray ( ) ) ;
}
}
import static org . junit . Assert . assertEquals ;
import static org . junit . Assert . assertFalse ;
import static org . junit . Assert . assertTrue ;
import junit . framework . Assert ;
import org . junit . Test ;
public class <unk> {
@Test
public void <unk> ( ) throws Exception {
String output = Board . createBoard ( ) . toString ( ) ;
assertEquals ( "
+ "
+ "
+ "
+ " , output ) ;
}
@Test
public void <unk> ( ) throws Exception {
Board board = Board . createBoard ( ) ;
board . playX ( <num> ) ;
assertEquals ( "
+ "
+ "
+ "
+ " , board . toString ( ) ) ;
}
@Test
public void <unk> ( ) throws Exception {
Board board = Board . createBoard ( ) ;
board . playO ( <num> ) ;
assertEquals ( "
+ "
+ "
+ "
+ " , board . toString ( ) ) ;
}
@Test
public void <unk> ( ) throws Exception {
Board board = Board . createBoard ( ) ;
try {
board . playX ( <num> ) ;
board . playO ( <num> ) ;
Assert . fail ( ) ;
} catch ( Exception e ) {
}
assertEquals ( "
+ "
+ "
+ "
+ " , board . toString ( ) ) ;
}
@Test
public void <unk> ( ) {
Board board = Board . createBoard ( ) ;
board . playX ( <num> ) ;
board . playX ( <num> ) ;
assertFalse ( board . hasWinner ( ) ) ;
board . playX ( <num> ) ;
assertTrue ( board . hasWinner ( ) ) ;
}
@Test
public void <unk> ( ) {
Board board = Board . createBoard ( ) ;
board . playX ( <num> ) ;
board . playX ( <num> ) ;
assertFalse ( board . hasWinner ( ) ) ;
board . playX ( <num> ) ;
assertTrue ( board . hasWinner ( ) ) ;
}
@Test
public void <unk> ( ) {
Board board = Board . createBoard ( ) ;
board . playX ( <num> ) ;
board . playX ( <num> ) ;
assertFalse ( board . hasWinner ( ) ) ;
board . playX ( <num> ) ;
assertTrue ( board . hasWinner ( ) ) ;
}
@Test
public void <unk> ( ) {
Board board = Board . createBoard ( ) ;
board . playX ( <num> ) ;
board . playX ( <num> ) ;
board . playO ( <num> ) ;
assertFalse ( board . hasWinner ( ) ) ;
}
@Test(expected=RuntimeException.class)
public void <unk> ( ) {
Board board = Board . createBoard ( ) ;
board . playX ( <num> ) ;
}
@Test(expected=RuntimeException.class)
public void <unk> ( ) {
Board board = Board . createBoard ( ) ;
board . playX (  <num> ) ;
}
@Test
public void <unk> ( ) {
Board board = Board . createFourByFourBoard ( ) ;
assertEquals ( "
+ "
+ "
+ "
+ "
+ "
+ " , board . toString ( ) ) ;
}
@Test
public void <unk> ( ) {
Board board = Board . createFourByFourBoard ( ) ;
board . playX ( <num> ) ;
board . playX ( <num> ) ;
board . playX ( <num> ) ;
assertFalse ( board . hasWinner ( ) ) ;
board . playX ( <num> ) ;
assertTrue ( board . hasWinner ( ) ) ;
}
}
public interface Grid {
boolean hasWinner ( Board board ) ;
String displayString ( ) ;
}
package me . <unk> . <unk> ;
import org . bukkit . Bukkit ;
import org . bukkit . ChatColor ;
import org . bukkit . entity . Player ;
import org . bukkit . event . EventHandler ;
import org . bukkit . event . Listener ;
import org . bukkit . event . player . PlayerJoinEvent ;
import org . bukkit . event . player . PlayerQuitEvent ;
import org . bukkit . plugin . PluginManager ;
import org . bukkit . plugin . java . JavaPlugin ;
public class <unk> extends JavaPlugin implements Listener {
public void onDisable ( ) {
System . out . println ( getDescription ( ) . getName ( ) + " + getDescription ( ) . getVersion ( ) + " ) ;
}
public void onEnable ( ) {
System . out . println ( getDescription ( ) . getName ( ) + " + getDescription ( ) . getVersion ( ) + " ) ;
PluginManager pm = this . getServer ( ) . getPluginManager ( ) ;
pm . registerEvents ( this , this ) ;
}
@EventHandler
public void onPlayerJoin ( PlayerJoinEvent event ) {
Player player = event . getPlayer ( ) ;
if ( player . hasPermission ( " ) ) {
event . setJoinMessage ( " ) ;
for ( Player onlinePlayer : Bukkit . getServer ( ) . getOnlinePlayers ( ) ) {
if ( onlinePlayer . isOp ( ) ) {
onlinePlayer . sendMessage ( ChatColor . GREEN + player . getName ( ) + " ) ;
}
}
return ;
}
if ( player . hasPermission ( " ) ) {
for ( org . bukkit . entity . Player onlinePlayer : Bukkit . getServer ( ) . getOnlinePlayers ( ) ) {
if ( onlinePlayer . equals ( player ) == false ) {
event . setJoinMessage ( " ) ;
onlinePlayer . sendMessage ( ChatColor . YELLOW + player . getName ( ) + " ) ;
}
}
return ;
}
}
@EventHandler
public void <unk> ( PlayerQuitEvent event ) {
Player player = event . getPlayer ( ) ;
if ( player . hasPermission ( " ) ) {
event . setQuitMessage ( " ) ;
for ( Player onlinePlayer : Bukkit . getServer ( ) . getOnlinePlayers ( ) ) {
if ( onlinePlayer . isOp ( ) ) {
onlinePlayer . sendMessage ( ChatColor . GREEN + player . getName ( ) + " ) ;
}
}
return ;
}
if ( player . hasPermission ( " ) ) {
for ( Player onlinePlayer : Bukkit . getServer ( ) . getOnlinePlayers ( ) ) {
if ( onlinePlayer . equals ( player ) == false ) {
event . setQuitMessage ( " ) ;
onlinePlayer . sendMessage ( ChatColor . YELLOW + player . getName ( ) + " ) ;
}
}
return ;
}
}
package com . linvald . emacs . data ;
import java . io . Serializable ;
import java . util . ArrayList ;
public class EmacsSubject implements Serializable {
private static final long serialVersionUID = <num> ;
private ArrayList < Command > data = new ArrayList < Command > ( ) ;
private String subjectName ;
private String category ;
public EmacsSubject ( String subjectName ) {
this . subjectName = subjectName ;
}
public String getSubjectName ( ) {
return this . subjectName ;
}
public void addKeyMapping ( Command mapping ) {
data . add ( mapping ) ;
}
public ArrayList < Command > getKeyMappings ( ) {
return this . data ;
}
@Override
public String toString ( ) {
return this . subjectName ;
}
public String getCategory ( ) {
return category ;
}
public void setCategory ( String category ) {
this . category = category ;
}
@Override
public boolean equals ( Object other ) {
if ( other instanceof EmacsSubject ) {
return ( ( EmacsSubject ) other ) . getSubjectName ( ) . equals ( getSubjectName ( ) ) ;
}
return false ;
}
public int hashCode ( ) {
int hash = <num> ;
hash = <num> * hash + ( null == getSubjectName ( ) ? <num> : getSubjectName ( ) . hashCode ( ) ) ;
return hash ;
}
}
package com . linvald . emacs ;
public final class R {
public static final class anim {
public static final int animation = <num> ;
}
public static final class attr {
}
public static final class drawable {
public static final int <unk> = <num> ;
public static final int arrow = <num> ;
public static final int calc = <num> ;
public static final int emacs = <num> ;
public static final int gnu = <num> ;
public static final int icon = <num> ;
public static final int key = <num> ;
public static final int org = <num> ;
public static final int <unk> = <num> ;
}
public static final class id {
public static final int about_id = <num> ;
public static final int button1 = <num> ;
public static final int calc = <num> ;
public static final int dired = <num> ;
public static final int emacs_id = <num> ;
public static final int <unk> = <num> ;
public static final int image = <num> ;
public static final int org = <num> ;
public static final int relativeLayout1 = <num> ;
public static final int text = <num> ;
public static final int text2 = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int viper = <num> ;
}
public static final class layout {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int main_layout = <num> ;
public static final int menu = <num> ;
}
public static final class raw {
public static final int <unk> = <num> ;
}
public static final class string {
public static final int about = <num> ;
public static final int app_description = <num> ;
public static final int app_label = <num> ;
public static final int app_name = <num> ;
public static final int calc = <num> ;
public static final int <unk> = <num> ;
public static final int dired = <num> ;
public static final int <unk> = <num> ;
public static final int emacs = <num> ;
public static final int gnu = <num> ;
public static final int org = <num> ;
public static final int search_hint = <num> ;
public static final int <unk> = <num> ;
public static final int viper = <num> ;
}
public static final class xml {
public static final int searchable = <num> ;
}
}
package com . linvald . emacs ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . List ;
import android . app . AlertDialog ;
import android . app . ExpandableListActivity ;
import android . app . SearchManager ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . database . Cursor ;
import android . database . sqlite . SQLiteDatabase ;
import android . os . Bundle ;
import android . text . Html ;
import android . util . Log ;
import android . view . Gravity ;
import android . view . Menu ;
import android . view . MenuInflater ;
import android . view . MenuItem ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . AbsListView ;
import android . widget . BaseExpandableListAdapter ;
import android . widget . ExpandableListView ;
import android . widget . ExpandableListView . ExpandableListContextMenuInfo ;
import android . widget . TextView ;
import android . widget . Toast ;
import com . linvald . emacs . data . Command ;
import com . linvald . emacs . data . EmacsSubject ;
public class ExpandableCategoryListView extends ExpandableListActivity {
private EmacsExpandableListAdapter adapter ;
private List < EmacsSubject > groups = null ;
private List < EmacsSubject > originalGroups = null ;
protected final static String LOG_CATEGORY = " ;
private DataBaseHelper dbHelper = null ;
private SQLiteDatabase database = null ;
private String searchTerm = null ;
private String currentCategory = " ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
dbHelper = new DataBaseHelper ( this ) ;
groups = new ArrayList < EmacsSubject > ( ) ;
database = dbHelper . getDatabase ( ) ;
try {
dbHelper . createDataBase ( ) ;
dbHelper . openDataBase ( " ) ;
database = dbHelper . getDatabase ( ) ;
loadDatabase ( ) ;
} catch ( IOException e ) {
Log . e ( LOG_CATEGORY , " + e . getMessage ( ) ) ;
e . printStackTrace ( ) ;
}
this . setDefaultKeyMode ( <unk> ) ;
Intent intent = getIntent ( ) ;
if ( Intent . ACTION_SEARCH . equals ( intent . getAction ( ) ) ) {
String keyPressed = intent . getStringExtra ( SearchManager . <unk> ) ;
Log . d ( SEARCH_SERVICE , " + keyPressed ) ;
String query = intent . getStringExtra ( SearchManager . QUERY ) ;
doSearch ( query ) ;
} else {
searchTerm = null ;
}
}
@Override
protected void onDestroy ( ) {
super . onDestroy ( ) ;
dbHelper . close ( ) ;
}
private void mapResultSetToGroups ( Cursor cursor ) {
EmacsSubject currentSubject = null ;
Command cmd = null ;
groups = new ArrayList < EmacsSubject > ( ) ;
String subject = null ;
String command = null ;
String key = null ;
String category = null ;
while ( cursor . moveToNext ( ) ) {
subject = cursor . getString ( <num> ) ;
command = cursor . getString ( <num> ) ;
key = cursor . getString ( <num> ) ;
category = cursor . getString ( <num> ) ;
currentSubject = new EmacsSubject ( subject ) ;
currentSubject . setCategory ( category ) ;
if ( groups . indexOf ( currentSubject ) >= <num> ) {
currentSubject = groups . get ( groups . indexOf ( currentSubject ) ) ;
} else {
groups . add ( currentSubject ) ;
}
cmd = new Command ( ) ;
cmd . setCommand ( key ) ;
cmd . setName ( command ) ;
currentSubject . addKeyMapping ( cmd ) ;
}
cursor . close ( ) ;
}
@Override
public boolean onChildClick ( ExpandableListView parent , View v , int groupPosition , int childPosition , long id ) {
Log . d ( LOG_CATEGORY , " ) ;
EmacsSubject group = groups . get ( groupPosition ) ;
Command cmd = group . getKeyMappings ( ) . get ( childPosition ) ;
AlertDialog . Builder alertbox = new AlertDialog . Builder ( this ) ;
alertbox . setTitle ( group . getSubjectName ( ) ) ;
alertbox . setMessage ( cmd . getName ( ) + " + cmd . getCommand ( ) ) ;
alertbox . setIcon ( R . drawable . key ) ;
alertbox . setNeutralButton ( " , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface arg0 , int arg1 ) {
}
} ) ;
alertbox . show ( ) ;
Log . d ( getPackageName ( ) , " + cmd . getName ( ) ) ;
return true ;
}
private void doSearch ( String query ) {
Log . d ( SEARCH_SERVICE , " ) ;
searchTerm = query ;
Cursor cursor = database . query ( " , new String [ ] { " , " , " , " } , " + currentCategory + " + " + query + " + query + " + query + " + query + " , null , null , null , null ) ;
mapResultSetToGroups ( cursor ) ;
if ( groups . size ( ) == <num> ) {
Toast . makeText ( this , " , Toast . LENGTH_LONG ) . show ( ) ;
} else {
EmacsExpandableListAdapter searchAdapter = new EmacsExpandableListAdapter ( groups ) ;
this . adapter = searchAdapter ;
adapter = new EmacsExpandableListAdapter ( groups ) ;
setListAdapter ( adapter ) ;
this . registerForContextMenu ( getExpandableListView ( ) ) ;
for ( int i = <num> ; i < searchAdapter . getGroupCount ( ) ; i ++ ) {
getExpandableListView ( ) . expandGroup ( i ) ;
}
}
}
private void loadDatabase ( ) {
Cursor cursor = database . query ( " , new String [ ] { " , " , " , " } , " + currentCategory + " , null , null , null , null ) ;
mapResultSetToGroups ( cursor ) ;
EmacsExpandableListAdapter searchAdapter = new EmacsExpandableListAdapter ( groups ) ;
this . adapter = searchAdapter ;
adapter = new EmacsExpandableListAdapter ( groups ) ;
setListAdapter ( adapter ) ;
this . registerForContextMenu ( getExpandableListView ( ) ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
MenuInflater inflater = getMenuInflater ( ) ;
inflater . inflate ( R . layout . menu , menu ) ;
return true ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case R . id . about_id :
showInfo ( ) ;
return true ;
case R . id . emacs_id :
currentCategory = " ;
loadDatabase ( ) ;
return true ;
case R . id . dired :
currentCategory = " ;
loadDatabase ( ) ;
return true ;
case R . id . calc :
currentCategory = " ;
loadDatabase ( ) ;
return true ;
case R . id . org :
currentCategory = " ;
loadDatabase ( ) ;
return true ;
case R . id . viper :
currentCategory = " ;
loadDatabase ( ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
private void showInfo ( ) {
Log . d ( LOG_CATEGORY , " ) ;
Cursor cursor = database . query ( " , new String [ ] { " } , null , null , null , null , null ) ;
cursor . moveToNext ( ) ;
String emacs_version = cursor . getString ( <num> ) ;
AlertDialog . Builder alertbox = new AlertDialog . Builder ( this ) ;
alertbox . setTitle ( " ) ;
StringBuffer buf = new StringBuffer ( " ) ;
buf . append ( " + emacs_version ) ;
alertbox . setMessage ( buf . toString ( ) ) ;
alertbox . setIcon ( R . drawable . key ) ;
alertbox . setNeutralButton ( " , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface arg0 , int arg1 ) {
}
} ) ;
alertbox . show ( ) ;
}
@Override
public boolean onContextItemSelected ( MenuItem item ) {
ExpandableListContextMenuInfo info = ( ExpandableListContextMenuInfo ) item . getMenuInfo ( ) ;
String title = ( ( TextView ) info . targetView ) . getText ( ) . toString ( ) ;
int type = ExpandableListView . getPackedPositionType ( info . packedPosition ) ;
if ( type == ExpandableListView . <unk> ) {
int groupPos = ExpandableListView . getPackedPositionGroup ( info . packedPosition ) ;
int childPos = ExpandableListView . <unk> ( info . packedPosition ) ;
Toast . makeText ( this , title + " + childPos + " + groupPos , Toast . LENGTH_SHORT ) . show ( ) ;
return true ;
} else if ( type == ExpandableListView . PACKED_POSITION_TYPE_GROUP ) {
int groupPos = ExpandableListView . getPackedPositionGroup ( info . packedPosition ) ;
Toast . makeText ( this , title + " + groupPos + " , Toast . LENGTH_SHORT ) . show ( ) ;
return true ;
}
return false ;
}
public class EmacsExpandableListAdapter extends BaseExpandableListAdapter {
List < EmacsSubject > groups = null ;
public EmacsExpandableListAdapter ( ) {
groups = originalGroups ;
}
public EmacsExpandableListAdapter ( List < EmacsSubject > groups ) {
this . groups = groups ;
}
public List < EmacsSubject > getGroups ( ) {
return groups ;
}
public Object getChild ( int groupPosition , int childPosition ) {
EmacsSubject group = groups . get ( groupPosition ) ;
Command command = group . getKeyMappings ( ) . get ( childPosition ) ;
return command ;
}
public long getChildId ( int groupPosition , int childPosition ) {
return childPosition ;
}
public int getChildrenCount ( int groupPosition ) {
EmacsSubject group = groups . get ( groupPosition ) ;
int count = group . getKeyMappings ( ) . size ( ) ;
return count ;
}
public TextView getGenericView ( ) {
AbsListView . LayoutParams lp = new AbsListView . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , <num> ) ;
TextView textView = new TextView ( ExpandableCategoryListView . this ) ;
textView . setLayoutParams ( lp ) ;
textView . setGravity ( Gravity . BOTTOM | Gravity . LEFT ) ;
textView . setPadding ( <num> , <num> , <num> , <num> ) ;
return textView ;
}
public View getChildView ( int groupPosition , int childPosition , boolean isLastChild , View convertView , ViewGroup parent ) {
TextView textView = getGenericView ( ) ;
String txt = getChild ( groupPosition , childPosition ) . toString ( ) ;
if ( searchTerm != null ) {
String html = txt . replaceAll ( searchTerm , " + searchTerm + " ) ;
textView . setText ( Html . fromHtml ( html ) ) ;
} else {
textView . setText ( txt ) ;
}
return textView ;
}
public Object getGroup ( int groupPosition ) {
return groups . get ( groupPosition ) ;
}
public int getGroupCount ( ) {
return groups . size ( ) ;
}
public long getGroupId ( int groupPosition ) {
return groupPosition ;
}
public View getGroupView ( int groupPosition , boolean isExpanded , View convertView , ViewGroup parent ) {
TextView textView = getGenericView ( ) ;
String txt = getGroup ( groupPosition ) . toString ( ) ;
if ( searchTerm != null ) {
String html = txt . replaceAll ( searchTerm , " + searchTerm + " ) ;
textView . setText ( Html . fromHtml ( html ) ) ;
} else {
textView . setText ( txt ) ;
}
return textView ;
}
public boolean isChildSelectable ( int groupPosition , int childPosition ) {
return true ;
}
public boolean hasStableIds ( ) {
return true ;
}
}
package com . linvald . emacs . data ;
import java . io . Serializable ;
public class Command implements Serializable {
private static final long serialVersionUID = <num> ;
private String name , command ;
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
public String getCommand ( ) {
return command ;
}
public void setCommand ( String command ) {
this . command = command ;
}
@Override
public String toString ( ) {
return name ;
}
}
package com . linvald . emacs ;
import java . io . FileOutputStream ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . OutputStream ;
import android . content . Context ;
import android . database . sqlite . SQLiteDatabase ;
import android . database . sqlite . SQLiteException ;
import android . database . sqlite . SQLiteOpenHelper ;
import android . util . Log ;
public class DataBaseHelper extends SQLiteOpenHelper {
private static String DB_PATH = " ;
private static String DB_NAME_EMACS = " ;
private SQLiteDatabase myDataBase ;
private final Context myContext ;
public DataBaseHelper ( Context context ) {
super ( context , DB_NAME_EMACS , null , <num> ) ;
this . myContext = context ;
}
public void createDataBase ( ) throws IOException {
boolean dbExist = checkDataBase ( " ) ;
if ( dbExist ) {
Log . d ( ExpandableCategoryListView . LOG_CATEGORY , " ) ;
} else {
this . getReadableDatabase ( ) ;
Log . d ( ExpandableCategoryListView . LOG_CATEGORY , " ) ;
try {
copyDataBase ( " ) ;
} catch ( IOException e ) {
Log . e ( ExpandableCategoryListView . LOG_CATEGORY , e . getMessage ( ) ) ;
throw new Error ( " ) ;
}
}
}
private boolean checkDataBase ( String tableName ) {
Log . d ( ExpandableCategoryListView . LOG_CATEGORY , " + tableName ) ;
SQLiteDatabase checkDB = null ;
try {
String myPath = DB_PATH + tableName ;
checkDB = SQLiteDatabase . openDatabase ( myPath , null , SQLiteDatabase . OPEN_READONLY ) ;
Log . d ( ExpandableCategoryListView . LOG_CATEGORY , checkDB . toString ( ) ) ;
} catch ( SQLiteException e ) {
Log . d ( ExpandableCategoryListView . LOG_CATEGORY , " + e . getMessage ( ) ) ;
}
if ( checkDB != null ) {
checkDB . close ( ) ;
}
return checkDB != null ? true : false ;
}
private void copyDataBase ( String tableName ) throws IOException {
Log . d ( ExpandableCategoryListView . LOG_CATEGORY , " ) ;
InputStream myInput = myContext . getAssets ( ) . open ( tableName ) ;
Log . d ( ExpandableCategoryListView . LOG_CATEGORY , " + myInput . available ( ) ) ;
String outFileName = DB_PATH + tableName ;
OutputStream myOutput = new FileOutputStream ( outFileName ) ;
byte [ ] buffer = new byte [ <num> ] ;
int length ;
while ( ( length = myInput . read ( buffer ) ) > <num> ) {
myOutput . write ( buffer , <num> , length ) ;
}
myOutput . flush ( ) ;
myOutput . close ( ) ;
myInput . close ( ) ;
}
public void openDataBase ( String tableName ) {
String myPath = DB_PATH + tableName ;
try {
myDataBase = SQLiteDatabase . openDatabase ( myPath , null , SQLiteDatabase . OPEN_READONLY ) ;
} catch ( Exception e ) {
Log . d ( ExpandableCategoryListView . LOG_CATEGORY , e . getMessage ( ) ) ;
}
}
public SQLiteDatabase getDatabase ( ) {
return myDataBase ;
}
@Override
public synchronized void close ( ) {
if ( myDataBase != null ) {
myDataBase . close ( ) ;
}
super . close ( ) ;
}
@Override
public void onCreate ( SQLiteDatabase db ) { }
@Override
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) {
try {
copyDataBase ( " ) ;
} catch ( IOException e ) {
Log . e ( ExpandableCategoryListView . LOG_CATEGORY , e . getMessage ( ) ) ;
throw new Error ( " ) ;
}
}
package com . linvald . emacs ;
public final class BuildConfig {
public final static boolean DEBUG = true ;
import java . awt . * ;
import java . awt . event . * ;
import java . awt . image . * ;
public final class SpinButton extends Canvas implements MouseListener
{
protected final int BUTTON_INSET_X = <num> ;
protected final int BUTTON_INSET_Y = <num> ;
protected final int TEXT_INSET = <num> ;
protected final int BUTTON2_STEP = <num> ;
protected Image buffer = null ;
protected int maxValue ;
protected int minValue ;
protected int value ;
protected Color background = null ;
protected Rectangle upRect ;
protected Rectangle downRect ;
protected boolean fixedSize ;
protected int buttonWidth ;
protected int buttonHeight ;
protected Image arrowUp ;
protected Image arrowDown ;
public SpinButton ( int min , int max , int start )
{
maxValue = max ;
minValue = min ;
value = start ;
if ( value > maxValue )
value = maxValue ;
if ( value < minValue )
value = minValue ;
fixedSize = false ;
setSize ( <num> , <num> ) ;
addMouseListener ( this ) ;
int w = <num> ;
int h = <num> ;
int upPixels [ ] = { <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> } ;
arrowUp = createImage ( new MemoryImageSource ( w , h , upPixels , <num> , w ) ) ;
int downPixels [ ] = { <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> } ;
arrowDown = createImage ( new MemoryImageSource ( w , h , downPixels , <num> , w ) ) ;
}
public SpinButton ( int min , int max , int start , int width , int height )
{
this ( min , max , start ) ;
fixedSize = true ;
buttonWidth = width ;
buttonHeight = height ;
}
public int getValue ( )
{
return value ;
}
public void update ( Graphics g )
{
paint ( g ) ;
}
public void paint ( Graphics realG )
{
if ( buffer == null )
{
buffer = createImage ( getSize ( ) . width , getSize ( ) . height ) ;
MediaTracker tr = new MediaTracker ( this ) ;
tr . addImage ( buffer , <num> ) ;
tr . addImage ( arrowUp , <num> ) ;
tr . addImage ( arrowDown , <num> ) ;
try {
tr . waitForID ( <num> ) ;
tr . waitForID ( <num> ) ;
tr . waitForID ( <num> ) ;
} catch ( InterruptedException exp ) { }
}
if ( background == null )
background = getBackground ( ) ;
Graphics g = buffer . getGraphics ( ) ;
super . paint ( g ) ;
int middle = getSize ( ) . height / <num> ;
int stringWidth = g . getFontMetrics ( ) . stringWidth ( String . valueOf ( value ) ) + TEXT_INSET ;
int stringX = <num> ;
Polygon upArrow = new Polygon ( ) ;
Polygon downArrow = new Polygon ( ) ;
if ( fixedSize )
{
int xUp = BUTTON_INSET_X ;
int yUp = middle  buttonHeight  <num> ;
int widthUp = buttonWidth ;
int heightUp = buttonHeight ;
int xDown = xUp ;
int yDown = middle + <num> ;
int widthDown = widthUp ;
int heightDown = heightUp ;
upRect = new Rectangle ( xUp , yUp , widthUp , heightUp ) ;
downRect = new Rectangle ( xDown , yDown , widthDown , heightDown ) ;
stringX = buttonWidth + TEXT_INSET + BUTTON_INSET_X ;
} else
{
int rectWidth = getSize ( ) . width  BUTTON_INSET_X  stringWidth  TEXT_INSET ;
upRect = new Rectangle ( BUTTON_INSET_X , BUTTON_INSET_Y , rectWidth , middle  <num>  BUTTON_INSET_Y ) ;
downRect = new Rectangle ( BUTTON_INSET_X , middle + <num> , rectWidth , middle  BUTTON_INSET_Y  <num> ) ;
stringX = rectWidth + BUTTON_INSET_X + TEXT_INSET ;
}
g . setColor ( background ) ;
g . draw3DRect ( upRect . x , upRect . y , upRect . width , upRect . height , true ) ;
g . draw3DRect ( downRect . x , downRect . y , downRect . width , downRect . height , true ) ;
g . setColor ( Color . black ) ;
g . drawString ( String . valueOf ( value ) , stringX , middle + g . getFontMetrics ( ) . getAscent ( ) / <num> ) ;
int XMiddle = upRect . x + upRect . width / <num> ;
int upYMiddle = upRect . y + upRect . height / <num> ;
int downYMiddle = downRect . y + downRect . height / <num> ;
upArrow . addPoint ( XMiddle , upYMiddle  <num> ) ;
upArrow . addPoint ( XMiddle + <num> , upYMiddle + <num> ) ;
upArrow . addPoint ( XMiddle  <num> , upYMiddle + <num> ) ;
downArrow . addPoint ( XMiddle , downYMiddle + <num> ) ;
downArrow . addPoint ( XMiddle + <num> , downYMiddle  <num> ) ;
downArrow . addPoint ( XMiddle  <num> , downYMiddle  <num> ) ;
g . fillPolygon ( upArrow ) ;
g . fillPolygon ( downArrow ) ;
realG . drawImage ( buffer , <num> , <num> , null ) ;
g . dispose ( ) ;
buffer = null ;
}
public void mouseEntered ( MouseEvent e ) { }
public void mouseExited ( MouseEvent e ) { }
public void mousePressed ( MouseEvent e ) { }
public void mouseReleased ( MouseEvent e ) { }
public void mouseClicked ( MouseEvent e )
{
Point p = e . getPoint ( ) ;
int button2 = e . getModifiers ( ) & InputEvent . BUTTON2_MASK ;
if ( button2 == <num> )
{
if ( upRect . contains ( p ) && value < maxValue )
value ++ ;
if ( downRect . contains ( p ) && value > minValue )
value  ;
} else
{
if ( upRect . contains ( p ) && value < maxValue )
if ( maxValue  value > BUTTON2_STEP )
{
value = value + BUTTON2_STEP ;
} else
{
value = value + ( maxValue  value ) ;
}
if ( downRect . contains ( p ) && value > minValue )
if ( value  minValue > BUTTON2_STEP )
{
value = value  BUTTON2_STEP ;
} else
{
value = value  ( value  minValue ) ;
}
}
invalidate ( ) ;
repaint ( ) ;
}
public static void main ( String [ ] args )
{
Frame f = new Frame ( " ) ;
f . setLayout ( new BorderLayout ( ) ) ;
SpinButton sb = new SpinButton ( <num> , <num> , <num> , <num> , <num> ) ;
f . add ( " , sb ) ;
f . setSize ( <num> , <num> ) ;
f . show ( ) ;
}
}
import java . awt . * ;
public class Display extends Frame
{
protected DisplayListener listener ;
protected MenuBar menubar ;
protected Menu file , help ;
protected MenuItem fileConfig , fileQuit , helpAbout , helpSearchTips ;
protected Button search , newSearch , results , stop ;
protected TextField searchField , urlField ;
protected DoubleBufferedList statusArea ;
protected Panel fieldPanel , statusPanel , tabPage1 , tabPage2 , tabPage3 , buttonpanel ;
protected TabbedNotebook tabNotebook ;
protected Hunter hunter ;
protected GridBagLayout gridbag = new GridBagLayout ( ) ;
protected Label statProcessed , statWaiting , statBad , statTreeLevel ;
protected SpinButton numberOfDogs ;
public Display ( String title , Hunter h )
{
super ( title ) ;
hunter = h ;
listener = new DisplayListener ( hunter , this ) ;
tabNotebook = new TabbedNotebook ( ) ;
menubar = new MenuBar ( ) ;
this . setMenuBar ( menubar ) ;
file = new Menu ( " ) ;
fileConfig = new MenuItem ( " ) ;
fileConfig . addActionListener ( listener ) ;
fileConfig . setActionCommand ( " ) ;
file . add ( fileConfig ) ;
fileQuit = new MenuItem ( " ) ;
fileQuit . addActionListener ( listener ) ;
fileQuit . setActionCommand ( " ) ;
file . addSeparator ( ) ;
file . add ( fileQuit ) ;
menubar . add ( file ) ;
help = new Menu ( " ) ;
helpAbout = new MenuItem ( " ) ;
helpAbout . addActionListener ( listener ) ;
helpAbout . setActionCommand ( " ) ;
help . add ( helpAbout ) ;
help . addSeparator ( ) ;
helpSearchTips = new MenuItem ( " ) ;
helpSearchTips . addActionListener ( listener ) ;
helpSearchTips . setActionCommand ( " ) ;
help . add ( helpSearchTips ) ;
menubar . add ( help ) ;
menubar . <unk> ( help ) ;
search = new Button ( " ) ;
search . addActionListener ( listener ) ;
search . setActionCommand ( " ) ;
newSearch = new Button ( " ) ;
newSearch . addActionListener ( listener ) ;
newSearch . setActionCommand ( " ) ;
stop = new Button ( " ) ;
stop . addActionListener ( listener ) ;
stop . setActionCommand ( " ) ;
results = new Button ( " ) ;
results . addActionListener ( listener ) ;
results . setActionCommand ( " ) ;
searchField = new TextField ( ) ;
searchField . addActionListener ( listener ) ;
urlField = new TextField ( ) ;
urlField . addActionListener ( listener ) ;
String text = new String ( " ) ;
statusArea = new DoubleBufferedList ( <num> ) ;
statusArea . add ( " ) ;
for ( int i = <num> ; i <= hunter . noOfDogs ; i ++ )
{
statusArea . add ( " + i + " ) ;
}
tabPage1 = new Panel ( gridbag ) ;
fieldPanel = new Panel ( ) ;
fieldPanel . setLayout ( gridbag ) ;
constrain ( fieldPanel , new Label ( " ) , <num> , <num> , <num> , <num> ) ;
constrain ( fieldPanel , searchField , <num> , <num> , <num> , <num> , GridBagConstraints . HORIZONTAL ,
GridBagConstraints . NORTHWEST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
constrain ( fieldPanel , new Label ( " ) , <num> , <num> , <num> , <num> ) ;
constrain ( fieldPanel , urlField , <num> , <num> , <num> , <num> , GridBagConstraints . HORIZONTAL ,
GridBagConstraints . NORTHWEST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
statusPanel = new Panel ( ) ;
statusPanel . setLayout ( gridbag ) ;
constrain ( statusPanel , new Label ( " ) , <num> , <num> , <num> , <num> ) ;
constrain ( statusPanel , statusArea , <num> , <num> , <num> , <num> , GridBagConstraints . BOTH ,
GridBagConstraints . NORTH , <num> , <num> , <num> , <num> , <num> , <num> ) ;
buttonpanel = new Panel ( ) ;
buttonpanel . setLayout ( gridbag ) ;
constrain ( buttonpanel , search , <num> , <num> , <num> , <num> , GridBagConstraints . BOTH ,
GridBagConstraints . NORTHEAST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
constrain ( buttonpanel , newSearch , <num> , <num> , <num> , <num> , GridBagConstraints . BOTH ,
GridBagConstraints . NORTHEAST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
constrain ( buttonpanel , stop , <num> , <num> , <num> , <num> , GridBagConstraints . BOTH ,
GridBagConstraints . NORTHEAST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
constrain ( buttonpanel , results , <num> , <num> , <num> , <num> , GridBagConstraints . BOTH ,
GridBagConstraints . NORTHEAST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
constrain ( tabPage1 , fieldPanel , <num> , <num> , <num> , <num> , GridBagConstraints . HORIZONTAL ,
GridBagConstraints . NORTHWEST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
constrain ( tabPage1 , buttonpanel , <num> , <num> , <num> , <num> , GridBagConstraints . VERTICAL ,
GridBagConstraints . NORTHEAST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
tabPage2 = new Panel ( new GridBagLayout ( ) ) ;
numberOfDogs = new SpinButton ( Hunter . MIN_DOGS , Hunter . MAX_DOGS , Hunter . DEFAULT_DOGS , <num> , <num> ) ;
constrain ( tabPage2 , numberOfDogs , <num> , <num> , <num> , <num> , GridBagConstraints . NONE ,
GridBagConstraints . NORTHEAST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
tabPage3 = new Panel ( gridbag ) ;
statProcessed = new Label ( " , Label . LEFT ) ;
statWaiting = new Label ( " , Label . LEFT ) ;
statBad = new Label ( " , Label . LEFT ) ;
statTreeLevel = new Label ( " , Label . LEFT ) ;
constrain ( tabPage3 , statProcessed , <num> , <num> , <num> , <num> ) ;
constrain ( tabPage3 , statWaiting , <num> , <num> , <num> , <num> ) ;
constrain ( tabPage3 , statBad , <num> , <num> , <num> , <num> ) ;
constrain ( tabPage3 , statTreeLevel , <num> , <num> , <num> , <num> ) ;
tabNotebook . addPage ( tabPage1 , " ) ;
tabNotebook . addPage ( tabPage2 , " ) ;
tabNotebook . addPage ( tabPage3 , " ) ;
this . setLayout ( gridbag ) ;
constrain ( this , tabNotebook , <num> , <num> , <num> , <num> , GridBagConstraints . HORIZONTAL ,
GridBagConstraints . NORTHWEST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
constrain ( this , statusPanel , <num> , <num> , <num> , <num> , GridBagConstraints . BOTH ,
GridBagConstraints . CENTER , <num> , <num> , <num> , <num> , <num> , <num> ) ;
this . setSize ( <num> , <num> ) ;
this . show ( ) ;
}
public void constrain ( Container container , Component component ,
int grid_x , int grid_y , int grid_width , int grid_height ,
int fill , int anchor , double weight_x , double weight_y ,
int top , int left , int bottom , int right )
{
GridBagConstraints c = new GridBagConstraints ( ) ;
c . gridx = grid_x ; c . gridy = grid_y ;
c . gridwidth = grid_width ; c . gridheight = grid_height ;
c . fill = fill ; c . anchor = anchor ;
c . weightx = weight_x ; c . weighty = weight_y ;
if ( top + bottom + left + right > <num> )
c . insets = new Insets ( top , left , bottom , right ) ;
( ( GridBagLayout ) container . getLayout ( ) ) . setConstraints ( component , c ) ;
container . add ( component ) ;
}
public void constrain ( Container container , Component component ,
int grid_x , int grid_y , int grid_width , int grid_height )
{
constrain ( container , component , grid_x , grid_y ,
grid_width , grid_height , GridBagConstraints . NONE ,
GridBagConstraints . NORTHWEST , <num> , <num> , <num> , <num> , <num> , <num> ) ;
}
public void constrain ( Container container , Component component ,
int grid_x , int grid_y , int grid_width , int grid_height ,
int top , int left , int bottom , int right )
{
constrain ( container , component , grid_x , grid_y ,
grid_width , grid_height , GridBagConstraints . NONE ,
GridBagConstraints . NORTHWEST ,
0.0 , <num> , top , left , bottom , right ) ;
}
public String getSearchWords ( )
{
return searchField . getText ( ) ;
}
public String getStartURL ( )
{
return urlField . getText ( ) ;
}
public void setStatus ( int line , String message )
{
statusArea . <unk> ( message , line ) ;
}
public void setStatsProcessed ( long processed )
{
statProcessed . setText ( processed + " ) ;
}
public void setStatsWaiting ( long waiting )
{
statWaiting . setText ( waiting + " ) ;
}
public void setStatsBad ( long bad )
{
statBad . setText ( bad + " ) ;
}
public void setStatsLinkLevel ( long level )
{
statTreeLevel . setText ( " + level ) ;
}
}
import java . util . * ;
import java . net . * ;
public final class UrlDB
{
protected Vector urlLevels ;
protected int topUrlLevel ;
protected HunterStatistics stats ;
protected Hashtable visitedUrls ;
public UrlDB ( HunterStatistics stat )
{
stats = stat ;
topUrlLevel = <num> ;
stats . linkLevel ( topUrlLevel ) ;
urlLevels = new Vector ( ) ;
visitedUrls = new Hashtable ( ) ;
}
public int add ( HunterUrl url )
{
synchronized ( urlLevels )
{
if ( url . getLevel ( ) < topUrlLevel )
return  <num> ;
if ( visitedUrls . containsKey ( url . toString ( ) ) )
return  <num> ;
int relLevel = url . getLevel ( )  topUrlLevel ;
if ( ( relLevel + <num> ) > urlLevels . size ( ) )
{
Vector tmp_vec = new Vector ( ) ;
tmp_vec . addElement ( url ) ;
urlLevels . addElement ( tmp_vec ) ;
}
else
( ( Vector ) urlLevels . elementAt ( relLevel ) ) . addElement ( url ) ;
stats . addWaitingUrl ( <num> ) ;
visitedUrls . put ( url . toString ( ) , url ) ;
}
return <num> ;
}
public HunterUrl getNext ( )
{
synchronized ( urlLevels )
{
if ( urlLevels . isEmpty ( ) )
return null ;
Vector level = ( ( Vector ) urlLevels . firstElement ( ) ) ;
if ( level . isEmpty ( ) )
{
urlLevels . removeElement ( level ) ;
return null ;
}
HunterUrl tmpUrl = ( ( HunterUrl ) level . firstElement ( ) ) ;
level . removeElement ( tmpUrl ) ;
if ( level . isEmpty ( ) )
{
urlLevels . removeElement ( level ) ;
topUrlLevel ++ ;
stats . linkLevel ( topUrlLevel ) ;
}
stats . addWaitingUrl (  <num> ) ;
return tmpUrl ;
}
}
public int levels ( )
{
return urlLevels . size ( ) ;
}
public int <unk> ( )
{
return topUrlLevel ;
}
}
import java . util . * ;
import java . net . * ;
public final class DogLinkFilter
{
protected DogConnectionContent content ;
protected URL connectedUrl ;
protected HunterStatistics stats ;
public DogLinkFilter ( HunterStatistics stat , DogConnectionContent cont )
{
stats = stat ;
content = cont ;
}
public void setURL ( URL url )
{
connectedUrl = url ;
}
public Vector getLinks ( URL url )
{
setURL ( url ) ;
return getLinks ( ) ;
}
public Vector getLinks ( )
{
String newUrl ;
Vector returnVector = new Vector ( ) ;
int startIndex ;
int endIndex ;
URL tempURL ;
startIndex = endIndex = <num> ;
while ( startIndex >= <num> )
{
startIndex = content . getDataLowerCase ( ) . indexOf ( " , startIndex ) ;
if ( startIndex >= <num> )
startIndex = content . getDataLowerCase ( ) . indexOf ( " , startIndex ) ;
if ( startIndex >= <num> )
{
startIndex = content . getDataLowerCase ( ) . indexOf ( " , startIndex ) ;
endIndex = content . getDataLowerCase ( ) . indexOf ( " , startIndex + <num> ) ;
}
if ( startIndex >= <num> && endIndex >= <num> )
{
newUrl = content . getData ( ) . substring ( startIndex + <num> , endIndex ) ;
if ( newUrl . endsWith ( " ) || newUrl . endsWith ( " ) )
newUrl = newUrl . substring ( <num> , newUrl . lastIndexOf ( " ) ) ;
if ( newUrl . lastIndexOf ( " ) >  <num> )
newUrl = newUrl . substring ( <num> , newUrl . lastIndexOf ( " ) ) ;
try {
tempURL = new URL ( newUrl ) ;
returnVector . addElement ( tempURL ) ;
} catch ( MalformedURLException e1 )
{
try {
String trimmedUrl = connectedUrl . toString ( ) ;
if ( ! trimmedUrl . endsWith ( " ) && ( trimmedUrl . toLowerCase ( ) . indexOf ( " ) >  <num> ) )
trimmedUrl = trimmedUrl . substring ( <num> , trimmedUrl . lastIndexOf ( " ) + <num> ) ;
if ( ! trimmedUrl . endsWith ( " ) && ( trimmedUrl . toLowerCase ( ) . indexOf ( " ) < <num> ) )
trimmedUrl = trimmedUrl . concat ( " ) ;
tempURL = new URL ( trimmedUrl + newUrl ) ;
returnVector . addElement ( tempURL ) ;
} catch ( MalformedURLException e2 )
{
stats . addBadUrl ( ) ;
}
}
}
}
return returnVector ;
}
}
import java . net . * ;
public final class HunterUrl
{
protected int urlCount ;
protected int urlLevel ;
protected URL url ;
public HunterUrl ( URL newUrl , int level )
{
url = newUrl ;
urlLevel = level ;
urlCount = <num> ;
}
public int getLevel ( )
{
return urlLevel ;
}
public void setLevel ( int level )
{
urlLevel = level ;
}
public URL getURL ( )
{
return url ;
}
public void setURL ( URL newUrl )
{
url = newUrl ;
}
public int getCount ( )
{
return urlCount ;
}
public void setCount ( int newCount )
{
urlCount = newCount ;
}
public String toString ( )
{
return url . toString ( ) ;
}
}
import java . awt . * ;
public final class TabbedNotebook extends Panel
{
protected CardLayout layout ;
protected Panel <unk> , pagePanel ;
protected Tabs tabs ;
public TabbedNotebook ( )
{
layout = new CardLayout ( ) ;
pagePanel = new Panel ( layout ) ;
tabs = new Tabs ( this ) ;
setLayout ( new BorderLayout ( ) ) ;
add ( " , tabs ) ;
add ( " , pagePanel ) ;
}
public void addPage ( Panel panel , String name )
{
pagePanel . add ( panel , name ) ;
tabs . addTab ( name ) ;
}
public void showPage ( String name )
{
layout . show ( pagePanel , name ) ;
}
}
import java . awt . * ;
import java . awt . event . * ;
import java . awt . image . * ;
import java . util . * ;
public final class Tabs extends Canvas implements MouseListener
{
protected final int TOP_TABINSET = <num> ;
protected final int LEFT_TABINSET = <num> ;
protected final int <unk> = <num> ;
protected final int <unk> = <num> ;
protected final int BETWEEN_TABINSET = <num> ;
protected final int TEXT_TABINSET = <num> ;
protected int noOfTabs ;
protected int selectedTab ;
protected Vector tabNames ;
protected Vector tabRectangles ;
protected FontMetrics fm ;
protected int fontHeight ;
protected int fontBaseLine ;
protected TabbedNotebook noteBook ;
protected Color background = null ;
protected Image buffer ;
public Tabs ( TabbedNotebook nb )
{
noteBook = nb ;
tabNames = new Vector ( ) ;
tabRectangles = new Vector ( ) ;
noOfTabs = <num> ;
selectedTab = <num> ;
addMouseListener ( this ) ;
setSize ( <num> , <num> ) ;
}
public synchronized void addTab ( String name )
{
noOfTabs ++ ;
tabNames . addElement ( name ) ;
}
public void update ( Graphics g )
{
paint ( g ) ;
}
public void paint ( Graphics realG )
{
if ( buffer == null )
{
buffer = createImage ( getSize ( ) . width , getSize ( ) . height ) ;
MediaTracker tr = new MediaTracker ( this ) ;
tr . addImage ( buffer , <num> ) ;
try {
tr . waitForID ( <num> ) ;
} catch ( InterruptedException exp ) { }
}
Graphics g = buffer . getGraphics ( ) ;
if ( fm == null )
{
fm = g . getFontMetrics ( ) ;
fontHeight = fm . getHeight ( ) ;
fontBaseLine = TOP_TABINSET + fontHeight + TEXT_TABINSET  fm . getDescent ( )  <num> ;
}
if ( background == null )
background = getBackground ( ) ;
if ( tabNames . size ( ) != tabRectangles . size ( ) )
{
int nextXPos = LEFT_TABINSET ;
for ( Enumeration eNames = tabNames . elements ( ) ; eNames . hasMoreElements ( ) ; )
{
String curTab = ( String ) eNames . nextElement ( ) ;
int strWidth = fm . stringWidth ( curTab ) ;
tabRectangles . addElement ( new Rectangle ( nextXPos , TOP_TABINSET , strWidth + <num> * TEXT_TABINSET , <num> * TEXT_TABINSET + fontHeight ) ) ;
nextXPos = nextXPos + strWidth + <num> * TEXT_TABINSET + BETWEEN_TABINSET ;
}
setSize ( getSize ( ) . width , <num> * TEXT_TABINSET + TOP_TABINSET + fontHeight + <num> ) ;
}
int i = <num> ;
Rectangle rSelected = null ;
Enumeration eRects = tabRectangles . elements ( ) ;
g . setColor ( background ) ;
for ( Enumeration eNames = tabNames . elements ( ) ; eNames . hasMoreElements ( ) ; )
{
String curTab = ( String ) eNames . nextElement ( ) ;
Rectangle r = ( Rectangle ) eRects . nextElement ( ) ;
g . draw3DRect ( r . x , r . y , r . width , r . height , true ) ;
g . setColor ( Color . black ) ;
g . drawString ( curTab , r . x + TEXT_TABINSET , fontBaseLine ) ;
if ( i == selectedTab )
rSelected = r ;
i ++ ;
g . setColor ( background ) ;
}
g . setColor ( background . brighter ( ) ) ;
g . drawLine ( <num> , TOP_TABINSET + <num> * TEXT_TABINSET + fontHeight , getSize ( ) . width , TOP_TABINSET + <num> * TEXT_TABINSET + fontHeight ) ;
g . setColor ( background ) ;
if ( rSelected != null )
g . drawLine ( rSelected . x + <num> , rSelected . y + rSelected . height , rSelected . x + rSelected . width  <num> , rSelected . y + rSelected . height ) ;
realG . drawImage ( buffer , <num> , <num> , null ) ;
g . dispose ( ) ;
buffer = null ;
}
public void mouseEntered ( MouseEvent e ) { }
public void mouseExited ( MouseEvent e ) { }
public void mousePressed ( MouseEvent e ) { }
public void mouseReleased ( MouseEvent e ) { }
public void mouseClicked ( MouseEvent e )
{
Point p = e . getPoint ( ) ;
int i = <num> ;
int newSelected = selectedTab ;
for ( Enumeration eRect = tabRectangles . elements ( ) ; eRect . hasMoreElements ( ) ; i ++ )
{
if ( ( ( Rectangle ) eRect . nextElement ( ) ) . contains ( p ) )
newSelected = i ;
}
if ( newSelected != selectedTab )
{
selectedTab = newSelected ;
repaint ( ) ;
if ( noteBook != null )
noteBook . showPage ( ( String ) tabNames . elementAt ( selectedTab  <num> ) ) ;
}
}
public static void main ( String [ ] args )
{
Frame f = new Frame ( " ) ;
f . setLayout ( new BorderLayout ( ) ) ;
Tabs tabs = new Tabs ( null ) ;
tabs . addTab ( " ) ;
tabs . addTab ( " ) ;
f . add ( " , tabs ) ;
f . setSize ( <num> , <num> ) ;
f . pack ( ) ;
f . show ( ) ;
}
}
public final class DogConnectionContent
{
protected String contentData ;
protected String contentDataLowerCase ;
protected String contentType ;
protected String contentTitle ;
protected int dogNo ;
public DogConnectionContent ( )
{
this ( null , null , null , <num> ) ;
}
public DogConnectionContent ( String data , String type , String title , int dogNo )
{
set ( data , type , title , dogNo ) ;
}
public void set ( String data , String type , String title , int dogNo )
{
contentData = data ;
if ( data != null )
contentDataLowerCase = data . toLowerCase ( ) ;
contentTitle = title ;
this . dogNo = dogNo ;
}
public String getData ( )
{
return contentData ;
}
public String getDataLowerCase ( )
{
return contentDataLowerCase ;
}
public String getType ( )
{
return contentType ;
}
public String getTitle ( )
{
return contentTitle ;
}
public int getDogNo ( )
{
return dogNo ;
}
}
import java . awt . event . * ;
public final class DisplayListener implements ActionListener , ItemListener
{
protected Hunter hunter ;
protected Display display ;
public DisplayListener ( Hunter h , Display d )
{
hunter = h ;
display = d ;
}
public void actionPerformed ( ActionEvent e )
{
String action = e . getActionCommand ( ) ;
if ( action . equalsIgnoreCase ( " ) )
{
DogSearchExp searchExp = new DogSearchExp ( display . getSearchWords ( ) , false ) ;
hunter . startSearch ( searchExp , display . getStartURL ( ) ) ;
} else if ( action . equalsIgnoreCase ( " ) )
{
hunter . dumpResults ( ) ;
} else if ( action . equalsIgnoreCase ( " ) )
{
hunter . stopSearch ( ) ;
} else if ( action . equalsIgnoreCase ( " ) )
hunter . quit ( ) ;
}
public void itemStateChanged ( ItemEvent e )
{
}
}
import java . net . * ;
import java . util . * ;
public final class Hunter
{
public static final int MAX_DOGS = <num> ;
public static final int MIN_DOGS = <num> ;
public static final int DEFAULT_DOGS = <num> ;
public final int noOfDogs = <num> ;
protected HunterStatistics stats ;
protected UrlDB searchDB ;
protected DogSearchExp searchExp ;
protected HunterResult results ;
protected Vector dogs ;
protected Display display ;
public Hunter ( )
{
display = new Display ( " , this ) ;
}
public void startSearch ( DogSearchExp srchExp , String startURL )
{
stats = new HunterStatistics ( display ) ;
UrlDB searchDB = new UrlDB ( stats ) ;
searchExp = srchExp ;
results = new HunterResult ( " , stats ) ;
if ( ! startURL . equalsIgnoreCase ( " ) )
{
try {
searchDB . add ( new HunterUrl ( new URL ( startURL ) , <num> ) ) ;
} catch ( MalformedURLException e1 ) {
return ;
}
}
Dog . noOfDogs = <num> ;
dogs = new Vector ( ) ;
for ( int i = <num> ; i < noOfDogs ; i ++ )
dogs . addElement ( new Dog ( searchDB , searchExp , results , stats ) ) ;
stats . setHunterStatus ( " ) ;
}
public void stopSearch ( )
{
if ( stats != null )
stats . setHunterStatus ( " ) ;
for ( Enumeration e = dogs . elements ( ) ; e . hasMoreElements ( ) ; )
{
( ( Dog ) e . nextElement ( ) ) . signalStop ( ) ;
}
}
public void dumpResults ( )
{
results . dumpTempResults ( ) ;
}
public void quit ( )
{
System . exit ( <num> ) ;
}
public static void main ( String [ ] args )
{
Hunter hunter = new Hunter ( ) ;
while ( Dog . noOfDogs ( ) > <num> )
{
Thread . yield ( ) ;
}
return ;
}
}
import java . net . * ;
import java . io . * ;
import java . util . * ;
public final class DogConnection
{
protected URL connectedUrl ;
protected URLConnection connection ;
protected BufferedReader input = null ;
protected DogConnectionContent content ;
protected HunterStatistics stats ;
protected DogSearcher searcher ;
protected DogLinkFilter linkFilter ;
protected boolean connected ;
protected int dogNo ;
public DogConnection ( HunterStatistics stat , DogConnectionContent cont )
{
content = cont ;
dogNo = content . getDogNo ( ) ;
stats = stat ;
searcher = new DogSearcher ( content ) ;
linkFilter = new DogLinkFilter ( stats , content ) ;
connected = false ;
}
public void connect ( HunterUrl url ) throws IOException
{
connected = false ;
connection = url . getURL ( ) . openConnection ( ) ;
connection . connect ( ) ;
connectedUrl = connection . getURL ( ) ;
InputStream inStream = connection . getInputStream ( ) ;
InputStreamReader inStreamReader = new InputStreamReader ( inStream ) ;
input = new BufferedReader ( inStreamReader ) ;
int contentLength = connection . getContentLength ( ) ;
String cont ;
if ( contentLength >  <num> )
{
stats . setStatus ( dogNo , " + contentLength + " + connectedUrl . toString ( ) ) ;
char [ ] cbuf = new char [ contentLength ] ;
input . read ( cbuf , <num> , contentLength ) ;
cont = new String ( cbuf ) ;
}
else
{
stats . setStatus ( dogNo , " + connectedUrl . toString ( ) ) ;
char [ ] cbuf = new char [ <num> ] ;
int pos = <num> ;
cont = new String ( " ) ;
while ( pos >  <num> )
{
pos = input . read ( cbuf , <num> , <num> ) ;
cont = cont . concat ( new String ( cbuf ) ) ;
}
}
content . set ( cont , connection . getContentType ( ) , connection . getHeaderField ( " ) , content . getDogNo ( ) ) ;
input . close ( ) ;
if ( connection . <unk> ( ) )
inStream . close ( ) ;
if ( connection . <unk> ( ) )
connection . getOutputStream ( ) . close ( ) ;
connected = true ;
}
public boolean connected ( )
{
return connected ;
}
public Vector getLinks ( )
{
return linkFilter . getLinks ( connectedUrl ) ;
}
public URL getURL ( )
{
return connectedUrl ;
}
public int search ( DogSearchExp searchExp )
{
return searcher . search ( searchExp ) ;
}
}
import java . awt . * ;
public final class DoubleBufferedList extends List
{
Image buffer ;
public DoubleBufferedList ( int showLines )
{
super ( showLines ) ;
buffer = null ;
}
public void invalidate ( )
{
super . invalidate ( ) ;
buffer = null ;
}
public void update ( Graphics g )
{
paint ( g ) ;
}
public void paint ( Graphics g )
{
if ( buffer == null )
buffer = createImage ( getSize ( ) . width , getSize ( ) . height ) ;
Graphics bg = buffer . getGraphics ( ) ;
bg . setClip ( <num> , <num> , getSize ( ) . width , getSize ( ) . height ) ;
super . paint ( bg ) ;
g . drawImage ( buffer , <num> , <num> , null ) ;
}
}
public final class DogSearchExp
{
protected String searchString ;
protected boolean caseSensitive ;
public DogSearchExp ( String searchStr , boolean caseSens )
{
searchString = searchStr ;
caseSensitive = caseSens ;
}
public String getSearchString ( )
{
return searchString ;
}
public boolean caseSensitive ( )
{
return caseSensitive ;
}
}
public final class HunterStatistics
{
protected long badUrls = <num> ;
protected long waitingUrls = <num> ;
protected long processedUrls = <num> ;
protected long successedUrls = <num> ;
protected long failedUrls = <num> ;
protected Display display ;
protected long linkTreeLevel = <num> ;
public HunterStatistics ( Display d )
{
display = d ;
}
public void setStatus ( int dogNo , String message )
{
display . setStatus ( dogNo , " + dogNo + " + message ) ;
}
public void setHunterStatus ( String message )
{
display . setStatus ( <num> , " + message ) ;
}
public synchronized void addBadUrl ( )
{
addProcessedUrl ( ) ;
badUrls ++ ;
display . setStatsBad ( badUrls ) ;
}
public synchronized void addWaitingUrl ( int value )
{
if ( value > <num> )
for ( int i = <num> ; i <= value ; i ++ )
addProcessedUrl ( ) ;
if ( value < <num> )
for ( int i =  <num> ; i >= value ; i  )
addProcessedUrl ( ) ;
waitingUrls += value ;
display . setStatsWaiting ( waitingUrls ) ;
}
public synchronized void addProcessedUrl ( )
{
processedUrls ++ ;
display . setStatsProcessed ( processedUrls ) ;
}
public void addSuccessedUrl ( )
{
successedUrls ++ ;
}
public void addFailedUrl ( )
{
failedUrls ++ ;
}
public long getBadUrls ( )
{
return badUrls ;
}
public long <unk> ( )
{
return waitingUrls ;
}
public long getProcessedUrls ( )
{
return processedUrls ;
}
public long getSuccessedUrls ( )
{
return successedUrls ;
}
public long getFailedUrls ( )
{
return failedUrls ;
}
public synchronized void linkLevel ( long level )
{
linkTreeLevel = level ;
display . setStatsLinkLevel ( level ) ;
}
}
public final class DogSearcher
{
protected DogConnectionContent content ;
public DogSearcher ( DogConnectionContent cont )
{
content = cont ;
}
public int search ( DogSearchExp searchExp )
{
int startIndex ;
int occurs = <num> ;
String searchString ;
String searchContent ;
if ( searchExp . caseSensitive ( ) )
{
searchString = searchExp . getSearchString ( ) ;
searchContent = content . getData ( ) ;
}
else
{
searchString = searchExp . getSearchString ( ) . toLowerCase ( ) ;
searchContent = content . getDataLowerCase ( ) ;
}
startIndex = searchContent . indexOf ( searchString , <num> ) ;
while ( startIndex >= <num> )
{
occurs ++ ;
startIndex = searchContent . indexOf ( searchString , startIndex + <num> ) ;
}
return occurs ;
}
}
import java . net . * ;
import java . util . * ;
import java . io . * ;
public final class Dog extends Thread
{
public static int noOfDogs = <num> ;
protected static int activeDogs = <num> ;
protected static Vector dogPack = new Vector ( ) ;
protected static ThreadGroup dogThreads = new ThreadGroup ( " ) ;
protected DogConnection connection ;
protected UrlDB dataBase ;
protected DogSearchExp searchExp ;
protected HunterResult result ;
protected HunterStatistics stats ;
protected boolean done ;
protected boolean idle ;
protected int dogNo ;
protected DogConnectionContent content = new DogConnectionContent ( ) ;
protected boolean stopping ;
public Dog ( UrlDB db , DogSearchExp searchExp , HunterResult res , HunterStatistics stat )
{
super ( dogThreads , " + ( ++ noOfDogs ) ) ;
dogNo = noOfDogs ;
activeDogs ++ ;
content . set ( null , null , null , dogNo ) ;
done = false ;
idle = false ;
connection = new DogConnection ( stat , content ) ;
dataBase = db ;
result = res ;
stats = stat ;
stopping = false ;
dogPack . addElement ( this ) ;
this . setPriority ( Thread . MIN_PRIORITY ) ;
this . searchExp = searchExp ;
this . start ( ) ;
}
public static int noOfDogs ( )
{
return noOfDogs ;
}
public static ThreadGroup <unk> ( )
{
return dogThreads ;
}
public int dogNo ( )
{
return dogNo ;
}
public void signalStop ( )
{
stopping = true ;
}
public void run ( )
{
HunterUrl curUrl = dataBase . getNext ( ) ;
while ( ! stopping )
{
while ( curUrl != null && ! stopping )
{
if ( idle )
{
idle = false ;
activeDogs ++ ;
}
try {
stats . setStatus ( dogNo , " + curUrl . toString ( ) ) ;
connection . connect ( curUrl ) ;
} catch ( IOException e1 )
{
stats . setStatus ( dogNo , " + curUrl . toString ( ) + " + e1 . getMessage ( ) ) ;
stats . addBadUrl ( ) ;
}
if ( connection . connected ( ) )
{
stats . setStatus ( dogNo , " + connection . getURL ( ) . toString ( ) ) ;
int occurs = connection . search ( searchExp ) ;
if ( occurs > <num> )
{
result . add ( curUrl , occurs ) ;
}
else
{
stats . addFailedUrl ( ) ;
}
Vector newUrls = connection . getLinks ( ) ;
for ( Enumeration e = newUrls . elements ( ) ; e . hasMoreElements ( ) ; )
dataBase . add ( new HunterUrl ( ( URL ) e . nextElement ( ) , curUrl . getLevel ( ) + <num> ) ) ;
}
else
stats . addBadUrl ( ) ;
curUrl = dataBase . getNext ( ) ;
}
if ( ! idle )
{
idle = true ;
activeDogs  ;
stats . setStatus ( dogNo , " ) ;
}
try {
this . sleep ( <num> ) ;
} catch ( InterruptedException e1 ) { }
if ( activeDogs == <num> )
break ;
curUrl = dataBase . getNext ( ) ;
}
stats . setHunterStatus ( " ) ;
done = true ;
noOfDogs  ;
this . stop ( ) ;
}
public boolean idle ( )
{
return idle ;
}
public boolean done ( )
{
return done ;
}
}
import java . util . * ;
import java . io . * ;
import java . net . * ;
public final class HunterResult
{
protected RandomAccessFile outFile ;
protected String outFileName ;
protected int error ;
protected HunterStatistics stats ;
protected boolean addBlock ;
protected Thread blockedThread ;
public HunterResult ( String fileName , HunterStatistics stat )
{
outFileName = fileName ;
stats = stat ;
addBlock = false ;
blockedThread = null ;
error = <num> ;
try
{
outFile = new RandomAccessFile ( fileName + " , " ) ;
} catch ( IOException e1 )
{
outFile = null ;
error = <num> ;
}
if ( error == <num> )
{
this . writeHeader ( outFile ) ;
}
}
public int error ( )
{
return error ;
}
public void close ( )
{
if ( outFile != null )
{
writeFooter ( outFile ) ;
try {
outFile . close ( ) ;
} catch ( IOException e1 ) { }
outFile = null ;
}
}
public synchronized void add ( HunterUrl url , int count )
{
if ( addBlock )
{
blockedThread = Thread . currentThread ( ) ;
blockedThread . suspend ( ) ;
}
if ( outFile != null )
{
stats . addSuccessedUrl ( ) ;
url . setCount ( count ) ;
try {
outFile . writeUTF ( " + url . toString ( ) + " + url . toString ( ) + " ) ;
} catch ( IOException e1 ) { }
}
}
public String dumpTempResults ( )
{
addBlock = true ;
RandomAccessFile tmpFile ;
String tmpFileName = outFileName + " ;
try {
tmpFile = new RandomAccessFile ( tmpFileName , " ) ;
} catch ( IOException e1 )
{
addBlock = false ;
if ( blockedThread != null )
{
blockedThread . resume ( ) ;
blockedThread = null ;
}
return null ;
}
try {
outFile . getFD ( ) . sync ( ) ;
long pos = outFile . getFilePointer ( ) ;
outFile . seek ( <num> ) ;
String tmpLine ;
while ( ( tmpLine = outFile . readUTF ( ) ) != null )
{
tmpFile . writeUTF ( tmpLine + " ) ;
}
writeFooter ( tmpFile ) ;
tmpFile . getFD ( ) . sync ( ) ;
tmpFile . close ( ) ;
outFile . seek ( pos ) ;
} catch ( IOException e1 )
{
addBlock = false ;
if ( blockedThread != null )
{
blockedThread . resume ( ) ;
blockedThread = null ;
}
try {
tmpFile . close ( ) ;
} catch ( IOException e2 ) { }
return null ;
}
addBlock = false ;
if ( blockedThread != null )
{
blockedThread . resume ( ) ;
blockedThread = null ;
}
return tmpFileName ;
}
protected void finalize ( )
{
this . close ( ) ;
}
protected void writeHeader ( RandomAccessFile file )
{
if ( file != null )
{
try {
file . writeUTF ( " ) ;
file . writeUTF ( " ) ;
file . writeUTF ( " ) ;
file . writeUTF ( " ) ;
file . writeUTF ( " ) ;
} catch ( IOException e1 ) { }
}
}
protected void writeFooter ( RandomAccessFile file )
{
if ( file != null )
{
try {
file . writeUTF ( " ) ;
file . writeUTF ( " + stats . getProcessedUrls ( ) + " + stats . getBadUrls ( ) + " + stats . getSuccessedUrls ( ) + " + stats . getFailedUrls ( ) + " ) ;
file . writeUTF ( " ) ;
file . writeUTF ( " ) ;
file . writeUTF ( " ) ;
} catch ( IOException e1 ) { }
}
}
public static void main ( String args [ ] )
{
HunterStatistics testStat = new HunterStatistics ( null ) ;
HunterResult testRes = new HunterResult ( " , testStat ) ;
try {
testRes . add ( new HunterUrl ( new URL ( " , " , <num> , " ) , <num> ) , <num> ) ;
testRes . add ( new HunterUrl ( new URL ( " , " , <num> , " ) , <num> ) , <num> ) ;
testRes . add ( new HunterUrl ( new URL ( " , " , <num> , " ) , <num> ) , <num> ) ;
testRes . close ( ) ;
System . out . print ( " ) ;
} catch ( MalformedURLException e1 )
{
System . out . print ( " ) ;
}
}
}
package com . android . <unk> ;
import java . io . FileInputStream ;
import java . math . BigInteger ;
import java . security . cert . CertificateFactory ;
import java . security . cert . Certificate ;
import java . security . KeyStore ;
import java . security . Key ;
import java . security . PublicKey ;
import java . security . interfaces . RSAPublicKey ;
import sun . misc . BASE64Encoder ;
class <unk> {
static void check ( RSAPublicKey key ) throws Exception {
BigInteger pubexp = key . getPublicExponent ( ) ;
BigInteger modulus = key . getModulus ( ) ;
if ( ! pubexp . equals ( BigInteger . valueOf ( <num> ) ) )
throw new Exception ( " +
pubexp . toString ( <num> ) + " ) ;
if ( modulus . bitLength ( ) != <num> )
throw new Exception ( " +
modulus . bitLength ( ) + " ) ;
}
static String print ( RSAPublicKey key ) throws Exception {
check ( key ) ;
BigInteger N = key . getModulus ( ) ;
StringBuilder result = new StringBuilder ( ) ;
int nwords = N . bitLength ( ) / <num> ;
result . append ( " ) ;
result . append ( nwords ) ;
BigInteger B = BigInteger . valueOf ( <num> ) ;
BigInteger N0inv = B . subtract ( N . modInverse ( B ) ) ;
result . append ( " ) ;
result . append ( N0inv . toString ( <num> ) ) ;
BigInteger R = BigInteger . valueOf ( <num> ) . pow ( N . bitLength ( ) ) ;
BigInteger RR = R . multiply ( R ) . mod ( N ) ;
result . append ( " ) ;
for ( int i = <num> ; i < nwords ; ++ i ) {
long n = N . mod ( B ) . longValue ( ) ;
result . append ( n ) ;
if ( i != nwords  <num> ) {
result . append ( " ) ;
}
N = N . divide ( B ) ;
}
result . append ( " ) ;
result . append ( " ) ;
for ( int i = <num> ; i < nwords ; ++ i ) {
long rr = RR . mod ( B ) . longValue ( ) ;
result . append ( rr ) ;
if ( i != nwords  <num> ) {
result . append ( " ) ;
}
RR = RR . divide ( B ) ;
}
result . append ( " ) ;
result . append ( " ) ;
return result . toString ( ) ;
}
public static void main ( String [ ] args ) {
if ( args . length < <num> ) {
System . err . println ( " ) ;
System . exit ( <num> ) ;
}
try {
for ( int i = <num> ; i < args . length ; i ++ ) {
FileInputStream input = new FileInputStream ( args [ i ] ) ;
CertificateFactory cf = CertificateFactory . getInstance ( " ) ;
Certificate cert = cf . generateCertificate ( input ) ;
RSAPublicKey key = ( RSAPublicKey ) ( cert . getPublicKey ( ) ) ;
check ( key ) ;
System . out . print ( print ( key ) ) ;
System . out . println ( i < args . length  <num> ? " : " ) ;
}
} catch ( Exception e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
System . exit ( <num> ) ;
}
}
package com . victorvieux . fbsdkchecker ;
import java . util . List ;
import android . app . Activity ;
import android . app . ActivityManager ;
import android . app . ActivityManager . RunningServiceInfo ;
import android . content . Context ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . CompoundButton ;
import android . widget . CompoundButton . OnCheckedChangeListener ;
import android . widget . TextView ;
import android . widget . ToggleButton ;
public class FBSDKCheckerActivity extends Activity implements OnCheckedChangeListener {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
ToggleButton toggleButton = ( ToggleButton ) findViewById ( R . id . <unk> ) ;
toggleButton . setChecked ( isServiceRunning ( ) ) ;
if ( toggleButton . isChecked ( ) )
findViewById ( R . id . textViewHelp ) . setVisibility ( View . GONE ) ;
toggleButton . setOnCheckedChangeListener ( this ) ;
handleIntent ( getIntent ( ) ) ;
}
@Override
public void onNewIntent ( Intent i ) {
handleIntent ( i ) ;
}
private void handleIntent ( Intent i ) {
if ( i != null && i . getStringExtra ( " ) != null ) {
String line = i . getStringExtra ( " ) ;
( ( TextView ) findViewById ( R . id . textViewLine ) ) . setText ( line ) ;
( ( TextView ) findViewById ( R . id . textViewDate ) ) . setText ( getString ( R . string . warning , line . split ( " ) [ <num> ] ) ) ;
findViewById ( R . id . imageViewLogo ) . setVisibility ( View . VISIBLE ) ;
findViewById ( R . id . textViewHelp ) . setVisibility ( View . GONE ) ;
}
}
@Override
public void onCheckedChanged ( CompoundButton buttonView , boolean isChecked ) {
Intent service = new Intent ( this , FBSDKCheckerService . class ) ;
if ( isChecked ) {
startService ( service ) ;
findViewById ( R . id . textViewHelp ) . setVisibility ( View . GONE ) ;
}
else {
stopService ( service ) ;
( ( TextView ) findViewById ( R . id . textViewLine ) ) . setText ( " ) ;
( ( TextView ) findViewById ( R . id . textViewDate ) ) . setText ( " ) ;
findViewById ( R . id . imageViewLogo ) . setVisibility ( View . GONE ) ;
findViewById ( R . id . textViewHelp ) . setVisibility ( View . VISIBLE ) ;
}
}
public boolean isServiceRunning ( ) {
final ActivityManager activityManager = ( ActivityManager ) this . getSystemService ( Context . ACTIVITY_SERVICE ) ;
final List < RunningServiceInfo > services = activityManager . getRunningServices ( Integer . MAX_VALUE ) ;
for ( RunningServiceInfo runningServiceInfo : services ) {
if ( runningServiceInfo . service . getClassName ( ) . equals ( getPackageName ( ) + " ) ) {
return true ;
}
}
return false ;
}
package com . victorvieux . fbsdkchecker ;
import java . io . BufferedReader ;
import java . io . InputStreamReader ;
import android . app . Notification ;
import android . app . NotificationManager ;
import android . app . PendingIntent ;
import android . app . Service ;
import android . content . Context ;
import android . content . Intent ;
import android . os . IBinder ;
import android . util . Log ;
public class FBSDKCheckerService extends Service {
final String LOG_TAG = " ;
@Override
public IBinder onBind ( Intent intent ) {
return null ;
}
@Override
public int onStartCommand ( Intent intent , int flags , int startId ) {
super . onStart ( intent , startId ) ;
Thread t = new Thread ( ) {
public void run ( ) {
Process process = null ;
BufferedReader reader = null ;
String line = null ;
while ( true )
{
try {
process = Runtime . getRuntime ( ) . exec ( " ) ;
reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ;
while ( ( line = reader . readLine ( ) ) != null )
{
if ( line . contains ( " ) )
{
displayNotification ( line ) ;
}
line = null ;
}
} catch ( Exception e ) {
Log . e ( LOG_TAG , e . getMessage ( ) ) ;
e . printStackTrace ( ) ;
}
}
}
} ;
t . start ( ) ;
return START_STICKY ;
}
public void displayNotification ( String line ) {
Notification notification = new Notification ( R . drawable . ic_launcher , getString ( R . string . title ) , System . currentTimeMillis ( ) ) ; ;
notification . flags = Notification . FLAG_AUTO_CANCEL ;
Intent i = new Intent ( this , FBSDKCheckerActivity . class ) ;
i . putExtra ( " , line ) ;
notification . setLatestEventInfo ( this , getString ( R . string . app_name ) , getString ( R . string . title ) , PendingIntent . getActivity ( this , <num> , i , PendingIntent . FLAG_CANCEL_CURRENT | PendingIntent . FLAG_ONE_SHOT ) ) ;
( ( NotificationManager ) this . getSystemService ( Context . NOTIFICATION_SERVICE ) ) . notify ( line . hashCode ( ) , notification ) ;
}
}
package me . coolblinger . signrank ;
public class <unk> {
}
package me . coolblinger . signrank ;
public class <unk> {
package me . coolblinger . signrank . listeners ;
import me . coolblinger . signrank . SignRank ;
import org . bukkit . ChatColor ;
import org . bukkit . block . Block ;
import org . bukkit . block . BlockState ;
import org . bukkit . block . Sign ;
import org . bukkit . entity . Player ;
import org . bukkit . event . EventHandler ;
import org . bukkit . event . Listener ;
import org . bukkit . event . block . Action ;
import org . bukkit . event . player . PlayerInteractEvent ;
import java . util . Arrays ;
public class SignRankPlayerListener implements Listener {
private final SignRank plugin ;
public SignRankPlayerListener ( SignRank instance ) {
plugin = instance ;
}
@EventHandler
public void onPlayerInteract ( PlayerInteractEvent event ) {
if ( event . getAction ( ) == Action . LEFT_CLICK_BLOCK || event . getAction ( ) == Action . RIGHT_CLICK_BLOCK ) {
Block eventBlock = event . getClickedBlock ( ) ;
BlockState eventBlockState = eventBlock . getState ( ) ;
Player player = event . getPlayer ( ) ;
if ( eventBlockState instanceof Sign ) {
Sign eventSign = ( Sign ) eventBlockState ;
if ( plugin . isWorldEnabled ( player . getWorld ( ) ) == true && eventSign . getLine ( <num> ) . equals ( plugin . getFirstLine ( player . getWorld ( ) ) ) ) {
String [ ] groups = plugin . perms . <unk> ( player ) ;
String [ ] allgroups = plugin . perms . getGroups ( ) ;
if ( plugin . overrideGroup ( player . getWorld ( ) ) ) {
if ( Arrays . asList ( groups ) . contains ( plugin . getWorldDefault ( player . getWorld ( ) ) ) ) {
player . sendMessage ( ChatColor . RED + " ) ;
} else {
plugin . perms . playerAddGroup ( player , plugin . getWorldDefault ( player . getWorld ( ) ) ) ;
player . sendMessage ( ChatColor . GREEN + plugin . getRankMessage ( player . getWorld ( ) ) ) ;
}
} else {
if ( Arrays . asList ( groups ) . contains ( eventSign . getLine ( <num> ) ) ) {
player . sendMessage ( ChatColor . RED + " ) ;
} else {
if ( Arrays . asList ( allgroups ) . contains ( ( eventSign . getLine ( <num> ) ) ) ) {
plugin . perms . playerAddGroup ( player , eventSign . getLine ( <num> ) ) ;
player . sendMessage ( ChatColor . GREEN + plugin . getRankMessage ( player . getWorld ( ) ) ) ;
} else {
player . sendMessage ( ChatColor . RED + " ) ;
}
}
}
}
}
}
}
package me . coolblinger . signrank . listeners ;
import me . coolblinger . signrank . SignRank ;
import org . bukkit . ChatColor ;
import org . bukkit . Material ;
import org . bukkit . block . Block ;
import org . bukkit . block . BlockState ;
import org . bukkit . block . Sign ;
import org . bukkit . entity . Player ;
import org . bukkit . event . EventHandler ;
import org . bukkit . event . Listener ;
import org . bukkit . event . block . BlockBreakEvent ;
import org . bukkit . event . block . SignChangeEvent ;
public class SignRankBlockListener implements Listener {
private final SignRank plugin ;
public SignRankBlockListener ( SignRank instance ) {
plugin = instance ;
}
@EventHandler
public void onSignChange ( SignChangeEvent event ) {
Player player = event . getPlayer ( ) ;
if ( event . getLine ( <num> ) . equals ( plugin . getFirstLine ( player . getWorld ( ) ) ) ) {
if ( ! plugin . hasPermission ( player ) ) {
player . sendMessage ( ChatColor . RED + " ) ;
event . getBlock ( ) . setType ( Material . AIR ) ;
event . setCancelled ( true ) ;
}
}
}
@EventHandler
public void onBlockBreak ( BlockBreakEvent event ) {
Block eventBlock = event . getBlock ( ) ;
BlockState eventBlockState = eventBlock . getState ( ) ;
if ( eventBlockState instanceof Sign ) {
Sign eventSign = ( Sign ) eventBlockState ;
Player player = event . getPlayer ( ) ;
if ( eventSign . getLine ( <num> ) . equals ( plugin . getFirstLine ( player . getWorld ( ) ) ) ) {
if ( ! plugin . hasPermission ( player ) ) {
player . sendMessage ( ChatColor . RED + " ) ;
event . setCancelled ( true ) ;
}
}
}
}
}
package me . coolblinger . signrank ;
import me . coolblinger . signrank . listeners . SignRankBlockListener ;
import me . coolblinger . signrank . listeners . SignRankPlayerListener ;
import net . milkbowl . vault . permission . Permission ;
import org . bukkit . World ;
import org . bukkit . configuration . file . FileConfiguration ;
import org . bukkit . entity . Player ;
import org . bukkit . plugin . PluginDescriptionFile ;
import org . bukkit . plugin . RegisteredServiceProvider ;
import org . bukkit . plugin . java . JavaPlugin ;
import java . io . File ;
import java . util . logging . Logger ;
public class SignRank extends JavaPlugin {
private final Logger log = Logger . getLogger ( " ) ;
public FileConfiguration config ;
public String pluginName ;
public Permission perms = null ;
@Override
public void onDisable ( ) {
log . info ( " ) ;
}
@Override
public void onEnable ( ) {
PluginDescriptionFile pdFile = this . getDescription ( ) ;
if ( ! setupPerms ( ) ) {
log . info ( " ) ;
getServer ( ) . getPluginManager ( ) . disablePlugin ( this ) ;
return ;
}
getServer ( ) . getPluginManager ( ) . registerEvents ( new SignRankPlayerListener ( this ) , this ) ;
getServer ( ) . getPluginManager ( ) . registerEvents ( new SignRankBlockListener ( this ) , this ) ;
log . info ( " + pdFile . getName ( ) + " + pdFile . getVersion ( ) + " ) ;
loadConfiguration ( ) ;
}
public void loadConfiguration ( ) {
if ( exists ( ) == false ) {
config = getConfig ( ) ;
config . options ( ) . copyDefaults ( false ) ;
for ( World w : getServer ( ) . getWorlds ( ) ) {
String world = w . getName ( ) ;
String p0 = " + world + " ;
String p1 = " + world + " ;
String p2 = " + world + " ;
String p3 = " + world + " ;
String p4 = " + world + " ;
config . addDefault ( p0 , " ) ;
config . addDefault ( p1 , " ) ;
config . addDefault ( p2 , " ) ;
config . addDefault ( p3 , " ) ;
config . addDefault ( p4 , " ) ;
}
config . options ( ) . copyDefaults ( true ) ;
saveConfig ( ) ;
}
}
private boolean exists ( ) {
try {
File file = new File ( " ) ;
if ( file . exists ( ) ) {
return true ;
} else {
return false ;
}
} catch ( Exception e ) {
System . err . println ( " + e . getMessage ( ) ) ;
return true ;
}
}
public boolean overrideGroup ( World w ) {
String world = w . getName ( ) ;
config = getConfig ( ) ;
String message = config . getString ( " + world + " ) ;
if ( message . equalsIgnoreCase ( " ) ) {
return true ;
} else {
return false ;
}
}
public boolean isWorldEnabled ( World w ) {
String world = w . getName ( ) ;
config = getConfig ( ) ;
String message = config . getString ( " + world + " ) ;
if ( message . equalsIgnoreCase ( " ) ) {
return true ;
} else {
return false ;
}
}
public String getFirstLine ( World w ) {
String world = w . getName ( ) ;
config = getConfig ( ) ;
String message = config . getString ( " + world + " ) ;
return message ;
}
public String getRankMessage ( World w ) {
String world = w . getName ( ) ;
config = getConfig ( ) ;
String message = config . getString ( " + world + " ) ;
return message ;
}
public String getWorldDefault ( World w ) {
String world = w . getName ( ) ;
config = getConfig ( ) ;
String message = config . getString ( " + world + " ) ;
return message ;
}
private Boolean setupPerms ( ) {
RegisteredServiceProvider < Permission > permissionProvider = getServer ( ) . getServicesManager ( ) . getRegistration ( net . milkbowl . vault . permission . Permission . class ) ;
if ( permissionProvider != null ) {
perms = permissionProvider . getProvider ( ) ;
}
return ( perms != null ) ;
}
public boolean hasPermission ( Player player ) {
if ( perms . has ( player , " ) || player . isOp ( ) == true ) {
return true ;
} else {
return false ;
}
}
}
package dk . itu . spcl . dex . tools ;
import java . io . IOException ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . client . HttpClient ;
import org . apache . http . client . ResponseHandler ;
import org . apache . http . client . methods . HttpGet ;
import org . apache . http . impl . client . BasicResponseHandler ;
import org . apache . http . impl . client . DefaultHttpClient ;
public class HttpTools {
public static String readStringFromUrl ( String url ) throws IOException ,
ClientProtocolException {
HttpClient httpClient = new DefaultHttpClient ( ) ;
HttpGet get = new HttpGet ( url ) ;
ResponseHandler < String > resp = new BasicResponseHandler ( ) ;
String responseText = httpClient . execute ( get , resp ) ;
return responseText ;
}
}
package dk . itu . spcl . dex ;
import java . util . ArrayList ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . ListView ;
import dk . itu . spcl . dex . model . Preset ;
import dk . itu . spcl . dex . model . PresetEntry ;
import dk . itu . spcl . dex . model . Repository ;
import dk . itu . spcl . dex . model . Thingy ;
import dk . itu . spcl . dex . tools . UITools ;
public class PresetActivity extends Activity implements Repository . Listener {
private static final int PICK_THINGY_REQUEST_CODE = <num> ;
private Preset _preset ;
private Repository _repository ;
private ThingyUpdater _thingyUpdater ;
private CustomArrayAdapter < PresetEntry > _listAdapter ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . preset ) ;
_repository = Repository . getInstance ( ) ;
_thingyUpdater = ThingyUpdater . getInstance ( ) ;
_preset = Repository . getInstance ( ) . getPreset (
getIntent ( ) . getStringExtra ( " ) ) ;
setTitle ( " + _preset . getName ( ) ) ;
initializeThingyList ( ) ;
addListSelectionListener ( ) ;
_repository . addListener ( this ) ;
}
@Override
protected void onPause ( ) {
_thingyUpdater . cancelUpdatesFor ( this ) ;
super . onPause ( ) ;
}
@Override
protected void onResume ( ) {
_thingyUpdater . requestUpdatesFor ( this ) ;
super . onResume ( ) ;
}
@Override
protected void onDestroy ( ) {
_repository . removeListener ( this ) ;
super . onDestroy ( ) ;
}
@Override
public void repositoryStructureChanged ( ) {
}
@Override
public void repositoryStatusChanged ( ) {
runOnUiThread ( new Runnable ( ) {
@Override
public void run ( ) {
_listAdapter . notifyDataSetChanged ( ) ;
}
} ) ;
}
private void addListSelectionListener ( ) {
ListView listView = ( ListView ) findViewById ( R . id . presetThingyList ) ;
listView . setOnItemClickListener ( new OnItemClickListener ( ) {
public void onItemClick ( AdapterView < ? > parent , View view , int position ,
long id ) {
PresetEntry entry = ( PresetEntry ) parent . getItemAtPosition ( position ) ;
onEntrySelected ( entry ) ;
}
} ) ;
}
protected void onEntrySelected ( PresetEntry entry ) {
if ( entry == _repository . getDummyPresetEntry ( ) )
addEntry ( ) ;
}
public void <unk> ( View view ) {
for ( PresetEntry entry : _preset . getEntries ( ) ) {
entry . getThingy ( ) . setStatus ( entry . getStatus ( ) )
. setStatusChangeQueued ( true ) ;
}
}
private void initializeThingyList ( ) {
_listAdapter = new CustomArrayAdapter < PresetEntry > ( this ,
R . layout . default_list_item , R . id . listTextView ,
new ArrayList < PresetEntry > ( ) ) ;
ListView listView = ( ListView ) findViewById ( R . id . presetThingyList ) ;
listView . setAdapter ( _listAdapter ) ;
populateThingyList ( ) ;
}
private void populateThingyList ( ) {
_listAdapter . clear ( ) ;
for ( PresetEntry entry : _preset . getEntries ( ) )
_listAdapter . add ( entry ) ;
_listAdapter . add ( _repository . getDummyPresetEntry ( ) ) ;
_listAdapter . notifyDataSetChanged ( ) ;
}
private void addEntry ( ) {
startActivityForResult ( new Intent ( this , ThingyListActivity . class ) . putExtra (
" , true ) , PICK_THINGY_REQUEST_CODE ) ;
}
@Override
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) {
if ( resultCode != RESULT_CANCELED ) {
final Thingy selected = _repository . getThingy ( data . getExtras ( ) . getString (
" ) ) ;
UITools . promptForBoolean ( this , " ,
" ,
new UITools . PromptResultHandler < Boolean > ( ) {
@Override
public void closed ( boolean accepted , Boolean value ) {
if ( accepted && value != null ) {
_preset . addEntry ( new PresetEntry ( ) . setThingy ( selected )
. setStatus ( value ) ) ;
populateThingyList ( ) ;
}
}
} ) ;
}
}
}
package dk . itu . spcl . dex . juidl . tests ;
import dk . itu . spcl . dex . juidl . UIGenerator ;
import dk . itu . spcl . dex . juidl . Widget ;
public class MockUIGenerator extends UIGenerator {
public String canvasTitle ;
public String canvasDesription ;
public double canvasVersion ;
public Widget widget ;
public String stringContent ;
public String [ ] stringContentArray ;
public boolean boolContent ;
public boolean [ ] boolContentArray ;
public int intContent ;
public int [ ] intContentArray ;
@Override
protected void generateCanvas ( String title , String description ,
double version ) {
canvasTitle = title ;
canvasDesription = description ;
canvasVersion = version ;
}
@Override
protected void generateWidget ( Widget w , String content ) {
widget = w ;
stringContent = content ;
}
@Override
protected void generateWidget ( Widget w , String [ ] contentArray ) {
widget = w ;
this . stringContentArray = contentArray ;
}
@Override
protected void generateWidget ( Widget w , boolean content ) {
widget = w ;
this . boolContent = content ;
}
@Override
protected void generateWidget ( Widget w , boolean [ ] contentArray ) {
widget = w ;
this . boolContentArray = contentArray ;
}
@Override
protected void generateWidget ( Widget w , int content ) {
widget = w ;
this . intContent = content ;
}
@Override
protected void generateWidget ( Widget w , int [ ] contentArray ) {
widget = w ;
this . intContentArray = contentArray ;
}
}
package dk . itu . spcl . dex . tools ;
import android . app . AlertDialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . text . InputType ;
import android . widget . EditText ;
import android . widget . ToggleButton ;
public class UITools {
public interface PromptResultHandler < T > {
public void closed ( boolean accepted , T value ) ;
}
public static void promptForString ( Context context , String caption ,
String label , final PromptResultHandler < String > resultHandler ) {
AlertDialog . Builder alert = new AlertDialog . Builder ( context ) ;
alert . setTitle ( caption ) ;
alert . setMessage ( label ) ;
final EditText input = new EditText ( context ) ;
input . setSingleLine ( ) ;
input . setInputType ( InputType . <unk> | InputType . TYPE_CLASS_TEXT ) ;
alert . setView ( input ) ;
alert . setPositiveButton ( " , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialog , int which ) {
String value = input . getText ( ) . toString ( ) ;
resultHandler . closed ( true , value ) ;
}
} ) ;
alert . setNegativeButton ( " , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialog , int whichButton ) {
resultHandler . closed ( false , null ) ;
}
} ) ;
alert . show ( ) ;
}
public static void promptForBoolean ( Context context , String caption ,
String label , final PromptResultHandler < Boolean > resultHandler ) {
AlertDialog . Builder alert = new AlertDialog . Builder ( context ) ;
alert . setTitle ( caption ) ;
alert . setMessage ( label ) ;
final ToggleButton input = new ToggleButton ( context ) ;
input . <unk> ( " ) ;
input . <unk> ( " ) ;
input . setChecked ( false ) ;
alert . setView ( input ) ;
alert . setPositiveButton ( " , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialog , int which ) {
boolean value = input . isChecked ( ) ;
resultHandler . closed ( true , value ) ;
}
} ) ;
alert . setNegativeButton ( " , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialog , int whichButton ) {
resultHandler . closed ( false , null ) ;
}
} ) ;
alert . show ( ) ;
}
}
package dk . itu . spcl . dex . juidl . tests ;
import static org . junit . Assert . assertEquals ;
import org . json . JSONException ;
import org . json . JSONObject ;
import org . junit . Test ;
import dk . itu . spcl . dex . juidl . Widget ;
import dk . itu . spcl . dex . juidl . WidgetType ;
public class <unk> {
@Test
public void <unk> ( ) throws JSONException {
JSONObject json = new JSONObject ( ) ;
String expId = " ;
json . put ( " , expId ) ;
String expTitle = " ;
json . put ( " , expTitle ) ;
String expDesc = " ;
json . put ( " , expDesc ) ;
WidgetType expType = WidgetType . EDITABLE ;
json . put ( " , " ) ;
int [ ] expectedContent = new int [ ] { <num> , <num> , <num> } ;
json . put ( " , expectedContent ) ;
String expParentId = " ;
Widget widget = Widget . fromJSONObject ( json , expParentId ) ;
assertEquals ( expId , widget . getId ( ) ) ;
assertEquals ( expTitle , widget . getTitle ( ) ) ;
assertEquals ( expDesc , widget . getDescription ( ) ) ;
assertEquals ( expType , widget . getType ( ) ) ;
assertEquals ( expParentId , widget . getParentId ( ) ) ;
}
}
package dk . itu . spcl . dex ;
import java . util . ArrayList ;
import android . app . ListActivity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . ListView ;
import dk . itu . spcl . dex . model . Preset ;
import dk . itu . spcl . dex . model . Repository ;
import dk . itu . spcl . dex . model . Repository . Listener ;
import dk . itu . spcl . dex . tools . UITools ;
public class PresetListActivity extends ListActivity {
private Repository _repository ;
private CustomArrayAdapter < Preset > _listAdapter ;
private Repository . Listener _updateListener ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
_repository = Repository . getInstance ( ) ;
initializePresetList ( ) ;
addRepositoryListener ( ) ;
addListSelectionListener ( ) ;
}
@Override
protected void onDestroy ( ) {
super . onDestroy ( ) ;
removeUpdateListener ( ) ;
}
private void addRepositoryListener ( ) {
_updateListener = new Listener ( ) {
@Override
public void repositoryStructureChanged ( ) {
runOnUiThread ( new Runnable ( ) {
@Override
public void run ( ) {
populatePresetList ( ) ;
}
} ) ;
}
@Override
public void repositoryStatusChanged ( ) {
}
} ;
_repository . addListener ( _updateListener ) ;
}
private void removeUpdateListener ( ) {
_repository . removeListener ( _updateListener ) ;
}
private void addListSelectionListener ( ) {
ListView listView = getListView ( ) ;
listView . setOnItemClickListener ( new OnItemClickListener ( ) {
public void onItemClick ( AdapterView < ? > parent , View view , int position ,
long id ) {
Preset preset = ( Preset ) parent . getItemAtPosition ( position ) ;
onPresetSelected ( preset ) ;
}
} ) ;
}
private void onPresetSelected ( Preset preset ) {
if ( preset != _repository . getDummyPreset ( ) )
startPresetActivity ( preset ) ;
else
newPreset ( ) ;
}
private void startPresetActivity ( Preset preset ) {
Intent intent = new Intent ( this , PresetActivity . class ) . putExtra ( " ,
preset . getName ( ) ) ;
startActivity ( intent ) ;
}
private void initializePresetList ( ) {
_listAdapter = new CustomArrayAdapter < Preset > ( this ,
R . layout . default_list_item , R . id . listTextView , new ArrayList < Preset > ( ) ) ;
setListAdapter ( _listAdapter ) ;
populatePresetList ( ) ;
}
private void populatePresetList ( ) {
_listAdapter . clear ( ) ;
for ( Preset p : _repository . getPresets ( ) )
_listAdapter . add ( p ) ;
_listAdapter . add ( _repository . getDummyPreset ( ) ) ;
_listAdapter . notifyDataSetChanged ( ) ;
}
private void newPreset ( ) {
UITools . promptForString ( this , " , " , new UITools . PromptResultHandler < String > ( ) {
@Override
public void closed ( boolean accepted , String value ) {
if ( accepted && value . length ( ) > <num> )
addPreset ( value ) ;
}
} ) ;
}
protected void addPreset ( String name ) {
Preset newPreset = new Preset ( ) . setName ( name ) ;
_repository . addPreset ( newPreset ) ;
startPresetActivity ( newPreset ) ;
}
}
package dk . itu . spcl . dex . juidl . tests ;
import static org . junit . Assert . assertEquals ;
import org . json . JSONException ;
import org . json . JSONObject ;
import org . junit . Before ;
import org . junit . Test ;
import dk . itu . spcl . dex . juidl . JUIDLException ;
import dk . itu . spcl . dex . juidl . WidgetType ;
public class <unk> {
private MockUIGenerator p ;
@Before
public void Setup ( ) {
p = new MockUIGenerator ( ) ;
}
@Test
public void <unk> ( ) throws JSONException , JUIDLException {
String test_schema = " +
" +
" ;
JSONObject schema_json = new JSONObject ( test_schema ) ;
p . generate ( schema_json ) ;
assertEquals ( " , p . canvasTitle ) ;
assertEquals ( " , p . canvasDesription ) ;
assertEquals ( <num> , p . canvasVersion , <num> ) ;
}
@Test
public void <unk> ( ) throws JSONException , JUIDLException {
String test_schema = " +
" +
" +
" +
" +
" +
" +
" +
" +
" ;
JSONObject schema_json = new JSONObject ( test_schema ) ;
p . generate ( schema_json ) ;
assertEquals ( " , p . widget . getId ( ) ) ;
assertEquals ( " , p . widget . getTitle ( ) ) ;
assertEquals ( " , p . widget . getDescription ( ) ) ;
assertEquals ( WidgetType . EDITABLE , p . widget . getType ( ) ) ;
assertEquals ( " , p . widget . getContentType ( ) ) ;
assertEquals ( <num> , p . intContent ) ;
}
}
package dk . itu . spcl . dex . juidl ;
import java . util . Arrays ;
import java . util . Comparator ;
import java . util . HashSet ;
import org . json . JSONArray ;
import org . json . JSONObject ;
public abstract class UIGenerator {
public static final double [ ] SUPPORTED_SCHEMA_VERSIONS = { <num> } ;
private static Comparator < JSONObject > priorityComparator = new JSONWidgetPriorityComparator ( ) ;
private HashSet < String > idCol ;
public void generate ( JSONObject schema ) throws JUIDLException {
validate ( schema ) ;
generateCanvas ( schema . optString ( " ) ,
schema . optString ( " ) , schema . optDouble ( " ) ) ;
JSONArray widgets = schema . optJSONArray ( " ) ;
generateWidgets ( widgets , null ) ;
}
public void validate ( JSONObject schema ) throws JUIDLException {
if ( ! schema . has ( " ) || schema . isNull ( " ) ) {
throw new JUIDLException ( " ) ;
}
if ( ! schema . has ( " ) ) {
throw new JUIDLException ( " ) ;
} else if ( Arrays . binarySearch ( SUPPORTED_SCHEMA_VERSIONS ,
schema . optDouble ( " , <num> ) ) < <num> ) {
throw new JUIDLException ( " ) ;
}
if ( schema . optJSONArray ( " ) == null ) {
throw new JUIDLException (
" ) ;
}
idCol = new HashSet < String > ( ) ;
JSONArray widgets = schema . optJSONArray ( " ) ;
validateWidgets ( widgets ) ;
}
private void validateWidgets ( JSONArray widgets ) throws JUIDLException {
int index = <num> ;
JSONObject widget ;
while ( null != ( widget = widgets . optJSONObject ( index ) ) ) {
validateWidget ( widget ) ;
index ++ ;
}
}
private void validateWidget ( JSONObject widget ) throws JUIDLException {
if ( ! widget . has ( " ) || widget . optString ( " ) == null ) {
throw new JUIDLException ( String . format (
" , widget . toString ( ) ) ) ;
}
String id = widget . optString ( " ) ;
if ( idCol . contains ( id ) ) {
throw new JUIDLException ( String . format ( " , id ) ) ;
}
idCol . add ( id ) ;
JSONArray widgets = widget . optJSONArray ( " ) ;
if ( widgets != null && widgets . length ( ) > <num> ) {
validateWidgets ( widgets ) ;
}
}
private void generateWidgets ( JSONArray widgets , String parentId ) {
JSONObject [ ] sortedWidgets = new JSONObject [ widgets . length ( ) ] ;
int index = <num> ;
JSONObject widget ;
while ( null != ( widget = widgets . optJSONObject ( index ) ) ) {
sortedWidgets [ index ] = widget ;
index ++ ;
}
Arrays . sort ( sortedWidgets , priorityComparator ) ;
for ( index = <num> ; index < sortedWidgets . length ; index ++ ) {
generateWidget ( sortedWidgets [ index ] , parentId ) ;
}
}
private void generateWidget ( JSONObject widget , String parentId ) {
Widget w = Widget . fromJSONObject ( widget , parentId ) ;
String ct = w . getContentType ( ) ;
if ( w . getType ( ) == WidgetType . MULTI_SELECT
|| w . getType ( ) == WidgetType . SELECT ) {
JSONArray arr = widget . optJSONArray ( " ) ;
if ( ct . equalsIgnoreCase ( " ) ) {
String [ ] content = new String [ arr . length ( ) ] ;
for ( int i = <num> , len = arr . length ( ) ; i < len ; i ++ ) {
content [ i ] = arr . optString ( i ) ;
}
generateWidget ( w , content ) ;
} else if ( ct . equalsIgnoreCase ( " ) ) {
int [ ] content = new int [ arr . length ( ) ] ;
for ( int i = <num> , len = arr . length ( ) ; i < len ; i ++ ) {
content [ i ] = arr . optInt ( i ) ;
}
generateWidget ( w , content ) ;
} else if ( ct . equalsIgnoreCase ( " ) ) {
boolean [ ] content = new boolean [ arr . length ( ) ] ;
for ( int i = <num> , len = arr . length ( ) ; i < len ; i ++ ) {
content [ i ] = arr . optBoolean ( i ) ;
}
generateWidget ( w , content ) ;
}
} else {
if ( ct . equalsIgnoreCase ( " ) ) {
generateWidget ( w , widget . optString ( " ) ) ;
} else if ( ct . equalsIgnoreCase ( " ) ) {
generateWidget ( w , widget . optInt ( " ) ) ;
} else if ( ct . equalsIgnoreCase ( " ) ) {
generateWidget ( w , widget . optBoolean ( " ) ) ;
}
}
JSONArray widgets = widget . optJSONArray ( " ) ;
if ( widgets != null && widgets . length ( ) > <num> ) {
generateWidgets ( widgets , w . getId ( ) ) ;
}
}
protected abstract void generateCanvas ( String title , String description ,
double version ) ;
protected abstract void generateWidget ( Widget w , String content ) ;
protected abstract void generateWidget ( Widget w , String [ ] contentArray ) ;
protected abstract void generateWidget ( Widget w , boolean content ) ;
protected abstract void generateWidget ( Widget w , boolean [ ] contentArray ) ;
protected abstract void generateWidget ( Widget w , int content ) ;
protected abstract void generateWidget ( Widget w , int [ ] contentArray ) ;
private static class JSONWidgetPriorityComparator implements
Comparator < JSONObject > {
public int compare ( JSONObject widget1 , JSONObject widget2 ) {
int p1 = widget1 . optInt ( " , <num> ) ;
int p2 = widget2 . optInt ( " , <num> ) ;
return p1  p2 ;
}
}
}
package com . google . zxing . integration . android ;
import java . util . Arrays ;
import java . util . Collection ;
import java . util . Collections ;
import java . util . List ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . content . ActivityNotFoundException ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . pm . PackageManager ;
import android . content . pm . ResolveInfo ;
import android . net . Uri ;
import android . util . Log ;
public class IntentIntegrator {
public static final int REQUEST_CODE = <num> ;
private static final String TAG = IntentIntegrator . class . getSimpleName ( ) ;
public static final String DEFAULT_TITLE = " ;
public static final String DEFAULT_MESSAGE =
" ;
public static final String DEFAULT_YES = " ;
public static final String DEFAULT_NO = " ;
private static final String BS_PACKAGE = " ;
public static final Collection < String > PRODUCT_CODE_TYPES = list ( " , " , " , " , " ) ;
public static final Collection < String > ONE_D_CODE_TYPES =
list ( " , " , " , " , " , " , " ,
" , " , " ) ;
public static final Collection < String > QR_CODE_TYPES = Collections . singleton ( " ) ;
public static final Collection < String > DATA_MATRIX_TYPES = Collections . singleton ( " ) ;
public static final Collection < String > ALL_CODE_TYPES = null ;
public static final Collection < String > TARGET_BARCODE_SCANNER_ONLY = Collections . singleton ( BS_PACKAGE ) ;
public static final Collection < String > TARGET_ALL_KNOWN = list (
BS_PACKAGE ,
" ,
"
) ;
private final Activity activity ;
private String title ;
private String message ;
private String buttonYes ;
private String buttonNo ;
private Collection < String > targetApplications ;
public IntentIntegrator ( Activity activity ) {
this . activity = activity ;
title = DEFAULT_TITLE ;
message = DEFAULT_MESSAGE ;
buttonYes = DEFAULT_YES ;
buttonNo = DEFAULT_NO ;
targetApplications = TARGET_ALL_KNOWN ;
}
public String getTitle ( ) {
return title ;
}
public void setTitle ( String title ) {
this . title = title ;
}
public void setTitleByID ( int titleID ) {
title = activity . getString ( titleID ) ;
}
public String getMessage ( ) {
return message ;
}
public void setMessage ( String message ) {
this . message = message ;
}
public void setMessageByID ( int messageID ) {
message = activity . getString ( messageID ) ;
}
public String getButtonYes ( ) {
return buttonYes ;
}
public void setButtonYes ( String buttonYes ) {
this . buttonYes = buttonYes ;
}
public void setButtonYesByID ( int buttonYesID ) {
buttonYes = activity . getString ( buttonYesID ) ;
}
public String getButtonNo ( ) {
return buttonNo ;
}
public void setButtonNo ( String buttonNo ) {
this . buttonNo = buttonNo ;
}
public void setButtonNoByID ( int buttonNoID ) {
buttonNo = activity . getString ( buttonNoID ) ;
}
public Collection < String > getTargetApplications ( ) {
return targetApplications ;
}
public void setTargetApplications ( Collection < String > targetApplications ) {
this . targetApplications = targetApplications ;
}
public void setSingleTargetApplication ( String targetApplication ) {
this . targetApplications = Collections . singleton ( targetApplication ) ;
}
public AlertDialog initiateScan ( ) {
return initiateScan ( ALL_CODE_TYPES ) ;
}
public AlertDialog initiateScan ( Collection < String > desiredBarcodeFormats ) {
Intent intentScan = new Intent ( BS_PACKAGE + " ) ;
intentScan . addCategory ( Intent . CATEGORY_DEFAULT ) ;
if ( desiredBarcodeFormats != null ) {
StringBuilder joinedByComma = new StringBuilder ( ) ;
for ( String format : desiredBarcodeFormats ) {
if ( joinedByComma . length ( ) > <num> ) {
joinedByComma . append ( ,' ) ;
}
joinedByComma . append ( format ) ;
}
intentScan . putExtra ( " , joinedByComma . toString ( ) ) ;
}
String targetAppPackage = findTargetAppPackage ( intentScan ) ;
if ( targetAppPackage == null ) {
return showDownloadDialog ( ) ;
}
intentScan . setPackage ( targetAppPackage ) ;
intentScan . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
intentScan . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET ) ;
startActivityForResult ( intentScan , REQUEST_CODE ) ;
return null ;
}
protected void startActivityForResult ( Intent intent , int code ) {
activity . startActivityForResult ( intent , code ) ;
}
private String findTargetAppPackage ( Intent intent ) {
PackageManager pm = activity . getPackageManager ( ) ;
List < ResolveInfo > availableApps = pm . queryIntentActivities ( intent , PackageManager . MATCH_DEFAULT_ONLY ) ;
if ( availableApps != null ) {
for ( ResolveInfo availableApp : availableApps ) {
String packageName = availableApp . activityInfo . packageName ;
if ( targetApplications . contains ( packageName ) ) {
return packageName ;
}
}
}
return null ;
}
private AlertDialog showDownloadDialog ( ) {
AlertDialog . Builder downloadDialog = new AlertDialog . Builder ( activity ) ;
downloadDialog . setTitle ( title ) ;
downloadDialog . setMessage ( message ) ;
downloadDialog . setPositiveButton ( buttonYes , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialogInterface , int i ) {
Uri uri = Uri . parse ( " + BS_PACKAGE ) ;
Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ;
try {
activity . startActivity ( intent ) ;
} catch ( ActivityNotFoundException anfe ) {
Log . w ( TAG , " ) ;
}
}
} ) ;
downloadDialog . setNegativeButton ( buttonNo , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialogInterface , int i ) { }
} ) ;
return downloadDialog . show ( ) ;
}
public static IntentResult parseActivityResult ( int requestCode , int resultCode , Intent intent ) {
if ( requestCode == REQUEST_CODE ) {
if ( resultCode == Activity . RESULT_OK ) {
String contents = intent . getStringExtra ( " ) ;
String formatName = intent . getStringExtra ( " ) ;
byte [ ] rawBytes = intent . getByteArrayExtra ( " ) ;
int intentOrientation = intent . getIntExtra ( " , Integer . MIN_VALUE ) ;
Integer orientation = intentOrientation == Integer . MIN_VALUE ? null : intentOrientation ;
String errorCorrectionLevel = intent . getStringExtra ( " ) ;
return new IntentResult ( contents ,
formatName ,
rawBytes ,
orientation ,
errorCorrectionLevel ) ;
}
return new IntentResult ( ) ;
}
return null ;
}
public void shareText ( CharSequence text ) {
Intent intent = new Intent ( ) ;
intent . addCategory ( Intent . CATEGORY_DEFAULT ) ;
intent . setAction ( BS_PACKAGE + " ) ;
intent . putExtra ( " , " ) ;
intent . putExtra ( " , text ) ;
String targetAppPackage = findTargetAppPackage ( intent ) ;
if ( targetAppPackage == null ) {
showDownloadDialog ( ) ;
} else {
intent . setPackage ( targetAppPackage ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET ) ;
activity . startActivity ( intent ) ;
}
}
private static Collection < String > list ( String . . . values ) {
return Collections . unmodifiableCollection ( Arrays . asList ( values ) ) ;
}
}
package dk . itu . spcl . dex ;
import java . io . IOException ;
import java . util . ArrayList ;
import org . apache . http . client . ClientProtocolException ;
import android . util . Log ;
import dk . itu . spcl . dex . model . Repository ;
import dk . itu . spcl . dex . model . Thingy ;
import dk . itu . spcl . dex . tools . HttpTools ;
public class ThingyUpdater implements Runnable {
private Thread _runningThread ;
private final static int UPDATE_INTERVAL = <num> ;
private Repository _repository ;
private ArrayList < Object > _listeners = new ArrayList < Object > ( ) ;
private static ThingyUpdater _instance ;
private ThingyUpdater ( ) {
_repository = Repository . getInstance ( ) ;
}
public static ThingyUpdater getInstance ( ) {
if ( _instance == null ) {
_instance = new ThingyUpdater ( ) ;
}
return _instance ;
}
public void requestUpdatesFor ( Object me ) {
_listeners . add ( me ) ;
toggleUpdatesAsNeeded ( ) ;
}
public void cancelUpdatesFor ( Object me ) {
_listeners . remove ( me ) ;
toggleUpdatesAsNeeded ( ) ;
}
private synchronized void toggleUpdatesAsNeeded ( ) {
Log . i ( " , _listeners . size ( ) + " ) ;
if ( _listeners . size ( ) == <num> )
stopBackgroundUpdates ( ) ;
else
startBackgroundUpdates ( ) ;
}
private void startBackgroundUpdates ( ) {
if ( _runningThread != null )
return ;
_runningThread = new Thread ( this ) ;
_runningThread . start ( ) ;
}
private void stopBackgroundUpdates ( ) {
_runningThread = null ;
}
@Override
public void run ( ) {
while ( Thread . currentThread ( ) == _runningThread ) {
update ( ) ;
pause ( ) ;
}
}
private void update ( ) {
for ( Thingy thingy : _repository . getThingies ( ) )
updateThingy ( thingy ) ;
_repository . onStatusChanged ( ) ;
}
private void updateThingy ( Thingy thingy ) {
try {
String url = thingy . getUrl ( ) + " ;
if ( thingy . isStatusChangeQueued ( ) ) {
url += thingy . getStatus ( ) ? " : " ;
} else {
url += " ;
}
boolean thingyStatus = getStatusFromUrl ( url ) ;
if ( thingy . getStatus ( ) == thingyStatus ) {
thingy . setStatusChangeQueued ( false ) ;
}
if ( ! thingy . isStatusChangeQueued ( ) ) {
thingy . setStatus ( thingyStatus ) ;
}
} catch ( ClientProtocolException e ) {
Log . e ( " , e . toString ( ) ) ;
} catch ( IOException e ) {
Log . e ( " , e . toString ( ) ) ;
}
}
private boolean getStatusFromUrl ( String url ) throws ClientProtocolException ,
IOException {
String responseText = HttpTools . readStringFromUrl ( url ) ;
return responseText . contains ( " ) ;
}
private void pause ( ) {
try {
Thread . sleep ( UPDATE_INTERVAL ) ;
} catch ( InterruptedException e ) {
}
}
}
package dk . itu . spcl . dex . model ;
import java . util . ArrayList ;
public class Preset implements Comparable < Preset > {
private ArrayList < PresetEntry > _entries ;
private String _name ;
public Preset ( ) {
_entries = new ArrayList < PresetEntry > ( ) ;
}
public Preset setName ( String name ) {
_name = name ;
return this ;
}
public String getName ( ) {
return _name ;
}
public void addEntry ( PresetEntry e ) {
_entries . add ( e ) ;
}
public ArrayList < PresetEntry > getEntries ( ) {
return _entries ;
}
@Override
public String toString ( ) {
return getName ( ) ;
}
@Override
public int compareTo ( Preset another ) {
return getName ( ) . compareTo ( another . getName ( ) ) ;
}
}
package dk . itu . spcl . dex . juidl ;
@SuppressWarnings("serial")
public class JUIDLException extends Exception {
public JUIDLException ( String message ) {
super ( message ) ;
}
package dk . itu . spcl . dex ;
import android . app . TabActivity ;
import android . content . Intent ;
import android . content . res . Resources ;
import android . os . Bundle ;
import android . preference . PreferenceManager ;
import android . view . Menu ;
import android . view . MenuInflater ;
import android . view . MenuItem ;
import android . widget . TabHost ;
import dk . itu . spcl . dex . model . Repository ;
public class HomeActivity extends TabActivity {
private ThingyUpdater _thingyUpdater ;
private Repository _repository ;
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
_thingyUpdater = ThingyUpdater . getInstance ( ) ;
_repository = Repository . getInstance ( ) ;
setContentView ( R . layout . home ) ;
addTabs ( ) ;
PreferenceManager . setDefaultValues ( this , R . xml . settings , false ) ;
}
@Override
protected void onPause ( ) {
_thingyUpdater . cancelUpdatesFor ( this ) ;
super . onPause ( ) ;
}
@Override
protected void onResume ( ) {
_thingyUpdater . requestUpdatesFor ( this ) ;
super . onResume ( ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
MenuInflater inflater = getMenuInflater ( ) ;
inflater . inflate ( R . menu . homemenu , menu ) ;
return true ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case R . id . resetMenu :
_repository . reset ( ) ;
return true ;
case R . id . settingsMenu :
showSettings ( ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
private void showSettings ( ) {
startActivity ( new Intent ( this , SettingsActivity . class ) ) ;
}
private void addTabs ( ) {
Resources res = getResources ( ) ;
TabHost tabHost = getTabHost ( ) ;
addThingyTab ( res , tabHost ) ;
addPresetTab ( res , tabHost ) ;
}
private void addPresetTab ( Resources res , TabHost tabHost ) {
TabHost . TabSpec spec ;
Intent intent ;
intent = new Intent ( this , PresetListActivity . class ) ;
spec = tabHost . newTabSpec ( " ) . setIndicator ( " )
. setContent ( intent ) ;
tabHost . addTab ( spec ) ;
}
private void addThingyTab ( Resources res , TabHost tabHost ) {
Intent intent = new Intent ( this , ThingyListActivity . class ) ;
TabHost . TabSpec spec = tabHost . newTabSpec ( " )
. setIndicator ( " )
. setContent ( intent ) ;
tabHost . addTab ( spec ) ;
}
package dk . itu . spcl . dex ;
import java . util . ArrayList ;
import android . app . ListActivity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . ListView ;
import dk . itu . spcl . dex . model . Repository ;
import dk . itu . spcl . dex . model . Thingy ;
public class ThingyListActivity extends ListActivity implements
Repository . Listener {
private Repository _repository ;
private ThingyUpdater _thingyUpdater ;
private final int SCAN_FOR_THINGY_REQUEST_CODE = <num> ;
private CustomArrayAdapter < Thingy > _listAdapter ;
private boolean _selectionMode ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
_repository = Repository . getInstance ( ) ;
_thingyUpdater = ThingyUpdater . getInstance ( ) ;
_selectionMode = getIntent ( ) . getBooleanExtra ( " , false ) ;
if ( _selectionMode )
setTitle ( " ) ;
initializeThingyList ( ) ;
_repository . addListener ( this ) ;
addListSelectionListener ( ) ;
}
@Override
protected void onPause ( ) {
_thingyUpdater . cancelUpdatesFor ( this ) ;
super . onPause ( ) ;
}
@Override
protected void onResume ( ) {
_thingyUpdater . requestUpdatesFor ( this ) ;
super . onResume ( ) ;
}
@Override
protected void onDestroy ( ) {
_repository . removeListener ( this ) ;
super . onDestroy ( ) ;
}
@Override
public void repositoryStructureChanged ( ) {
runOnUiThread ( new Runnable ( ) {
@Override
public void run ( ) {
populateThingyList ( ) ;
}
} ) ;
}
@Override
public void repositoryStatusChanged ( ) {
runOnUiThread ( new Runnable ( ) {
@Override
public void run ( ) {
_listAdapter . notifyDataSetChanged ( ) ;
}
} ) ;
}
private void addListSelectionListener ( ) {
ListView listView = getListView ( ) ;
listView . setOnItemClickListener ( new OnItemClickListener ( ) {
public void onItemClick ( AdapterView < ? > parent , View view , int position ,
long id ) {
Thingy thingy = ( Thingy ) parent . getItemAtPosition ( position ) ;
onThingySelected ( thingy ) ;
}
} ) ;
}
private void onThingySelected ( Thingy thingy ) {
if ( _selectionMode ) {
returnThingy ( thingy ) ;
} else if ( thingy == _repository . getDummyThingy ( ) ) {
newThingy ( ) ;
} else {
startThingyActivity ( thingy ) ;
}
}
private void returnThingy ( Thingy thingy ) {
Intent data = new Intent ( this , getClass ( ) ) . putExtra ( " ,
thingy . getName ( ) ) ;
setResult ( RESULT_OK , data ) ;
finish ( ) ;
}
private void startThingyActivity ( Thingy thingy ) {
Intent intent = new Intent ( this , ThingyActivity . class ) . putExtra ( " ,
thingy . getName ( ) ) ;
startActivity ( intent ) ;
}
private void initializeThingyList ( ) {
_listAdapter = new CustomArrayAdapter < Thingy > ( this ,
R . layout . default_list_item , R . id . listTextView , new ArrayList < Thingy > ( ) ) ;
setListAdapter ( _listAdapter ) ;
populateThingyList ( ) ;
}
private void populateThingyList ( ) {
_listAdapter . clear ( ) ;
for ( Thingy t : _repository . getThingies ( ) )
_listAdapter . add ( t ) ;
if ( ! _selectionMode )
_listAdapter . add ( _repository . getDummyThingy ( ) ) ;
_listAdapter . notifyDataSetChanged ( ) ;
}
private void newThingy ( ) {
startActivityForResult ( new Intent ( this , ScanActivity . class ) ,
SCAN_FOR_THINGY_REQUEST_CODE ) ;
}
@Override
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) {
if ( resultCode != RESULT_CANCELED ) {
}
}
}
package dk . itu . spcl . dex ;
import android . content . Context ;
import android . content . SharedPreferences ;
import android . preference . PreferenceManager ;
public class Settings {
public static final String <unk> = " ;
public static String getHomeSsid ( Context context ) {
SharedPreferences sp = PreferenceManager
. getDefaultSharedPreferences ( context ) ;
return sp . getString ( " , null ) ;
}
public static String getHomePsk ( Context context ) {
SharedPreferences sp = PreferenceManager
. getDefaultSharedPreferences ( context ) ;
return sp . getString ( " , null ) ;
}
package dk . itu . spcl . dex . model ;
import java . util . HashMap ;
import dk . itu . spcl . dex . juidl . Widget ;
public class Thingy implements Comparable < Thingy > {
private String _name ;
private String _url ;
private boolean _status ;
private boolean _statusChangeQueued = false ;
public Thingy ( ) {
}
public String getName ( ) {
return _name ;
}
public Thingy setName ( String name ) {
_name = name ;
return this ;
}
public String getUrl ( ) {
return _url ;
}
public Thingy setUrl ( String url ) {
_url = url ;
return this ;
}
public boolean getStatus ( ) {
return _status ;
}
public Thingy setStatus ( boolean status ) {
_status = status ;
return this ;
}
public boolean isStatusChangeQueued ( ) {
return _statusChangeQueued ;
}
public Thingy setStatusChangeQueued ( boolean statusChangeQueued ) {
_statusChangeQueued = statusChangeQueued ;
return this ;
}
@Override
public String toString ( ) {
return getName ( ) ;
}
@Override
public int compareTo ( Thingy another ) {
return getName ( ) . compareTo ( another . getName ( ) ) ;
}
}
package dk . itu . spcl . dex . juidl ;
public enum WidgetType {
READ_ONLY ,
EDITABLE ,
SELECT ,
MULTI_SELECT ,
<unk> ,
GROUP
package dk . itu . spcl . dex ;
import android . os . Bundle ;
import android . preference . PreferenceActivity ;
public class SettingsActivity extends PreferenceActivity {
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
addPreferencesFromResource ( R . xml . settings ) ;
}
}
package dk . itu . spcl . dex . model ;
public class PresetEntry {
private Thingy _thingy ;
private boolean _status ;
public PresetEntry setThingy ( Thingy t ) {
_thingy = t ;
return this ;
}
public PresetEntry setStatus ( boolean status ) {
_status = status ;
return this ;
}
public Thingy getThingy ( ) {
return _thingy ;
}
public boolean getStatus ( ) {
return _status ;
}
@Override
public String toString ( ) {
return _thingy . toString ( ) + " + ( _status ? " : " ) + " ;
}
}
package dk . itu . spcl . dex ;
public final class R {
public static final class attr {
}
public static final class drawable {
public static final int home_icon = <num> ;
public static final int ic_launcher = <num> ;
public static final int <unk> = <num> ;
public static final int off = <num> ;
public static final int off_check = <num> ;
public static final int off_nocheck = <num> ;
public static final int on = <num> ;
public static final int on_check = <num> ;
public static final int on_nocheck = <num> ;
}
public static final class id {
public static final int addThingyMenu = <num> ;
public static final int listTextView = <num> ;
public static final int newPresetMenu = <num> ;
public static final int newThingyMenu = <num> ;
public static final int presetThingyList = <num> ;
public static final int resetMenu = <num> ;
public static final int settingsMenu = <num> ;
public static final int thingyToggleButton = <num> ;
}
public static final class layout {
public static final int default_list_item = <num> ;
public static final int home = <num> ;
public static final int preset = <num> ;
public static final int simple_thingy = <num> ;
}
public static final class menu {
public static final int homemenu = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
}
public static final class string {
public static final int addThingyMenu = <num> ;
public static final int app_name = <num> ;
public static final int newPresetMenu = <num> ;
public static final int newThingyMenu = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int resetMenu = <num> ;
}
public static final class xml {
public static final int settings = <num> ;
}
}
package dk . itu . spcl . dex . juidl ;
import org . json . JSONObject ;
public class Widget {
private String _id ;
private String _parentId ;
private String _title ;
private String _description ;
private String _contentType ;
private int _priority ;
private WidgetType _type ;
public String getId ( ) {
return _id ;
}
public void setId ( String id ) {
this . _id = id ;
}
public String getParentId ( ) {
return _parentId ;
}
public void setParentId ( String parentId ) {
this . _parentId = parentId ;
}
public String getTitle ( ) {
return _title ;
}
public void setTitle ( String title ) {
this . _title = title ;
}
public String getDescription ( ) {
return _description ;
}
public void setDescription ( String description ) {
this . _description = description ;
}
public WidgetType getType ( ) {
return _type ;
}
public void setType ( WidgetType type ) {
this . _type = type ;
}
public String getContentType ( ) {
return _contentType ;
}
private void setContentType ( String contentType ) {
this . _contentType = contentType ;
}
public static Widget fromJSONObject ( JSONObject json , String parentId ) {
Widget w = new Widget ( ) ;
w . setId ( json . optString ( " ) ) ;
w . setDescription ( json . optString ( " ) ) ;
w . setTitle ( json . optString ( " ) ) ;
w . setType ( Enum . valueOf ( WidgetType . class , json . optString ( " , " ) . replace ( -' , _' ) . toUpperCase ( ) ) ) ;
w . setParentId ( parentId ) ;
w . setContentType ( json . optString ( " , " ) . toLowerCase ( ) ) ;
return w ;
}
public int getPriority ( ) {
return _priority ;
}
public void setPriority ( int priority ) {
this . _priority = priority ;
}
package com . google . zxing . integration . android ;
public final class IntentResult {
private final String contents ;
private final String formatName ;
private final byte [ ] rawBytes ;
private final Integer orientation ;
private final String errorCorrectionLevel ;
IntentResult ( ) {
this ( null , null , null , null , null ) ;
}
IntentResult ( String contents ,
String formatName ,
byte [ ] rawBytes ,
Integer orientation ,
String errorCorrectionLevel ) {
this . contents = contents ;
this . formatName = formatName ;
this . rawBytes = rawBytes ;
this . orientation = orientation ;
this . errorCorrectionLevel = errorCorrectionLevel ;
}
public String getContents ( ) {
return contents ;
}
public String getFormatName ( ) {
return formatName ;
}
public byte [ ] getRawBytes ( ) {
return rawBytes ;
}
public Integer getOrientation ( ) {
return orientation ;
}
public String getErrorCorrectionLevel ( ) {
return errorCorrectionLevel ;
}
@Override
public String toString ( ) {
StringBuilder dialogText = new StringBuilder ( <num> ) ;
dialogText . append ( " ) . append ( formatName ) . append ( \n' ) ;
dialogText . append ( " ) . append ( contents ) . append ( \n' ) ;
int rawBytesLength = rawBytes == null ? <num> : rawBytes . length ;
dialogText . append ( " ) . append ( rawBytesLength ) . append ( " ) ;
dialogText . append ( " ) . append ( orientation ) . append ( \n' ) ;
dialogText . append ( " ) . append ( errorCorrectionLevel ) . append ( \n' ) ;
return dialogText . toString ( ) ;
}
}
package dk . itu . spcl . dex . juidl . tests ;
import org . json . JSONException ;
import org . json . JSONObject ;
import org . junit . Before ;
import org . junit . Test ;
import dk . itu . spcl . dex . juidl . JUIDLException ;
import dk . itu . spcl . dex . juidl . UIGenerator ;
public class <unk> {
private UIGenerator p ;
@Before
public void Setup ( ) {
p = new MockUIGenerator ( ) ;
}
@Test
public void <unk> ( ) throws JUIDLException , JSONException {
String test_schema = " ;
JSONObject schema_json = new JSONObject ( test_schema ) ;
p . generate ( schema_json ) ;
}
@Test(expected=JUIDLException.class)
public void <unk> ( ) throws JSONException , JUIDLException {
String test_schema = " ;
JSONObject schema_json = new JSONObject ( test_schema ) ;
p . validate ( schema_json ) ;
}
@Test(expected=JUIDLException.class)
public void <unk> ( ) throws JSONException , JUIDLException {
String test_schema = " ;
JSONObject schema_json = new JSONObject ( test_schema ) ;
p . validate ( schema_json ) ;
}
@Test(expected=JUIDLException.class)
public void <unk> ( ) throws JSONException , JUIDLException {
String test_schema = " ;
JSONObject schema_json = new JSONObject ( test_schema ) ;
p . validate ( schema_json ) ;
}
@Test(expected=JUIDLException.class)
public void <unk> ( ) throws JSONException , JUIDLException {
String test_schema = " +
" ;
JSONObject schema_json = new JSONObject ( test_schema ) ;
p . validate ( schema_json ) ;
}
@Test(expected=JUIDLException.class)
public void <unk> ( ) throws JSONException , JUIDLException {
String test_schema = " +
" ;
JSONObject schema_json = new JSONObject ( test_schema ) ;
p . validate ( schema_json ) ;
}
@Test(expected=JUIDLException.class)
public void <unk> ( ) throws JSONException , JUIDLException {
String test_schema = " +
" ;
JSONObject schema_json = new JSONObject ( test_schema ) ;
p . validate ( schema_json ) ;
}
}
package dk . itu . spcl . dex ;
import java . util . List ;
import android . content . Context ;
import android . graphics . Rect ;
import android . graphics . drawable . Drawable ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . ArrayAdapter ;
import android . widget . TextView ;
import dk . itu . spcl . dex . model . Preset ;
import dk . itu . spcl . dex . model . PresetEntry ;
import dk . itu . spcl . dex . model . Repository ;
import dk . itu . spcl . dex . model . Thingy ;
public class CustomArrayAdapter < T > extends ArrayAdapter < T > {
private Repository _repository ;
private int _textViewResourceId ;
private enum CheckStatus {
NONE , CHECK , FAIL
} ;
public CustomArrayAdapter ( Context context , int resource ,
int textViewResourceId , List < T > objects ) {
super ( context , resource , textViewResourceId , objects ) ;
_textViewResourceId = textViewResourceId ;
_repository = Repository . getInstance ( ) ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
View itemView = super . getView ( position , convertView , parent ) ;
TextView textView = ( TextView ) itemView . findViewById ( _textViewResourceId ) ;
T item = getItem ( position ) ;
setDrawablesForTextView ( textView , item ) ;
return itemView ;
}
private void setDrawablesForTextView ( TextView textView , T item ) {
Drawable typeIcon = getTypeIconForListItem ( item ) ;
if ( typeIcon != null )
typeIcon . setBounds ( new Rect ( <num> , <num> , <num> , <num> ) ) ;
Drawable statusIcon = getStatusIconForListItem ( item ) ;
if ( statusIcon != null )
statusIcon . setBounds ( new Rect ( <num> , <num> , <num> , <num> ) ) ;
textView . setCompoundDrawables ( typeIcon , null , statusIcon , null ) ;
}
private Drawable getStatusIconForListItem ( T item ) {
if ( ! ( item instanceof Thingy || item instanceof PresetEntry )
|| item == _repository . getDummyThingy ( )
|| item == _repository . getDummyPresetEntry ( ) )
return null ;
Thingy thingy ;
if ( item instanceof PresetEntry )
thingy = ( ( PresetEntry ) item ) . getThingy ( ) ;
else
thingy = ( Thingy ) item ;
boolean on = thingy . getStatus ( ) ;
CheckStatus checkStatus = getCheckStatus ( item ) ;
int iconId =  <num> ;
switch ( checkStatus ) {
case CHECK :
iconId = on ? R . drawable . on_check : R . drawable . off_check ;
break ;
case FAIL :
iconId = on ? R . drawable . on_nocheck : R . drawable . off_nocheck ;
break ;
case NONE :
iconId = on ? R . drawable . on : R . drawable . off ;
break ;
}
return getDrawableFromId ( iconId ) ;
}
private CheckStatus getCheckStatus ( T item ) {
if ( ! ( item instanceof PresetEntry ) )
return CheckStatus . NONE ;
PresetEntry entry = ( PresetEntry ) item ;
if ( entry . getStatus ( ) != entry . getThingy ( ) . getStatus ( ) )
return CheckStatus . FAIL ;
else
return CheckStatus . CHECK ;
}
private Drawable getDrawableFromId ( int iconId ) {
return getContext ( ) . getResources ( ) . getDrawable ( iconId ) ;
}
private Drawable getTypeIconForListItem ( T listItem ) {
if ( listItem == _repository . getDummyPreset ( )
|| listItem == _repository . getDummyThingy ( )
|| listItem == _repository . getDummyPresetEntry ( ) )
return getDrawableFromId ( android . R . drawable . ic_input_add ) ;
else if ( listItem instanceof Preset )
return null ;
else if ( listItem instanceof Thingy )
return null ;
else
return null ;
}
}
package dk . itu . spcl . dex ;
import android . app . Activity ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . ToggleButton ;
import dk . itu . spcl . dex . model . Repository ;
import dk . itu . spcl . dex . model . Thingy ;
public class ThingyActivity extends Activity implements Repository . Listener {
private Thingy _thingy ;
private ThingyUpdater _thingyUpdater ;
private Repository _repository ;
private ToggleButton _toggleButton ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
_repository = Repository . getInstance ( ) ;
_thingyUpdater = ThingyUpdater . getInstance ( ) ;
_thingy = Repository . getInstance ( ) . getThingy (
getIntent ( ) . getStringExtra ( " ) ) ;
setTitle ( " + _thingy . getName ( ) ) ;
setContentView ( R . layout . simple_thingy ) ;
_toggleButton = ( ToggleButton ) findViewById ( R . id . thingyToggleButton ) ;
_repository . addListener ( this ) ;
_toggleButton . setChecked ( _thingy . getStatus ( ) ) ;
}
public void <unk> ( View v ) {
ToggleButton button = ( ToggleButton ) v ;
boolean on = button . isChecked ( ) ;
_thingy . setStatus ( on ) . setStatusChangeQueued ( true ) ;
}
@Override
protected void onDestroy ( ) {
_repository . removeListener ( this ) ;
super . onDestroy ( ) ;
}
@Override
protected void onPause ( ) {
_thingyUpdater . cancelUpdatesFor ( this ) ;
super . onPause ( ) ;
}
@Override
protected void onResume ( ) {
_thingyUpdater . requestUpdatesFor ( this ) ;
super . onResume ( ) ;
}
@Override
public void repositoryStructureChanged ( ) {
}
@Override
public void repositoryStatusChanged ( ) {
runOnUiThread ( new Runnable ( ) {
@Override
public void run ( ) {
_toggleButton . setChecked ( _thingy . getStatus ( ) ) ;
}
} ) ;
}
}
package dk . itu . spcl . dex ;
import android . app . Activity ;
import android . widget . LinearLayout ;
import android . widget . ToggleButton ;
import dk . itu . spcl . dex . juidl . UIGenerator ;
import dk . itu . spcl . dex . juidl . Widget ;
import dk . itu . spcl . dex . juidl . WidgetType ;
import dk . itu . spcl . dex . model . Thingy ;
public class AndroidUIGenerator extends UIGenerator {
private Thingy _thingy ;
private Activity _activty ;
private LinearLayout _layout ;
public AndroidUIGenerator ( Thingy thingy , Activity activity ) {
_thingy = thingy ;
_activty = activity ;
}
@Override
protected void generateCanvas ( String title , String description , double version ) {
_layout = new LinearLayout ( _activty ) ;
_activty . setContentView ( _layout ) ;
}
@Override
protected void generateWidget ( Widget w , String content ) {
}
@Override
protected void generateWidget ( Widget w , String [ ] contentArray ) {
}
@Override
protected void generateWidget ( Widget w , boolean content ) {
ToggleButton button = new ToggleButton ( _activty ) ;
button . setEnabled ( w . getType ( ) != WidgetType . READ_ONLY ) ;
_layout . addView ( button ) ;
}
@Override
protected void generateWidget ( Widget w , boolean [ ] contentArray ) {
}
@Override
protected void generateWidget ( Widget w , int content ) {
}
@Override
protected void generateWidget ( Widget w , int [ ] contentArray ) {
}
}
package dk . itu . spcl . dex . model ;
import java . util . ArrayList ;
import java . util . Collections ;
import java . util . HashMap ;
public class Repository {
public interface Listener {
public void repositoryStructureChanged ( ) ;
public void repositoryStatusChanged ( ) ;
}
HashMap < String , Thingy > _thingies = new HashMap < String , Thingy > ( ) ;
HashMap < String , Preset > _presets = new HashMap < String , Preset > ( ) ;
private static Repository _instance ;
private ArrayList < Listener > _listeners = new ArrayList < Repository . Listener > ( ) ;
private Repository ( ) {
}
public void addListener ( Listener listener ) {
_listeners . add ( listener ) ;
}
public void removeListener ( Listener listener ) {
_listeners . remove ( listener ) ;
}
public static Repository getInstance ( ) {
if ( _instance == null )
_instance = new Repository ( ) ;
return _instance ;
}
public void addThingy ( Thingy t ) {
_thingies . put ( t . getName ( ) , t ) ;
onStructureChanged ( ) ;
}
public void addPreset ( Preset p ) {
_presets . put ( p . getName ( ) , p ) ;
onStructureChanged ( ) ;
}
private void onStructureChanged ( ) {
for ( Listener listener : _listeners ) {
listener . repositoryStructureChanged ( ) ;
}
}
public void onStatusChanged ( ) {
for ( Listener listener : _listeners ) {
listener . repositoryStatusChanged ( ) ;
}
}
public ArrayList < Preset > getPresets ( ) {
ArrayList < Preset > list = new ArrayList < Preset > ( _presets . values ( ) ) ;
Collections . sort ( list ) ;
return list ;
}
public ArrayList < Thingy > getThingies ( ) {
ArrayList < Thingy > list = new ArrayList < Thingy > ( _thingies . values ( ) ) ;
Collections . sort ( list ) ;
return list ;
}
public Thingy getThingy ( String name ) {
return _thingies . get ( name ) ;
}
public Preset getPreset ( String name ) {
return _presets . get ( name ) ;
}
private Preset _dummyPreset ;
private Thingy _dummyThingy ;
private PresetEntry _dummyPresetEntry ;
public Preset getDummyPreset ( ) {
if ( _dummyPreset == null ) {
_dummyPreset = new Preset ( ) . setName ( " ) ;
}
return _dummyPreset ;
}
public Thingy getDummyThingy ( ) {
if ( _dummyThingy == null ) {
_dummyThingy = new Thingy ( ) . setName ( " ) ;
}
return _dummyThingy ;
}
public PresetEntry getDummyPresetEntry ( ) {
if ( _dummyPresetEntry == null ) {
_dummyPresetEntry = new PresetEntry ( ) {
@Override
public String toString ( ) {
return " ;
}
} ;
}
return _dummyPresetEntry ;
}
public void reset ( ) {
_thingies . clear ( ) ;
_presets . clear ( ) ;
onStructureChanged ( ) ;
}
}
package dk . itu . spcl . dex ;
import java . io . BufferedReader ;
import java . io . BufferedWriter ;
import java . io . IOException ;
import java . io . InputStreamReader ;
import java . io . OutputStreamWriter ;
import java . lang . reflect . InvocationTargetException ;
import java . lang . reflect . Method ;
import java . net . ServerSocket ;
import java . net . Socket ;
import java . nio . charset . Charset ;
import android . content . Context ;
import android . net . wifi . WifiConfiguration ;
import android . net . wifi . WifiManager ;
import android . util . Log ;
public class Bootstrapper {
private WifiManager _wifiManager ;
private String _ssid ;
private String _key ;
private Context _context ;
public Bootstrapper ( Context context , String ssid , String key ) {
_context = context ;
_wifiManager = ( WifiManager ) context . getSystemService ( Context . WIFI_SERVICE ) ;
_ssid = ssid ;
_key = key ;
}
public String runBootstrapping ( ) {
try {
toggleWifi ( false ) ;
toggleHotspot ( true ) ;
String thingyUrl = listenForBootstrapRequests ( ) ;
pause ( ) ;
toggleHotspot ( false ) ;
toggleWifi ( true ) ;
return thingyUrl ;
} catch ( Exception e ) {
Log . e ( " , e . toString ( ) ) ;
}
return null ;
}
private void pause ( ) {
try {
Thread . sleep ( <num> ) ;
} catch ( InterruptedException e ) {
}
}
private String listenForBootstrapRequests ( ) throws IOException {
Log . i ( " , " ) ;
ServerSocket server = new ServerSocket ( <num> ) ;
String thingyUrl = null ;
while ( thingyUrl == null ) {
Socket connection = server . accept ( ) ;
BufferedReader reader = new BufferedReader ( new InputStreamReader (
connection . getInputStream ( ) ) ) ;
String request = reader . readLine ( ) ;
if ( request . contains ( " ) ) {
thingyUrl = "
+ request . split ( " ) [ <num> ] . substring ( " . length ( ) ) + " ;
}
BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter (
connection . getOutputStream ( ) , Charset . forName ( " ) ) ) ;
String response = " + "
+ " + Settings . getHomeSsid ( _context ) + " + Settings . getHomePsk ( _context ) + " ;
writer . write ( response ) ;
writer . flush ( ) ;
writer . close ( ) ;
}
server . close ( ) ;
return thingyUrl ;
}
private void toggleHotspot ( boolean enable ) throws IllegalArgumentException ,
IllegalAccessException , InvocationTargetException , SecurityException ,
NoSuchMethodException {
Log . i ( " , " ) ;
WifiConfiguration wifiConfig = new WifiConfiguration ( ) ;
wifiConfig . SSID = _ssid ;
wifiConfig . <unk> = _key ;
wifiConfig . <unk> . set ( WifiConfiguration . <unk> . <unk> ) ;
Method method = _wifiManager . getClass ( ) . getMethod ( " ,
WifiConfiguration . class , boolean . class ) ;
method . invoke ( _wifiManager , wifiConfig , enable ) ;
}
private void toggleWifi ( boolean enable ) {
_wifiManager . setWifiEnabled ( enable ) ;
}
}
package dk . itu . spcl . dex ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . AsyncTask ;
import android . os . Bundle ;
import android . util . Log ;
import android . widget . TextView ;
import com . google . zxing . integration . android . IntentIntegrator ;
import com . google . zxing . integration . android . IntentResult ;
import dk . itu . spcl . dex . model . Repository ;
import dk . itu . spcl . dex . model . Thingy ;
import dk . itu . spcl . dex . tools . UITools ;
public class ScanActivity extends Activity {
private Repository _repository ;
private BootstrapTask _bootstrapTask ;
private TextView _textView ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
_repository = Repository . getInstance ( ) ;
setTitle ( " ) ;
_textView = new TextView ( this ) ;
_textView . setTextSize ( <num> ) ;
setContentView ( _textView ) ;
IntentIntegrator integrator = new IntentIntegrator ( this ) ;
integrator . initiateScan ( ) ;
}
public void onActivityResult ( int requestCode , int resultCode , Intent intent ) {
IntentResult scanResult = IntentIntegrator . parseActivityResult ( requestCode ,
resultCode , intent ) ;
if ( scanResult != null ) {
String scannedText = scanResult . getContents ( ) ;
if ( scannedText . startsWith ( " ) ) {
showText ( " ) ;
String [ ] wifiInfo = scannedText . substring ( " . length ( ) ) . split (
" ) ;
startBootstrap ( wifiInfo [ <num> ] , wifiInfo [ <num> ] ) ;
}
}
}
private void startBootstrap ( String ssid , String key ) {
_bootstrapTask = new BootstrapTask ( ) ;
_bootstrapTask . execute ( ssid , key ) ;
}
private void addThingy ( String name , String url ) {
Thingy thingy = new Thingy ( ) . setName ( name ) . setUrl ( url ) ;
Log . i ( " , " + url ) ;
_repository . addThingy ( thingy ) ;
returnScannedThingy ( thingy ) ;
}
private void returnScannedThingy ( Thingy thingy ) {
if ( thingy == null ) {
setResult ( RESULT_CANCELED ) ;
} else {
Intent data = new Intent ( ScanActivity . this , getClass ( ) ) . putExtra (
" , thingy . getName ( ) ) ;
setResult ( RESULT_OK , data ) ;
}
finish ( ) ;
}
@Override
protected void onDestroy ( ) {
if ( _bootstrapTask != null )
_bootstrapTask . cancel ( true ) ;
super . onDestroy ( ) ;
}
private void showText ( final String text ) {
runOnUiThread ( new Runnable ( ) {
public void run ( ) {
_textView . setText ( text ) ;
}
} ) ;
}
private class BootstrapTask extends AsyncTask < String , Integer , String > {
@Override
protected String doInBackground ( String . . . params ) {
Bootstrapper bootstrapper = new Bootstrapper ( ScanActivity . this ,
params [ <num> ] , params [ <num> ] ) ;
return bootstrapper . runBootstrapping ( ) ;
}
@Override
protected void onPostExecute ( final String result ) {
showText ( " ) ;
UITools . promptForString ( ScanActivity . this , " , " ,
new UITools . PromptResultHandler < String > ( ) {
@Override
public void closed ( boolean accepted , String value ) {
if ( accepted && value . length ( ) > <num> ) {
showText ( " ) ;
addThingy ( value , result ) ;
}
}
} ) ;
}
}
}
package info . ilyaraz . passwordgenerator ;
import info . ilyaraz . passwordgenerator . domain . ClueData ;
import info . ilyaraz . passwordgenerator . ui . ClueAdapter ;
import info . ilyaraz . passwordgenerator . util . Callback1 ;
import info . ilyaraz . passwordgenerator . util . Closure ;
import info . ilyaraz . passwordgenerator . util . Constants ;
import info . ilyaraz . passwordgenerator . util . HashCalculator ;
import info . ilyaraz . passwordgenerator . util . ObjectSerializer ;
import info . ilyaraz . passwordgenerator . util . StringCallback ;
import java . util . ArrayList ;
import java . util . Collections ;
import java . util . Comparator ;
import java . util . Map ;
import java . util . Set ;
import android . app . Activity ;
import android . content . SharedPreferences ;
import android . os . Bundle ;
import android . text . ClipboardManager ;
import android . text . Editable ;
import android . text . TextWatcher ;
import android . view . Menu ;
import android . view . MenuItem ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . EditText ;
import android . widget . ImageView ;
import android . widget . Spinner ;
import android . widget . SpinnerAdapter ;
import android . widget . TextView ;
public class MainActivity extends Activity {
private static final String MASTER_HASH = " ;
private Object lock = new Object ( ) ;
private String masterHash = null ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
final SharedPreferences settings = this . getSharedPreferences ( " , <num> ) ;
String masterPasswordHash = settings . getString ( MASTER_HASH , null ) ;
if ( masterPasswordHash == null ) {
MasterPasswordEditor . editMasterPassword ( this , " , " ,
new StringCallback ( ) {
@Override
public void Run ( String value ) {
finishCreation ( ) ;
}
} ,
new Closure ( ) {
@Override
public void Run ( ) {
moveTaskToBack ( true ) ;
}
} ) ;
return ;
}
finishCreation ( ) ;
}
private String getMasterHash ( ) {
synchronized ( lock ) {
if ( masterHash != null )
return masterHash ;
final SharedPreferences settings = this . getSharedPreferences ( " , <num> ) ;
String masterPasswordHash = settings . getString ( MASTER_HASH , null ) ;
masterHash = masterPasswordHash ;
return masterHash ;
}
}
private void finishCreation ( ) {
setContentView ( R . layout . activity_main ) ;
addCluesToSpinner ( ) ;
EditText masterPasswordField = ( EditText ) findViewById ( R . id . master_password ) ;
final Activity parent = this ;
final ArrayList < ClueData > clues = this . clues ;
masterPasswordField . addTextChangedListener ( new TextWatcher ( ) {
@Override
public void afterTextChanged ( Editable arg0 ) {
updateGeneratedPassword ( parent , clues ) ;
}
@Override
public void beforeTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) { }
@Override
public void onTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) { }
} ) ;
Spinner clueSpinner = ( Spinner ) parent . findViewById ( R . id . clue ) ;
clueSpinner . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) {
@Override
public void onItemSelected ( AdapterView < ? > arg0 , View arg1 , int arg2 , long arg3 ) {
updateGeneratedPassword ( parent , clues ) ;
}
@Override
public void onNothingSelected ( AdapterView < ? > arg0 ) {
updateGeneratedPassword ( parent , clues ) ;
}
} ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
getMenuInflater ( ) . inflate ( R . menu . activity_main , menu ) ;
return true ;
}
void changeMasterPasswordMenuItem ( ) {
final Activity parent = this ;
final ArrayList < ClueData > clues = this . clues ;
MasterPasswordEditor . editMasterPassword ( this , " , " ,
new StringCallback ( ) {
@Override
public void Run ( String value ) {
synchronized ( lock ) {
masterHash = null ;
}
updateGeneratedPassword ( parent , clues ) ;
}
} ,
new Closure ( ) {
@Override
public void Run ( ) {
}
} ) ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case R . id . <unk> :
changeMasterPasswordMenuItem ( ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
public void <unk> ( View view ) {
ClueEditor . editClue ( null , this ,
new Callback1 < ClueData > ( ) {
@Override
public void Run ( ClueData value ) {
addCluesToSpinner ( ) ;
}
} ,
new Closure ( ) {
@Override
public void Run ( ) {
}
} ) ;
}
private ArrayList < ClueData > clues = new ArrayList < ClueData > ( ) ;
private void addCluesToSpinner ( ) {
final SharedPreferences settings = getSharedPreferences ( Constants . STORAGE_NAMESPACE , <num> ) ;
Map < String , ? > settingsMap = settings . getAll ( ) ;
clues . clear ( ) ;
try {
for ( String key : settingsMap . keySet ( ) ) {
if ( key . startsWith ( Constants . CLUES_PREFIX ) ) {
clues . add ( ( ClueData ) ObjectSerializer . deserialize ( ( String ) settingsMap . get ( key ) ) ) ;
}
}
}
catch ( Exception e ) {
throw new RuntimeException ( e ) ;
}
Collections . sort ( clues , new Comparator < ClueData > ( ) {
@Override
public int compare ( ClueData arg0 , ClueData arg1 ) {
return arg0 . toString ( ) . compareTo ( arg1 . toString ( ) ) ;
}
} ) ;
ArrayList < String > clueNames = new ArrayList < String > ( ) ;
ArrayList < String > clueIds = new ArrayList < String > ( ) ;
for ( int i = <num> ; i < clues . size ( ) ; ++ i ) {
clueNames . add ( clues . get ( i ) . getClueName ( ) ) ;
clueIds . add ( clues . get ( i ) . getId ( ) ) ;
}
final Activity context = this ;
final Spinner cluesSpinner = ( Spinner ) findViewById ( R . id . clue ) ;
SpinnerAdapter newSpinnerAdapter = new ClueAdapter ( clueNames , clueIds , this ,
new StringCallback ( ) {
@Override
public void Run ( String value ) {
ClueEditor . editClue ( value , context ,
new Callback1 < ClueData > ( ) {
@Override
public void Run ( ClueData value ) {
int index = cluesSpinner . getSelectedItemPosition ( ) ;
addCluesToSpinner ( ) ;
cluesSpinner . setSelection ( index ) ;
}
} ,
new Closure ( ) {
@Override
public void Run ( ) {
addCluesToSpinner ( ) ;
}
} ) ;
}
} ,
new StringCallback ( ) {
@Override
public void Run ( String value ) {
int index = cluesSpinner . getSelectedItemPosition ( ) ;
settings . edit ( ) . remove ( Constants . CLUES_PREFIX + value ) . commit ( ) ;
addCluesToSpinner ( ) ;
if ( index < cluesSpinner . getCount ( ) )
cluesSpinner . setSelection ( index ) ;
}
} ,
new Callback1 < Integer > ( ) {
@Override
public void Run ( Integer value ) {
cluesSpinner . setSelection ( value ) ;
}
} ) ;
cluesSpinner . setAdapter ( newSpinnerAdapter ) ;
}
private boolean updateGeneratedPassword ( final Activity parent ,
final ArrayList < ClueData > clues ) {
TextView passwordField = ( TextView ) parent . findViewById ( R . id . password ) ;
passwordField . setText ( " ) ;
EditText masterPasswordField = ( EditText ) parent . findViewById ( R . id . master_password ) ;
String masterPassword = masterPasswordField . getText ( ) . toString ( ) ;
ImageView indicator = ( ImageView ) parent . findViewById ( R . id . <unk> ) ;
if ( ! getMasterHash ( ) . equals ( HashCalculator . base64SHA512 ( masterPassword ) ) ) {
indicator . setImageResource ( R . drawable . cross ) ;
return false ;
}
indicator . setImageResource ( R . drawable . check ) ;
Spinner clueSpinner = ( Spinner ) parent . findViewById ( R . id . clue ) ;
long position = clueSpinner . getSelectedItemPosition ( ) ;
if ( position < <num> || position >= clues . size ( ) ) {
return false ;
}
ClueData clueData = clues . get ( ( int ) position ) ;
String clue = clueData . getClueName ( ) ;
int passwordLength = clueData . getPasswordLength ( ) ;
Set < Character > alphabet = clueData . getAlphabet ( ) ;
String password = HashCalculator . getPassword ( masterPassword , clue , passwordLength , alphabet ) ;
passwordField . setText ( password ) ;
return true ;
}
public void <unk> ( View view ) {
if ( ! updateGeneratedPassword ( this , clues ) ) return ;
TextView passwordField = ( TextView ) findViewById ( R . id . password ) ;
String password = passwordField . getText ( ) . toString ( ) ;
ClipboardManager clipboard = ( ClipboardManager ) getSystemService ( CLIPBOARD_SERVICE ) ;
clipboard . setText ( password ) ;
}
@Override
protected void onPause ( ) {
super . onPause ( ) ;
EditText masterPasswordField = ( EditText ) findViewById ( R . id . master_password ) ;
masterPasswordField . setText ( " ) ;
}
}
package info . ilyaraz . passwordgenerator . util ;
public interface Closure {
void Run ( ) ;
}
package info . ilyaraz . passwordgenerator . util ;
public interface StringCallback {
void Run ( String value ) ;
}
package info . ilyaraz . passwordgenerator . util ;
public class Constants {
public static final String STORAGE_NAMESPACE = " ;
public static final String MASTER_HASH = " ;
public static final int MAX_PASSWORD_LENGTH = <num> ;
public static final String CLUES_PREFIX = " ;
}
package info . ilyaraz . passwordgenerator . util ;
import java . math . BigInteger ;
import java . security . MessageDigest ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Set ;
import java . util . TreeSet ;
import android . util . Base64 ;
public class HashCalculator {
public static String getPassword ( String masterPassword , String clue , int passwordLength , Set < Character > alphabet ) {
MessageDigest digest ;
try {
digest = MessageDigest . getInstance ( " ) ;
}
catch ( Exception e ) {
throw new RuntimeException ( e ) ;
}
digest . update ( masterPassword . getBytes ( ) ) ;
digest . update ( clue . getBytes ( ) ) ;
BigInteger num = BigInteger . ZERO ;
byte [ ] hash = digest . digest ( ) ;
for ( int i = <num> ; i < hash . length ; ++ i ) {
num = num . multiply ( BigInteger . valueOf ( <num> ) ) . add ( BigInteger . valueOf ( ( hash [ i ] >= <num> ) ? hash [ i ] : ( ( ( int ) hash [ i ] ) + <num> ) ) ) ;
}
List < Character > chars = new ArrayList < Character > ( new TreeSet < Character > ( alphabet ) ) ;
StringBuilder res = new StringBuilder ( ) ;
for ( int i = <num> ; i < passwordLength ; ++ i ) {
res . append ( chars . get ( num . mod ( BigInteger . valueOf ( chars . size ( ) ) ) . intValue ( ) ) ) ;
num = num . divide ( BigInteger . valueOf ( chars . size ( ) ) ) ;
}
return res . toString ( ) ;
}
public static String base64SHA512 ( String text ) {
MessageDigest digest ;
try {
digest = MessageDigest . getInstance ( " ) ;
}
catch ( Exception e ) {
throw new RuntimeException ( e ) ;
}
return Base64 . encodeToString ( digest . digest ( text . getBytes ( ) ) , Base64 . DEFAULT ) ;
}
}
package info . ilyaraz . passwordgenerator . util ;
public interface Callback1 < T > {
void Run ( T value ) ;
}
package info . ilyaraz . passwordgenerator ;
import info . ilyaraz . passwordgenerator . util . Closure ;
import info . ilyaraz . passwordgenerator . util . Constants ;
import info . ilyaraz . passwordgenerator . util . HashCalculator ;
import info . ilyaraz . passwordgenerator . util . StringCallback ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . content . <unk> ;
import android . content . DialogInterface ;
import android . content . SharedPreferences ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . widget . EditText ;
public class MasterPasswordEditor {
public static void editMasterPassword ( final Activity context , String caption , String text , final StringCallback onSuccess , final Closure onFailure ) {
final SharedPreferences settings = context . getSharedPreferences ( Constants . STORAGE_NAMESPACE , <num> ) ;
AlertDialog . Builder masterPasswordDialog = new AlertDialog . Builder ( context ) ;
masterPasswordDialog . setTitle ( caption ) ;
masterPasswordDialog . setCancelable ( false ) ;
LayoutInflater inflater = context . getLayoutInflater ( ) ;
final View dialogLayout = inflater . inflate ( R . layout . <unk> , null ) ;
masterPasswordDialog . setView ( dialogLayout ) ;
masterPasswordDialog . setPositiveButton ( " , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialog , int which ) {
EditText input = ( EditText ) dialogLayout . findViewById ( R . id . master_password ) ;
String value = input . getText ( ) . toString ( ) ;
value = HashCalculator . base64SHA512 ( value ) ;
settings . edit ( ) . putString ( Constants . MASTER_HASH , value ) . commit ( ) ;
onSuccess . Run ( value ) ;
}
} ) ;
masterPasswordDialog . setNegativeButton ( " , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialog , int which ) {
onFailure . Run ( ) ;
}
} ) ;
masterPasswordDialog . show ( ) ;
}
}
package info . ilyaraz . passwordgenerator . util ;
import java . io . ByteArrayInputStream ;
import java . io . ByteArrayOutputStream ;
import java . io . IOException ;
import java . io . ObjectInputStream ;
import java . io . ObjectOutputStream ;
import java . io . Serializable ;
import android . util . Base64 ;
public class ObjectSerializer {
public static String serialize ( Serializable object ) throws IOException {
ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ;
ObjectOutputStream oos = new ObjectOutputStream ( baos ) ;
oos . writeObject ( object ) ;
oos . close ( ) ;
return Base64 . encodeToString ( baos . toByteArray ( ) , Base64 . DEFAULT ) ;
}
public static Object deserialize ( String data ) throws IOException , ClassNotFoundException {
ByteArrayInputStream bais = new ByteArrayInputStream ( Base64 . decode ( data , Base64 . DEFAULT ) ) ;
ObjectInputStream ois = new ObjectInputStream ( bais ) ;
Object result ;
result = ois . readObject ( ) ;
ois . close ( ) ;
return result ;
}
}
package info . ilyaraz . passwordgenerator . domain ;
import java . io . Serializable ;
import java . util . Collection ;
import java . util . Collections ;
import java . util . HashSet ;
import java . util . Set ;
public class ClueData implements Serializable {
private static final long serialVersionUID =  <num> ;
public ClueData ( String id , String clueName , int passwordLength , Collection < Character > alphabet ) {
this . id = id ;
this . clueName = clueName ;
this . passwordLength = passwordLength ;
this . alphabet = new HashSet < Character > ( alphabet ) ;
}
private String id ;
private String clueName ;
private int passwordLength ;
private HashSet < Character > alphabet ;
public String getId ( ) {
return id ;
}
public String getClueName ( ) {
return clueName ;
}
public int getPasswordLength ( ) {
return passwordLength ;
}
public Set < Character > getAlphabet ( ) {
return Collections . unmodifiableSet ( alphabet ) ;
}
public String toString ( ) {
return clueName ;
}
}
package info . ilyaraz . passwordgenerator ;
import info . ilyaraz . passwordgenerator . domain . ClueData ;
import info . ilyaraz . passwordgenerator . util . Callback1 ;
import info . ilyaraz . passwordgenerator . util . Closure ;
import info . ilyaraz . passwordgenerator . util . Constants ;
import info . ilyaraz . passwordgenerator . util . ObjectSerializer ;
import java . io . IOException ;
import java . util . HashMap ;
import java . util . HashSet ;
import java . util . Map ;
import java . util . Set ;
import java . util . UUID ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
import android . content . SharedPreferences ;
import android . text . Editable ;
import android . text . TextWatcher ;
import android . util . Log ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . widget . EditText ;
import android . widget . Spinner ;
public class ClueEditor {
public static void editClue ( final String clueId , final Activity context , final Callback1 < ClueData > onSuccess , final Closure onFailure ) {
final SharedPreferences settings = context . getSharedPreferences ( Constants . STORAGE_NAMESPACE , <num> ) ;
LayoutInflater inflater = context . getLayoutInflater ( ) ;
final View dialogLayout = inflater . inflate ( R . layout . <unk> , null ) ;
AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ;
builder . setView ( dialogLayout ) ;
final EditText passwordLengthField = ( EditText ) dialogLayout . findViewById ( R . id . <unk> ) ;
final EditText clueNameField = ( EditText ) dialogLayout . findViewById ( R . id . clue ) ;
final Spinner alphabetField = ( Spinner ) dialogLayout . findViewById ( R . id . <unk> ) ;
if ( clueId != null ) {
String clueString = settings . getString ( Constants . CLUES_PREFIX + clueId , null ) ;
if ( clueString != null ) {
ClueData data = null ;
try {
data = ( ClueData ) ObjectSerializer . deserialize ( clueString ) ;
} catch ( Exception e ) {
}
if ( data != null ) {
passwordLengthField . setText ( Integer . toString ( data . getPasswordLength ( ) ) ) ;
clueNameField . setText ( data . getClueName ( ) ) ;
int index =  <num> ;
for ( int i = <num> ; i < <num> ; ++ i ) {
HashSet < Character > chars = new HashSet < Character > ( ) ;
populateAlphabet ( chars , i ) ;
if ( chars . equals ( data . getAlphabet ( ) ) ) {
index = i ;
break ;
}
}
if ( index ==  <num> ) {
throw new RuntimeException ( ) ;
}
alphabetField . setSelection ( index ) ;
}
}
}
builder . setPositiveButton ( " , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialog , int which ) {
String clueName = clueNameField . getText ( ) . toString ( ) ;
int passwordLength = Integer . parseInt ( passwordLengthField . getText ( ) . toString ( ) ) ;
if ( clueName . equals ( " ) || passwordLength > Constants . MAX_PASSWORD_LENGTH ) {
throw new RuntimeException ( " + passwordLength ) ;
}
HashSet < Character > alphabet = new HashSet < Character > ( ) ;
long alphabetID = alphabetField . getSelectedItemId ( ) ;
populateAlphabet ( alphabet , alphabetID ) ;
ClueData clue = new ClueData ( clueId == null ? getRandomId ( ) : clueId , clueName , passwordLength , alphabet ) ;
try {
settings . edit ( ) . putString ( Constants . CLUES_PREFIX + clue . getId ( ) , ObjectSerializer . serialize ( clue ) ) . commit ( ) ;
}
catch ( IOException e ) {
throw new RuntimeException ( e ) ;
}
onSuccess . Run ( clue ) ;
}
} ) ;
builder . setNegativeButton ( " , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( DialogInterface dialog , int which ) {
onFailure . Run ( ) ;
}
} ) ;
builder . setCancelable ( false ) ;
final AlertDialog dialog = builder . create ( ) ;
TextWatcher textWatcher = new TextWatcher ( ) {
@Override
public void onTextChanged ( CharSequence s , int start , int before , int count ) {
updateOkState ( dialog , passwordLengthField , clueNameField ) ;
}
@Override
public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { }
@Override
public void afterTextChanged ( Editable s ) { }
} ;
passwordLengthField . addTextChangedListener ( textWatcher ) ;
clueNameField . addTextChangedListener ( textWatcher ) ;
dialog . setOnShowListener ( new DialogInterface . OnShowListener ( ) {
@Override
public void onShow ( DialogInterface dialogInterface ) {
updateOkState ( dialog , passwordLengthField , clueNameField ) ;
}
} ) ;
dialog . show ( ) ;
}
private static String getRandomId ( ) {
return UUID . randomUUID ( ) . toString ( ) ;
}
private static void updateOkState ( final AlertDialog dialog , final EditText passwordLengthField , EditText clueNameField ) {
boolean ok = true ;
try {
int passwordLength = Integer . parseInt ( passwordLengthField . getText ( ) . toString ( ) ) ;
if ( passwordLength > Constants . MAX_PASSWORD_LENGTH ) {
ok = false ;
}
if ( clueNameField . getText ( ) . toString ( ) . equals ( " ) ) {
ok = false ;
}
} catch ( Throwable e ) {
ok = false ;
}
dialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setEnabled ( ok ) ;
}
private static void populateAlphabet ( HashSet < Character > alphabet ,
long alphabetID ) {
if ( alphabetID == <num> ) {
for ( int c = <num> ; c < <num> ; ++ c ) {
alphabet . add ( ( char ) c ) ;
}
}
else {
for ( char c = A' ; c <= Z' ; ++ c ) {
alphabet . add ( c ) ;
}
for ( char c = a' ; c <= z' ; ++ c ) {
alphabet . add ( c ) ;
}
for ( char c = <num>  ; c <= <num>  ; ++ c ) {
alphabet . add ( c ) ;
}
}
}
}
package info . ilyaraz . passwordgenerator . ui ;
import info . ilyaraz . passwordgenerator . R ;
import info . ilyaraz . passwordgenerator . util . Callback1 ;
import info . ilyaraz . passwordgenerator . util . StringCallback ;
import java . util . ArrayList ;
import android . app . Activity ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . BaseAdapter ;
import android . widget . ImageButton ;
import android . widget . ImageView ;
import android . widget . SpinnerAdapter ;
import android . widget . TextView ;
public class ClueAdapter extends BaseAdapter implements SpinnerAdapter {
private ArrayList < String > items = new ArrayList < String > ( ) ;
private ArrayList < String > itemIds = new ArrayList < String > ( ) ;
private Activity activity ;
private final StringCallback onEditClue ;
private final StringCallback onRemoveClue ;
private final Callback1 < Integer > onClick ;
public ClueAdapter ( ArrayList < String > items , ArrayList < String > itemIds , Activity activity , StringCallback editClue , StringCallback removeClue , Callback1 < Integer > onClick ) {
this . items = new ArrayList < String > ( items ) ;
this . itemIds = new ArrayList < String > ( itemIds ) ;
this . activity = activity ;
this . onEditClue = editClue ;
this . onRemoveClue = removeClue ;
this . onClick = onClick ;
}
@Override
public int getCount ( ) {
return items . size ( ) ;
}
@Override
public Object getItem ( int arg0 ) {
return items . get ( arg0 ) ;
}
@Override
public long getItemId ( int arg0 ) {
return arg0 ;
}
@Override
public View getView ( int arg0 , View arg1 , ViewGroup arg2 ) {
final String clueId = itemIds . get ( arg0 ) ;
final LayoutInflater inflater = activity . getLayoutInflater ( ) ;
View entry = arg1 ;
if ( entry == null ) {
entry = inflater . inflate ( R . layout . <unk> , null ) ;
}
final View spinnerEntry = entry ;
final TextView clueName = ( TextView ) spinnerEntry . findViewById ( R . id . <unk> ) ;
final ImageView editClue = ( ImageView ) spinnerEntry . findViewById ( R . id . <unk> ) ;
final ImageView removeClue = ( ImageView ) spinnerEntry . findViewById ( R . id . <unk> ) ;
final int index = arg0 ;
clueName . setText ( items . get ( arg0 ) ) ;
editClue . setOnClickListener ( new View . OnClickListener ( ) {
@Override
public void onClick ( View v ) {
onEditClue . Run ( clueId ) ;
}
} ) ;
removeClue . setOnClickListener ( new View . OnClickListener ( ) {
@Override
public void onClick ( View v ) {
onRemoveClue . Run ( clueId ) ;
}
} ) ;
return spinnerEntry ;
}
@Override
public View getDropDownView ( int position , View convertView , ViewGroup parent ) {
return getView ( position , convertView , parent ) ;
}
}
package org . itea . neotiq . devicemodel ;
import org . itea . neotiq . application . CustomApplication ;
import java . util . ArrayList ;
import java . util . Collection ;
import java . util . HashMap ;
import java . util . Map ;
public abstract class VirtualDevice extends Device {
protected static Map < String , String > subclasses ;
private static Collection < VirtualDevice > instantiatedVirtualDevices = new ArrayList < VirtualDevice > ( ) ;
protected static String uiElementName ;
public static Collection < String > getVirtualDeviceTypes ( ) {
if ( VirtualDevice . subclasses == null ) {
VirtualDevice . subclasses = new HashMap < String , String > ( ) ;
VirtualDevice . subclasses . put ( " , " ) ;
VirtualDevice . subclasses . put ( " , " ) ;
VirtualDevice . subclasses . put ( " , " ) ;
VirtualDevice . subclasses . put ( " , " ) ;
}
return VirtualDevice . subclasses . keySet ( ) ;
}
public static Collection < VirtualDevice > getInstantiatedVirtualDevices ( ) {
return VirtualDevice . instantiatedVirtualDevices ;
}
public static void addDevice ( String text , String name ) {
String className = VirtualDevice . subclasses . get ( text ) ;
try {
VirtualDevice vd = ( VirtualDevice ) Class . forName ( className ) . newInstance ( ) ;
vd . setName ( name ) ;
if ( " . equals ( text ) ) {
( ( VDEditText ) vd ) . setInt ( true ) ;
}
vd . setDelegate ( CustomApplication . getDefaultDelegate ( ) ) ;
} catch ( ClassNotFoundException e ) {
e . printStackTrace ( ) ;
} catch ( IllegalAccessException e ) {
e . printStackTrace ( ) ;
} catch ( InstantiationException e ) {
e . printStackTrace ( ) ;
}
}
protected VirtualDevice ( ) {
super ( ) ;
instantiatedVirtualDevices . add ( this ) ;
}
public static String <unk> ( ) {
return uiElementName ;
}
}
package org . itea . neotiq . devicemodel ;
import org . itea . neotiq . devicemodel . DeviceManager . EventType ;
import java . util . EventObject ;
import java . util . HashMap ;
import java . util . Map ;
public class DeviceEvent extends EventObject {
private static final long serialVersionUID =  <num> ;
private DeviceManager . EventType eventType ;
private Map < String , Object > parameters ;
public DeviceEvent ( Device source , DeviceManager . EventType eventType ) {
super ( source ) ;
this . setEventType ( eventType ) ;
this . parameters = new HashMap < String , Object > ( ) ;
}
public void setParameter ( String key , Object value ) {
this . parameters . put ( key , value ) ;
}
public Object getParameters ( String key ) {
return parameters . get ( key ) ;
}
public void setEventType ( DeviceManager . EventType eventType ) {
this . eventType = eventType ;
}
public DeviceManager . EventType getEventType ( ) {
return eventType ;
}
@Override
public String toString ( ) {
String params = " ;
for ( String key : parameters . keySet ( ) ) {
params += key + " + parameters . get ( key ) + " ;
}
params += " ;
return " + this . source . getClass ( ) . toString ( ) + " + this . eventType + " + params ;
}
public String asXML ( ) {
StringBuilder l_sb = new StringBuilder ( ) ;
l_sb . append ( " ) ;
if ( this . source instanceof VDEditText && ( ( VDEditText ) this . source ) . isInt ( ) ) {
l_sb . append ( " ) ;
} else {
l_sb . append ( " ) ;
}
l_sb . append ( " ) ;
if ( this . eventType == EventType . EVT_ON_CLICK ) {
l_sb . append ( " ) ;
} else {
l_sb . append ( ( ( RequestableDevice ) this . source ) . getCurrentValue ( ) . toString ( ) ) ;
}
l_sb . append ( " ) ;
return l_sb . toString ( ) ;
}
}
package org . itea . neotiq . devicemodel ;
import org . itea . neotiq . application . CustomApplication ;
import org . itea . neotiq . devicemodel . DeviceManager . EventType ;
import android . text . Editable ;
import android . text . InputType ;
import android . text . TextWatcher ;
import android . util . Log ;
import android . widget . EditText ;
import java . util . ArrayList ;
import java . util . Collection ;
public class VDEditText extends VirtualDevice implements RequestableDevice {
@SuppressWarnings("unused")
private static final String uiElementName = " ;
private static Collection < VDEditText > instantiatedButtons = new ArrayList < VDEditText > ( ) ;
private TextWatcher tw ;
private boolean isInt = false ;
public VDEditText ( ) {
this . uiElement = new EditText ( CustomApplication . getAppContext ( ) ) ;
( ( EditText ) this . uiElement ) . addTextChangedListener ( this . getTextWatcher ( ) ) ;
instantiatedButtons . add ( this ) ;
}
@Override
public void setName ( String name ) {
super . setName ( name ) ;
if ( this . isInt ( ) ) {
( ( EditText ) this . uiElement ) . setText ( " ) ;
} else {
( ( EditText ) this . uiElement ) . setText ( name ) ;
}
}
public void setInt ( boolean isInt ) {
this . isInt = isInt ;
( ( EditText ) this . uiElement ) . setInputType ( InputType . TYPE_CLASS_NUMBER ) ;
( ( EditText ) this . uiElement ) . setText ( " ) ;
}
public boolean isInt ( ) {
return isInt ;
}
private TextWatcher getTextWatcher ( ) {
if ( tw == null ) {
tw = new TextWatcher ( ) {
public void onTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) {
}
public void beforeTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) {
}
public void afterTextChanged ( Editable arg0 ) {
VDEditText . afterTextChanged ( arg0 ) ;
}
} ;
}
return tw ;
}
protected static void afterTextChanged ( Editable arg0 ) {
for ( VDEditText btn : VDEditText . instantiatedButtons ) {
EditText view = ( EditText ) btn . getView ( ) ;
if ( view . getText ( ) == arg0 ) {
DeviceEvent de = new DeviceEvent ( btn , EventType . EVT_TXT_CHANGED ) ;
de . setParameter ( " , arg0 . toString ( ) ) ;
btn . sendEvent ( de ) ;
return ;
}
}
Log . e ( " , " ) ;
}
public String getCurrentValue ( ) {
return ( ( EditText ) this . uiElement ) . getText ( ) . toString ( ) ;
}
@Override
public String getSemanticAnnotation ( ) {
return this . isInt ( ) ? " : " ;
}
}
package org . itea . neotiq . xmpp ;
import org . apache . http . HttpResponse ;
import org . apache . http . ParseException ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . client . methods . HttpPost ;
import org . apache . http . entity . StringEntity ;
import org . apache . http . impl . client . DefaultHttpClient ;
import org . apache . http . util . EntityUtils ;
import org . itea . neotiq . devicemodel . Device ;
import org . itea . neotiq . devicemodel . DeviceManager ;
import org . itea . neotiq . devicemodel . VDEditText ;
import org . xmlpull . v1 . XmlSerializer ;
import android . util . Log ;
import android . util . Xml ;
import java . io . IOException ;
import java . io . StringWriter ;
import java . io . UnsupportedEncodingException ;
public class XmlDescription {
private static final String WS_URL = " ;
private static final String WS_ADD_QUERY = " ;
public static String generateXML ( ) {
XmlSerializer serializer = Xml . <unk> ( ) ;
String id = " ;
StringWriter writer = new StringWriter ( ) ;
try {
serializer . setOutput ( writer ) ;
serializer . startDocument ( " , true ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , id ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , id ) ;
serializer . attribute ( " , " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
for ( Device d : DeviceManager . getDevices ( ) ) {
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , d . getName ( ) . replace ( " , " ) + " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , d . getSemanticAnnotation ( ) ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , ( d instanceof VDEditText && ( ( VDEditText ) d ) . isInt ( ) ) ? " : " ) ;
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , d . getName ( ) . replace ( " , " ) + " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , d . getClass ( ) . getName ( ) ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , ( d instanceof VDEditText && ( ( VDEditText ) d ) . isInt ( ) ) ? " : " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
}
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . startTag ( " , " ) ;
for ( Device d : DeviceManager . getDevices ( ) ) {
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " + XMPPComm . XMPP_HOST + " + ( ( XMPPComm ) d . getDelegate ( ) ) . XMPP_NODE ) ;
serializer . attribute ( " , " , d . getName ( ) . replace ( " , " ) + " ) ;
serializer . endTag ( " , " ) ;
}
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , XMPPComm . getInstance ( ) . XMPP_JID + " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . startTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , XMPPComm . getInstance ( ) . XMPP_JID + " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . startTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
for ( Device d : DeviceManager . getDevices ( ) ) {
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , d . getName ( ) . replace ( " , " ) + " ) ;
serializer . attribute ( " , " , ( ( XMPPComm ) d . getDelegate ( ) ) . XMPP_JID + " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , d . getName ( ) . replace ( " , " ) + " ) ;
serializer . startTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . startTag ( " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . attribute ( " , " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
}
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endTag ( " , " ) ;
serializer . endDocument ( ) ;
} catch ( IllegalArgumentException e ) {
e . printStackTrace ( ) ;
} catch ( IllegalStateException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
Log . d ( " , writer . toString ( ) ) ;
return writer . toString ( ) ;
}
public static void sendToGlobalRepo ( ) {
DefaultHttpClient httpclient = new DefaultHttpClient ( ) ;
HttpPost request = new HttpPost ( WS_URL + " + WS_ADD_QUERY + " + XMPPComm . getInstance ( ) . XMPP_JID ) ;
try {
request . setEntity ( new StringEntity ( generateXML ( ) ) ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
}
request . setHeader ( " , " ) ;
HttpResponse result = null ;
try {
result = httpclient . execute ( request ) ;
} catch ( ClientProtocolException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
try {
Log . d ( " , result . toString ( ) ) ;
if ( result . getStatusLine ( ) . getStatusCode ( ) == <num> ) {
Log . d ( " , " ) ;
} else {
Log . d ( " , " + EntityUtils . toString ( result . getEntity ( ) ) ) ;
}
} catch ( ParseException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
httpclient . getConnectionManager ( ) . shutdown ( ) ;
}
}
package org . itea . neotiq . xmpp ;
import org . itea . neotiq . devicemodel . Device ;
import org . itea . neotiq . devicemodel . DeviceDelegate ;
import org . itea . neotiq . devicemodel . DeviceEvent ;
import org . jivesoftware . smack . AccountManager ;
import org . jivesoftware . smack . ConnectionConfiguration ;
import org . jivesoftware . smack . PacketListener ;
import org . jivesoftware . smack . SmackConfiguration ;
import org . jivesoftware . smack . XMPPConnection ;
import org . jivesoftware . smack . XMPPException ;
import org . jivesoftware . smack . filter . PacketFilter ;
import org . jivesoftware . smack . packet . Packet ;
import org . jivesoftware . smack . packet . Presence ;
import org . jivesoftware . smack . provider . ProviderManager ;
import org . jivesoftware . smackx . pubsub . AccessModel ;
import org . jivesoftware . smackx . pubsub . ConfigureForm ;
import org . jivesoftware . smackx . pubsub . FormType ;
import org . jivesoftware . smackx . pubsub . LeafNode ;
import org . jivesoftware . smackx . pubsub . NodeType ;
import org . jivesoftware . smackx . pubsub . PayloadItem ;
import org . jivesoftware . smackx . pubsub . PubSubManager ;
import org . jivesoftware . smackx . pubsub . PublishModel ;
import org . jivesoftware . smackx . pubsub . SimplePayload ;
import android . util . Log ;
public class XMPPComm implements DeviceDelegate , PacketListener , PacketFilter {
private static final String TAG = " ;
protected static final String PREFIX = " ;
protected static final String XMPP_HOST = " ;
protected static final int XMPP_PORT = <num> ;
private static final String XMPP_SERVICE_NAME = " ;
private static final String XMPP_SERVICE_LOGIN = PREFIX + " ;
private static final String XMPP_SERVICE_PASSWORD = PREFIX + " ;
private static final String XMPP_PS_NS = " ;
private static final Object DEMO_NAME = " ;
private static XMPPComm mInstance ;
private static ConnectionConfiguration XMPP_CONFIG ;
private String XMPP_LOGIN ;
protected String XMPP_JID ;
protected String XMPP_NODE ;
private String XMPP_PASSWORD ;
private Device mDevice ;
private XMPPConnection mXMPPConn ;
private PubSubManager mPSMgr ;
private XMPPComm ( Device d ) {
this . mDevice = d ;
XMPPConnection . <unk> = true ;
SmackConfiguration . <unk> ( <num> ) ;
if ( this . mDevice == null ) {
this . XMPP_LOGIN = XMPP_SERVICE_LOGIN ;
this . XMPP_PASSWORD = XMPP_SERVICE_PASSWORD ;
} else {
this . XMPP_LOGIN = PREFIX + d . getName ( ) . replace ( " , " ) ;
this . XMPP_NODE = PREFIX + d . getName ( ) . replace ( " , " ) ;
this . XMPP_PASSWORD = PREFIX + d . getName ( ) . replace ( " , " ) ;
}
this . XMPP_JID = XMPP_LOGIN + " + XMPP_SERVICE_NAME ;
XMPP_CONFIG = new ConnectionConfiguration ( XMPP_HOST , XMPP_PORT , XMPP_SERVICE_NAME ) ;
try {
this . initiateConnection ( ) ;
} catch ( XMPPException e ) {
e . printStackTrace ( ) ;
}
}
public static XMPPComm getInstance ( ) {
if ( mInstance == null ) {
ProviderManager . getInstance ( ) . addIQProvider ( " , XmppRest . NAMESPACE ,
new XmppRest . Provider ( ) ) ;
ProviderManager . getInstance ( ) . addIQProvider ( " , XmppRest . NAMESPACE ,
new XmppRest . Provider ( ) ) ;
mInstance = new XMPPComm ( null ) ;
}
return mInstance ;
}
private void initiateConnection ( ) throws XMPPException {
if ( mXMPPConn == null || ! mXMPPConn . isConnected ( ) ) {
mXMPPConn = new XMPPConnection ( XMPP_CONFIG ) ;
Log . d ( TAG , " ) ;
mXMPPConn . connect ( ) ;
}
Log . d ( TAG , " + XMPP_LOGIN + " + XMPP_PASSWORD ) ;
try {
mXMPPConn . login ( XMPP_LOGIN , XMPP_PASSWORD ) ;
} catch ( XMPPException e ) {
Log . d ( TAG , " ) ;
AccountManager am = new AccountManager ( mXMPPConn ) ;
am . <unk> ( XMPP_LOGIN , XMPP_PASSWORD ) ;
Log . d ( TAG , " ) ;
mXMPPConn . login ( XMPP_JID , XMPP_PASSWORD ) ;
}
Log . d ( TAG , " + mXMPPConn . getUser ( ) ) ;
Log . d ( TAG , " ) ;
Presence presence = new Presence ( Presence . Type . available ) ;
mXMPPConn . sendPacket ( presence ) ;
if ( this . mDevice != null ) {
mPSMgr = new PubSubManager ( mXMPPConn , " + XMPP_SERVICE_NAME ) ;
ConfigureForm f = new ConfigureForm ( FormType . submit ) ;
f . <unk> ( true ) ;
f . <unk> ( true ) ;
f . <unk> ( AccessModel . open ) ;
f . <unk> ( PublishModel . open ) ;
f . <unk> ( true ) ;
f . setNodeType ( NodeType . leaf ) ;
Log . d ( TAG , " + XMPP_NODE ) ;
try {
mPSMgr . createNode ( XMPP_NODE , f ) ;
} catch ( XMPPException e ) {
mPSMgr . deleteNode ( XMPP_NODE ) ;
mPSMgr . createNode ( XMPP_NODE , f ) ;
}
Log . d ( TAG , " + XMPP_NODE + " ) ;
} else {
Log . d ( TAG , " ) ;
mXMPPConn . addPacketListener ( this , this ) ;
}
}
public void eventOccured ( DeviceEvent de ) {
Log . d ( TAG , " + de . toString ( ) ) ;
if ( mDevice != null ) {
try {
LeafNode node = ( LeafNode ) mPSMgr . getNode ( XMPP_NODE ) ;
node . send ( getItemForEvent ( de ) ) ;
} catch ( XMPPException e ) {
e . printStackTrace ( ) ;
}
if ( mDevice . getName ( ) . equals ( DEMO_NAME ) ) {
}
}
}
private PayloadItem < SimplePayload > getItemForEvent ( DeviceEvent de ) {
String deviceName = ( ( Device ) de . getSource ( ) ) . getName ( ) ;
PayloadItem < SimplePayload > retItem = new PayloadItem < SimplePayload > ( deviceName
+ System . currentTimeMillis ( ) , new SimplePayload ( deviceName ,
XMPP_PS_NS + deviceName , de . asXML ( ) ) ) ;
return retItem ;
}
public void deviceCreated ( Device d ) {
Log . d ( TAG , " + d ) ;
if ( mDevice == null ) {
d . setDelegate ( new XMPPComm ( d ) ) ;
XmlDescription . sendToGlobalRepo ( ) ;
return ;
}
}
@Override
protected void finalize ( ) throws Throwable {
mXMPPConn . disconnect ( ) ;
super . finalize ( ) ;
}
public boolean accept ( Packet packet ) {
return ( packet instanceof XmppRest ) ;
}
public void processPacket ( Packet packet ) {
try {
XmppRest respIq = RestDevices . treatResponse ( ( XmppRest ) packet ) ;
mXMPPConn . sendPacket ( respIq ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
}
package org . itea . neotiq ;
public final class R {
public static final class attr {
}
public static final class drawable {
public static final int icon = <num> ;
}
public static final class id {
public static final int btnAddDevice = <num> ;
public static final int btnOk = <num> ;
public static final int devicesView = <num> ;
public static final int <unk> = <num> ;
public static final int spnDevice = <num> ;
public static final int txtDevice = <num> ;
}
public static final class layout {
public static final int device_adder = <num> ;
public static final int list_item = <num> ;
public static final int main = <num> ;
}
public static final class string {
public static final int app_name = <num> ;
public static final int hello = <num> ;
}
}
package org . itea . neotiq . application ;
import org . itea . neotiq . devicemodel . Device ;
import org . itea . neotiq . devicemodel . DeviceDelegate ;
import org . itea . neotiq . devicemodel . DeviceEvent ;
import android . util . Log ;
public class <unk> implements DeviceDelegate {
public void eventOccured ( DeviceEvent de ) {
Log . d ( " , " + de . toString ( ) ) ;
}
public void deviceCreated ( Device d ) {
Log . d ( " , " + d . getName ( ) ) ;
}
}
package org . itea . neotiq . xmpp ;
import org . itea . neotiq . devicemodel . DeviceToCreate ;
import org . xml . sax . Attributes ;
import org . xml . sax . ContentHandler ;
import org . xml . sax . Locator ;
import org . xml . sax . SAXException ;
import android . util . Log ;
public class DeviceContentHandler implements ContentHandler {
private DeviceToCreate d ;
public DeviceContentHandler ( ) {
super ( ) ;
}
public void characters ( char [ ] ch , int start , int length ) throws SAXException {
Log . d ( " , " + String . valueOf ( ch ) + " + start + " + length ) ;
}
public void endDocument ( ) throws SAXException {
Log . d ( " , " ) ;
}
public void endElement ( String uri , String localName , String qName ) throws SAXException {
Log . d ( " , " + uri + " + localName + " + qName ) ;
}
public void endPrefixMapping ( String prefix ) throws SAXException {
Log . d ( " , prefix ) ;
}
public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException {
Log . d ( " , " + String . valueOf ( ch ) + " + start + " + length ) ;
}
public void processingInstruction ( String target , String data ) throws SAXException {
Log . d ( " , " + target + " + data ) ;
}
public void setDocumentLocator ( Locator locator ) {
Log . d ( " , locator . toString ( ) ) ;
}
public void skippedEntity ( String name ) throws SAXException {
Log . d ( " , name ) ;
}
public void startDocument ( ) throws SAXException {
Log . d ( " , " ) ;
}
public void startElement ( String uri , String localName , String qName , Attributes atts )
throws SAXException {
Log . d ( " , " + uri + " + localName + " + qName + " + atts ) ;
d = new DeviceToCreate ( ) ;
d . setName ( atts . getValue ( " ) ) ;
d . setType ( atts . getValue ( " ) ) ;
}
public void startPrefixMapping ( String prefix , String uri ) throws SAXException {
Log . d ( " , " + prefix + " + uri ) ;
}
public DeviceToCreate getParsedData ( ) {
return d ;
}
}
package org . itea . neotiq . devicemodel ;
import org . itea . neotiq . application . CustomApplication ;
import org . itea . neotiq . devicemodel . DeviceManager . EventType ;
import android . util . Log ;
import android . view . View ;
import android . widget . Button ;
import java . util . ArrayList ;
import java . util . Collection ;
public class VDButton extends VirtualDevice {
@SuppressWarnings("unused")
private static final String uiElementName = " ;
private static Collection < VDButton > instantiatedButtons = new ArrayList < VDButton > ( ) ;
private View . OnClickListener ocl ;
public VDButton ( ) {
this . uiElement = new Button ( CustomApplication . getAppContext ( ) ) ;
( ( Button ) this . uiElement ) . setOnClickListener ( this . getOcl ( ) ) ;
instantiatedButtons . add ( this ) ;
}
@Override
public void setName ( String name ) {
super . setName ( name ) ;
( ( Button ) this . uiElement ) . setText ( name ) ;
}
public View . OnClickListener getOcl ( ) {
if ( ocl == null ) {
ocl = new View . OnClickListener ( ) {
public void onClick ( View arg0 ) {
VDButton . onClickOccured ( arg0 ) ;
}
} ;
}
return ocl ;
}
protected static void onClickOccured ( View arg0 ) {
for ( VDButton btn : VDButton . instantiatedButtons ) {
if ( btn . getView ( ) == arg0 ) {
DeviceEvent de = new DeviceEvent ( btn , EventType . EVT_ON_CLICK ) ;
btn . sendEvent ( de ) ;
return ;
}
}
Log . e ( " , " ) ;
}
@Override
public String getSemanticAnnotation ( ) {
return " ;
}
}
package org . itea . neotiq . devicemodel ;
public class DeviceToCreate {
private String name ;
private String type ;
public void setName ( String name ) {
this . name = name ;
}
public void setType ( String type ) {
this . type = type ;
}
public String getName ( ) {
return this . name ;
}
public String getType ( ) {
return this . type ;
}
}
package org . itea . neotiq . xmpp ;
import org . itea . neotiq . devicemodel . Device ;
import org . itea . neotiq . devicemodel . DeviceManager ;
import org . itea . neotiq . devicemodel . DeviceNotFoundException ;
import org . itea . neotiq . devicemodel . DeviceNotSupportedException ;
import org . itea . neotiq . devicemodel . DeviceToCreate ;
import org . itea . neotiq . devicemodel . RequestableDevice ;
import org . json . JSONArray ;
import org . json . JSONException ;
import org . json . JSONObject ;
import org . xml . sax . InputSource ;
import org . xml . sax . SAXException ;
import org . xml . sax . XMLReader ;
import android . util . Log ;
import java . io . IOException ;
import java . io . StringReader ;
import java . lang . reflect . Method ;
import javax . xml . parsers . ParserConfigurationException ;
import javax . xml . parsers . SAXParser ;
import javax . xml . parsers . SAXParserFactory ;
public class RestDevices {
private static final String TAG = " ;
public static XmppRest treatResponse ( XmppRest xPacket ) {
try {
Class < RestDevices > c = RestDevices . class ;
String restMethod = xPacket . getMethod ( ) . toLowerCase ( )
+ toCamelCaseStripSlashes ( xPacket . getResource ( ) ) ;
Class < ? > [ ] parTypes = new Class < ? > [ <num> ] ;
parTypes [ <num> ] = XmppRest . class ;
Method m = c . getDeclaredMethod ( restMethod , parTypes ) ;
XmppRest iq = ( XmppRest ) m . invoke ( null , xPacket ) ;
return iq ;
} catch ( Exception e ) {
try {
return RestDevices . otherServiceMethod ( xPacket ) ;
} catch ( Exception e1 ) {
e1 . printStackTrace ( ) ;
return unavailableMethodIq ( xPacket ) ;
}
}
}
private static String toCamelCaseStripSlashes ( String s ) {
String [ ] parts = s . split ( " ) ;
String camelCaseString = " ;
for ( String part : parts ) {
camelCaseString = camelCaseString + toProperCase ( part ) ;
}
return camelCaseString ;
}
private static String toProperCase ( String s ) {
if ( ! s . equals ( " ) ) {
return s . substring ( <num> , <num> ) . toUpperCase ( ) + s . substring ( <num> ) . toLowerCase ( ) ;
}
return " ;
}
private static XmppRest unavailableMethodIq ( XmppRest xPacket ) {
XmppRest iq = new XmppRest ( ) ;
iq . setTo ( xPacket . getFrom ( ) ) ;
iq . setPacketID ( xPacket . getPacketID ( ) ) ;
iq . setResult ( <num> , " ) ;
return iq ;
}
private static XmppRest otherServiceMethod ( XmppRest xPacket ) throws Exception {
String [ ] parts = xPacket . getResource ( ) . split ( " ) ;
try {
Device d = DeviceManager . getDeviceNamed ( parts [ <num> ] ) ;
if ( xPacket . getMethod ( ) . equals ( " ) ) {
return getDevice ( d , xPacket ) ;
} else if ( xPacket . getMethod ( ) . equals ( " ) ) {
return postDevice ( d , xPacket ) ;
} else {
return unavailableMethodIq ( xPacket ) ;
}
} catch ( DeviceNotFoundException e ) {
return deviceNotFoundIq ( xPacket , parts [ <num> ] ) ;
}
}
private static XmppRest deviceNotFoundIq ( XmppRest xPacket , String string ) {
XmppRest iq = new XmppRest ( ) ;
iq . setTo ( xPacket . getFrom ( ) ) ;
iq . setPacketID ( xPacket . getPacketID ( ) ) ;
iq . setResult ( <num> , " + string + " ) ;
return iq ;
}
private static XmppRest postDevice ( Device d , XmppRest xPacket ) {
return unavailableMethodIq ( xPacket ) ;
}
private static XmppRest getDevice ( Device d , XmppRest xPacket ) throws Exception {
String [ ] parts = xPacket . getResource ( ) . split ( " ) ;
if ( parts [ <num> ] . toLowerCase ( ) . equals ( " ) && ( d instanceof RequestableDevice ) ) {
XmppRest iq = getDefaultOkIq ( xPacket ) ;
iq . getHeaders ( ) . put ( " , " ) ;
iq . setBody ( ( ( RequestableDevice ) d ) . getCurrentValue ( ) ) ;
return iq ;
}
return unavailableMethodIq ( xPacket ) ;
}
@SuppressWarnings("unused")
private static XmppRest <unk> ( XmppRest xPacket ) {
XmppRest iq = new XmppRest ( ) ;
iq . getHeaders ( ) . put ( " , " ) ;
iq . setBody ( " ) ;
return iq ;
}
@SuppressWarnings("unused")
private static XmppRest postDevice ( XmppRest xPacket ) {
Log . d ( TAG , " ) ;
SAXParserFactory spf = SAXParserFactory . newInstance ( ) ;
SAXParser sp = null ;
try {
sp = spf . newSAXParser ( ) ;
} catch ( ParserConfigurationException e ) {
e . printStackTrace ( ) ;
} catch ( SAXException e ) {
e . printStackTrace ( ) ;
}
XMLReader xr = null ;
try {
xr = sp . getXMLReader ( ) ;
} catch ( SAXException e ) {
e . printStackTrace ( ) ;
}
DeviceContentHandler myExampleHandler = new DeviceContentHandler ( ) ;
xr . setContentHandler ( myExampleHandler ) ;
InputSource inputSource = new InputSource ( ) ;
inputSource . setEncoding ( " ) ;
inputSource . setCharacterStream ( new StringReader ( xPacket . getBody ( ) ) ) ;
try {
xr . parse ( inputSource ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
} catch ( SAXException e ) {
e . printStackTrace ( ) ;
}
DeviceToCreate d = myExampleHandler . getParsedData ( ) ;
Log . d ( TAG , " + d . getName ( ) + " + d . getType ( ) ) ;
try {
DeviceManager . addDevice ( d . getType ( ) , d . getName ( ) ) ;
} catch ( DeviceNotSupportedException e ) {
XmppRest iq = new XmppRest ( ) ;
iq . setTo ( xPacket . getFrom ( ) ) ;
iq . setPacketID ( xPacket . getPacketID ( ) ) ;
iq . setResult ( <num> , " ) ;
return iq ;
}
XmppRest iq = getDefaultOkIq ( xPacket ) ;
iq . getHeaders ( ) . put ( " , " ) ;
iq . setBody ( " ) ;
return iq ;
}
@SuppressWarnings("unused")
private static XmppRest <unk> ( XmppRest xPacket ) {
Log . d ( TAG , " ) ;
XmppRest iq = getDefaultOkIq ( xPacket ) ;
if ( DeviceManager . getDevices ( ) . size ( ) == <num> ) {
iq . getHeaders ( ) . put ( " , " ) ;
iq . setBody ( " ) ;
} else {
if ( " . equals ( xPacket . getBody ( ) ) ) {
iq . getHeaders ( ) . put ( " , " ) ;
iq . setBody ( XmlDescription . generateXML ( ) ) ;
} else {
JSONArray jsArray = new JSONArray ( ) ;
for ( Device d : DeviceManager . getDevices ( ) ) {
JSONObject device = new JSONObject ( ) ;
try {
device . put ( " , d . getName ( ) ) ;
device . put ( " , d . getClass ( ) . getName ( ) ) ;
device . put ( " , XMPPComm . PREFIX + d . getName ( ) ) ;
device . put ( " , XMPPComm . PREFIX + d . getName ( ) ) ;
} catch ( JSONException e ) {
e . printStackTrace ( ) ;
}
jsArray . put ( device ) ;
}
iq . getHeaders ( ) . put ( " , " ) ;
iq . setBody ( jsArray . toString ( ) ) ;
}
}
return iq ;
}
private static XmppRest getDefaultOkIq ( XmppRest xPacket ) {
XmppRest iq = new XmppRest ( ) ;
iq . setTo ( xPacket . getFrom ( ) ) ;
iq . setPacketID ( xPacket . getPacketID ( ) ) ;
iq . setResult ( <num> , " ) ;
return iq ;
}
}
package org . itea . neotiq . devicemodel ;
import org . itea . neotiq . application . CustomApplication ;
import org . itea . neotiq . devicemodel . DeviceManager . EventType ;
import android . content . Context ;
import android . hardware . Sensor ;
import android . hardware . SensorEvent ;
import android . hardware . SensorEventListener ;
import android . hardware . SensorManager ;
import android . widget . TextView ;
import java . util . ArrayList ;
import java . util . Arrays ;
import java . util . Collection ;
public class InternalDevice extends Device implements SensorEventListener , RequestableDevice {
private static final EventType EVT_VALUES_CHANGED = null ;
private static Collection < String > subclasses ;
private static Collection < InternalDevice > instantiatedInternalDevices = new ArrayList < InternalDevice > ( ) ;
private static SensorManager mSensorManager ;
private Sensor mSensor ;
private float [ ] lastValues ;
private long lastChange = <num> ;
public static Collection < String > getInternalDeviceTypes ( ) {
if ( InternalDevice . subclasses == null ) {
InternalDevice . subclasses = new ArrayList < String > ( ) ;
if ( ! " . equals ( android . os . Build . MODEL ) ) {
mSensorManager = ( SensorManager ) CustomApplication . getAppContext ( ) . getSystemService (
Context . SENSOR_SERVICE ) ;
for ( Sensor s : mSensorManager . getSensorList ( Sensor . TYPE_ALL ) ) {
InternalDevice . subclasses . add ( s . getName ( ) ) ;
}
}
}
return InternalDevice . subclasses ;
}
public static Collection < InternalDevice > getInstantiatedInternalDevices ( ) {
return InternalDevice . instantiatedInternalDevices ;
}
protected InternalDevice ( String name , String sensor ) {
super ( ) ;
this . name = name ;
for ( Sensor s : mSensorManager . getSensorList ( Sensor . TYPE_ALL ) ) {
if ( s . getName ( ) . equals ( sensor ) ) {
mSensor = s ;
mSensorManager . registerListener ( this , mSensor , SensorManager . SENSOR_DELAY_NORMAL ) ;
}
}
this . uiElement = new TextView ( CustomApplication . getAppContext ( ) ) ;
instantiatedInternalDevices . add ( this ) ;
this . setDelegate ( CustomApplication . getDefaultDelegate ( ) ) ;
}
public String getCurrentValue ( ) {
return Arrays . toString ( lastValues ) ;
}
public void onSensorChanged ( SensorEvent arg0 ) {
if ( System . currentTimeMillis ( )  this . lastChange > <num>
&& ! this . getCurrentValue ( ) . equals ( Arrays . toString ( arg0 . values ) ) ) {
String oldValue = this . getCurrentValue ( ) ;
this . lastValues = arg0 . values ;
DeviceEvent de = new DeviceEvent ( this , EVT_VALUES_CHANGED ) ;
de . setParameter ( " , oldValue ) ;
de . setParameter ( " , this . getCurrentValue ( ) ) ;
this . sendEvent ( de ) ;
( ( TextView ) this . uiElement ) . setText ( this . getCurrentValue ( ) ) ;
this . lastChange = System . currentTimeMillis ( ) ;
}
}
public static void addDevice ( String text , String name ) {
new InternalDevice ( name , text ) ;
}
public void onAccuracyChanged ( Sensor arg0 , int arg1 ) {
}
@Override
public String getSemanticAnnotation ( ) {
return mSensor . getName ( ) ;
}
}
package org . itea . neotiq . devicemodel ;
public class DeviceNotSupportedException extends Exception {
private static final long serialVersionUID = <num> ;
}
package org . itea . neotiq . devicemodel ;
public class DeviceNotFoundException extends Exception {
private static final long serialVersionUID = <num> ;
public DeviceNotFoundException ( ) {
}
public DeviceNotFoundException ( String detailMessage ) {
super ( detailMessage ) ;
}
public DeviceNotFoundException ( Throwable throwable ) {
super ( throwable ) ;
}
public DeviceNotFoundException ( String detailMessage , Throwable throwable ) {
super ( detailMessage , throwable ) ;
}
}
package org . itea . neotiq . devicemodel ;
import org . itea . neotiq . application . CustomApplication ;
import android . content . Intent ;
import android . util . Log ;
import java . util . ArrayList ;
import java . util . Collection ;
public class DeviceManager {
public enum EventType {
EVT_ON_CLICK , EVT_TXT_CHANGED , EVT_ON_TOGGLE ,
}
public static Collection < Device > getDevices ( ) {
Collection < Device > dev = new ArrayList < Device > ( ) ;
dev . addAll ( VirtualDevice . getInstantiatedVirtualDevices ( ) ) ;
dev . addAll ( InternalDevice . getInstantiatedInternalDevices ( ) ) ;
return dev ;
}
public static Collection < String > getDeviceTypes ( ) {
Collection < String > dTypes = new ArrayList < String > ( ) ;
dTypes . addAll ( VirtualDevice . getVirtualDeviceTypes ( ) ) ;
dTypes . addAll ( InternalDevice . getInternalDeviceTypes ( ) ) ;
return dTypes ;
}
public static void addDevice ( String text , String name ) throws DeviceNotSupportedException {
Log . d ( " , " + text + " + name ) ;
for ( String s : VirtualDevice . getVirtualDeviceTypes ( ) ) {
if ( s . equals ( text ) ) {
VirtualDevice . addDevice ( text , name ) ;
refreshActivity ( ) ;
return ;
}
}
for ( String s : InternalDevice . getInternalDeviceTypes ( ) ) {
if ( s . equals ( text ) ) {
InternalDevice . addDevice ( text , name ) ;
refreshActivity ( ) ;
return ;
}
}
throw new DeviceNotSupportedException ( ) ;
}
private static void refreshActivity ( ) {
Intent intent = new Intent ( " ) ;
CustomApplication . getAppContext ( ) . sendBroadcast ( intent ) ;
}
public static Device getDeviceNamed ( String string ) throws DeviceNotFoundException {
for ( Device d : getDevices ( ) ) {
if ( d . getName ( ) . equals ( string ) ) {
return d ;
}
}
throw new DeviceNotFoundException ( ) ;
}
}
package org . itea . neotiq . xmpp ;
import java . io . IOException ;
import java . util . HashMap ;
import java . util . Iterator ;
import java . util . Map ;
import org . jivesoftware . smack . packet . IQ ;
import org . jivesoftware . smack . provider . IQProvider ;
import org . jivesoftware . smack . provider . ProviderManager ;
import org . xmlpull . v1 . XmlPullParser ;
import org . xmlpull . v1 . XmlPullParserException ;
public class XmppRest extends IQ {
static {
ProviderManager . getInstance ( ) . addIQProvider ( " , XmppRest . NAMESPACE , new XmppRest . Provider ( ) ) ;
ProviderManager . getInstance ( ) . addIQProvider ( " , XmppRest . NAMESPACE , new XmppRest . Provider ( ) ) ;
}
public static final String NAMESPACE = " ;
public enum RestType {
XMPPREST_UNKNOWN , XMPPREST_QUERY , XMPPREST_RESULT
}
protected RestType type = RestType . XMPPREST_UNKNOWN ;
protected String method = null ;
protected String resource = null ;
protected int status = <num> ;
protected String message = null ;
protected HashMap < String , String > headers = null ;
protected String body = null ;
private static final String [ ] [ ] XML_ESCAPE = {
{ " , " } ,
{ " , " } ,
{ " , " } ,
{ " , " } ,
{ " , " } ,
} ;
private static final Iterable < Integer > getUnicodeIterable ( final String data ) {
return new Iterable < Integer > ( ) {
public Iterator < Integer > iterator ( ) {
return new Iterator < Integer > ( ) {
int nextIndex = <num> ;
public boolean hasNext ( ) {
return nextIndex < data . length ( ) ;
}
public Integer next ( ) {
int result = data . codePointAt ( nextIndex ) ;
nextIndex += Character . charCount ( result ) ;
return result ;
}
public void remove ( ) {
throw new UnsupportedOperationException ( ) ;
}
} ;
}
} ;
}
private static final int [ ] getCodepointsFromString ( String data ) {
int [ ] result = new int [ data . <unk> ( <num> , data . length ( ) ) ] ;
int i = <num> ;
for ( Integer codePoint : getUnicodeIterable ( data ) ) {
result [ i ] = codePoint ;
i ++ ;
}
return result ;
}
private static final < T > Map < T , T > mapFromArray ( T [ ] [ ] elements ) {
Map < T , T > items = new HashMap < T , T > ( ) ;
for ( T [ ] item : elements ) {
if ( item . length == <num> ) {
items . put ( item [ <num> ] , item [ <num> ] ) ;
}
}
return items ;
}
private static final < T > Map < T , T > mapFromArrayInverted ( T [ ] [ ] elements ) {
Map < T , T > items = new HashMap < T , T > ( ) ;
for ( T [ ] item : elements ) {
if ( item . length == <num> ) {
items . put ( item [ <num> ] , item [ <num> ] ) ;
}
}
return items ;
}
private static final String translate ( String data , Map < String , String > table ) {
StringBuilder builder = new StringBuilder ( data . length ( ) * <num> ) ;
int min , max ;
min = Integer . MAX_VALUE ;
max = <num> ;
for ( String s : table . keySet ( ) ) {
if ( s . length ( ) > max )
max = s . length ( ) ;
if ( s . length ( ) < min )
min = s . length ( ) ;
}
if ( min == <num> || max < min ) {
throw new IllegalArgumentException ( ) ;
}
int [ ] codepoints = getCodepointsFromString ( data ) ;
int index = <num> ;
while ( index < codepoints . length ) {
int j ;
for ( j = Math . min ( max , codepoints . length  index ) ; j >= min ; j  ) {
String replacement = table . get ( new String ( codepoints , index , j ) ) ;
if ( replacement != null ) {
builder . append ( replacement ) ;
index = index + j ;
break ;
}
}
if ( j < min ) {
builder . <unk> ( codepoints [ index ] ) ;
index = index + <num> ;
}
}
return builder . toString ( ) ;
}
protected static final String escapeXML ( String data ) {
Map < String , String > escapes = mapFromArray ( XML_ESCAPE ) ;
return translate ( data , escapes ) ;
}
protected static final String unescapeXML ( String data ) {
Map < String , String > escapes = mapFromArrayInverted ( XML_ESCAPE ) ;
return translate ( data , escapes ) ;
}
public XmppRest ( ) {
headers = new HashMap < String , String > ( ) ;
}
public void setHeader ( String field , String value ) {
headers . put ( field , value ) ;
}
public void setQuery ( String method , String resource ) {
this . type = RestType . XMPPREST_QUERY ;
this . method = method ;
this . resource = resource ;
}
public void setResult ( int status , String message ) {
this . type = RestType . XMPPREST_RESULT ;
this . status = status ;
this . message = message ;
}
public void setBody ( String body ) {
this . body = body ;
}
public RestType getRestType ( ) {
return type ;
}
public String getMethod ( ) throws Exception {
if ( type != RestType . XMPPREST_QUERY ) {
throw new Exception ( " ) ;
}
return method ;
}
public String getResource ( ) throws Exception {
if ( type != RestType . XMPPREST_QUERY ) {
throw new Exception ( " ) ;
}
return resource ;
}
public int getStatus ( ) throws Exception {
if ( type != RestType . XMPPREST_RESULT ) {
throw new Exception ( " ) ;
}
return status ;
}
public String getMessage ( ) throws Exception {
if ( type != RestType . XMPPREST_RESULT ) {
throw new Exception ( " ) ;
}
return message ;
}
public String getBody ( ) {
return body ;
}
public Map < String , String > getHeaders ( ) {
return headers ;
}
public static class Provider implements IQProvider {
public Provider ( ) {
super ( ) ;
}
protected void parseHeaders ( XmlPullParser parser , XmppRest iq ) throws XmlPullParserException , IOException {
int eventType = parser . next ( ) ;
while ( true ) {
if ( eventType == XmlPullParser . START_TAG ) {
if ( parser . getName ( ) . equals ( " ) ) {
String field = null ;
String value = null ;
for ( int i = <num> ; i < parser . getAttributeCount ( ) ; i ++ ) {
if ( parser . getAttributeName ( i ) . equals ( " ) ) {
field = unescapeXML ( parser . getAttributeValue ( i ) ) ;
}
else if ( parser . getAttributeName ( i ) . equals ( " ) ) {
value = unescapeXML ( parser . getAttributeValue ( i ) ) ;
}
}
if ( field != null && value != null ) {
iq . setHeader ( field , value ) ;
}
}
else {
break ;
}
}
else if ( eventType == XmlPullParser . END_TAG ) {
if ( parser . getName ( ) . equals ( " ) ) {
break ;
}
else if ( parser . getName ( ) . equals ( " ) ) {
}
else {
break ;
}
}
eventType = parser . next ( ) ;
}
}
public IQ <unk> ( XmlPullParser parser ) throws Exception {
XmppRest iq = new XmppRest ( ) ;
boolean done = false ;
if ( parser . getEventType ( ) == XmlPullParser . START_TAG ) {
if ( parser . getName ( ) . equals ( " ) ) {
String method = null ;
String resource = null ;
for ( int i = <num> ; i < parser . getAttributeCount ( ) ; i ++ ) {
if ( parser . getAttributeName ( i ) . equals ( " ) ) {
method = unescapeXML ( parser . getAttributeValue ( i ) ) ;
}
else if ( parser . getAttributeName ( i ) . equals ( " ) ) {
resource = unescapeXML ( parser . getAttributeValue ( i ) ) ;
}
}
if ( method != null && resource != null ) {
iq . setQuery ( method , resource ) ;
}
else {
throw new Exception ( " ) ;
}
}
else if ( parser . getName ( ) . equals ( " ) ) {
int status = <num> ;
String message = null ;
for ( int i = <num> ; i < parser . getAttributeCount ( ) ; i ++ ) {
if ( parser . getAttributeName ( i ) . equals ( " ) ) {
status = Integer . parseInt ( parser . getAttributeValue ( i ) ) ;
}
else if ( parser . getAttributeName ( i ) . equals ( " ) ) {
message = unescapeXML ( parser . getAttributeValue ( i ) ) ;
}
}
if ( message == null ) {
message = " ;
}
if ( status >= <num> && status < <num> ) {
iq . setResult ( status , message ) ;
}
else {
throw new Exception ( " ) ;
}
}
else {
return null ;
}
}
while ( ! done ) {
int eventType = parser . next ( ) ;
if ( eventType == XmlPullParser . START_TAG ) {
if ( parser . getName ( ) . equals ( " ) ) {
parseHeaders ( parser , iq ) ;
}
else if ( parser . getName ( ) . equals ( " ) ) {
iq . setBody ( unescapeXML ( parser . nextText ( ) ) ) ;
}
}
else if ( eventType == XmlPullParser . END_TAG ) {
if ( ( iq . getRestType ( ) == RestType . XMPPREST_QUERY && parser . getName ( ) . equals ( " ) ) ||
( iq . getRestType ( ) == RestType . XMPPREST_RESULT && parser . getName ( ) . equals ( " ) ) ) {
done = true ;
}
}
}
return iq ;
}
}
public String <unk> ( ) {
StringBuilder buf = new StringBuilder ( ) ;
buf . append ( " ) ;
switch ( type ) {
case XMPPREST_QUERY :
buf . append ( " ) . append ( escapeXML ( method ) ) . append ( " ) . append ( escapeXML ( resource ) ) . append ( " ) ;
break ;
case XMPPREST_RESULT :
buf . append ( " ) . append ( status ) . append ( " ) . append ( escapeXML ( message ) ) . append ( " ) ;
break ;
default :
return " ;
}
buf . append ( " ) . append ( NAMESPACE ) . append ( " ) ;
if ( headers . size ( ) > <num> ) {
buf . append ( " ) ;
for ( Map . Entry < String , String > e : headers . entrySet ( ) ) {
buf . append ( " ) . append ( escapeXML ( e . getKey ( ) ) ) . append ( " ) . append ( escapeXML ( e . getValue ( ) ) ) . append ( " ) ;
}
buf . append ( " ) ;
}
if ( body != null && body . length ( ) > <num> ) {
buf . append ( " ) . append ( escapeXML ( body ) ) . append ( " ) ;
}
switch ( type ) {
case XMPPREST_QUERY :
buf . append ( " ) ;
break ;
case XMPPREST_RESULT :
buf . append ( " ) ;
break ;
}
return buf . toString ( ) ;
}
}
package org . itea . neotiq . activities ;
import org . itea . neotiq . R ;
import org . itea . neotiq . devicemodel . DeviceManager ;
import org . itea . neotiq . devicemodel . DeviceNotSupportedException ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . widget . ArrayAdapter ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . Spinner ;
public class DeviceAdder extends Activity {
public static final String TAG = " ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
Log . i ( TAG , " ) ;
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . device_adder ) ;
Spinner v = ( Spinner ) findViewById ( R . id . spnDevice ) ;
String [ ] devices = ( String [ ] ) DeviceManager . getDeviceTypes ( ) . toArray ( new String [ <num> ] ) ;
ArrayAdapter < String > adapter = new ArrayAdapter < String > ( this ,
android . R . layout . simple_spinner_item , devices ) ;
adapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
v . setAdapter ( adapter ) ;
Button add = ( Button ) findViewById ( R . id . btnOk ) ;
add . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
btnAddClicked ( ) ;
}
} ) ;
}
protected void btnAddClicked ( ) {
Spinner v = ( Spinner ) findViewById ( R . id . spnDevice ) ;
addDevice ( ( String ) v . getSelectedItem ( ) , ( ( EditText ) findViewById ( R . id . txtDevice ) ) . getText ( ) . toString ( ) ) ;
}
protected void addDevice ( String text , String name ) {
try {
DeviceManager . addDevice ( text , name ) ;
} catch ( DeviceNotSupportedException e ) {
e . printStackTrace ( ) ;
}
Intent i = new Intent ( this , DevicesView . class ) ;
startActivity ( i ) ;
}
}
package org . itea . neotiq . application ;
import org . itea . neotiq . devicemodel . DeviceDelegate ;
import org . itea . neotiq . xmpp . XMPPComm ;
import org . itea . neotiq . xmpp . XmlDescription ;
import android . app . Application ;
import android . content . Context ;
public class CustomApplication extends Application {
private static Context context ;
private static DeviceDelegate defaultDelegate ;
@Override
public void onCreate ( ) {
super . onCreate ( ) ;
CustomApplication . context = getApplicationContext ( ) ;
CustomApplication . defaultDelegate = XMPPComm . getInstance ( ) ;
XmlDescription . sendToGlobalRepo ( ) ;
}
public static Context getAppContext ( ) {
return CustomApplication . context ;
}
public static DeviceDelegate getDefaultDelegate ( ) {
return defaultDelegate ;
}
}
package org . itea . neotiq . devicemodel ;
public interface RequestableDevice {
public String getCurrentValue ( ) ;
}
package org . itea . neotiq . devicemodel ;
import org . itea . neotiq . application . CustomApplication ;
import org . itea . neotiq . devicemodel . DeviceManager . EventType ;
import android . util . Log ;
import android . view . View ;
import android . widget . ToggleButton ;
import java . util . ArrayList ;
import java . util . Collection ;
public class VDToggle extends VirtualDevice implements RequestableDevice {
@SuppressWarnings("unused")
private static final String uiElementName = " ;
private static Collection < VDToggle > instantiatedButtons = new ArrayList < VDToggle > ( ) ;
private View . OnClickListener ocl ;
public VDToggle ( ) {
this . uiElement = new ToggleButton ( CustomApplication . getAppContext ( ) ) ;
( ( ToggleButton ) this . uiElement ) . setOnClickListener ( this . getOcl ( ) ) ;
instantiatedButtons . add ( this ) ;
}
public View . OnClickListener getOcl ( ) {
if ( ocl == null ) {
ocl = new View . OnClickListener ( ) {
public void onClick ( View arg0 ) {
VDToggle . onClickOccured ( arg0 ) ;
}
} ;
}
return ocl ;
}
protected static void onClickOccured ( View arg0 ) {
for ( VDToggle btn : VDToggle . instantiatedButtons ) {
if ( btn . getView ( ) == arg0 ) {
DeviceEvent de = new DeviceEvent ( btn , EventType . EVT_ON_TOGGLE ) ;
de . setParameter (
" ,
( ! ( ( ToggleButton ) btn . uiElement ) . isChecked ( ) ? ( ( ToggleButton ) btn . uiElement )
. getTextOn ( ) : ( ( ToggleButton ) btn . uiElement ) . getTextOff ( ) ) ) ;
de . setParameter (
" ,
( ( ( ToggleButton ) btn . uiElement ) . isChecked ( ) ? ( ( ToggleButton ) btn . uiElement )
. getTextOn ( ) : ( ( ToggleButton ) btn . uiElement ) . getTextOff ( ) ) ) ;
btn . sendEvent ( de ) ;
return ;
}
}
Log . e ( " , " ) ;
}
public String getCurrentValue ( ) {
return ( String ) ( ( ( ToggleButton ) this . uiElement ) . isChecked ( ) ? ( ( ToggleButton ) this . uiElement )
. getTextOn ( ) : ( ( ToggleButton ) this . uiElement ) . getTextOff ( ) ) ;
}
@Override
public String getSemanticAnnotation ( ) {
return " ;
}
}
package org . itea . neotiq . devicemodel ;
public interface DeviceDelegate {
public void eventOccured ( DeviceEvent de ) ;
public void deviceCreated ( Device d ) ;
}
package org . itea . neotiq . activities ;
import org . itea . neotiq . R ;
import org . itea . neotiq . devicemodel . Device ;
import org . itea . neotiq . devicemodel . DeviceManager ;
import android . app . Activity ;
import android . content . BroadcastReceiver ;
import android . content . Context ;
import android . content . Intent ;
import android . content . IntentFilter ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . widget . Button ;
import android . widget . TableLayout ;
import android . widget . TableRow ;
public class DevicesView extends Activity {
public static final String TAG = " ;
private Button mAddDeviceBtn ;
private TableLayout mDevicesView ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
mAddDeviceBtn = ( Button ) findViewById ( R . id . btnAddDevice ) ;
mAddDeviceBtn . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
Log . i ( TAG , " ) ;
launchAdder ( ) ;
}
} ) ;
mDevicesView = ( TableLayout ) findViewById ( R . id . devicesView ) ;
this . populateDevices ( ) ;
BroadcastReceiver receiver = new BroadcastReceiver ( ) {
@Override
public void onReceive ( Context context , Intent intent ) {
if ( intent . getAction ( ) . equals ( " ) ) {
populateDevices ( ) ;
}
}
} ;
registerReceiver ( receiver , new IntentFilter ( " ) ) ;
}
private void populateDevices ( ) {
mDevicesView . removeAllViews ( ) ;
for ( Device d : DeviceManager . getDevices ( ) ) {
TableRow tmp = ( TableRow ) d . getView ( ) . getParent ( ) ;
if ( tmp != null )
tmp . removeAllViews ( ) ;
TableRow tr = new TableRow ( getBaseContext ( ) ) ;
tr . addView ( d . getView ( ) ) ;
Button delBtn = new Button ( getBaseContext ( ) ) ;
delBtn . setTag ( d ) ;
delBtn . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
Log . i ( TAG , " ) ;
sendDeleteToDevice ( v ) ;
}
} ) ;
delBtn . setText ( " ) ;
delBtn . setPadding ( <num> , <num> , <num> , <num> ) ;
tr . addView ( delBtn ) ;
mDevicesView . addView ( tr ) ;
}
}
protected void sendDeleteToDevice ( View v ) {
}
private void launchAdder ( ) {
Intent i = new Intent ( this , DeviceAdder . class ) ;
startActivity ( i ) ;
}
@Override
public void finish ( ) {
super . finish ( ) ;
}
}
package org . itea . neotiq . devicemodel ;
import org . itea . neotiq . application . CustomApplication ;
import android . view . View ;
import java . util . ArrayList ;
import java . util . Collection ;
public abstract class Device {
protected String name ;
protected Collection < DeviceEvent > eventsOccured = new ArrayList < DeviceEvent > ( ) ;
protected DeviceDelegate delegate ;
protected View uiElement ;
protected Device ( ) {
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
public Collection < DeviceEvent > <unk> ( ) {
return eventsOccured ;
}
public void setDelegate ( DeviceDelegate delegate ) {
this . delegate = delegate ;
this . getDelegate ( ) . deviceCreated ( this ) ;
}
protected void sendEvent ( DeviceEvent de ) {
this . eventsOccured . add ( de ) ;
this . getDelegate ( ) . eventOccured ( de ) ;
}
public DeviceDelegate getDelegate ( ) {
if ( delegate == null ) {
delegate = CustomApplication . getDefaultDelegate ( ) ;
}
return delegate ;
}
public View getView ( ) {
return uiElement ;
}
public abstract String getSemanticAnnotation ( ) ;
}
public class <unk> {
}
public class <unk> {
private String s ;
}
package at . dahlgren . warpdrive . pages ;
import android . os . Bundle ;
import android . view . Menu ;
import android . view . MenuItem ;
import at . dahlgren . warpdrive . Page ;
import at . dahlgren . warpdrive . R ;
public class About extends Page {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . about ) ;
}
public boolean onCreateOptionsMenu ( Menu menu ) { return false ; }
public boolean onOptionsItemSelected ( MenuItem item ) { return false ; }
package org . me . sfBackendClient ;
import java . io . BufferedReader ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . InputStreamReader ;
import java . util . ArrayList ;
import java . util . Iterator ;
import java . util . List ;
import org . apache . http . HttpEntity ;
import org . apache . http . HttpResponse ;
import org . apache . http . NameValuePair ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . client . entity . UrlEncodedFormEntity ;
import org . apache . http . client . methods . HttpGet ;
import org . apache . http . client . methods . HttpPost ;
import org . apache . http . impl . client . DefaultHttpClient ;
import org . apache . http . message . BasicNameValuePair ;
public class sfRequest {
protected String url ;
protected String method ;
protected List < NameValuePair > params ;
protected HttpGet getRequest ;
protected HttpPost postRequest ;
protected HttpResponse response ;
protected String result ;
protected DefaultHttpClient httpClient ;
public sfRequest ( DefaultHttpClient client ) {
this . httpClient = client ;
this . params = new ArrayList < NameValuePair > ( <num> ) ;
}
public void setUrl ( String url ) {
this . url = url ;
}
public String getUrl ( ) {
return this . url ;
}
public void setMethod ( String method ) {
this . method = method ;
}
public String getMethod ( ) {
return this . method ;
}
public sfRequest clone ( ) {
sfRequest request = new sfRequest ( this . httpClient ) ;
request . setUrl ( this . url ) ;
request . setMethod ( this . method ) ;
Iterator < NameValuePair > iter = this . params . iterator ( ) ;
while ( iter . hasNext ( ) ) {
NameValuePair param = iter . next ( ) ;
request . addParam ( param . getName ( ) , param . getValue ( ) ) ;
}
return request ;
}
public void addParam ( String key , String value ) {
this . params . add ( new BasicNameValuePair ( key , value ) ) ;
}
public String getResult ( ) {
return this . result ;
}
public void execute ( ) {
try {
if ( this . getMethod ( ) == null )
this . setMethod ( " ) ;
if ( this . method . compareTo ( " ) == <num> ) {
String url = this . url ;
if ( params . size ( ) > <num> ) {
if ( ! url . contains ( " ) )
url = url + " ;
if ( ! url . endsWith ( " ) )
url = url + " ;
for ( int i = <num> ; i < params . size ( ) ; i ++ )
url = url + params . get ( i ) . getName ( ) + " + params . get ( i ) . getValue ( ) + " ;
}
this . getRequest = new HttpGet ( url ) ;
this . response = this . httpClient . execute ( this . getRequest ) ;
} else if ( this . method . compareToIgnoreCase ( " ) == 0
|| this . method . compareToIgnoreCase ( " ) == 0
|| this . method . compareToIgnoreCase ( " ) == <num> ) {
this . addParam ( " , this . getMethod ( ) ) ;
this . postRequest = new HttpPost ( this . getUrl ( ) ) ;
this . postRequest . setEntity ( new UrlEncodedFormEntity ( this . params , " ) ) ;
this . response = this . httpClient . execute ( this . postRequest ) ;
}
HttpEntity entity = response . getEntity ( ) ;
if ( entity != null ) {
InputStream inputStream = entity . getContent ( ) ;
this . result = convertStreamToString ( inputStream ) ;
}
} catch ( ClientProtocolException e ) {
this . result = e . getMessage ( ) ;
} catch ( IOException e ) {
this . result = e . getMessage ( ) ;
}
this . params . clear ( ) ;
}
private static String convertStreamToString ( InputStream is ) {
BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ;
StringBuilder stringBuilder = new StringBuilder ( ) ;
String line = null ;
try {
while ( ( line = reader . readLine ( ) ) != null ) {
stringBuilder . append ( line + " ) ;
}
} catch ( IOException e ) {
e . printStackTrace ( ) ;
} finally {
try {
is . close ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
return stringBuilder . toString ( ) ;
}
package at . dahlgren . warpdrive ;
public class Comment {
final int id ;
final String date ;
final String user ;
final String text ;
public Comment ( String user , String date , String text ) {
this . id = <num> ;
this . user = user ;
this . date = date ;
this . text = text ;
}
public int getId ( ) {
return id ;
}
public String getDate ( ) {
return date ;
}
public String getUser ( ) {
return user ;
}
public String getText ( ) {
return text ;
}
}
package at . dahlgren . warpdrive . pages ;
public class Top extends ShowQuotes {
protected void refresh ( ) {
request . setMethod ( " ) ;
request . setUrl ( " ) ;
runCommand ( ) ;
}
}
package org . me . sfBackendClient ;
import org . apache . http . conn . ClientConnectionManager ;
import org . apache . http . conn . scheme . PlainSocketFactory ;
import org . apache . http . conn . scheme . Scheme ;
import org . apache . http . conn . scheme . SchemeRegistry ;
import org . apache . http . impl . client . DefaultHttpClient ;
import org . apache . http . impl . conn . tsccm . ThreadSafeClientConnManager ;
import org . apache . http . params . BasicHttpParams ;
import org . apache . http . params . HttpParams ;
public class sfClient {
private static sfClient instance ;
protected DefaultHttpClient httpClient ;
private sfClient ( ) {
HttpParams params = new BasicHttpParams ( ) ;
SchemeRegistry schemeRegistry = new SchemeRegistry ( ) ;
schemeRegistry . register ( new Scheme ( " , PlainSocketFactory . getSocketFactory ( ) , <num> ) ) ;
ClientConnectionManager cm = new ThreadSafeClientConnManager ( params , schemeRegistry ) ;
this . httpClient = new DefaultHttpClient ( cm , params ) ;
}
public static sfClient getInstance ( ) {
if ( null == instance ) {
instance = new sfClient ( ) ;
}
return instance ;
}
public sfRequest createRequest ( ) {
sfRequest request = new sfRequest ( this . httpClient ) ;
return request ;
}
package at . dahlgren . warpdrive ;
import java . util . List ;
import android . content . Context ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . BaseAdapter ;
public class DefaultListAdapter < T > extends BaseAdapter {
protected Context context ;
private List < T > arr ;
public DefaultListAdapter ( Context c , List < T > arr ) {
this . context = c ;
this . arr = arr ;
}
@Override
public int getCount ( ) {
return arr . size ( ) ;
}
@Override
public T getItem ( int position ) {
return arr . get ( position ) ;
}
@Override
public long getItemId ( int position ) {
return position ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
return null ;
}
}
package at . dahlgren . warpdrive . pages ;
public class Random extends ShowQuotes {
protected void refresh ( ) {
request . setMethod ( " ) ;
request . setUrl ( " ) ;
runCommand ( ) ;
}
}
package at . dahlgren . warpdrive ;
public class Quote {
final int id ;
final int rank ;
final String text ;
public Quote ( int id , int rank , String text ) {
this . id = id ;
this . rank = rank ;
this . text = text ;
}
public int getId ( ) {
return id ;
}
public int getRank ( ) {
return rank ;
}
public String getText ( ) {
return text ;
}
}
package at . dahlgren . warpdrive . pages ;
import java . util . ArrayList ;
import android . content . Context ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . Menu ;
import android . view . MenuInflater ;
import android . view . MenuItem ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . AdapterView ;
import android . widget . ListView ;
import android . widget . TextView ;
import at . dahlgren . warpdrive . DefaultListAdapter ;
import at . dahlgren . warpdrive . Page ;
import at . dahlgren . warpdrive . R ;
public class MainMenu extends Page {
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . pages ) ;
ArrayList < MainMenuItem > arr = new ArrayList < MainMenuItem > ( ) ;
arr . add ( new MainMenuItem ( getResources ( ) . getString ( R . string . latest ) , new Intent ( this , Latest . class ) ) ) ;
arr . add ( new MainMenuItem ( getResources ( ) . getString ( R . string . top ) , new Intent ( this , Top . class ) ) ) ;
arr . add ( new MainMenuItem ( getResources ( ) . getString ( R . string . random ) , new Intent ( this , Random . class ) ) ) ;
arr . add ( new MainMenuItem ( getResources ( ) . getString ( R . string . search ) , new Intent ( this , Search . class ) ) ) ;
ListView list = ( ListView ) this . findViewById ( R . id . list ) ;
list . setAdapter ( new ListAdapter ( this , arr ) ) ;
list . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) {
@Override
public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) {
MainMenuItem item = ( ( MainMenuItem ) parent . getAdapter ( ) . getItem ( position ) ) ;
if ( item . intent . getComponent ( ) . getClassName ( ) . contentEquals ( Search . class . getName ( ) ) )
startSearch ( null , false , null , false ) ;
else
MainMenu . this . startActivity ( item . intent ) ;
}
} ) ;
}
protected class MainMenuItem {
final String text ;
final Intent intent ;
MainMenuItem ( String text , Intent intent ) {
this . text = text ;
this . intent = intent ;
}
}
public boolean onCreateOptionsMenu ( Menu menu ) {
MenuInflater inflater = getMenuInflater ( ) ;
inflater . inflate ( R . menu . mainmenu , menu ) ;
return true ;
}
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case R . id . aboutButton :
startActivity ( new Intent ( this , About . class ) ) ;
return true ;
}
return false ;
}
private class ListAdapter extends DefaultListAdapter < MainMenuItem > {
public ListAdapter ( Context c , ArrayList < MainMenuItem > arr ) {
super ( c , arr ) ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
View view ;
if ( convertView != null )
view = convertView ;
else
view = View . inflate ( context , R . layout . <unk> , null ) ;
TextView text = ( TextView ) view . findViewById ( R . id . name ) ;
MainMenuItem item = this . getItem ( position ) ;
text . setText ( item . text ) ;
return view ;
}
}
}
package at . dahlgren . warpdrive . pages ;
import java . util . List ;
import android . app . AlertDialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . text . Html ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemLongClickListener ;
import android . widget . ListView ;
import android . widget . TextView ;
import at . dahlgren . warpdrive . DefaultListAdapter ;
import at . dahlgren . warpdrive . Page ;
import at . dahlgren . warpdrive . Parser ;
import at . dahlgren . warpdrive . Quote ;
import at . dahlgren . warpdrive . R ;
public class ShowQuotes extends Page {
private List < Quote > quotes ;
protected void commandReady ( String data ) {
quotes = Parser . parseQuotes ( data ) ;
showQuotes ( ) ;
}
private void showQuotes ( ) {
this . setContentView ( R . layout . pages ) ;
ListView list = ( ListView ) this . findViewById ( R . id . list ) ;
list . setAdapter ( new ListAdapter ( ShowQuotes . this , quotes ) ) ;
list . setOnItemLongClickListener ( new OnItemLongClickListener ( ) {
@Override
public boolean onItemLongClick ( AdapterView < ? > parent , View view , int position , long id ) {
final Quote quote = ( ( Quote ) parent . getAdapter ( ) . getItem ( position ) ) ;
final CharSequence [ ] items = { " , " } ;
AlertDialog . Builder builder = new AlertDialog . Builder ( ShowQuotes . this ) ;
builder . setTitle ( " + quote . getId ( ) ) ;
builder . setItems ( items , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int item ) {
switch ( item ) {
case <num> :
Intent intent = new Intent ( ShowQuotes . this , ShowComments . class ) ;
intent . putExtra ( " , quote . getId ( ) ) ;
startActivity ( intent ) ;
break ;
case <num> :
Intent shareIntent = new Intent ( android . content . Intent . ACTION_SEND ) ;
shareIntent . setType ( " ) ;
shareIntent . putExtra ( android . content . Intent . EXTRA_TEXT , Html . fromHtml ( quote . getText ( ) ) . toString ( ) ) ;
startActivity ( Intent . createChooser ( shareIntent , " + quote . getId ( ) ) ) ;
break ;
}
}
} ) . create ( ) . show ( ) ;
return true ;
}
} ) ;
ShowQuotes . this . setContentView ( list ) ;
}
private class ListAdapter extends DefaultListAdapter < Quote > {
public ListAdapter ( Context c , List < Quote > arr ) {
super ( c , arr ) ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
View view ;
if ( convertView != null )
view = convertView ;
else
view = View . inflate ( context , R . layout . quote , null ) ;
TextView id = ( TextView ) view . findViewById ( R . id . quote_id ) ;
TextView rank = ( TextView ) view . findViewById ( R . id . quote_rank ) ;
TextView text = ( TextView ) view . findViewById ( R . id . quote_text ) ;
Quote quote = ( Quote ) this . getItem ( position ) ;
id . setText ( " + quote . getId ( ) ) ;
rank . setText ( " + quote . getRank ( ) ) ;
String str = quote . getText ( ) ;
while ( str . endsWith ( " ) )
str = str . substring ( <num> , str . length ( )  " . length ( ) ) ;
text . setText ( Html . fromHtml ( str ) ) ;
return view ;
}
}
}
package at . dahlgren . warpdrive ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . regex . Matcher ;
import java . util . regex . Pattern ;
public class Parser {
public static List < Quote > parseQuotes ( String html ) {
ArrayList < Quote > quotes = new ArrayList < Quote > ( ) ;
Pattern pattern = Pattern . compile (
" +
" +
" +
" +
"
, Pattern . DOTALL ) ;
Matcher match = pattern . matcher ( html ) ;
while ( match . find ( ) ) {
int id = Integer . parseInt ( match . group ( <num> ) ) ;
int rank = Integer . parseInt ( match . group ( <num> ) . trim ( ) ) ;
String text = match . group ( <num> ) ;
quotes . add ( new Quote ( id , rank , text ) ) ;
}
return quotes ;
}
public static List < Comment > parseComments ( String html ) {
ArrayList < Comment > comments = new ArrayList < Comment > ( ) ;
Pattern pattern = Pattern . compile (
" +
" +
" +
" +
"
, Pattern . DOTALL ) ;
Matcher match = pattern . matcher ( html ) ;
while ( match . find ( ) ) {
String user = match . group ( <num> ) ;
String date = match . group ( <num> ) ;
String text = match . group ( <num> ) ;
comments . add ( new Comment ( user , date , text ) ) ;
}
return comments ;
}
}
package at . dahlgren . warpdrive ;
import org . me . sfBackendClient . sfClient ;
import org . me . sfBackendClient . sfRequest ;
import android . app . Activity ;
import android . content . Context ;
import android . os . Bundle ;
import android . util . Log ;
import android . widget . Toast ;
public class Page extends Activity {
protected RunCommand mTask ;
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . setContentView ( R . layout . loading ) ;
Object retained = getLastNonConfigurationInstance ( ) ;
if ( retained instanceof RunCommand ) {
mTask = ( RunCommand ) retained ;
mTask . setActivity ( this ) ;
} else {
refresh ( ) ;
}
}
@Override
public Object onRetainNonConfigurationInstance ( ) {
if ( mTask != null ) {
mTask . setActivity ( null ) ;
return mTask ;
}
return null ;
}
protected final sfRequest request = sfClient . getInstance ( ) . createRequest ( ) ;
protected String <unk> ;
private class RunCommand extends Task < sfRequest , Void , String > {
String data ;
protected RunCommand ( Activity activity ) {
super ( activity ) ;
}
protected void onPreExecute ( ) { }
@Override
protected String doInBackground ( sfRequest . . . request ) {
request [ <num> ] . execute ( ) ;
return request [ <num> ] . getResult ( ) ;
}
protected void onPostExecute ( String data ) {
Log . v ( " , data ) ;
this . data = data ;
this . completed = true ;
notifyActivityTaskCompleted ( ) ;
}
@Override
protected void notifyActivityTaskCompleted ( ) {
if ( data . contains ( " ) || data . contains ( " ) )
( ( Page ) activity ) . showToast ( " ) ;
else
( ( Page ) activity ) . commandReady ( data ) ;
}
}
protected void runCommand ( ) {
mTask = new RunCommand ( this ) ;
mTask . execute ( request ) ;
}
protected void commandReady ( String data ) { }
protected void refresh ( ) {
}
public void showToast ( String text , int length ) {
Context context = getApplicationContext ( ) ;
int duration = length ;
Toast toast = Toast . makeText ( context , text , duration ) ;
toast . show ( ) ;
}
public void showToast ( String text ) {
showToast ( text , Toast . LENGTH_LONG ) ;
}
}
package at . dahlgren . warpdrive . pages ;
import java . util . List ;
import android . content . Context ;
import android . os . Bundle ;
import android . text . Html ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . ListView ;
import android . widget . TextView ;
import at . dahlgren . warpdrive . Comment ;
import at . dahlgren . warpdrive . DefaultListAdapter ;
import at . dahlgren . warpdrive . Page ;
import at . dahlgren . warpdrive . Parser ;
import at . dahlgren . warpdrive . R ;
public class ShowComments extends Page {
private List < Comment > comments ;
private int offset ;
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
if ( savedInstanceState != null )
offset = savedInstanceState . getInt ( " , <num> ) ;
}
protected void refresh ( ) {
int id = this . getIntent ( ) . getIntExtra ( " , <num> ) ;
request . setMethod ( " ) ;
request . setUrl ( " + id + " + offset ) ;
offset ++ ;
runCommand ( ) ;
}
protected void commandReady ( String data ) {
comments = Parser . parseComments ( data ) ;
showComments ( ) ;
}
private void showComments ( ) {
ListView list = new ListView ( ShowComments . this ) ;
list . setId ( R . id . layout_root ) ;
list . setAdapter ( new ListAdapter ( ShowComments . this , comments ) ) ;
ShowComments . this . setContentView ( list ) ;
}
private class ListAdapter extends DefaultListAdapter < Comment > {
public ListAdapter ( Context c , List < Comment > arr ) {
super ( c , arr ) ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
View view ;
if ( convertView != null )
view = convertView ;
else
view = View . inflate ( context , R . layout . quote , null ) ;
TextView id = ( TextView ) view . findViewById ( R . id . quote_id ) ;
TextView rank = ( TextView ) view . findViewById ( R . id . quote_rank ) ;
TextView text = ( TextView ) view . findViewById ( R . id . quote_text ) ;
Comment comment = ( Comment ) this . getItem ( position ) ;
id . setText ( comment . getUser ( ) ) ;
rank . setText ( comment . getDate ( ) ) ;
text . setText ( Html . fromHtml ( comment . getText ( ) ) ) ;
return view ;
}
}
}
package at . dahlgren . warpdrive . pages ;
public class Latest extends ShowQuotes {
protected void refresh ( ) {
request . setMethod ( " ) ;
request . setUrl ( " ) ;
runCommand ( ) ;
}
}
package at . dahlgren . warpdrive ;
import android . app . Activity ;
import android . os . AsyncTask ;
public abstract class Task < T1 , T2 , T3 > extends AsyncTask < T1 , T2 , T3 > {
protected Activity activity ;
protected boolean completed ;
protected abstract void notifyActivityTaskCompleted ( ) ;
protected Task ( Activity activity ) {
this . activity = activity ;
}
public void setActivity ( Activity activity ) {
this . activity = activity ;
if ( completed && activity != null ) {
notifyActivityTaskCompleted ( ) ;
}
}
}
package org . roguepanda . gcc ;
import java . io . File ;
import org . apache . tools . ant . ProjectComponent ;
public class LibDir extends ProjectComponent
{
private String dir ;
public void setDir ( String dir )
{
this . dir = dir ;
}
public File asFile ( )
{
File file = getProject ( ) . resolveFile ( dir ) ;
if ( file . isDirectory ( ) )
{
return file ;
}
else
{
return file . getParentFile ( ) ;
}
}
}
package org . roguepanda . gcc ;
import java . io . PrintStream ;
import java . util . ArrayList ;
import java . util . List ;
import org . apache . tools . ant . DefaultLogger ;
import org . apache . tools . ant . Project ;
public class TestLogger extends DefaultLogger
{
private List < String > messages = new ArrayList < String > ( ) ;
public TestLogger ( )
{
this . <unk> ( System . err ) ;
this . <unk> ( System . out ) ;
this . <unk> ( Project . MSG_VERBOSE ) ;
}
@Override
protected void log ( String message )
{
messages . add ( message ) ;
}
public String getLastMessage ( )
{
return messages . get ( messages . size ( )  <num> ) ;
}
public String getMessage ( int index )
{
return messages . get ( index ) ;
}
public List < String > getMessages ( )
{
return messages ;
}
public void <unk> ( PrintStream out )
{
for ( String message : messages )
{
out . println ( message ) ;
}
}
}
package org . roguepanda . gcc ;
import static org . junit . Assert . * ;
import java . io . File ;
import org . apache . tools . ant . BuildException ;
import org . apache . tools . ant . Project ;
import org . apache . tools . ant . types . FileSet ;
import org . apache . tools . ant . types . Path ;
import org . apache . tools . ant . types . <unk> . FilenameSelector ;
import org . junit . After ;
import org . junit . Before ;
import org . junit . Test ;
public class <unk>
{
private Project project ;
private TestLogger logger ;
private GCCTask task ;
@Before
public void setUp ( )
{
task = new GCCTask ( ) ;
logger = new TestLogger ( ) ;
project = new Project ( ) ;
project . init ( ) ;
project . <unk> ( logger ) ;
task . setProject ( project ) ;
task . <unk> ( " ) ;
}
@After
public void tearDown ( )
{
project = null ;
logger = null ;
task = null ;
}
@Test
public void testEmpty ( )
{
try
{
task . setObjectFiles ( true ) ;
task . execute ( ) ;
}
catch ( BuildException e )
{
return ;
}
fail ( " ) ;
}
public void <unk> ( )
{
FileSet fileSet = new FileSet ( ) ;
fileSet . setProject ( project ) ;
fileSet . setDir ( new File ( " ) ) ;
FilenameSelector selector = new FilenameSelector ( ) ;
selector . setProject ( project ) ;
selector . setName ( " ) ;
fileSet . add ( selector ) ;
task . addConfiguredFileSet ( fileSet ) ;
task . setObjectFiles ( true ) ;
task . execute ( ) ;
}
@Test
public void <unk> ( )
{
Path path = new Path ( project ) ;
}
}
package org . roguepanda . gcc ;
import java . io . File ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . HashSet ;
import java . util . Iterator ;
import java . util . List ;
import java . util . Set ;
import org . apache . tools . ant . BuildException ;
import org . apache . tools . ant . Project ;
import org . apache . tools . ant . Task ;
import org . apache . tools . ant . taskdefs . Execute ;
import org . apache . tools . ant . types . FileSet ;
import org . apache . tools . ant . types . Resource ;
public class GCCTask extends Task
{
private Set < FileSet > fileSets = new HashSet < FileSet > ( ) ;
private Set < LibDir > libDirs = new HashSet < LibDir > ( ) ;
private String gccPath ;
private boolean objectFiles ;
private File destDir ;
private String output ;
private boolean verbose ;
@Override
public void execute ( ) throws BuildException
{
try
{
if ( verbose )
{
listFiles ( Project . MSG_INFO ) ;
}
else
{
listFiles ( Project . MSG_VERBOSE ) ;
}
Execute exec = new Execute ( ) ;
exec . <unk> ( getProject ( ) ) ;
exec . <unk> ( toArray ( buildCommand ( ) ) ) ;
logCommand ( exec ) ;
exec . setWorkingDirectory ( getExecDir ( ) ) ;
int sc = exec . execute ( ) ;
log ( " + sc ) ;
}
catch ( IOException e )
{
throw new BuildException ( e ) ;
}
}
private void logCommand ( Execute exec )
{
StringBuilder sb = new StringBuilder ( ) ;
for ( String s : exec . <unk> ( ) )
{
sb . append ( s ) ;
sb . append ( " ) ;
}
String cmd = sb . toString ( ) ;
if ( verbose )
{
log ( " , Project . MSG_INFO ) ;
log ( cmd , Project . MSG_INFO ) ;
}
else
{
log ( " , Project . MSG_VERBOSE ) ;
log ( cmd , Project . MSG_VERBOSE ) ;
}
}
private String [ ] toArray ( List < String > lst )
{
String [ ] array = new String [ lst . size ( ) ] ;
for ( int i = <num> ; i < lst . size ( ) ; i ++ )
{
array [ i ] = lst . get ( i ) ;
}
return array ;
}
@SuppressWarnings("unchecked")
private List < String > buildCommand ( ) throws IOException
{
List < String > cmd = new ArrayList < String > ( ) ;
if ( gccPath != null )
{
cmd . add ( gccPath ) ;
}
else
{
cmd . add ( " ) ;
}
if ( objectFiles )
{
cmd . add ( " ) ;
}
for ( LibDir ld : libDirs )
{
cmd . add ( " + ld . asFile ( ) . getCanonicalPath ( ) ) ;
}
if ( fileSets . isEmpty ( ) )
{
throw new BuildException ( " ) ;
}
for ( FileSet fs : fileSets )
{
for ( Iterator < Resource > iter = fs . iterator ( ) ; iter . hasNext ( ) ; )
{
cmd . add ( iter . next ( ) . toString ( ) ) ;
}
}
if ( ! objectFiles )
{
if ( output != null )
{
cmd . add ( " ) ;
cmd . add ( output ) ;
}
else
{
throw new BuildException ( " ) ;
}
}
return cmd ;
}
public void setVerbose ( boolean verbose )
{
this . verbose = verbose ;
}
public void setOutput ( String output )
{
this . output = output ;
}
public void <unk> ( File dir )
{
destDir = dir ;
}
public void <unk> ( String path )
{
this . gccPath = path ;
}
public void setObjectFiles ( boolean objectFiles )
{
this . objectFiles = objectFiles ;
}
public void addConfiguredFileSet ( FileSet fileSet )
{
fileSets . add ( fileSet ) ;
}
public void <unk> ( LibDir ld )
{
libDirs . add ( ld ) ;
}
private File getExecDir ( )
{
if ( destDir != null )
{
return destDir ;
}
else
{
return getProject ( ) . getBaseDir ( ) ;
}
}
@SuppressWarnings("unchecked")
private void listFiles ( int level ) throws IOException
{
log ( " , level ) ;
for ( LibDir ld : libDirs )
{
log ( ld . asFile ( ) . getCanonicalPath ( ) , level ) ;
}
log ( " , level ) ;
for ( FileSet fs : fileSets )
{
for ( Iterator < Resource > iter = fs . iterator ( ) ; iter . hasNext ( ) ; )
{
log ( iter . next ( ) . toString ( ) , level ) ;
}
}
}
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class Massa {
}
package com . phm . hf . pp . cap4 . pizzarias . impl ;
import com . phm . hf . pp . cap4 . Pizza ;
import com . phm . hf . pp . cap4 . fabrica . FabricaIngredientesPizza ;
import com . phm . hf . pp . cap4 . fabrica . impl . FabricaIngredientesPizzaCalifornia ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
import com . phm . hf . pp . cap4 . pizzarias . Pizzaria ;
import com . phm . hf . pp . cap4 . sabores . PizzaMoluscos ;
import com . phm . hf . pp . cap4 . sabores . PizzaPepperoni ;
import com . phm . hf . pp . cap4 . sabores . PizzaQueijo ;
import com . phm . hf . pp . cap4 . sabores . PizzaVegetais ;
public class PizzariaCalifornia extends Pizzaria {
@Override
protected Pizza criarPizza ( final TiposPizza pTipo ) {
Pizza pizza = null ;
final FabricaIngredientesPizza fabricaIngredientesPizza = new FabricaIngredientesPizzaCalifornia ( ) ;
if ( TiposPizza . QUEIJO == pTipo ) {
pizza = new PizzaQueijo ( fabricaIngredientesPizza ) ;
} if ( TiposPizza . PEPPERONI == pTipo ) {
pizza = new PizzaPepperoni ( fabricaIngredientesPizza ) ;
} if ( TiposPizza . MOLUSCOS == pTipo ) {
pizza = new PizzaMoluscos ( fabricaIngredientesPizza ) ;
} if ( TiposPizza . VEGETAIS == pTipo ) {
pizza = new PizzaVegetais ( fabricaIngredientesPizza ) ;
}
return pizza ;
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class MassaCrostaGrossa extends Massa {
}
package com . phm . hf . pp . cap4 . pizzarias . impl ;
import com . phm . hf . pp . cap4 . Pizza ;
import com . phm . hf . pp . cap4 . fabrica . FabricaIngredientesPizza ;
import com . phm . hf . pp . cap4 . fabrica . impl . FabricaIngredientesPizzaNY ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
import com . phm . hf . pp . cap4 . pizzarias . Pizzaria ;
import com . phm . hf . pp . cap4 . sabores . PizzaMoluscos ;
import com . phm . hf . pp . cap4 . sabores . PizzaPepperoni ;
import com . phm . hf . pp . cap4 . sabores . PizzaQueijo ;
import com . phm . hf . pp . cap4 . sabores . PizzaVegetais ;
public class PizzariaNY extends Pizzaria {
@Override
protected Pizza criarPizza ( final TiposPizza pTipo ) {
Pizza pizza = null ;
final FabricaIngredientesPizza fabricaIngredientesPizza = new FabricaIngredientesPizzaNY ( ) ;
if ( TiposPizza . QUEIJO == pTipo ) {
pizza = new PizzaQueijo ( fabricaIngredientesPizza ) ;
} if ( TiposPizza . PEPPERONI == pTipo ) {
pizza = new PizzaPepperoni ( fabricaIngredientesPizza ) ;
} if ( TiposPizza . MOLUSCOS == pTipo ) {
pizza = new PizzaMoluscos ( fabricaIngredientesPizza ) ;
} if ( TiposPizza . VEGETAIS == pTipo ) {
pizza = new PizzaVegetais ( fabricaIngredientesPizza ) ;
}
return pizza ;
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class Alho extends Vegetal {
}
package com . phm . hf . pp . cap4 . pizzarias . impl ;
import com . phm . hf . pp . cap4 . Pizza ;
import com . phm . hf . pp . cap4 . fabrica . FabricaIngredientesPizza ;
import com . phm . hf . pp . cap4 . fabrica . impl . FabricaIngredientesPizzaChicago ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
import com . phm . hf . pp . cap4 . pizzarias . Pizzaria ;
import com . phm . hf . pp . cap4 . sabores . PizzaMoluscos ;
import com . phm . hf . pp . cap4 . sabores . PizzaPepperoni ;
import com . phm . hf . pp . cap4 . sabores . PizzaQueijo ;
import com . phm . hf . pp . cap4 . sabores . PizzaVegetais ;
public class PizzariaChicago extends Pizzaria {
@Override
protected Pizza criarPizza ( final TiposPizza pTipo ) {
Pizza pizza = null ;
final FabricaIngredientesPizza fabricaIngredientesPizza = new FabricaIngredientesPizzaChicago ( ) ;
if ( TiposPizza . QUEIJO == pTipo ) {
pizza = new PizzaQueijo ( fabricaIngredientesPizza ) ;
} if ( TiposPizza . PEPPERONI == pTipo ) {
pizza = new PizzaPepperoni ( fabricaIngredientesPizza ) ;
} if ( TiposPizza . MOLUSCOS == pTipo ) {
pizza = new PizzaMoluscos ( fabricaIngredientesPizza ) ;
} if ( TiposPizza . VEGETAIS == pTipo ) {
pizza = new PizzaVegetais ( fabricaIngredientesPizza ) ;
}
return pizza ;
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class Cebola extends Vegetal {
}
package com . phm . hf . pp . cap4 . fabrica . impl ;
import com . phm . hf . pp . cap4 . fabrica . FabricaIngredientesPizza ;
import com . phm . hf . pp . cap4 . ingredientes . Alho ;
import com . phm . hf . pp . cap4 . ingredientes . Cebola ;
import com . phm . hf . pp . cap4 . ingredientes . Cogumelo ;
import com . phm . hf . pp . cap4 . ingredientes . Massa ;
import com . phm . hf . pp . cap4 . ingredientes . MassaCrostaGrossa ;
import com . phm . hf . pp . cap4 . ingredientes . Molho ;
import com . phm . hf . pp . cap4 . ingredientes . MolhoMarinara ;
import com . phm . hf . pp . cap4 . ingredientes . Molusco ;
import com . phm . hf . pp . cap4 . ingredientes . MoluscoFresco ;
import com . phm . hf . pp . cap4 . ingredientes . Pepperoni ;
import com . phm . hf . pp . cap4 . ingredientes . PepperoniFatiado ;
import com . phm . hf . pp . cap4 . ingredientes . PimentaVermelha ;
import com . phm . hf . pp . cap4 . ingredientes . Queijo ;
import com . phm . hf . pp . cap4 . ingredientes . QueijoReggiano ;
import com . phm . hf . pp . cap4 . ingredientes . Vegetal ;
public class FabricaIngredientesPizzaCalifornia implements FabricaIngredientesPizza {
public Massa criarMassa ( ) {
return new MassaCrostaGrossa ( ) ;
}
public Molho criarMolho ( ) {
return new MolhoMarinara ( ) ;
}
public Queijo criarQueijo ( ) {
return new QueijoReggiano ( ) ;
}
public Vegetal [ ] criarVegetal ( ) {
Vegetal [ ] vegetals = { new Alho ( ) , new Cebola ( ) , new Cogumelo ( ) , new PimentaVermelha ( ) } ;
return vegetals ;
}
public Pepperoni criarPepperoni ( ) {
return new PepperoniFatiado ( ) ;
}
public Molusco criarMolusco ( ) {
return new MoluscoFresco ( ) ;
}
}
package com . phm . hf . pp . cap4 . sabores ;
import com . phm . hf . pp . cap4 . Pizza ;
import com . phm . hf . pp . cap4 . fabrica . FabricaIngredientesPizza ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
public class PizzaPepperoni extends Pizza {
FabricaIngredientesPizza fabricaIngredientesPizza ;
public PizzaPepperoni ( FabricaIngredientesPizza pFabricaIngredientesPizza ) {
fabricaIngredientesPizza = pFabricaIngredientesPizza ;
}
@Override
public void preparar ( ) {
setTipo ( TiposPizza . PEPPERONI ) ;
setNome ( " ) ;
setMassa ( fabricaIngredientesPizza . criarMassa ( ) ) ;
setMolho ( fabricaIngredientesPizza . criarMolho ( ) ) ;
setVegetals ( fabricaIngredientesPizza . criarVegetal ( ) ) ;
setQueijo ( fabricaIngredientesPizza . criarQueijo ( ) ) ;
setPepperoni ( fabricaIngredientesPizza . criarPepperoni ( ) ) ;
setMolusco ( fabricaIngredientesPizza . criarMolusco ( ) ) ;
}
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class Queijo {
}
package com . phm . hf . pp . cap4 . pizzarias ;
import com . phm . hf . pp . cap4 . Pizza ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
public abstract class Pizzaria {
public Pizza encomendaPizza ( final TiposPizza pTipo ) {
Pizza pizza = criarPizza ( pTipo ) ;
pizza . preparar ( ) ;
pizza . assar ( ) ;
pizza . cortar ( ) ;
pizza . encaixotar ( ) ;
return pizza ;
}
protected abstract Pizza criarPizza ( final TiposPizza pTipo ) ;
package com . phm . hf . pp . cap4 . ingredientes ;
public class PimentaVermelha extends Vegetal {
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class Vegetal {
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class Cogumelo extends Vegetal {
}
package com . phm . hf . pp . cap4 . fabrica ;
import com . phm . hf . pp . cap4 . ingredientes . Massa ;
import com . phm . hf . pp . cap4 . ingredientes . Molho ;
import com . phm . hf . pp . cap4 . ingredientes . Molusco ;
import com . phm . hf . pp . cap4 . ingredientes . Pepperoni ;
import com . phm . hf . pp . cap4 . ingredientes . Queijo ;
import com . phm . hf . pp . cap4 . ingredientes . Vegetal ;
public interface FabricaIngredientesPizza {
Massa criarMassa ( ) ;
Molho criarMolho ( ) ;
Queijo criarQueijo ( ) ;
Vegetal [ ] criarVegetal ( ) ;
Pepperoni criarPepperoni ( ) ;
Molusco criarMolusco ( ) ;
}
package com . phm . hf . pp . cap4 . fabrica . impl ;
import com . phm . hf . pp . cap4 . fabrica . FabricaIngredientesPizza ;
import com . phm . hf . pp . cap4 . ingredientes . Alho ;
import com . phm . hf . pp . cap4 . ingredientes . Cebola ;
import com . phm . hf . pp . cap4 . ingredientes . Cogumelo ;
import com . phm . hf . pp . cap4 . ingredientes . Massa ;
import com . phm . hf . pp . cap4 . ingredientes . MassaCrostaFina ;
import com . phm . hf . pp . cap4 . ingredientes . Molho ;
import com . phm . hf . pp . cap4 . ingredientes . MolhoMarinara ;
import com . phm . hf . pp . cap4 . ingredientes . Molusco ;
import com . phm . hf . pp . cap4 . ingredientes . MoluscoFresco ;
import com . phm . hf . pp . cap4 . ingredientes . Pepperoni ;
import com . phm . hf . pp . cap4 . ingredientes . PepperoniFatiado ;
import com . phm . hf . pp . cap4 . ingredientes . PimentaVermelha ;
import com . phm . hf . pp . cap4 . ingredientes . Queijo ;
import com . phm . hf . pp . cap4 . ingredientes . QueijoReggiano ;
import com . phm . hf . pp . cap4 . ingredientes . Vegetal ;
public class FabricaIngredientesPizzaNY implements FabricaIngredientesPizza {
public Massa criarMassa ( ) {
return new MassaCrostaFina ( ) ;
}
public Molho criarMolho ( ) {
return new MolhoMarinara ( ) ;
}
public Queijo criarQueijo ( ) {
return new QueijoReggiano ( ) ;
}
public Vegetal [ ] criarVegetal ( ) {
Vegetal [ ] vegetals = { new Alho ( ) , new Cebola ( ) , new Cogumelo ( ) , new PimentaVermelha ( ) } ;
return vegetals ;
}
public Pepperoni criarPepperoni ( ) {
return new PepperoniFatiado ( ) ;
}
public Molusco criarMolusco ( ) {
return new MoluscoFresco ( ) ;
}
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class QueijoReggiano extends Queijo {
}
package com . phm . hf . pp . cap4 ;
import com . phm . hf . pp . cap4 . Pizza ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
import com . phm . hf . pp . cap4 . pizzarias . Pizzaria ;
import com . phm . hf . pp . cap4 . pizzarias . impl . PizzariaCalifornia ;
import com . phm . hf . pp . cap4 . pizzarias . impl . PizzariaChicago ;
import com . phm . hf . pp . cap4 . pizzarias . impl . PizzariaNY ;
public class <unk> {
public static void main ( String [ ] args ) {
final Pizzaria pizzariaNy = new PizzariaNY ( ) ;
Pizza pizza = pizzariaNy . encomendaPizza ( TiposPizza . QUEIJO ) ;
System . out . println ( pizza . getNome ( ) ) ;
final Pizzaria pizzariaChicago = new PizzariaChicago ( ) ;
pizza = pizzariaChicago . encomendaPizza ( TiposPizza . QUEIJO ) ;
System . out . println ( pizza . getNome ( ) ) ;
final Pizzaria pizzariaCalifornia = new PizzariaCalifornia ( ) ;
pizza = pizzariaCalifornia . encomendaPizza ( TiposPizza . QUEIJO ) ;
System . out . println ( pizza . getNome ( ) ) ;
}
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class MolhoMarinara extends Molho {
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class MassaCrostaFina extends Massa {
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class PepperoniFatiado extends Pepperoni {
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class Molusco {
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class Molho {
}
package com . phm . hf . pp . cap4 . sabores ;
import com . phm . hf . pp . cap4 . Pizza ;
import com . phm . hf . pp . cap4 . fabrica . FabricaIngredientesPizza ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
public class PizzaMoluscos extends Pizza {
FabricaIngredientesPizza fabricaIngredientesPizza ;
public PizzaMoluscos ( FabricaIngredientesPizza pFabricaIngredientesPizza ) {
fabricaIngredientesPizza = pFabricaIngredientesPizza ;
}
@Override
public void preparar ( ) {
setTipo ( TiposPizza . MOLUSCOS ) ;
setNome ( " ) ;
setMassa ( fabricaIngredientesPizza . criarMassa ( ) ) ;
setMolho ( fabricaIngredientesPizza . criarMolho ( ) ) ;
setVegetals ( fabricaIngredientesPizza . criarVegetal ( ) ) ;
setQueijo ( fabricaIngredientesPizza . criarQueijo ( ) ) ;
setPepperoni ( fabricaIngredientesPizza . criarPepperoni ( ) ) ;
setMolusco ( fabricaIngredientesPizza . criarMolusco ( ) ) ;
}
}
package com . phm . hf . pp . cap4 ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
import com . phm . hf . pp . cap4 . pizzarias . Pizzaria ;
import com . phm . hf . pp . cap4 . pizzarias . impl . PizzariaNY ;
public class <unk> {
public static void main ( String [ ] args ) {
Pizzaria mypizzaStore = new PizzariaNY ( ) ;
mypizzaStore . encomendaPizza ( TiposPizza . QUEIJO ) ;
}
}
package com . phm . hf . pp . cap4 . sabores ;
import com . phm . hf . pp . cap4 . Pizza ;
import com . phm . hf . pp . cap4 . fabrica . FabricaIngredientesPizza ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
public class PizzaQueijo extends Pizza {
FabricaIngredientesPizza fabricaIngredientesPizza ;
public PizzaQueijo ( FabricaIngredientesPizza pFabricaIngredientesPizza ) {
fabricaIngredientesPizza = pFabricaIngredientesPizza ;
}
@Override
public void preparar ( ) {
setTipo ( TiposPizza . QUEIJO ) ;
setNome ( " ) ;
setMassa ( fabricaIngredientesPizza . criarMassa ( ) ) ;
setMolho ( fabricaIngredientesPizza . criarMolho ( ) ) ;
setVegetals ( fabricaIngredientesPizza . criarVegetal ( ) ) ;
setQueijo ( fabricaIngredientesPizza . criarQueijo ( ) ) ;
setPepperoni ( fabricaIngredientesPizza . criarPepperoni ( ) ) ;
setMolusco ( fabricaIngredientesPizza . criarMolusco ( ) ) ;
}
}
package com . phm . hf . pp . cap4 . ingredientes ;
public enum TiposPizza {
QUEIJO ( " ) {
@Override
public String toString ( ) {
return this . getTipo ( ) ;
}
} ,
PEPPERONI ( " ) {
@Override
public String toString ( ) {
return this . getTipo ( ) ;
}
} ,
MOLUSCOS ( " ) {
@Override
public String toString ( ) {
return this . getTipo ( ) ;
}
} ,
VEGETAIS ( " ) {
@Override
public String toString ( ) {
return this . getTipo ( ) ;
}
} ;
private String tipo ;
TiposPizza ( final String pTipo ) {
String tipoTemp = null ;
if ( pTipo != null ) {
tipoTemp = pTipo . toLowerCase ( ) ;
}
this . tipo = tipoTemp ;
}
public String getTipo ( ) {
return this . tipo ;
}
package com . phm . hf . pp . cap4 ;
import com . phm . hf . pp . cap4 . ingredientes . Massa ;
import com . phm . hf . pp . cap4 . ingredientes . Molho ;
import com . phm . hf . pp . cap4 . ingredientes . Molusco ;
import com . phm . hf . pp . cap4 . ingredientes . Pepperoni ;
import com . phm . hf . pp . cap4 . ingredientes . Queijo ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
import com . phm . hf . pp . cap4 . ingredientes . Vegetal ;
public abstract class Pizza {
private TiposPizza tipo ;
private String nome ;
private Massa massa ;
private Molho molho ;
private Vegetal [ ] vegetals ;
private Queijo queijo ;
private Pepperoni pepperoni ;
private Molusco molusco ;
public abstract void preparar ( ) ;
public void assar ( ) {
System . out . println ( " ) ;
}
public void cortar ( ) {
System . out . println ( " ) ;
}
public void encaixotar ( ) {
System . out . println ( " ) ;
}
public String getNome ( ) {
return nome ;
}
public void setNome ( String nome ) {
this . nome = nome ;
}
public TiposPizza getTipo ( ) {
return tipo ;
}
public Massa <unk> ( ) {
return massa ;
}
public void setMassa ( Massa massa ) {
this . massa = massa ;
}
public Molho <unk> ( ) {
return molho ;
}
public void setMolho ( Molho molho ) {
this . molho = molho ;
}
public Vegetal [ ] <unk> ( ) {
return vegetals ;
}
public void setVegetals ( Vegetal [ ] vegetals ) {
this . vegetals = vegetals ;
}
public Queijo <unk> ( ) {
return queijo ;
}
public void setQueijo ( Queijo queijo ) {
this . queijo = queijo ;
}
public Pepperoni <unk> ( ) {
return pepperoni ;
}
public void setPepperoni ( Pepperoni pepperoni ) {
this . pepperoni = pepperoni ;
}
public Molusco <unk> ( ) {
return molusco ;
}
public void setMolusco ( Molusco molusco ) {
this . molusco = molusco ;
}
public void setTipo ( TiposPizza tipo ) {
this . tipo = tipo ;
}
package com . phm . hf . pp . cap4 . sabores ;
import com . phm . hf . pp . cap4 . Pizza ;
import com . phm . hf . pp . cap4 . fabrica . FabricaIngredientesPizza ;
import com . phm . hf . pp . cap4 . ingredientes . TiposPizza ;
public class PizzaVegetais extends Pizza {
FabricaIngredientesPizza fabricaIngredientesPizza ;
public PizzaVegetais ( FabricaIngredientesPizza pFabricaIngredientesPizza ) {
fabricaIngredientesPizza = pFabricaIngredientesPizza ;
}
@Override
public void preparar ( ) {
setTipo ( TiposPizza . VEGETAIS ) ;
setNome ( " ) ;
setMassa ( fabricaIngredientesPizza . criarMassa ( ) ) ;
setMolho ( fabricaIngredientesPizza . criarMolho ( ) ) ;
setVegetals ( fabricaIngredientesPizza . criarVegetal ( ) ) ;
setQueijo ( fabricaIngredientesPizza . criarQueijo ( ) ) ;
setPepperoni ( fabricaIngredientesPizza . criarPepperoni ( ) ) ;
setMolusco ( fabricaIngredientesPizza . criarMolusco ( ) ) ;
}
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class Pepperoni {
}
package com . phm . hf . pp . cap4 . ingredientes ;
public class MoluscoFresco extends Molusco {
}
package com . phm . hf . pp . cap4 . fabrica . impl ;
import com . phm . hf . pp . cap4 . fabrica . FabricaIngredientesPizza ;
import com . phm . hf . pp . cap4 . ingredientes . Alho ;
import com . phm . hf . pp . cap4 . ingredientes . Cebola ;
import com . phm . hf . pp . cap4 . ingredientes . Cogumelo ;
import com . phm . hf . pp . cap4 . ingredientes . Massa ;
import com . phm . hf . pp . cap4 . ingredientes . MassaCrostaGrossa ;
import com . phm . hf . pp . cap4 . ingredientes . Molho ;
import com . phm . hf . pp . cap4 . ingredientes . MolhoMarinara ;
import com . phm . hf . pp . cap4 . ingredientes . Molusco ;
import com . phm . hf . pp . cap4 . ingredientes . MoluscoFresco ;
import com . phm . hf . pp . cap4 . ingredientes . Pepperoni ;
import com . phm . hf . pp . cap4 . ingredientes . PepperoniFatiado ;
import com . phm . hf . pp . cap4 . ingredientes . PimentaVermelha ;
import com . phm . hf . pp . cap4 . ingredientes . Queijo ;
import com . phm . hf . pp . cap4 . ingredientes . QueijoReggiano ;
import com . phm . hf . pp . cap4 . ingredientes . Vegetal ;
public class FabricaIngredientesPizzaChicago implements FabricaIngredientesPizza {
public Massa criarMassa ( ) {
return new MassaCrostaGrossa ( ) ;
}
public Molho criarMolho ( ) {
return new MolhoMarinara ( ) ;
}
public Queijo criarQueijo ( ) {
return new QueijoReggiano ( ) ;
}
public Vegetal [ ] criarVegetal ( ) {
Vegetal [ ] vegetals = { new Alho ( ) , new Cebola ( ) , new Cogumelo ( ) , new PimentaVermelha ( ) } ;
return vegetals ;
}
public Pepperoni criarPepperoni ( ) {
return new PepperoniFatiado ( ) ;
}
public Molusco criarMolusco ( ) {
return new MoluscoFresco ( ) ;
}
}
import java . awt . * ;
import javax . swing . * ;
import java . util . ArrayList ;
import TSP . * ;
public class <unk> {
public static void main ( String [ ] args )
{
JFrame graph = new JFrame ( " ) ;
ArrayList < GraphVertex > points = new ArrayList < GraphVertex > ( ) ;
points . add ( new GraphVertex ( <num> , <num> ) ) ;
points . add ( new GraphVertex ( <num> , <num> ) ) ;
points . add ( new GraphVertex ( <num> , <num> ) ) ;
points . add ( new GraphVertex ( <num> , <num> ) ) ;
points . add ( new GraphVertex ( <num> , <num> ) ) ;
Grapher plot = new Grapher ( points ) ;
Dimension d = new Dimension ( <num> , <num> ) ;
graph . setPreferredSize ( d ) ;
graph . getContentPane ( ) . add ( plot ) ;
graph . pack ( ) ;
graph . setVisible ( true ) ;
}
}
package TSP ;
import java . util . ArrayList ;
public class TSP
{
public static ArrayList < GraphVertex > generateTSP ( MinSpanTree MST )
{
ArrayList < GraphVertex > verts = MST . getVerticies ( ) ;
double dist = <num> ;
ArrayList < GraphVertex > tsp = new ArrayList < GraphVertex > ( ) ;
for ( GraphVertex gv : verts )
{
gv . Marked = false ;
}
recurTSP ( verts . get ( <num> ) , tsp ) ;
tsp . add ( verts . get ( <num> ) ) ;
GraphVertex last = verts . get ( <num> ) ;
boolean first = true ;
for ( GraphVertex gv : tsp )
{
if ( first ) { first = false ; continue ; }
dist += last . distanceTo ( gv ) ;
last = gv ;
}
System . out . println ( " + dist + " ) ;
return tsp ;
}
private static void recurTSP ( GraphVertex par , ArrayList < GraphVertex > tsp )
{
par . Marked = true ;
tsp . add ( par ) ;
for ( GraphVertex gv : par . getConnected ( ) )
{
if ( ! gv . Marked )
{
recurTSP ( gv , tsp ) ;
}
}
}
}
import TSP . GraphVertex ;
import TSP . Grapher ;
import java . awt . Dimension ;
import java . util . ArrayList ;
import javax . swing . JFrame ;
import java . util . Random ;
public class <unk> {
public static void main ( String [ ] args )
{
int n = <num> ;
if ( args . length >= <num> )
{
n = Integer . parseInt ( args [ <num> ] ) ;
}
JFrame graph = new JFrame ( " ) ;
ArrayList < GraphVertex > points = new ArrayList < GraphVertex > ( ) ;
Random r = new Random ( ) ;
for ( int i = <num> ; i < n ; i ++ )
{
points . add ( new GraphVertex ( r . nextInt ( <num> ) + <num> , r . nextInt ( <num> ) + <num> ) ) ;
}
Grapher plot = new Grapher ( points ) ;
Dimension d = new Dimension ( <num> , <num> ) ;
graph . setPreferredSize ( d ) ;
graph . getContentPane ( ) . add ( plot ) ;
graph . pack ( ) ;
graph . setVisible ( true ) ;
}
}
package TSP ;
import java . util . ArrayList ;
import java . awt . * ;
public class GraphVertex
{
private Point p ;
private ArrayList < GraphVertex > conn ;
public boolean Marked = false ;
public GraphVertex ( int x , int y )
{
conn = new ArrayList < GraphVertex > ( ) ;
p = new Point ( x , y ) ;
}
public void connectTo ( GraphVertex gv )
{
gv . conn . add ( this ) ;
conn . add ( gv ) ;
}
public double distanceTo ( GraphVertex gv )
{
return p . distance ( gv . p ) ;
}
public Point getLocation ( )
{
return p ;
}
public ArrayList < GraphVertex > getConnected ( )
{
return conn ;
}
}
package TSP ;
import java . util . ArrayList ;
import java . util . List ;
import java . awt . * ;
public class MinSpanTree
{
private ArrayList < GraphVertex > verts ;
private double [ ] Queue ;
private int [ ] Parent ;
public MinSpanTree ( ArrayList < GraphVertex > Vertices )
{
verts = Vertices ;
Queue = new double [ verts . size ( ) ] ;
Parent = new int [ verts . size ( ) ] ;
}
public void generateTree ( )
{
for ( int i = <num> ; i < verts . size ( ) ; i ++ )
{
Queue [ i ] = Double . MAX_VALUE ;
Parent [ i ] =  <num> ;
verts . get ( i ) . Marked = false ;
}
addNode ( <num> ) ;
}
private int addNode ( int par )
{
GraphVertex p = verts . get ( par ) ;
p . Marked = true ;
int unmarked = <num> ;
double t_min ;
GraphVertex gv ;
for ( int i = <num> ; i < verts . size ( ) ; i ++ )
{
if ( i == par ) continue ;
gv = verts . get ( i ) ;
if ( ! gv . Marked )
{
unmarked ++ ;
t_min = p . distanceTo ( gv ) ;
if ( t_min < Queue [ i ] )
{
Parent [ i ] = par ;
Queue [ i ] = t_min ;
}
}
}
double minQ = Double . MAX_VALUE ;
int minI =  <num> ;
for ( int i = <num> ; i < verts . size ( ) ; i ++ )
{
if ( Queue [ i ] < minQ )
{
minI = i ;
minQ = Queue [ i ] ;
}
}
GraphVertex conn_par = verts . get ( Parent [ minI ] ) ;
GraphVertex conn_child = verts . get ( minI ) ;
Queue [ minI ] = Double . MAX_VALUE ;
conn_child . connectTo ( conn_par ) ;
conn_child . Marked = true ;
unmarked  ;
if ( unmarked > <num> )
{
addNode ( minI ) ;
}
return unmarked ;
}
public ArrayList < GraphVertex > getVerticies ( )
{
return verts ;
}
}
package TSP ;
import java . util . ArrayList ;
import java . awt . * ;
import javax . swing . * ;
public class Grapher extends JPanel
{
public int POINT_SIZE = <num> ;
ArrayList < GraphVertex > verts = new ArrayList < GraphVertex > ( ) ;
ArrayList < GraphVertex > TSPath ;
public Grapher ( ArrayList < GraphVertex > vertices )
{
verts = vertices ;
MinSpanTree mst = new MinSpanTree ( verts ) ;
mst . generateTree ( ) ;
TSPath = TSP . generateTSP ( mst ) ;
}
public void paintComponent ( Graphics g )
{
super . paintComponent ( g ) ;
g . setColor ( Color . white ) ;
g . fillRect ( <num> , <num> , this . getWidth ( ) , this . getHeight ( ) ) ;
g . setColor ( Color . blue ) ;
for ( GraphVertex gv : verts )
{
Point p = gv . getLocation ( ) ;
g . drawOval ( p . x  POINT_SIZE / <num> , p . y  POINT_SIZE / <num> , POINT_SIZE , POINT_SIZE ) ;
}
graphTSP ( g ) ;
graphMST ( g ) ;
}
private void graphMST ( Graphics g )
{
g . setColor ( Color . black ) ;
for ( GraphVertex gv : verts )
{
gv . Marked = false ;
}
graphDFS ( g , verts . get ( <num> ) ) ;
}
private void graphDFS ( Graphics g , GraphVertex par )
{
par . Marked = true ;
for ( GraphVertex gv : par . getConnected ( ) )
{
if ( ! gv . Marked )
{
g . drawLine ( par . getLocation ( ) . x , par . getLocation ( ) . y , gv . getLocation ( ) . x , gv . getLocation ( ) . y ) ;
graphDFS ( g , gv ) ;
}
}
}
private void graphTSP ( Graphics g )
{
Graphics2D g2d = ( Graphics2D ) g ;
g2d . setStroke ( new BasicStroke ( <num> ) ) ;
g2d . setColor ( new Color ( <num> , <num> , <num> , <num> ) ) ;
GraphVertex last = verts . get ( <num> ) ;
boolean first = true ;
for ( GraphVertex gv : TSPath )
{
if ( first ) { first = false ; continue ; }
g2d . drawLine ( gv . getLocation ( ) . x , gv . getLocation ( ) . y , last . getLocation ( ) . x , last . getLocation ( ) . y ) ;
last = gv ;
}
g2d . setStroke ( new BasicStroke ( <num> ) ) ;
}
}
package com . laukien . bean . html2gallery ;
import com . laukien . bean . BeanInfo ;
public class <unk> extends BeanInfo {
public String getName ( ) {
return " ;
}
}
package com . laukien . bean . html2gallery ;
import java . io . BufferedReader ;
import java . io . File ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . io . IOException ;
import java . io . InputStreamReader ;
import com . laukien . array . Add ;
class Filter {
private String [ ] gFilters ;
private int gSize ;
public Filter ( String pName , String pPath ) throws IOException {
gFilters = new String [ ] { } ;
if ( com . laukien . string . String . isEmpty ( pName ) ) return ;
String path = pPath ;
if ( path == null ) path = " ;
else if ( path . length ( ) > <num> && path . charAt ( path . length ( )  <num> ) != File . separatorChar ) path += File . separatorChar ;
BufferedReader br = null ;
String line = null ;
try {
br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( path + pName + " ) ) ) ;
while ( ( line = br . readLine ( ) ) != null ) {
line = line . trim ( ) ;
if ( line . length ( ) == <num> ) continue ;
gFilters = ( String [ ] ) Add . <unk> ( String . class , gFilters , line ) ;
}
} catch ( FileNotFoundException e ) {
gFilters = new String [ ] { } ;
e . printStackTrace ( ) ;
} finally {
try {
if ( br != null ) br . close ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
gSize = gFilters . length ;
}
public boolean accept ( String pImageURL ) {
for ( int i = <num> ; i < gSize ; i ++ ) {
if ( pImageURL . indexOf ( gFilters [ i ] ) !=  <num> ) return false ;
}
return true ;
}
public int size ( ) {
return gSize ;
}
}
import java . io . File ;
import java . io . IOException ;
import java . util . Vector ;
import com . laukien . bean . html2gallery . Html2Gallery ;
public class <unk> {
public static void main ( String [ ] args ) throws IOException {
Html2Gallery forum = new Html2Gallery ( " , " ) ;
if ( ! new File ( " ) . exists ( ) ) forum . setFilterPath ( " ) ;
forum . read ( ) ;
Vector gallery = forum . getList ( ) ;
System . out . println ( " + forum . getSize ( ) ) ;
for ( int i = <num> ; i < gallery . size ( ) ; i ++ ) {
System . out . println ( ( String ) gallery . get ( i ) ) ;
}
}
}
package com . laukien . bean . html2gallery ;
import com . laukien . exception . ParameterException ;
class ExtractImage {
private String gString ;
public ExtractImage ( ) {
gString = null ;
}
public void setString ( String pString ) {
if ( pString == null ) throw new ParameterException ( " ) ;
gString = pString ;
}
public boolean isImage ( ) {
return ( gString . indexOf ( " ) !=  <num> ) ;
}
public String getImageTag ( ) {
int start = gString . indexOf ( " ) ;
if ( start ==  <num> ) return null ;
int end = gString . indexOf ( " , start ) ;
return gString . substring ( start , end + <num> ) ;
}
public String getImageURL ( ) {
String tag = getImageTag ( ) ;
if ( tag == null ) return null ;
int start = gString . indexOf ( " ) ;
if ( start ==  <num> ) return null ;
int end = gString . indexOf ( " , start + <num> ) ;
return gString . substring ( start + <num> , end ) ;
}
public static boolean isTemplate ( String address ) {
return address . startsWith ( " ) ;
}
public static boolean isJpeg ( String address ) {
return address . endsWith ( " ) ;
}
}
package com . laukien . bean . html2gallery ;
import java . io . IOException ;
import java . util . Hashtable ;
import java . util . Vector ;
import com . laukien . exception . ParameterException ;
public class Html2Gallery {
private static Hashtable gsCache ;
private String gURL ;
private Vector gImages ;
private String gFilterName ;
private String gFilterPath ;
static {
init ( ) ;
}
private synchronized static void init ( ) {
gsCache = new Hashtable ( ) ;
}
public synchronized static void reload ( ) {
synchronized ( gsCache ) {
gsCache . clear ( ) ;
}
}
public Html2Gallery ( ) {
gURL = null ;
gFilterName = null ;
gFilterPath = null ;
gImages = null ;
}
public Html2Gallery ( String pURL ) throws IOException {
this ( ) ;
gURL = pURL ;
}
public Html2Gallery ( String pURL , String pFilterName ) throws IOException {
this ( ) ;
gURL = pURL ;
gFilterName = pFilterName ;
}
public void setURL ( String pURL ) {
gURL = pURL ;
}
public void <unk> ( String pFilterName ) {
gFilterName = pFilterName ;
}
public void setFilterPath ( String pFilterPath ) {
gFilterPath = pFilterPath ;
}
public Vector read ( ) throws IOException {
if ( gURL == null ) throw new ParameterException ( " ) ;
gImages = new Vector ( ) ;
synchronized ( gsCache ) {
gImages = ( Vector ) gsCache . get ( gURL ) ;
if ( gImages == null ) {
gImages = new Vector ( ) ;
Filter filter = new Filter ( gFilterName , gFilterPath ) ;
String line , address ;
ExtractImage img = new ExtractImage ( ) ;
Content content = null ;
try {
content = new Content ( ) ;
content . setURL ( gURL ) ;
content . open ( ) ;
while ( ( line = content . getLine ( ) ) != null ) {
img . setString ( line ) ;
if ( ! img . isImage ( ) ) continue ;
address = img . getImageURL ( ) ;
if ( address == null || ExtractImage . isTemplate ( address ) || ! ExtractImage . isJpeg ( address ) || ! filter . accept ( address ) ) continue ;
gImages . add ( address ) ;
}
} catch ( IOException e ) {
throw new IOException ( " + e ) ;
} finally {
if ( content != null ) content . close ( ) ;
}
gsCache . put ( gURL , gImages ) ;
}
}
return gImages ;
}
public Vector getList ( ) {
return gImages ;
}
public int getSize ( ) {
return gImages == null ?  <num> : gImages . size ( ) ;
}
}
package com . laukien . bean . html2gallery ;
import java . io . BufferedReader ;
import java . io . IOException ;
import java . io . InputStreamReader ;
import java . net . MalformedURLException ;
import java . net . URL ;
import java . net . URLConnection ;
import com . laukien . exception . ParameterException ;
class Content {
URL gURL ;
private BufferedReader gBR ;
public void setURL ( String pURL ) {
try {
gURL = new URL ( pURL ) ;
} catch ( MalformedURLException e ) {
throw new ParameterException ( " + e ) ;
}
}
public void open ( ) throws IOException {
URLConnection conn = gURL . openConnection ( ) ;
gBR = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) ) ) ;
}
public void close ( ) throws IOException {
gBR . close ( ) ;
}
public String getLine ( ) throws IOException {
return gBR . readLine ( ) ;
}
}
package me . tomsaksa . goodnight ;
import java . util . logging . Logger ;
import org . bukkit . plugin . PluginDescriptionFile ;
import org . bukkit . plugin . PluginManager ;
import org . bukkit . plugin . java . JavaPlugin ;
public class GoodnightPlugin extends JavaPlugin {
public static GoodnightPlugin plugin ;
public final Logger logger = Logger . getLogger ( " ) ;
public final MessageListener MessageListener = new MessageListener ( this ) ;
@Override
public void onDisable ( ) {
PluginDescriptionFile pdfFile = this . getDescription ( ) ;
this . logger . info ( pdfFile . getName ( ) + " ) ;
}
@Override
public void onEnable ( ) {
PluginManager pm = getServer ( ) . getPluginManager ( ) ;
pm . registerEvents ( this . MessageListener , this ) ;
PluginDescriptionFile pdfFile = this . getDescription ( ) ;
this . logger . info ( pdfFile . getName ( ) + " + pdfFile . getVersion ( ) + " ) ;
}
}
package me . tomsaksa . goodnight ;
import org . bukkit . ChatColor ;
import org . bukkit . entity . Player ;
import org . bukkit . event . EventHandler ;
import org . bukkit . event . Listener ;
import org . bukkit . event . player . PlayerChatEvent ;
public class MessageListener implements Listener {
public static GoodnightPlugin plugin ;
public MessageListener ( GoodnightPlugin event ) {
plugin = event ;
}
@EventHandler
public void onPlayerChat ( PlayerChatEvent chat ) {
Player p = chat . getPlayer ( ) ;
String message = chat . getMessage ( ) ;
String message_lower = message . toLowerCase ( ) ;
ChatColor RED = ChatColor . RED ;
ChatColor WHITE = ChatColor . WHITE ;
if ( message_lower . contains ( " ) && message_lower . contains ( " ) ) {
p . sendMessage ( RED + " + WHITE + " + p . getName ( ) ) ;
chat . setCancelled ( true ) ;
}
}
}
package eu . danman . mediacenter ;
import java . io . StringReader ;
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import org . w3c . dom . Document ;
import org . w3c . dom . Element ;
import org . w3c . dom . NodeList ;
import org . xml . sax . InputSource ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . text . Html ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . AdapterView . OnItemLongClickListener ;
import android . widget . ImageView ;
import android . widget . ListView ;
import android . widget . SimpleAdapter ;
import android . widget . TextView ;
public class PlaylistActivity extends Activity {
ImageView img ;
TextView title ;
TextView desc ;
MediaCenter global ;
ListView list ;
XMLParser parser ;
NodeList playlist ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . playlist ) ;
img = ( ImageView ) findViewById ( R . id . imgIcon ) ;
title = ( TextView ) findViewById ( R . id . textTitle ) ;
desc = ( TextView ) findViewById ( R . id . textDesc ) ;
list = ( ListView ) findViewById ( R . id . listItems ) ;
global = ( MediaCenter ) getApplicationContext ( ) ;
Bundle bundle = this . getIntent ( ) . getExtras ( ) ;
final String playlistURL = bundle . getString ( " ) ;
String <unk> = bundle . getString ( " ) ;
parser = new XMLParser ( ) ;
String xml = global . get ( playlistURL ) ;
if ( ! ( xml . contains ( " ) ) ) {
finish ( ) ;
return ;
}
InputSource is = new InputSource ( ) ;
is . setCharacterStream ( new StringReader ( xml ) ) ;
Document doc = parser . getDomElement ( is ) ;
playlist = doc . getElementsByTagName ( " ) ;
List < HashMap < String , String >> fillMaps = new ArrayList < HashMap < String , String >> ( ) ;
for ( int i = <num> ; i < playlist . getLength ( ) ; i ++ ) {
HashMap < String , String > map = new HashMap < String , String > ( ) ;
map . put ( " , " + i ) ;
map . put ( " , parser . getValue ( ( Element ) playlist . item ( i ) , " ) ) ;
map . put ( " , parser . getValue ( ( Element ) playlist . item ( i ) , " ) ) ;
fillMaps . add ( map ) ;
}
String [ ] from = new String [ ] { " , " } ;
int [ ] to = new int [ ] { R . id . itemTitle , R . id . itemDesc } ;
SimpleAdapter adapter = new SimpleAdapter ( this , fillMaps , R . layout . plitem , from , to ) ;
list . setAdapter ( adapter ) ;
list . setOnItemLongClickListener ( new OnItemLongClickListener ( ) {
public boolean onItemLongClick ( AdapterView adapterView , View view , int position , long id ) {
Bundle bundle = new Bundle ( ) ;
bundle . putString ( " , playlistURL ) ;
bundle . putInt ( " , position ) ;
Intent myIntent = new Intent ( getBaseContext ( ) , PlayerActivity . class ) ;
myIntent . putExtras ( bundle ) ;
startActivity ( myIntent ) ;
return true ;
}
} ) ;
list . setOnItemClickListener ( new OnItemClickListener ( ) {
public void onItemClick ( AdapterView adapterView , View view , int position , long id ) {
showItem ( position ) ;
}
} ) ;
}
private void showItem ( int num ) {
title . setText ( parser . getValue ( ( Element ) playlist . item ( num ) , " ) ) ;
img . setImageBitmap ( global . getLogoBitmap ( parser . getValue ( ( Element ) playlist . item ( num ) , " ) ) ) ;
String desctxt = parser . getValue ( ( Element ) playlist . item ( num ) , " ) ;
desctxt = desctxt . replace ( " , " ) ;
desctxt = desctxt . replace ( " , " ) ;
desc . setText ( desctxt ) ;
}
}
package eu . danman . mediacenter ;
import android . app . Activity ;
import android . app . Dialog ;
import java . io . StringReader ;
import org . w3c . dom . Document ;
import org . w3c . dom . Element ;
import org . w3c . dom . NamedNodeMap ;
import org . w3c . dom . NodeList ;
import org . xml . sax . InputSource ;
import eu . danman . mediacenter . MediaCenter . programmeType ;
import android . content . Intent ;
import android . os . Bundle ;
import android . os . Handler ;
import android . text . format . Time ;
import android . util . Log ;
import android . view . Gravity ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . view . ViewGroup ;
import android . widget . Button ;
import android . widget . HorizontalScrollView ;
import android . widget . ImageView ;
import android . widget . LinearLayout ;
import android . widget . RelativeLayout ;
import android . widget . TextView ;
public class EPGActivity extends Activity {
Document xmlEPG ;
private int scroll_px ;
Dialog mDialog ;
MediaCenter global ;
Handler handler ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . epg ) ;
global = ( ( MediaCenter ) getApplicationContext ( ) ) ;
handler = new Handler ( ) ;
Runnable render = new Runnable ( ) {
public void run ( ) {
Time now = new Time ( ) ;
now . setToNow ( ) ;
loadEPG ( now ) ;
}
} ;
Runnable finish = new Runnable ( ) {
public void run ( ) {
HorizontalScrollView scroll = ( HorizontalScrollView ) findViewById ( R . id . horizontalScrollView1 ) ;
scroll . smoothScrollTo ( scroll_px , <num> ) ;
}
} ;
handler . postDelayed ( render , <num> ) ;
handler . postDelayed ( finish , <num> ) ;
}
private void loadEPG ( Time date ) {
setContentView ( R . layout . epg ) ;
final LinearLayout chanNames = ( LinearLayout ) findViewById ( R . id . chanNames ) ;
final LinearLayout stations = ( LinearLayout ) findViewById ( R . id . programs ) ;
final TextView title = ( TextView ) findViewById ( R . id . titleEPG ) ;
title . setText ( " + date . format ( " ) ) ;
final Button prev = ( Button ) findViewById ( R . id . prevDate ) ;
final Time prevDate = new Time ( ) ;
prevDate . set ( date . toMillis ( false )  <num> * <num> * <num> * <num> ) ;
prev . setText ( " + prevDate . format ( " ) ) ;
prev . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
Runnable render = new Runnable ( ) {
public void run ( ) {
setContentView ( R . layout . epg ) ;
}
} ;
Runnable finish = new Runnable ( ) {
public void run ( ) {
loadEPG ( prevDate ) ;
}
} ;
handler . post ( render ) ;
handler . postDelayed ( finish , <num> ) ;
}
} ) ;
final Button next = ( Button ) findViewById ( R . id . nextDate ) ;
final Time nextDate = new Time ( ) ;
nextDate . set ( date . toMillis ( false ) + <num> * <num> * <num> * <num> ) ;
next . setText ( nextDate . format ( " ) + " ) ;
next . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
Runnable render = new Runnable ( ) {
public void run ( ) {
setContentView ( R . layout . epg ) ;
}
} ;
Runnable finish = new Runnable ( ) {
public void run ( ) {
loadEPG ( nextDate ) ;
}
} ;
handler . post ( render ) ;
handler . postDelayed ( finish , <num> ) ;
}
} ) ;
String mychans = global . profileVar ( " ) ;
String [ ] channels = mychans . split ( " ) ;
int scale = <num> ;
RelativeLayout timeline_layout = new RelativeLayout ( global ) ;
stations . addView ( timeline_layout ) ;
TextView timetitle = new TextView ( global ) ;
chanNames . addView ( timetitle ) ;
for ( int h = <num> ; h < <num> ; h ++ ) {
TextView hour = new TextView ( global ) ;
hour . setWidth ( <num> / scale ) ;
hour . setText ( h + " ) ;
hour . setGravity ( Gravity . CENTER_VERTICAL | Gravity . CENTER_HORIZONTAL ) ;
timeline_layout . addView ( hour ) ;
ViewGroup . MarginLayoutParams mlp = ( ViewGroup . MarginLayoutParams ) hour . getLayoutParams ( ) ;
mlp . leftMargin = ( h * <num>  <num> ) / scale ;
}
for ( int j = <num> ; j < channels . length ; j ++ )
{
String channel_id = channels [ j ] ;
XMLParser parser = new XMLParser ( ) ;
Log . d ( " , " + date . format ( " ) + " + channel_id ) ;
String xmlch = global . get ( " + date . format ( " ) + " + channel_id ) ;
if ( ! xmlch . contains ( " ) ) {
break ;
}
InputSource isch = new InputSource ( ) ;
isch . setCharacterStream ( new StringReader ( xmlch ) ) ;
xmlEPG = parser . getDomElement ( isch ) ;
NodeList channel_info = xmlEPG . getElementsByTagName ( " ) . item ( <num> ) . getChildNodes ( ) ;
String icon_src = " ;
for ( int p = <num> ; p < channel_info . getLength ( ) ; p ++ ) {
if ( channel_info . item ( p ) . getNodeName ( ) . equals ( " ) ) {
NamedNodeMap attrs = channel_info . item ( p ) . getAttributes ( ) ;
icon_src = attrs . getNamedItem ( " ) . getNodeValue ( ) ;
}
}
ImageView channel_button = new ImageView ( global ) ;
chanNames . addView ( channel_button ) ;
channel_button . setImageBitmap ( global . getLogoBitmap ( icon_src ) ) ;
channel_button . setAdjustViewBounds ( true ) ;
channel_button . <unk> ( <num> ) ;
channel_button . setMinimumHeight ( <num> ) ;
final int chid = j ;
channel_button . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
Bundle bundle = new Bundle ( ) ;
bundle . putString ( " , " ) ;
bundle . putInt ( " , chid ) ;
Intent myIntent = new Intent ( getBaseContext ( ) , PlayerActivity . class ) ;
myIntent . putExtras ( bundle ) ;
startActivity ( myIntent ) ;
}
} ) ;
RelativeLayout channel_layout = new RelativeLayout ( global ) ;
stations . addView ( channel_layout ) ;
programmeType [ ] epg = global . epgFromXMLTV ( " + date . format ( " ) + " + channel_id ) ;
for ( int i = <num> ; i < epg . length ; i ++ ) {
TextView program = new TextView ( global ) ;
program . setHeight ( <num> ) ;
program . setWidth ( epg [ i ] . lasting / scale ) ;
program . setText ( epg [ i ] . title ) ;
program . setGravity ( Gravity . CENTER_VERTICAL | Gravity . CENTER_HORIZONTAL ) ;
program . setBackgroundResource ( R . drawable . rectangle ) ;
channel_layout . addView ( program ) ;
ViewGroup . MarginLayoutParams mlp = ( ViewGroup . MarginLayoutParams ) program . getLayoutParams ( ) ;
mlp . leftMargin = epg [ i ] . start / scale ;
}
TextView pointer = new TextView ( global ) ;
pointer . setHeight ( <num> ) ;
pointer . setWidth ( <num> ) ;
pointer . bringToFront ( ) ;
pointer . setBackgroundResource ( R . drawable . ruler ) ;
channel_layout . addView ( pointer ) ;
ViewGroup . MarginLayoutParams mlp = ( ViewGroup . MarginLayoutParams ) pointer . getLayoutParams ( ) ;
mlp . leftMargin = ( ( date . hour * <num> + date . minute ) * <num> + date . second ) / scale ;
}
scroll_px = ( ( date . hour * <num> + date . minute  <num> ) * <num> + date . second ) / scale ;
}
}
package eu . danman . mediacenter ;
import java . io . BufferedInputStream ;
import java . io . File ;
import java . io . FileNotFoundException ;
import java . io . FileOutputStream ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . StringReader ;
import java . io . UnsupportedEncodingException ;
import java . lang . reflect . Array ;
import java . net . HttpURLConnection ;
import java . net . MalformedURLException ;
import java . net . ProtocolException ;
import java . net . URI ;
import java . net . URL ;
import java . net . URLConnection ;
import java . net . URLEncoder ;
import java . util . HashMap ;
import java . util . LinkedList ;
import java . util . List ;
import java . util . Map ;
import org . apache . http . HttpEntity ;
import org . apache . http . HttpResponse ;
import org . apache . http . HttpStatus ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . client . CookieStore ;
import org . apache . http . client . HttpClient ;
import org . apache . http . client . methods . HttpPost ;
import org . apache . http . entity . FileEntity ;
import org . apache . http . impl . client . BasicCookieStore ;
import org . apache . http . impl . client . DefaultHttpClient ;
import org . apache . http . util . ByteArrayBuffer ;
import org . apache . http . util . EntityUtils ;
import org . w3c . dom . Document ;
import org . w3c . dom . Element ;
import org . w3c . dom . NodeList ;
import org . xml . sax . InputSource ;
import android . content . Context ;
import android . content . Intent ;
import android . graphics . Bitmap ;
import android . graphics . Bitmap . Config ;
import android . graphics . BitmapFactory ;
import android . util . Log ;
import android . app . Activity ;
import android . app . Application ;
public class MediaCenter extends Application {
public class programmeType {
int start ;
int end ;
String title ;
String desc ;
int lasting ;
} ;
CookieStore cookieStore ;
public Document userProfile ;
public programmeType [ ] epgFromXMLTV ( String uri ) {
XMLParser parser = new XMLParser ( ) ;
String xmlch = get ( uri ) ;
InputSource isch = new InputSource ( ) ;
isch . setCharacterStream ( new StringReader ( xmlch ) ) ;
Document xmlEPG = parser . getDomElement ( isch ) ;
NodeList programmes = xmlEPG . getElementsByTagName ( " ) ;
programmeType [ ] output = new programmeType [ programmes . getLength ( ) ] ;
for ( int i = <num> ; i < programmes . getLength ( ) ; i ++ ) {
programmeType current = new programmeType ( ) ;
Element element = ( Element ) programmes . item ( i ) ;
current . title = " ;
current . desc = " ;
current . start = date2sec ( element . getAttributes ( ) . getNamedItem ( " ) . getTextContent ( ) ) ;
current . end = date2sec ( element . getAttributes ( ) . getNamedItem ( " ) . getTextContent ( ) ) ;
if ( current . end < current . start )
current . end += ( <num> * <num> * <num> ) ;
current . lasting = current . end  current . start ;
current . title = element . getElementsByTagName ( " ) . item ( <num> ) . getTextContent ( ) ;
current . desc = element . getElementsByTagName ( " ) . item ( <num> ) . getTextContent ( ) ;
output [ i ] = current ;
}
return output ;
}
int date2sec ( String totok ) {
int y = Integer . parseInt ( totok . substring ( <num> , <num> ) ) ;
int mo = Integer . parseInt ( totok . substring ( <num> , <num> ) ) ;
int d = Integer . parseInt ( totok . substring ( <num> , <num> ) ) ;
int h = Integer . parseInt ( totok . substring ( <num> , <num> ) ) ;
int m = Integer . parseInt ( totok . substring ( <num> , <num> ) ) ;
int s = Integer . parseInt ( totok . substring ( <num> , <num> ) ) ;
return s + m * <num> + h * <num> ;
}
String baseurl = " ;
public boolean getLogin ( ) {
cookieStore = new BasicCookieStore ( ) ;
Intent login = new Intent ( this , LoginActivity . class ) ;
login . setFlags ( <num> ) ;
startActivity ( login ) ;
return true ;
}
public boolean loadProfile ( ) {
XMLParser parser = new XMLParser ( ) ;
String get = get ( " ) ;
if ( get . contains ( " ) ) {
InputSource is = new InputSource ( ) ;
is . setCharacterStream ( new StringReader ( get ) ) ;
userProfile = parser . getDomElement ( is ) ;
return true ;
}
return false ;
}
public String profileVar ( String var ) {
try {
NodeList cont = userProfile . getElementsByTagName ( var ) ;
if ( cont . getLength ( ) != <num> ) {
return cont . item ( <num> ) . getTextContent ( ) ;
} else {
return " ;
}
} catch ( NullPointerException e ) {
return " ;
}
}
public boolean str2bool ( String bool ) {
if ( bool . contains ( " ) ) {
return true ;
}
return false ;
}
public String get ( String request ) {
String body = " ;
String url = baseurl + request ;
Log . d ( " , url ) ;
try {
DefaultHttpClient httpClient = new DefaultHttpClient ( ) ;
HttpPost httpPost = new HttpPost ( url ) ;
httpClient . setCookieStore ( cookieStore ) ;
HttpResponse httpResponse = httpClient . execute ( httpPost ) ;
HttpEntity httpEntity = httpResponse . getEntity ( ) ;
cookieStore = httpClient . getCookieStore ( ) ;
body = EntityUtils . toString ( httpEntity , " ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
} catch ( ClientProtocolException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
if ( body . contains ( " ) ) {
Intent intent = new Intent ( getApplicationContext ( ) , LoginActivity . class ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ;
startActivity ( intent ) ;
}
return body ;
}
public boolean fileDownload ( String url , String filename ) {
String to = this . getFilesDir ( ) . toString ( ) + " + filename ;
Log . d ( " , url + " + to ) ;
try {
DefaultHttpClient httpClient = new DefaultHttpClient ( ) ;
HttpPost httpPost = new HttpPost ( url ) ;
httpClient . setCookieStore ( cookieStore ) ;
HttpResponse httpResponse = httpClient . execute ( httpPost ) ;
HttpEntity httpEntity = httpResponse . getEntity ( ) ;
cookieStore = httpClient . getCookieStore ( ) ;
if ( httpEntity != null ) {
File file = new File ( to ) ;
FileOutputStream fos = new FileOutputStream ( file ) ;
httpEntity . writeTo ( fos ) ;
fos . close ( ) ;
}
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
} catch ( ClientProtocolException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
return true ;
}
public Bitmap getLogoBitmap ( String url ) {
String icon_name = url . substring ( url . lastIndexOf ( /' ) + <num> ) ;
try {
openFileInput ( icon_name ) ;
} catch ( FileNotFoundException e1 ) {
Log . d ( " , url + " + icon_name ) ;
fileDownload ( url , icon_name ) ;
}
Bitmap logoBitmap ;
try {
InputStream instream = openFileInput ( icon_name ) ;
logoBitmap = BitmapFactory . decodeStream ( instream ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
Config conf = Bitmap . Config . ARGB_8888 ;
logoBitmap = Bitmap . createBitmap ( <num> , <num> , conf ) ;
}
return logoBitmap ;
}
public String fileUpload ( String request , String filepath , String filename ) {
DefaultHttpClient httpClient = new DefaultHttpClient ( ) ;
String body = " ;
try {
httpClient . getParams ( ) . setParameter ( " , new Integer ( <num> ) ) ;
HttpPost post = new HttpPost ( new URI ( baseurl + request ) ) ;
File file = new File ( filepath ) ;
FileEntity entity ;
entity = new FileEntity ( file , " ) ;
entity . setChunked ( true ) ;
post . setEntity ( entity ) ;
post . addHeader ( " , filename ) ;
httpClient . setCookieStore ( cookieStore ) ;
HttpResponse response = httpClient . execute ( post ) ;
HttpEntity httpEntity = response . getEntity ( ) ;
cookieStore = httpClient . getCookieStore ( ) ;
body = EntityUtils . toString ( httpEntity , " ) ;
} catch ( Exception ex ) {
Log . e ( " , " + ex . getMessage ( ) ) ;
ex . printStackTrace ( ) ;
} finally {
httpClient . getConnectionManager ( ) . shutdown ( ) ;
}
return body ;
}
}
package eu . danman . mediacenter ;
import java . io . StringReader ;
import org . w3c . dom . Document ;
import org . w3c . dom . Element ;
import org . w3c . dom . NodeList ;
import org . xml . sax . InputSource ;
import android . app . Activity ;
import android . content . Context ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . graphics . Bitmap ;
import android . media . MediaPlayer ;
import android . media . MediaPlayer . OnPreparedListener ;
import android . net . Uri ;
import android . os . Bundle ;
import android . os . Handler ;
import android . os . Message ;
import android . os . PowerManager ;
import android . view . MotionEvent ;
import android . view . View ;
import android . view . View . OnTouchListener ;
import android . view . animation . AnimationUtils ;
import android . widget . ImageView ;
import android . widget . MediaController ;
import android . widget . RelativeLayout ;
import android . widget . TextView ;
import android . widget . VideoView ;
import android . widget . ViewFlipper ;
public class PlayerActivity extends Activity implements OnTouchListener {
private static final int GONE = <num> ;
float downXValue ;
float downYValue ;
@Override
public boolean onTouch ( View arg0 , MotionEvent arg1 ) {
topBar . setVisibility ( View . VISIBLE ) ;
mHandler . removeCallbacks ( hideTopbar ) ;
if ( videoView . isPlaying ( ) ) {
mHandler . postDelayed ( hideTopbar , <num> ) ;
}
switch ( arg1 . getAction ( ) )
{
case MotionEvent . ACTION_DOWN :
{
downXValue = arg1 . getX ( ) ;
downYValue = arg1 . getY ( ) ;
}
break ;
case MotionEvent . ACTION_UP :
{
float lenghtX = downXValue  arg1 . getX ( ) ;
float lenghtY = downYValue  arg1 . getY ( ) ;
if ( lenghtX <  <num> )
{
videoView . stopPlayback ( ) ;
ViewFlipper vf = ( ViewFlipper ) findViewById ( R . id . details ) ;
vf . setAnimation ( AnimationUtils . loadAnimation ( this , R . anim . slide_left ) ) ;
vf . showPrevious ( ) ;
pid  ;
playCurrent ( ) ;
}
if ( lenghtX > <num> )
{
videoView . stopPlayback ( ) ;
topBar . setInAnimation ( AnimationUtils . loadAnimation ( this , R . anim . slide_right ) ) ;
topBar . showNext ( ) ;
pid ++ ;
playCurrent ( ) ;
}
}
break ;
}
return true ;
}
int pid ;
VideoView videoView ;
private RelativeLayout layoutPerc ;
private NodeList playlist ;
private XMLParser parser ;
private Bitmap logoBitmap ;
SharedPreferences sharedPreferences ;
int buffered ;
private Handler mHandler ;
private Handler startfirst ;
ViewFlipper topBar ;
ImageView logoView ;
PowerManager pm ;
PowerManager . WakeLock wl ;
MediaCenter global ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
sharedPreferences = getSharedPreferences ( " , MODE_PRIVATE ) ;
setContentView ( R . layout . player ) ;
videoView = ( VideoView ) findViewById ( R . id . videoView1 ) ;
videoView . setOnPreparedListener ( new OnPreparedListener ( ) {
public void onPrepared ( MediaPlayer mp ) {
layoutPerc . setVisibility ( View . INVISIBLE ) ;
mHandler . postDelayed ( hideTopbar , <num> ) ;
videoView . start ( ) ;
}
} ) ;
RelativeLayout layMain = ( RelativeLayout ) findViewById ( R . id . layMain ) ;
logoView = ( ImageView ) findViewById ( R . id . logoTV ) ;
logoView . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
startActivity ( new Intent ( getApplicationContext ( ) , EPGActivity . class ) ) ;
}
} ) ;
topBar = ( ViewFlipper ) findViewById ( R . id . details ) ;
mHandler = new Handler ( ) ;
layMain . setOnTouchListener ( ( OnTouchListener ) this ) ;
layoutPerc = ( RelativeLayout ) findViewById ( R . id . layoutPerc ) ;
MediaController mediaController = new MediaController ( this ) ;
videoView . setMediaController ( mediaController ) ;
Bundle bundle = this . getIntent ( ) . getExtras ( ) ;
String playlistURL = bundle . getString ( " ) ;
int chid = bundle . getInt ( " ) ;
parser = new XMLParser ( ) ;
global = ( ( MediaCenter ) getApplicationContext ( ) ) ;
String xml = global . get ( playlistURL ) ;
if ( ! ( xml . contains ( " ) ) ) {
finish ( ) ;
return ;
}
InputSource is = new InputSource ( ) ;
is . setCharacterStream ( new StringReader ( xml ) ) ;
Document doc = parser . getDomElement ( is ) ;
playlist = doc . getElementsByTagName ( " ) ;
pid = chid ;
playCurrent ( ) ;
}
@Override
public void onPause ( ) {
super . onPause ( ) ;
videoView . stopPlayback ( ) ;
wl . release ( ) ;
}
@Override
public void onResume ( ) {
super . onResume ( ) ;
pm = ( PowerManager ) getSystemService ( Context . POWER_SERVICE ) ;
wl = pm . newWakeLock ( PowerManager . FULL_WAKE_LOCK , " ) ;
wl . acquire ( ) ;
}
public void playCurrent ( ) {
if ( pid < <num> ) {
pid = playlist . getLength ( )  <num> ;
}
if ( pid >= playlist . getLength ( ) ) {
pid = <num> ;
}
Element track = ( Element ) playlist . item ( pid ) ;
TextView topBarText = ( TextView ) findViewById ( R . id . textBig ) ;
topBarText . setText ( " + ( pid + <num> ) + " + parser . getValue ( track , " ) ) ;
TextView textSmall = ( TextView ) findViewById ( R . id . textSmall ) ;
textSmall . setText ( parser . getValue ( track , " ) ) ;
loadLogo ( parser . getValue ( track , " ) ) ;
layoutPerc . setVisibility ( View . VISIBLE ) ;
videoView . stopPlayback ( ) ;
String url = parser . getValue ( track , " ) ;
videoView . setVideoURI ( Uri . parse ( url ) ) ;
}
public void loadLogo ( final String url ) {
Thread t = new Thread ( ) {
public void run ( ) {
logoBitmap = global . getLogoBitmap ( url ) ;
Message myMessage = new Message ( ) ;
Bundle resBundle = new Bundle ( ) ;
resBundle . putString ( " , " ) ;
myMessage . obj = resBundle ;
handler . sendMessage ( myMessage ) ;
}
} ;
t . start ( ) ;
}
private Runnable hideTopbar = new Runnable ( ) {
public void run ( ) {
topBar . setVisibility ( View . INVISIBLE ) ;
}
} ;
private Handler handler = new Handler ( ) {
@Override
public void handleMessage ( Message b ) {
logoView . setImageBitmap ( logoBitmap ) ;
}
} ;
}
package eu . danman . mediacenter ;
public final class R {
public static final class anim {
public static final int cycle_7 = <num> ;
public static final int fade = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int shake = <num> ;
public static final int slide_left = <num> ;
public static final int slide_right = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int zoom_enter = <num> ;
public static final int zoom_exit = <num> ;
}
public static final class attr {
}
public static final class drawable {
public static final int <unk> = <num> ;
public static final int arrow = <num> ;
public static final int arrow2 = <num> ;
public static final int ball = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int logo = <num> ;
public static final int <unk> = <num> ;
public static final int rectangle = <num> ;
public static final int ruler = <num> ;
public static final int user_icon = <num> ;
}
public static final class id {
public static final int RelativeLayout1 = <num> ;
public static final int TextView01 = <num> ;
public static final int addUser = <num> ;
public static final int arrowImage = <num> ;
public static final int ball = <num> ;
public static final int btnEPG = <num> ;
public static final int btnListTV = <num> ;
public static final int btnLogout = <num> ;
public static final int btnRefresh = <num> ;
public static final int btnSettings = <num> ;
public static final int btnTV = <num> ;
public static final int btnVOD = <num> ;
public static final int button1 = <num> ;
public static final int button2 = <num> ;
public static final int chanNames = <num> ;
public static final int details = <num> ;
public static final int horizontalScrollView1 = <num> ;
public static final int imageView1 = <num> ;
public static final int imgIcon = <num> ;
public static final int itemDesc = <num> ;
public static final int itemTitle = <num> ;
public static final int layMain = <num> ;
public static final int layoutPerc = <num> ;
public static final int linearLayout1 = <num> ;
public static final int linearLayout2 = <num> ;
public static final int listItems = <num> ;
public static final int loginBtn = <num> ;
public static final int loginControlls = <num> ;
public static final int logoTV = <num> ;
public static final int nextDate = <num> ;
public static final int passwordBox = <num> ;
public static final int prevDate = <num> ;
public static final int programs = <num> ;
public static final int progressBar1 = <num> ;
public static final int rememberBox = <num> ;
public static final int scrollView1 = <num> ;
public static final int surfacePlayer = <num> ;
public static final int surface_camera = <num> ;
public static final int textBig = <num> ;
public static final int textDesc = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int textPerc = <num> ;
public static final int textSmall = <num> ;
public static final int textTitle = <num> ;
public static final int textView1 = <num> ;
public static final int textView2 = <num> ;
public static final int textView3 = <num> ;
public static final int textView4 = <num> ;
public static final int textView5 = <num> ;
public static final int textView6 = <num> ;
public static final int textWelcome = <num> ;
public static final int titleEPG = <num> ;
public static final int unameBox = <num> ;
public static final int userBtns = <num> ;
public static final int videoView1 = <num> ;
}
public static final class layout {
public static final int epg = <num> ;
public static final int intro = <num> ;
public static final int login = <num> ;
public static final int menu1 = <num> ;
public static final int menu2 = <num> ;
public static final int player = <num> ;
public static final int <unk> = <num> ;
public static final int playlist = <num> ;
public static final int plitem = <num> ;
}
public static final class string {
public static final int app_name = <num> ;
}
public static final class style {
public static final int Outline = <num> ;
}
public static final class xml {
public static final int settings = <num> ;
}
}
package eu . danman . mediacenter ;
import android . app . AlertDialog . Builder ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . content . DialogInterface . OnClickListener ;
import android . preference . ListPreference ;
import android . preference . Preference ;
import android . util . AttributeSet ;
import android . util . Log ;
import android . os . Bundle ;
public class ListPreferenceMultiSelect extends ListPreference {
private static final String SEPARATOR = " ;
private boolean [ ] mClickedDialogEntryIndices ;
private String resultentries ;
public ListPreferenceMultiSelect ( Context context , AttributeSet attrs ) {
super ( context , attrs ) ;
}
@Override
public void setEntries ( CharSequence [ ] entries ) {
super . setEntries ( entries ) ;
mClickedDialogEntryIndices = new boolean [ entries . length ] ;
}
public ListPreferenceMultiSelect ( Context context ) {
this ( context , null ) ;
}
@Override
protected void <unk> ( Builder builder ) {
CharSequence [ ] entries = getEntries ( ) ;
CharSequence [ ] entryValues = getEntryValues ( ) ;
if ( entries == null || entryValues == null || entries . length != entryValues . length ) {
throw new IllegalStateException (
" ) ;
}
builder . setMultiChoiceItems ( entries , mClickedDialogEntryIndices ,
new DialogInterface . OnMultiChoiceClickListener ( ) {
public void onClick ( DialogInterface dialog , int which , boolean val ) {
String entryValue = getEntryValues ( ) [ which ] + " ;
if ( val ) {
resultentries += entryValue ;
} else {
resultentries = resultentries . replace ( entryValue , " ) ;
}
mClickedDialogEntryIndices [ which ] = val ;
}
} ) ;
}
public static String [ ] parseStoredValue ( CharSequence val ) {
if ( " . equals ( val ) )
return null ;
else
return ( ( String ) val ) . split ( SEPARATOR ) ;
}
private void <unk> ( ) {
CharSequence [ ] entryValues = getEntryValues ( ) ;
String [ ] vals = parseStoredValue ( getValue ( ) ) ;
if ( vals != null ) {
for ( int j = <num> ; j < vals . length ; j ++ ) {
String val = vals [ j ] . trim ( ) ;
for ( int i = <num> ; i < entryValues . length ; i ++ ) {
CharSequence entry = entryValues [ i ] ;
if ( entry . equals ( val ) ) {
mClickedDialogEntryIndices [ i ] = false ;
break ;
}
}
}
}
}
public void setEntryStatuses ( String get ) {
CharSequence [ ] entryValues = getEntryValues ( ) ;
resultentries = get ;
String [ ] vals = parseStoredValue ( get ) ;
if ( vals != null ) {
for ( int j = <num> ; j < vals . length ; j ++ ) {
String val = vals [ j ] . trim ( ) ;
for ( int i = <num> ; i < entryValues . length ; i ++ ) {
CharSequence entry = entryValues [ i ] ;
Log . d ( ( String ) entry , val ) ;
if ( entry . equals ( val ) ) {
mClickedDialogEntryIndices [ i ] = true ;
break ;
}
}
}
}
}
@Override
protected void onDialogClosed ( boolean positiveResult ) {
CharSequence [ ] entryValues = getEntryValues ( ) ;
if ( positiveResult && entryValues != null ) {
StringBuffer value = new StringBuffer ( ) ;
value . append ( resultentries ) ;
if ( callChangeListener ( value ) ) {
String val = value . toString ( ) ;
if ( val . length ( ) > <num> )
val = val . substring ( <num> , val . length ( )  SEPARATOR . length ( ) ) ;
setValue ( val ) ;
}
}
}
package eu . danman . mediacenter ;
import java . io . BufferedReader ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . InputStreamReader ;
import java . io . OutputStream ;
import java . io . PrintWriter ;
import java . io . StringReader ;
import java . net . MalformedURLException ;
import java . net . Socket ;
import java . net . URL ;
import java . net . UnknownHostException ;
import java . util . Timer ;
import java . util . TimerTask ;
import org . w3c . dom . Document ;
import org . w3c . dom . Element ;
import org . w3c . dom . NodeList ;
import org . xml . sax . InputSource ;
import eu . danman . mediacenter . MediaCenter . programmeType ;
import android . app . Activity ;
import android . content . Context ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . graphics . Bitmap ;
import android . graphics . BitmapFactory ;
import android . media . MediaPlayer ;
import android . media . MediaPlayer . OnBufferingUpdateListener ;
import android . media . MediaPlayer . OnPreparedListener ;
import android . opengl . <unk> ;
import android . os . Bundle ;
import android . os . Handler ;
import android . os . Message ;
import android . os . PowerManager ;
import android . text . format . Time ;
import android . util . Log ;
import android . view . MotionEvent ;
import android . view . SurfaceHolder ;
import android . view . SurfaceView ;
import android . view . View ;
import android . view . View . OnTouchListener ;
import android . view . animation . AnimationUtils ;
import android . widget . HorizontalScrollView ;
import android . widget . ImageView ;
import android . widget . MediaController ;
import android . widget . MediaController . <unk> ;
import android . widget . RelativeLayout ;
import android . widget . TextView ;
import android . widget . ViewFlipper ;
public class PlayerActivity extends Activity implements OnTouchListener , OnBufferingUpdateListener , OnPreparedListener {
private static final int GONE = <num> ;
float downXValue ;
float downYValue ;
@Override
public boolean onTouch ( View arg0 , MotionEvent arg1 ) {
topBar . setVisibility ( View . VISIBLE ) ;
mHandler . removeCallbacks ( mUpdateTimeTask ) ;
if ( buffered == <num> ) {
mHandler . postDelayed ( mUpdateTimeTask , <num> ) ;
}
switch ( arg1 . getAction ( ) )
{
case MotionEvent . ACTION_DOWN :
{
downXValue = arg1 . getX ( ) ;
downYValue = arg1 . getY ( ) ;
}
break ;
case MotionEvent . ACTION_UP :
{
float lenghtX = downXValue  arg1 . getX ( ) ;
float lenghtY = downYValue  arg1 . getY ( ) ;
if ( lenghtX <  <num> )
{
mMediaPlayer . reset ( ) ;
ViewFlipper vf = ( ViewFlipper ) findViewById ( R . id . details ) ;
vf . setAnimation ( AnimationUtils . loadAnimation ( this , R . anim . slide_left ) ) ;
vf . showPrevious ( ) ;
pid  ;
playCurrent ( ) ;
}
if ( lenghtX > <num> )
{
mMediaPlayer . reset ( ) ;
topBar . setInAnimation ( AnimationUtils . loadAnimation ( this , R . anim . slide_right ) ) ;
topBar . showNext ( ) ;
pid ++ ;
playCurrent ( ) ;
}
}
break ;
}
return true ;
}
int pid ;
private MediaPlayer mMediaPlayer ;
private SurfaceHolder holder ;
private SurfaceView mPreview ;
private RelativeLayout layoutPerc ;
private NodeList playlist ;
private XMLParser parser ;
private Bitmap logoBitmap ;
SharedPreferences sharedPreferences ;
int buffered ;
private Handler mHandler ;
private Handler startfirst ;
ViewFlipper topBar ;
ImageView logoView ;
PowerManager pm ;
PowerManager . WakeLock wl ;
MediaCenter global ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
sharedPreferences = getSharedPreferences ( " , MODE_PRIVATE ) ;
setContentView ( R . layout . player ) ;
mPreview = ( SurfaceView ) findViewById ( R . id . surfacePlayer ) ;
holder = mPreview . getHolder ( ) ;
holder . setType ( SurfaceHolder . SURFACE_TYPE_PUSH_BUFFERS ) ;
RelativeLayout layMain = ( RelativeLayout ) findViewById ( R . id . layMain ) ;
logoView = ( ImageView ) findViewById ( R . id . logoTV ) ;
logoView . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
startActivity ( new Intent ( getApplicationContext ( ) , EPGActivity . class ) ) ;
}
} ) ;
topBar = ( ViewFlipper ) findViewById ( R . id . details ) ;
mHandler = new Handler ( ) ;
layMain . setOnTouchListener ( ( OnTouchListener ) this ) ;
mMediaPlayer = new MediaPlayer ( ) ;
mMediaPlayer . setOnBufferingUpdateListener ( this ) ;
mMediaPlayer . setDisplay ( holder ) ;
layoutPerc = ( RelativeLayout ) findViewById ( R . id . layoutPerc ) ;
Bundle bundle = this . getIntent ( ) . getExtras ( ) ;
String playlistURL = bundle . getString ( " ) ;
int chid = bundle . getInt ( " ) ;
parser = new XMLParser ( ) ;
global = ( ( MediaCenter ) getApplicationContext ( ) ) ;
String xml = global . get ( playlistURL ) ;
if ( ! ( xml . contains ( " ) ) ) {
finish ( ) ;
return ;
}
InputSource is = new InputSource ( ) ;
is . setCharacterStream ( new StringReader ( xml ) ) ;
Document doc = parser . getDomElement ( is ) ;
playlist = doc . getElementsByTagName ( " ) ;
mMediaPlayer . reset ( ) ;
pid = chid ;
startfirst = new Handler ( ) ;
Runnable first = new Runnable ( ) {
public void run ( ) {
playCurrent ( ) ;
}
} ;
startfirst . postDelayed ( first , <num> ) ;
}
@Override
public void onPause ( ) {
super . onPause ( ) ;
mMediaPlayer . reset ( ) ;
wl . release ( ) ;
}
@Override
public void onResume ( ) {
super . onResume ( ) ;
pm = ( PowerManager ) getSystemService ( Context . POWER_SERVICE ) ;
wl = pm . newWakeLock ( PowerManager . FULL_WAKE_LOCK , " ) ;
wl . acquire ( ) ;
}
private Runnable mUpdateTimeTask = new Runnable ( ) {
public void run ( ) {
topBar . setVisibility ( View . INVISIBLE ) ;
}
} ;
public void playCurrent ( ) {
if ( pid < <num> ) {
pid = playlist . getLength ( )  <num> ;
}
if ( pid >= playlist . getLength ( ) ) {
pid = <num> ;
}
Element track = ( Element ) playlist . item ( pid ) ;
TextView topBarText = ( TextView ) findViewById ( R . id . textBig ) ;
topBarText . setText ( " + ( pid + <num> ) + " + parser . getValue ( track , " ) ) ;
TextView textSmall = ( TextView ) findViewById ( R . id . textSmall ) ;
textSmall . setText ( parser . getValue ( track , " ) ) ;
loadLogo ( parser . getValue ( track , " ) ) ;
layoutPerc . setVisibility ( View . VISIBLE ) ;
TextView textPerc = ( TextView ) findViewById ( R . id . textPerc ) ;
textPerc . setText ( " ) ;
mMediaPlayer . reset ( ) ;
String url = parser . getValue ( track , " ) ;
try {
mMediaPlayer . setDataSource ( url ) ;
} catch ( IllegalArgumentException e ) {
e . printStackTrace ( ) ;
} catch ( IllegalStateException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
mMediaPlayer . setOnPreparedListener ( this ) ;
mMediaPlayer . prepareAsync ( ) ;
}
public String <unk> ( int secs ) {
int h = secs / <num> ;
int m = ( secs  h * <num> ) / <num> ;
if ( h >= <num> ) h -= <num> ;
return String . format ( " , h ) + " + String . format ( " , m ) ;
}
public void loadLogo ( final String url ) {
Thread t = new Thread ( ) {
public void run ( ) {
logoBitmap = global . getLogoBitmap ( url ) ;
Message myMessage = new Message ( ) ;
Bundle resBundle = new Bundle ( ) ;
resBundle . putString ( " , " ) ;
myMessage . obj = resBundle ;
handler . sendMessage ( myMessage ) ;
}
} ;
t . start ( ) ;
}
private Handler handler = new Handler ( ) {
@Override
public void handleMessage ( Message b ) {
logoView . setImageBitmap ( logoBitmap ) ;
}
} ;
public void onBufferingUpdate ( MediaPlayer arg0 , int percent ) {
Log . v ( " , percent + " ) ;
buffered = percent ;
if ( percent == <num> ) {
layoutPerc . setVisibility ( View . INVISIBLE ) ;
mHandler . postDelayed ( mUpdateTimeTask , <num> ) ;
} else {
layoutPerc . setVisibility ( View . VISIBLE ) ;
topBar . setVisibility ( View . VISIBLE ) ;
mHandler . removeCallbacks ( mUpdateTimeTask ) ;
TextView textPerc = ( TextView ) findViewById ( R . id . textPerc ) ;
textPerc . setText ( percent + " ) ;
}
}
public void onPrepared ( MediaPlayer mediaplayer ) {
layoutPerc . setVisibility ( View . INVISIBLE ) ;
mHandler . postDelayed ( mUpdateTimeTask , <num> ) ;
mMediaPlayer . start ( ) ;
topBar . bringToFront ( ) ;
}
}
package eu . danman . mediacenter ;
import java . io . BufferedOutputStream ;
import java . io . FileNotFoundException ;
import java . io . FileOutputStream ;
import java . io . IOException ;
import android . app . Activity ;
import android . app . ProgressDialog ;
import android . content . Context ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . content . pm . ActivityInfo ;
import android . graphics . Bitmap ;
import android . graphics . Bitmap . CompressFormat ;
import android . graphics . BitmapFactory ;
import android . graphics . Color ;
import android . graphics . PixelFormat ;
import android . hardware . Camera ;
import android . hardware . Camera . Size ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . Gravity ;
import android . view . SurfaceHolder ;
import android . view . SurfaceView ;
import android . view . View ;
import android . view . View . * ;
import android . view . Window ;
import android . view . WindowManager ;
import android . widget . Button ;
import android . widget . CheckBox ;
import android . widget . EditText ;
import android . widget . LinearLayout ;
import android . widget . LinearLayout . LayoutParams ;
import android . widget . RelativeLayout ;
import android . widget . Toast ;
public class LoginActivity extends Activity implements SurfaceHolder . Callback {
static MediaCenter global ;
Camera mCamera ;
boolean mPreviewRunning = false ;
private static final String TAG = " ;
private Context mContext = this ;
String users [ ] ;
EditText uname ;
EditText pass ;
CheckBox remember ;
View LoginControlls ;
ProgressDialog progressIndicator ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_LANDSCAPE ) ;
getWindow ( ) . setFormat ( PixelFormat . TRANSLUCENT ) ;
requestWindowFeature ( Window . FEATURE_NO_TITLE ) ;
getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_FULLSCREEN ,
WindowManager . LayoutParams . FLAG_FULLSCREEN ) ;
setContentView ( R . layout . login ) ;
progressIndicator = new ProgressDialog ( mContext ) ;
progressIndicator . setMessage ( " ) ;
uname = ( EditText ) findViewById ( R . id . unameBox ) ;
pass = ( EditText ) findViewById ( R . id . passwordBox ) ;
remember = ( CheckBox ) findViewById ( R . id . rememberBox ) ;
LoginControlls = ( View ) findViewById ( R . id . loginControlls ) ;
final Button btnAddUser = ( Button ) findViewById ( R . id . addUser ) ;
SurfaceView mSurfaceView = ( SurfaceView ) findViewById ( R . id . surface_camera ) ;
SurfaceHolder mSurfaceHolder = mSurfaceView . getHolder ( ) ;
mSurfaceHolder . addCallback ( this ) ;
mSurfaceHolder . setType ( SurfaceHolder . SURFACE_TYPE_PUSH_BUFFERS ) ;
global = ( ( MediaCenter ) getApplicationContext ( ) ) ;
getUsers ( ) ;
final LinearLayout layout = ( LinearLayout ) findViewById ( R . id . userBtns ) ;
for ( int i = <num> ; i < users . length ; i ++ ) {
Button btn = new Button ( this ) ;
layout . addView ( btn ) ;
btn . setGravity ( btnAddUser . getGravity ( ) ) ;
btn . setGravity ( Gravity . BOTTOM | Gravity . CENTER ) ;
btn . setText ( users [ i ] ) ;
btn . setId ( i ) ;
btn . setBackgroundResource ( R . drawable . user_icon ) ;
btn . setTextColor ( Color . WHITE ) ;
btn . setWidth ( <num> ) ;
btn . setHeight ( <num> ) ;
btn . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
String name = users [ v . getId ( ) ] ;
uname . setText ( name ) ;
if ( getPreference ( name + " ) . equals ( " ) ) {
pass . setText ( getPreference ( name + " ) ) ;
LoginControlls . setVisibility ( <num> ) ;
remember . setChecked ( true ) ;
progressIndicator . show ( ) ;
passwordLogin ( ) ;
} else {
LoginControlls . setVisibility ( <num> ) ;
}
}
} ) ;
btn . setOnLongClickListener ( new OnLongClickListener ( ) {
@Override
public boolean onLongClick ( View v ) {
delUser ( users [ v . getId ( ) ] ) ;
layout . removeView ( v ) ;
return true ;
}
} ) ;
}
uname . setText ( getPreference ( " ) ) ;
pass . setText ( getPreference ( " ) ) ;
if ( getPreference ( " ) . equals ( " ) ) remember . setChecked ( true ) ;
final Button btnLogin = ( Button ) findViewById ( R . id . loginBtn ) ;
btnLogin . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
progressIndicator . show ( ) ;
passwordLogin ( ) ;
}
} ) ;
btnAddUser . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
LoginControlls . setVisibility ( <num> ) ;
}
} ) ;
mSurfaceView . setOnClickListener ( new SurfaceView . OnClickListener ( ) {
public void onClick ( View v ) {
progressIndicator . show ( ) ;
Log . e ( " , " ) ;
mCamera . takePicture ( null , mPictureCallback , mPictureCallback ) ;
}
} ) ;
}
Camera . PictureCallback mPictureCallback = new Camera . PictureCallback ( ) {
public void onPictureTaken ( byte [ ] imageData , Camera c ) {
if ( imageData != null ) {
Log . e ( " , " ) ;
Intent mIntent = new Intent ( ) ;
photoLogin ( mContext , imageData , <num> , " ) ;
mCamera . startPreview ( ) ;
setResult ( <num> , mIntent ) ;
}
}
} ;
public void onBackPressed ( ) {
return ;
}
public void surfaceCreated ( SurfaceHolder holder ) {
Log . e ( TAG , " ) ;
mCamera = openFrontFacingCamera ( ) ;
}
public void surfaceChanged ( SurfaceHolder holder , int format , int w , int h ) {
Log . e ( TAG , " ) ;
if ( mCamera == null )
return ;
if ( mPreviewRunning ) {
mCamera . stopPreview ( ) ;
}
Camera . Parameters p = mCamera . getParameters ( ) ;
try {
mCamera . setPreviewDisplay ( holder ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
mCamera . startPreview ( ) ;
mPreviewRunning = true ;
}
public void surfaceDestroyed ( SurfaceHolder holder ) {
if ( mCamera == null )
return ;
Log . e ( TAG , " ) ;
mCamera . stopPreview ( ) ;
mPreviewRunning = false ;
mCamera . release ( ) ;
}
private Camera openFrontFacingCamera ( )
{
int cameraCount = <num> ;
Camera cam = null ;
Camera . CameraInfo cameraInfo = new Camera . CameraInfo ( ) ;
cameraCount = Camera . getNumberOfCameras ( ) ;
for ( int camIdx = <num> ; camIdx < cameraCount ; camIdx ++ ) {
Camera . getCameraInfo ( camIdx , cameraInfo ) ;
if ( cameraInfo . facing == Camera . CameraInfo . CAMERA_FACING_FRONT ) {
try {
cam = Camera . open ( camIdx ) ;
} catch ( RuntimeException e ) {
Log . e ( TAG , " + e . getLocalizedMessage ( ) ) ;
}
}
}
return cam ;
}
public boolean photoLogin ( Context mContext , byte [ ] imageData , int quality , String <unk> ) {
try {
BitmapFactory . Options options = new BitmapFactory . Options ( ) ;
options . inSampleSize = <num> ;
Bitmap myImage = BitmapFactory . decodeByteArray ( imageData , <num> , imageData . length , options ) ;
FileOutputStream fileOutputStream = mContext . openFileOutput ( " , Context . MODE_PRIVATE ) ;
BufferedOutputStream bos = new BufferedOutputStream ( fileOutputStream ) ;
myImage . compress ( CompressFormat . JPEG , quality , bos ) ;
bos . flush ( ) ;
bos . close ( ) ;
} catch ( FileNotFoundException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
String result = global . fileUpload ( " , mContext . getFilesDir ( ) . toString ( ) + " , " ) ;
finishLogin ( result ) ;
return true ;
}
public void passwordLogin ( ) {
String usname = uname . getText ( ) . toString ( ) ;
String result = global . get ( " + usname + " + pass . getText ( ) ) ;
if ( remember . isChecked ( ) ) {
setPreference ( usname + " , pass . getText ( ) . toString ( ) ) ;
setPreference ( usname + " , " ) ;
} else {
setPreference ( usname + " , " ) ;
setPreference ( usname + " , " ) ;
}
finishLogin ( result ) ;
if ( result . contains ( " ) && ! knownUser ( usname ) ) addUser ( usname ) ;
}
private void finishLogin ( String returned ) {
Log . d ( " , returned ) ;
if ( returned . equals ( " ) ) {
if ( ! global . loadProfile ( ) ) return ;
String menu = global . profileVar ( " ) ;
Log . d ( " , menu ) ;
if ( menu . equals ( " ) ) {
startActivity ( new Intent ( getApplicationContext ( ) , MenuActivity1 . class ) ) ;
}
if ( menu . equals ( " ) ) {
startActivity ( new Intent ( getApplicationContext ( ) , MenuActivity2 . class ) ) ;
}
progressIndicator . dismiss ( ) ;
finish ( ) ;
return ;
}
progressIndicator . hide ( ) ;
Toast . makeText ( getApplicationContext ( ) , " , Toast . LENGTH_LONG ) . show ( ) ;
}
private boolean knownUser ( String usname ) {
getUsers ( ) ;
if ( users . length < <num> ) return false ;
for ( int i = <num> ; i < users . length ; i ++ ) {
if ( users [ i ] . equals ( usname ) ) return true ;
}
return false ;
}
private void delUser ( String usname ) {
getUsers ( ) ;
setPreference ( " , " ) ;
for ( int i = <num> ; i < users . length ; i ++ ) {
if ( ! users [ i ] . equals ( usname ) ) addUser ( usname ) ;
}
}
private void addUser ( String usname ) {
setPreference ( " , getPreference ( " ) + " + usname ) ;
}
private void getUsers ( ) {
String usrs = getPreference ( " ) ;
users = usrs . split ( " ) ;
}
private void setPreference ( String key , String value ) {
SharedPreferences sharedPreferences = getSharedPreferences ( " , MODE_PRIVATE ) ;
SharedPreferences . Editor editor = sharedPreferences . edit ( ) ;
editor . putString ( key , value ) ;
editor . commit ( ) ;
}
private String getPreference ( String key ) {
SharedPreferences sharedPreferences = getSharedPreferences ( " , MODE_PRIVATE ) ;
String preference = sharedPreferences . getString ( key , " ) ;
return preference ;
}
}
package eu . danman . mediacenter ;
import java . io . StringReader ;
import java . net . URLEncoder ;
import java . util . Iterator ;
import java . util . List ;
import org . w3c . dom . Document ;
import org . w3c . dom . Node ;
import org . w3c . dom . NodeList ;
import org . xml . sax . InputSource ;
import android . app . Activity ;
import android . content . Context ;
import android . os . Bundle ;
import android . preference . CheckBoxPreference ;
import android . preference . EditTextPreference ;
import android . preference . Preference ;
import android . preference . Preference . OnPreferenceChangeListener ;
import android . preference . PreferenceActivity ;
import android . util . Log ;
import android . widget . Toast ;
public class SettingsActivity extends PreferenceActivity {
MediaCenter global ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
addPreferencesFromResource ( R . xml . settings ) ;
global = ( MediaCenter ) getApplicationContext ( ) ;
global . loadProfile ( ) ;
final OnPreferenceChangeListener save = new Preference . OnPreferenceChangeListener ( ) {
public boolean onPreferenceChange ( Preference preference , Object newValue ) {
String res = global . get ( " + preference . getKey ( ) + " + URLEncoder . encode ( newValue . toString ( ) ) ) ;
if ( res . contains ( " ) ) {
setVal ( preference , newValue . toString ( ) ) ;
}
Toast . makeText ( getApplicationContext ( ) , res , Toast . LENGTH_SHORT ) . show ( ) ;
return false ;
}
} ;
Preference unamePref = ( Preference ) findPreference ( " ) ;
unamePref . setTitle ( " + global . profileVar ( " ) ) ;
XMLParser parser = new XMLParser ( ) ;
String xmlch = global . get ( " ) ;
InputSource isch = new InputSource ( ) ;
isch . setCharacterStream ( new StringReader ( xmlch ) ) ;
Document xmlEPG = parser . getDomElement ( isch ) ;
NodeList idN = xmlEPG . getElementsByTagName ( " ) ;
NodeList nameN = xmlEPG . getElementsByTagName ( " ) ;
String [ ] chanNames = new String [ idN . getLength ( ) ] ;
String [ ] chanIds = new String [ idN . getLength ( ) ] ;
boolean [ ] <unk> = new boolean [ idN . getLength ( ) ] ;
for ( int i = <num> ; i < idN . getLength ( ) ; i ++ ) {
chanIds [ i ] = idN . item ( i ) . getTextContent ( ) ;
chanNames [ i ] = nameN . item ( i ) . getTextContent ( ) ;
}
ListPreferenceMultiSelect chans = ( ListPreferenceMultiSelect ) findPreference ( " ) ;
chans . setEntries ( chanNames ) ;
chans . setEntryValues ( chanIds ) ;
chans . setEntryStatuses ( global . profileVar ( " ) ) ;
chans . setOnPreferenceChangeListener ( save ) ;
String [ ] prefs = { " , " , " , " , " } ;
for ( int i = <num> ; i < prefs . length ; i ++ )
{
final Preference thisPref = getPreferenceManager ( ) . findPreference ( prefs [ i ] ) ;
thisPref . setPersistent ( false ) ;
setVal ( thisPref , global . profileVar ( prefs [ i ] ) ) ;
thisPref . setOnPreferenceChangeListener ( save ) ;
}
}
private void setVal ( Preference mPref , String val ) {
if ( mPref . getClass ( ) . equals ( new CheckBoxPreference ( global ) . getClass ( ) ) ) {
( ( CheckBoxPreference ) mPref ) . setChecked ( global . str2bool ( val ) ) ;
}
if ( mPref . getClass ( ) . equals ( new EditTextPreference ( global ) . getClass ( ) ) ) {
( ( EditTextPreference ) mPref ) . setText ( " + val ) ;
}
}
@Override
public void onPause ( ) {
super . onPause ( ) ;
global . loadProfile ( ) ;
}
}
package eu . danman . mediacenter ;
public final class BuildConfig {
public final static boolean DEBUG = true ;
package eu . danman . mediacenter ;
import android . app . Activity ;
import android . util . FloatMath ;
import android . util . Log ;
import android . view . View ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . content . pm . ActivityInfo ;
import android . graphics . Bitmap ;
import android . graphics . BitmapFactory ;
import android . graphics . Matrix ;
import android . graphics . drawable . BitmapDrawable ;
import android . hardware . Sensor ;
import android . hardware . SensorEvent ;
import android . hardware . SensorEventListener ;
import android . hardware . SensorManager ;
import android . os . Bundle ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . ImageView ;
import android . widget . TextView ;
public class MenuActivity2 extends Activity implements SensorEventListener {
SensorManager sensorManager = null ;
TextView outputX ;
TextView outputY ;
TextView outputZ ;
TextView outputX2 ;
TextView outputY2 ;
TextView outputZ2 ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_LANDSCAPE ) ;
sensorManager = ( SensorManager ) getSystemService ( SENSOR_SERVICE ) ;
setContentView ( R . layout . menu1 ) ;
initArrow ( ) ;
outputX = ( TextView ) findViewById ( R . id . textView1 ) ;
outputY = ( TextView ) findViewById ( R . id . textView2 ) ;
outputZ = ( TextView ) findViewById ( R . id . textView3 ) ;
outputX2 = ( TextView ) findViewById ( R . id . textView4 ) ;
outputY2 = ( TextView ) findViewById ( R . id . textView5 ) ;
outputZ2 = ( TextView ) findViewById ( R . id . textView6 ) ;
final Button button = ( Button ) findViewById ( R . id . button1 ) ;
button . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
Bundle bundle = new Bundle ( ) ;
bundle . putString ( " , " ) ;
Intent myIntent = null ;
myIntent = new Intent ( getBaseContext ( ) , PlayerActivity . class ) ;
myIntent . putExtras ( bundle ) ;
startActivity ( myIntent ) ;
}
} ) ;
final Button button2 = ( Button ) findViewById ( R . id . button2 ) ;
button2 . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
SharedPreferences sharedPreferences = getSharedPreferences ( " , MODE_PRIVATE ) ;
SharedPreferences . Editor editor = sharedPreferences . edit ( ) ;
editor . putString ( " , " ) ;
editor . putString ( " , " ) ;
editor . putString ( " , " ) ;
editor . commit ( ) ;
startActivity ( new Intent ( getBaseContext ( ) , LoginActivity . class ) ) ;
finish ( ) ;
}
} ) ;
MediaCenter server = ( ( MediaCenter ) getApplicationContext ( ) ) ;
}
@Override
protected void onResume ( ) {
super . onResume ( ) ;
sensorManager . registerListener ( this , sensorManager . getDefaultSensor ( Sensor . TYPE_ACCELEROMETER ) , sensorManager . SENSOR_DELAY_GAME ) ;
sensorManager . registerListener ( this , sensorManager . getDefaultSensor ( Sensor . TYPE_ORIENTATION ) , sensorManager . SENSOR_DELAY_GAME ) ;
}
@Override
protected void onStop ( ) {
super . onStop ( ) ;
sensorManager . unregisterListener ( this , sensorManager . getDefaultSensor ( Sensor . TYPE_ACCELEROMETER ) ) ;
sensorManager . unregisterListener ( this , sensorManager . getDefaultSensor ( Sensor . TYPE_ORIENTATION ) ) ;
}
public void onSensorChanged ( SensorEvent event ) {
synchronized ( this ) {
switch ( event . sensor . getType ( ) ) {
case Sensor . TYPE_ACCELEROMETER :
outputX . setText ( " + Float . toString ( event . values [ <num> ] ) ) ;
outputY . setText ( " + Float . toString ( event . values [ <num> ] ) ) ;
outputZ . setText ( " + Float . toString ( event . values [ <num> ] ) ) ;
break ;
case Sensor . TYPE_ORIENTATION :
outputX2 . setText ( " + Float . toString ( event . values [ <num> ] ) ) ;
outputY2 . setText ( " + Float . toString ( event . values [ <num> ] ) ) ;
outputZ2 . setText ( " + Float . toString ( event . values [ <num> ] ) ) ;
turnArrow ( ( float ) ( <num> * event . values [ <num> ] ) ) ;
break ;
}
}
}
@Override
public void onAccuracyChanged ( Sensor sensor , int accuracy ) { }
Bitmap bitmapOrg ;
float scaleWidth ;
float scaleHeight ;
int width ;
int height ;
ImageView rotacka ;
float [ ] degs = { <num> , <num> , <num> , <num> , <num> } ;
private void initArrow ( ) {
bitmapOrg = BitmapFactory . decodeResource ( getResources ( ) , R . drawable . arrow2 ) ;
width = <num> ;
height = <num> ;
rotacka = ( ImageView ) findViewById ( R . id . arrowImage ) ;
}
private void turnArrow ( float deg ) {
degs [ <num> ] = degs [ <num> ] ;
degs [ <num> ] = degs [ <num> ] ;
degs [ <num> ] = degs [ <num> ] ;
degs [ <num> ] = degs [ <num> ] ;
degs [ <num> ] = deg ;
float averdeg = ( degs [ <num> ] + degs [ <num> ] + degs [ <num> ] ) / <num> ;
Matrix matrix = new Matrix ( ) ;
matrix . postRotate ( averdeg ) ;
Bitmap resizedBitmap = Bitmap . createBitmap ( bitmapOrg , <num> , <num> , width , height , matrix , true ) ;
BitmapDrawable bmd = new BitmapDrawable ( resizedBitmap ) ;
rotacka . setImageDrawable ( bmd ) ;
}
}
package eu . danman . mediacenter ;
import android . app . Activity ;
import android . util . FloatMath ;
import android . util . Log ;
import android . view . Display ;
import android . view . View ;
import android . view . ViewGroup . LayoutParams ;
import android . view . WindowManager ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . content . pm . ActivityInfo ;
import android . graphics . Bitmap ;
import android . graphics . BitmapFactory ;
import android . graphics . Matrix ;
import android . graphics . Point ;
import android . graphics . drawable . BitmapDrawable ;
import android . hardware . Sensor ;
import android . hardware . SensorEvent ;
import android . hardware . SensorEventListener ;
import android . hardware . SensorManager ;
import android . os . Bundle ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . ImageButton ;
import android . widget . ImageView ;
import android . widget . ImageView . ScaleType ;
import android . widget . TextView ;
public class MenuActivity1 extends Activity implements SensorEventListener {
SensorManager sensorManager = null ;
TextView outputX ;
TextView outputX2 ;
Button btnTV ;
Button btnVOD ;
Button btnEPG ;
Button btnLogout ;
Button btnSettings ;
Button btnListTV ;
ImageButton btnRefresh ;
MediaCenter global ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_LANDSCAPE ) ;
setContentView ( R . layout . menu1 ) ;
outputX = ( TextView ) findViewById ( R . id . textView1 ) ;
outputX2 = ( TextView ) findViewById ( R . id . textView4 ) ;
btnRefresh = ( ImageButton ) findViewById ( R . id . btnRefresh ) ;
btnTV = ( Button ) findViewById ( R . id . btnTV ) ;
btnVOD = ( Button ) findViewById ( R . id . btnVOD ) ;
btnLogout = ( Button ) findViewById ( R . id . btnLogout ) ;
btnEPG = ( Button ) findViewById ( R . id . btnEPG ) ;
btnSettings = ( Button ) findViewById ( R . id . btnSettings ) ;
btnListTV = ( Button ) findViewById ( R . id . btnListTV ) ;
initBall ( ) ;
btnTV . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
Bundle bundle = new Bundle ( ) ;
bundle . putString ( " , " ) ;
Intent myIntent = null ;
myIntent = new Intent ( getBaseContext ( ) , PlayerActivity . class ) ;
myIntent . putExtras ( bundle ) ;
startActivity ( myIntent ) ;
}
} ) ;
btnVOD . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
Bundle bundle = new Bundle ( ) ;
bundle . putString ( " , " ) ;
Intent myIntent = null ;
myIntent = new Intent ( getBaseContext ( ) , PlaylistActivity . class ) ;
myIntent . putExtras ( bundle ) ;
startActivity ( myIntent ) ;
}
} ) ;
btnListTV . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
Bundle bundle = new Bundle ( ) ;
bundle . putString ( " , " ) ;
Intent myIntent = null ;
myIntent = new Intent ( getBaseContext ( ) , PlaylistActivity . class ) ;
myIntent . putExtras ( bundle ) ;
startActivity ( myIntent ) ;
}
} ) ;
btnLogout . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
global . get ( " ) ;
}
} ) ;
btnSettings . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
startActivity ( new Intent ( getBaseContext ( ) , SettingsActivity . class ) ) ;
}
} ) ;
btnEPG . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
startActivity ( new Intent ( getBaseContext ( ) , EPGActivity . class ) ) ;
}
} ) ;
btnRefresh . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
startX = <num> ;
startY = <num> ;
ball . scrollTo ( <num> , <num> ) ;
}
} ) ;
global = ( ( MediaCenter ) getApplicationContext ( ) ) ;
}
@Override
protected void onResume ( ) {
super . onResume ( ) ;
sensorManager = ( SensorManager ) getSystemService ( SENSOR_SERVICE ) ;
global . loadProfile ( ) ;
gravity = ( global . profileVar ( " ) . contains ( " ) ) ?  <num> : <num> ;
gravity *= <num> ;
startX = <num> ;
startY = <num> ;
ball . scrollTo ( <num> , <num> ) ;
if ( ! global . str2bool ( global . profileVar ( " ) ) ) {
sensorManager . registerListener ( this , sensorManager . getDefaultSensor ( Sensor . TYPE_ORIENTATION ) , sensorManager . SENSOR_DELAY_GAME ) ;
sensorManager . registerListener ( this , sensorManager . getDefaultSensor ( Sensor . TYPE_ACCELEROMETER ) , sensorManager . SENSOR_DELAY_GAME ) ;
}
( ( TextView ) findViewById ( R . id . textWelcome ) ) . setText ( " + global . profileVar ( " ) ) ;
}
@Override
protected void onPause ( ) {
super . onPause ( ) ;
sensorManager . unregisterListener ( this , sensorManager . getDefaultSensor ( Sensor . TYPE_ACCELEROMETER ) ) ;
sensorManager . unregisterListener ( this , sensorManager . getDefaultSensor ( Sensor . TYPE_ORIENTATION ) ) ;
}
float startX ;
float startY ;
public void onSensorChanged ( SensorEvent event ) {
if ( ball == null ) return ;
synchronized ( this ) {
switch ( event . sensor . getType ( ) ) {
case Sensor . TYPE_ACCELEROMETER :
break ;
case Sensor . TYPE_ORIENTATION :
if ( startX == <num> ) {
startX = event . values [ <num> ] ;
break ;
}
if ( startY == <num> ) {
startY = event . values [ <num> ] ;
break ;
}
int mvX = ( int ) ( startX  event . values [ <num> ] ) ;
int mvY = ( int ) ( startY  event . values [ <num> ] ) ;
if ( abs ( ball . getScrollX ( )  mvX * gravity ) < maxX ) {
ball . scrollBy (  mvX * gravity , <num> ) ;
}
if ( abs ( ball . getScrollY ( ) + mvY * gravity ) < maxY ) {
ball . scrollBy ( <num> , + mvY * gravity ) ;
}
checkDist ( btnTV ) ;
checkDist ( btnEPG ) ;
checkDist ( btnLogout ) ;
checkDist ( btnSettings ) ;
checkDist ( btnVOD ) ;
checkDist ( btnListTV ) ;
break ;
}
}
}
private int abs ( int val ) {
if ( val < <num> ) return  val ;
return val ;
}
private void checkDist ( View obj ) {
if ( ( distX ( obj ) < <num> ) && ( distY ( obj ) < <num> ) ) {
ball . scrollTo ( <num> , <num> ) ;
obj . performClick ( ) ;
}
}
private int distX ( View obj ) {
return abs ( maxX  ball . getScrollX ( )  obj . getLeft ( )  obj . getHeight ( ) / <num> ) ;
}
private int distY ( View obj ) {
return abs ( maxY  ball . getScrollY ( )  obj . getTop ( )  obj . getWidth ( ) / <num> ) ;
}
@Override
public void onAccuracyChanged ( Sensor sensor , int accuracy ) {
startX = <num> ;
startY = <num> ;
Log . d ( " , " ) ;
}
Bitmap bitmapOrg ;
float scaleWidth ;
float scaleHeight ;
int width ;
int height ;
ImageView ball ;
LayoutParams params ;
int maxX , maxY ;
int gravity ;
float [ ] degs = { <num> , <num> , <num> , <num> , <num> } ;
private void initBall ( ) {
ball = ( ImageView ) findViewById ( R . id . ball ) ;
Display display = getWindowManager ( ) . getDefaultDisplay ( ) ;
maxX = display . getWidth ( ) / <num> ;
maxY = display . getHeight ( ) / <num> ;
}
}
package eu . danman . mediacenter ;
import java . io . IOException ;
import java . io . StringReader ;
import java . io . UnsupportedEncodingException ;
import javax . xml . parsers . DocumentBuilder ;
import javax . xml . parsers . DocumentBuilderFactory ;
import javax . xml . parsers . ParserConfigurationException ;
import org . apache . http . HttpEntity ;
import org . apache . http . HttpResponse ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . client . methods . HttpPost ;
import org . apache . http . impl . client . DefaultHttpClient ;
import org . apache . http . util . EntityUtils ;
import org . w3c . dom . Document ;
import org . w3c . dom . Element ;
import org . w3c . dom . Node ;
import org . w3c . dom . NodeList ;
import org . xml . sax . InputSource ;
import org . xml . sax . SAXException ;
import android . util . Log ;
public class XMLParser {
public XMLParser ( ) {
}
public Document getDomElement ( InputSource is ) {
Document doc = null ;
DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ;
try {
DocumentBuilder db = dbf . newDocumentBuilder ( ) ;
doc = db . parse ( is ) ;
} catch ( ParserConfigurationException e ) {
Log . e ( " , e . getMessage ( ) ) ;
return null ;
} catch ( SAXException e ) {
Log . e ( " , e . getMessage ( ) ) ;
return null ;
} catch ( IOException e ) {
Log . e ( " , e . getMessage ( ) ) ;
return null ;
}
return doc ;
}
public final String getElementValue ( Node elem ) {
Node child ;
if ( elem != null ) {
if ( elem . hasChildNodes ( ) ) {
for ( child = elem . getFirstChild ( ) ; child != null ; child = child . getNextSibling ( ) ) {
if ( child . getNodeType ( ) == Node . TEXT_NODE ) {
return child . getNodeValue ( ) ;
}
}
}
}
return " ;
}
public String getValue ( Element item , String str ) {
NodeList n = item . getElementsByTagName ( str ) ;
return this . getElementValue ( n . item ( <num> ) ) ;
}
}
package eu . danman . mediacenter ;
import java . util . Timer ;
import java . util . TimerTask ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . os . SystemClock ;
import android . util . Log ;
public class <unk> extends Activity {
Timer timer ;
TimerTask task ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . intro ) ;
timer = new Timer ( ) ;
final MediaCenter global = ( ( MediaCenter ) getApplicationContext ( ) ) ;
task = new TimerTask ( ) {
@Override
public void run ( ) {
global . loadProfile ( ) ;
String menu = global . profileVar ( " ) ;
Log . d ( " , menu ) ;
if ( menu . equals ( " ) ) {
startActivity ( new Intent ( getApplicationContext ( ) , MenuActivity1 . class ) ) ;
}
timer . cancel ( ) ;
finish ( ) ;
}
} ;
timer . schedule ( task , <num> , <num> ) ;
}
}
package multi . threaded . trains . model ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . concurrent . CopyOnWriteArrayList ;
import java . util . concurrent . CountDownLatch ;
import java . util . concurrent . ExecutorService ;
import java . util . concurrent . Executors ;
import org . apache . log4j . Logger ;
import multi . threaded . trains . base . Resource ;
import multi . threaded . trains . utils . PropertiesLoader ;
public class ResourcesCollection {
private static Logger log = Logger . getLogger ( ResourcesCollection . class ) ;
private static List < Resource > trainSimulatorResources ;
private static List < String > trainSimulatorResourcesByName ;
private static ResourcesCollection resourcesCollection = getSingletonResourcesCollection ( ) ;
private ResourcesCollection ( ) {
trainSimulatorResources = new CopyOnWriteArrayList < Resource > ( ) ;
trainSimulatorResourcesByName = new ArrayList < String > ( ) ;
}
private static ResourcesCollection getSingletonResourcesCollection ( ) {
if ( resourcesCollection == null ) {
resourcesCollection = new ResourcesCollection ( ) ;
}
return resourcesCollection ;
}
public static String <unk> ( String bringMeNextStrResource ) {
if ( bringMeNextStrResource == null ) {
return trainSimulatorResourcesByName . get ( <num> ) ;
}
for ( String currentResourceStr : trainSimulatorResourcesByName ) {
if ( currentResourceStr . equals ( bringMeNextStrResource ) ) {
int currentResourceStrPosition = trainSimulatorResourcesByName . indexOf ( currentResourceStr ) ;
if ( currentResourceStrPosition == trainSimulatorResourcesByName . size ( )  <num> ) {
return trainSimulatorResourcesByName . get ( <num> ) ;
} else {
return trainSimulatorResourcesByName . get ( ++ currentResourceStrPosition ) ;
}
}
}
return null ;
}
public static Resource getNextTrainSimulatorResource ( Resource bringMeNextResource ) {
if ( bringMeNextResource == null ) {
return trainSimulatorResources . get ( <num> ) ;
}
for ( Resource currentResource : trainSimulatorResources ) {
if ( currentResource . equals ( bringMeNextResource ) ) {
int currentResourcePosition = trainSimulatorResources . indexOf ( currentResource ) ;
if ( currentResourcePosition == trainSimulatorResources . size ( )  <num> ) {
return trainSimulatorResources . get ( <num> ) ;
} else {
return trainSimulatorResources . get ( ++ currentResourcePosition ) ;
}
}
}
return null ;
}
public static void createStationAndRailResourcesForTheTrainSimulator ( ) {
for ( int i = <num> ; i < PropertiesLoader . getTotalStationNumber ( ) ; i ++ ) {
IStation newStation = Station . newConcurrentQueueCargoStation ( ) ;
trainSimulatorResources . add ( newStation ) ;
trainSimulatorResourcesByName . add ( newStation . getResourceName ( ) ) ;
log . info ( " + newStation . getStationName ( ) + " ) ;
IRailTrack newRailTrack = RailTrack . newRailTrack ( ) ;
trainSimulatorResources . add ( newRailTrack ) ;
trainSimulatorResourcesByName . add ( newRailTrack . getResourceName ( ) ) ;
log . info ( " + newRailTrack . getResourceName ( ) + " ) ;
}
}
public static void createTrainsAndCargoGeneratorThreads ( CountDownLatch latch ) {
int totalTrainsNumber = PropertiesLoader . getTotalTrainNumber ( ) ;
int totalCargoGeneratorNumber = <num> ;
ExecutorService executor = Executors . newFixedThreadPool ( totalCargoGeneratorNumber + totalTrainsNumber ) ;
for ( int i = <num> ; i < totalTrainsNumber ; i ++ ) {
ITrain newTrain = Train . newTrain ( latch ) ;
executor . execute ( newTrain ) ;
log . info ( " + newTrain . getTrainName ( ) + " ) ;
}
CargoGenerator cargoGenerator = CargoGenerator . create ( latch ) ;
executor . execute ( cargoGenerator ) ;
log . info ( " + CargoGenerator . getCargoGeneratorName ( ) + " ) ;
executor . shutdown ( ) ;
}
}
package multi . threaded . trains . utils ;
public enum PropertiesParams {
STATIONS_TOTAL_NUMBER ( " , <num> ) ,
STATIONS_CARGO_CAPACITY ( " , <num> ) ,
TRAINS_TOTAL_NUMBER ( " , <num> ) ,
TRAINS_CARGO_CAPACITY ( " , <num> ) ,
TRAINS_CARGO_UNIT_LOAD_TIME ( " , <num> ) ,
TRAINS_CARGO_UNIT_UNLOAD_TIME ( " , <num> ) ,
TRAINS_MAX_SPEED ( " , <num> ) ,
RAIL_TRACK_MAX_DISTANCE_UNIT ( " , <num> ) ,
CARGO_GENERATOR_MAX_SLEEP_TIME ( " , <num> ) ;
private PropertiesParams ( String param , int defaultValue ) {
this . param = param ;
this . defaultValue = defaultValue ;
}
private String param ;
private int defaultValue ;
@Override
public String toString ( ) {
return this . param ;
}
public int getDefaultValue ( ) {
return this . defaultValue ;
}
}
package multi . threaded . trains . base ;
public enum ValidationError {
<unk> ( " , false ) ,
CANNOT_LOAD_PROPERTIES ( " , false ) ,
CANNOT_FIND_STATIONS_CARGO_CAPACITY ( " , true ) ,
CANNOT_FIND_TRAINS_CARGO_CAPACITY ( " , true ) ,
CANNOT_FIND_STATIONS_TOTAL_NUMBER ( " , true ) ,
CANNOT_FIND_TRAINS_TOTAL_NUMBER ( " , true ) ,
CANNOT_FIND_TRAINS_CARGO_UNIT_LOAD_TIME ( " , true ) ,
CANNOT_FIND_TRAINS_CARGO_UNIT_UNLOAD_TIME ( " , true ) ,
ERROR_WHILE_UNLOADING_TRAIN_CARGO ( " , false ) ,
CANNOT_FIND_TRAINS_MAX_SPEED ( " , true ) ,
CANNOT_FIND_RAIL_TRACK_MAX_DISTANCE_UNIT ( " , true ) ,
ERROR_WHILE_TRAIN_COMMUTING ( " , true ) ,
ERROR_WHILE_LOADING_TRAIN_CARGO_FROM_STATION ( " , false ) ,
ERROR_WHILE_UNLOADING_TRAIN_CARGO_TO_STATION ( " , false ) ,
CANNOT_FIND_CARGO_GENERATOR_MAX_SLEEP_TIME ( " , true ) ,
ERROR_WHILE_CARGO_GENERATOR_WAS_SLEEPING ( " , false ) ,
ERROR_WHILE_TRAINS_AWAITING_COUNTDOWN_LATCH_SIGNAL ( " , false ) ,
<unk> ( " , false ) ;
private ValidationError ( String message , boolean canRecover ) {
this . message = message ;
this . canRecover = canRecover ;
}
private String message ;
private boolean canRecover ;
@Override
public String toString ( ) {
return message ;
}
public boolean canRecover ( ) {
return this . canRecover ;
}
}
package multi . threaded . trains . base ;
public class MultithreadedTrainsException extends Exception {
private static final long serialVersionUID = <num> ;
private boolean recover ;
public MultithreadedTrainsException ( ValidationError error ) {
super ( error . toString ( ) ) ;
}
public boolean <unk> ( ) {
return this . recover ;
}
}
package multi . threaded . trains . model ;
import java . util . concurrent . CountDownLatch ;
import multi . threaded . trains . base . Resource ;
import multi . threaded . trains . base . TrainStateMachine ;
import multi . threaded . trains . base . ValidationError ;
import multi . threaded . trains . utils . NumberUtils ;
import org . apache . log4j . Logger ;
import com . google . common . base . Joiner ;
import com . google . common . collect . ArrayListMultimap ;
import com . google . common . collect . ListMultimap ;
import com . google . common . collect . Multimaps ;
public class Train implements ITrain {
private static int trainNameCounterUniqueIdentifier = <num> ;
private static final Logger log = Logger . getLogger ( Train . class ) ;
private final String trainName ;
private ListMultimap < String , ICargo > deliveryCargoMap ;
private int currentTrainCargoSpaceLeft ;
private double trainSpeed = NumberUtils . getRandomTrainSpeed ( ) ;
private Resource currentResource ;
private CountDownLatch latch ;
private TrainStateMachine currentTrainState ;
private Train ( ListMultimap < String , ICargo > deliveryCargoMap , CountDownLatch latch ) {
trainName = TRAIN_NAME_PREFIX + ++ trainNameCounterUniqueIdentifier ;
this . deliveryCargoMap = deliveryCargoMap ;
currentTrainCargoSpaceLeft = trainCargoCapacity ;
currentTrainState = TrainStateMachine . UNLOADING_CARGO_TO_STATION ;
this . latch = latch ;
}
public static ITrain newTrain ( CountDownLatch latch ) {
ListMultimap < String , ICargo > deliveryCargoMap = ArrayListMultimap . create ( ) ;
return new Train ( Multimaps . <unk> ( deliveryCargoMap ) , latch ) ;
}
public void <unk> ( ICargo <unk> ) {
try {
Thread . sleep ( trainCargoUnitLoadTime ) ;
} catch ( InterruptedException e ) {
log . error ( ValidationError . ERROR_WHILE_UNLOADING_TRAIN_CARGO ) ;
}
}
public String getTrainName ( ) {
return this . trainName ;
}
public TrainStateMachine <unk> ( ) {
return this . currentTrainState ;
}
public TrainStateMachine transitionToNextTrainState ( ) {
currentTrainState = currentTrainState . stateMachineTransition ( ) ;
return currentTrainState ;
}
public void lockRailTrackAndCommute ( IRailTrack railTrack ) {
synchronized ( railTrack ) {
currentResource = railTrack ;
logCurrentTrainOverallState ( ) ;
log . info ( " + currentResource . getResourceName ( ) + " ) ;
try {
Thread . sleep ( ( long ) ( trainSpeed * <num> ) ) ;
} catch ( InterruptedException e ) {
log . error ( ValidationError . ERROR_WHILE_TRAIN_COMMUTING ) ;
}
}
}
public void loadStationCargo ( IStation station ) {
currentResource = station ;
boolean hasLoaded = false ;
logCurrentTrainOverallState ( ) ;
while ( currentTrainCargoSpaceLeft > <num> && station . isStationCargoAvailable ( ) ) {
ICargo currentStationCargo = station . loadToTrainStationCargo ( ) ;
this . deliveryCargoMap . put ( currentStationCargo . getDeliveryStation ( ) . getStationName ( ) , currentStationCargo ) ;
currentTrainCargoSpaceLeft  ;
hasLoaded = true ;
log . info ( " + station . getResourceName ( ) + " ) ;
try {
Thread . sleep ( trainCargoUnitLoadTime ) ;
} catch ( InterruptedException e ) {
log . error ( ValidationError . ERROR_WHILE_LOADING_TRAIN_CARGO_FROM_STATION ) ;
}
}
if ( ! hasLoaded ) {
log . info ( " + station . getStationName ( ) ) ;
}
}
public void unloadTrainCargoToDestinationStation ( IStation station ) {
currentResource = station ;
boolean hasUnloaded = false ;
logCurrentTrainOverallState ( ) ;
if ( deliveryCargoMap . containsKey ( currentResource . getResourceName ( ) ) ) {
int numOfCargosForThisStation = deliveryCargoMap . get ( currentResource . getResourceName ( ) ) . size ( ) ;
deliveryCargoMap . removeAll ( currentResource . getResourceName ( ) ) ;
currentTrainCargoSpaceLeft += numOfCargosForThisStation ;
hasUnloaded = true ;
log . info ( " + numOfCargosForThisStation + " + ( numOfCargosForThisStation > <num> ? " : " ) + " + currentResource . getResourceName ( ) + " ) ;
try {
Thread . sleep ( trainCargoUnitUnloadTime ) ;
} catch ( InterruptedException e ) {
log . error ( ValidationError . ERROR_WHILE_UNLOADING_TRAIN_CARGO_TO_STATION ) ;
}
}
if ( ! hasUnloaded ) {
log . info ( " + station . getStationName ( ) ) ;
}
}
@Override
public void run ( ) {
try {
Thread . currentThread ( ) . setName ( trainName ) ;
latch . await ( ) ;
while ( true ) {
switch ( currentTrainState ) {
case COMMUTING : {
Resource nextResource = ResourcesCollection . getNextTrainSimulatorResource ( currentResource ) ;
IRailTrack railTrack = ( IRailTrack ) nextResource ;
lockRailTrackAndCommute ( railTrack ) ;
break ; }
case UNLOADING_CARGO_TO_STATION : {
Resource nextResource = ResourcesCollection . getNextTrainSimulatorResource ( currentResource ) ;
IStation station = ( IStation ) nextResource ;
unloadTrainCargoToDestinationStation ( station ) ;
break ; }
case LOADING_STATION_CARGO : {
IStation station = ( IStation ) currentResource ;
loadStationCargo ( station ) ;
break ; }
}
transitionToNextTrainState ( ) ;
}
} catch ( InterruptedException e ) {
log . error ( ValidationError . ERROR_WHILE_TRAINS_AWAITING_COUNTDOWN_LATCH_SIGNAL ) ;
}
}
private void logCurrentTrainOverallState ( ) {
log . info ( this . toString ( ) ) ;
}
@Override
public String toString ( ) {
StringBuilder output = new StringBuilder ( getTrainName ( ) ) . append ( " ) ;
output . append ( currentTrainState . toString ( ) ) . append ( " ) . append ( currentResource . getResourceName ( ) ) ;
output . append ( " ) . append ( deliveryCargoMap . size ( ) ) ;
if ( ! deliveryCargoMap . isEmpty ( ) ) {
output . append ( " ) ;
output . append ( Joiner . on ( " ) . <unk> ( ) . join ( deliveryCargoMap . keys ( ) ) ) ;
}
return output . toString ( ) ;
}
}
package multi . threaded . trains . base ;
public enum TrainStateMachine {
COMMUTING ( " ) {
public TrainStateMachine stateMachineTransition ( ) {
return UNLOADING_CARGO_TO_STATION ;
}
} ,
UNLOADING_CARGO_TO_STATION ( " ) {
public TrainStateMachine stateMachineTransition ( ) {
return LOADING_STATION_CARGO ;
}
} ,
LOADING_STATION_CARGO ( " ) {
public TrainStateMachine stateMachineTransition ( ) {
return COMMUTING ;
}
} ;
public abstract TrainStateMachine stateMachineTransition ( ) ;
private String name ;
private TrainStateMachine ( String name ) {
this . name = name ;
}
@Override
public String toString ( ) {
return this . name ;
}
}
package multi . threaded . trains . model ;
public class Cargo implements ICargo {
private final IStation deliveryStation ;
private Cargo ( IStation deliveryStation ) {
this . deliveryStation = deliveryStation ;
}
public static ICargo newCargo ( IStation deliveryStation ) {
return new Cargo ( deliveryStation ) ;
}
@Override
public final IStation getDeliveryStation ( ) {
return this . deliveryStation ;
}
@Override
public String toString ( ) {
return " + deliveryStation . getStationName ( ) ;
}
}
package multi . threaded . trains . model ;
import multi . threaded . trains . base . Resource ;
public abstract interface IStation extends Resource {
public static final String STATION_NAME_PREFIX = " ;
public abstract String getStationName ( ) ;
public abstract boolean addStationCargo ( ICargo cargo ) ;
public abstract ICargo loadToTrainStationCargo ( ) ;
public abstract boolean isStationCargoAvailable ( ) ;
}
package multi . threaded . trains . model ;
public interface ICargo {
public abstract IStation getDeliveryStation ( ) ;
}
package multi . threaded . trains . service ;
import java . util . concurrent . CountDownLatch ;
import multi . threaded . trains . model . ResourcesCollection ;
public class <unk> {
public static void main ( String [ ] args ) {
CountDownLatch signalLatch = new CountDownLatch ( <num> ) ;
Thread . currentThread ( ) . setName ( " ) ;
ResourcesCollection . createStationAndRailResourcesForTheTrainSimulator ( ) ;
ResourcesCollection . createTrainsAndCargoGeneratorThreads ( signalLatch ) ;
signalLatch . countDown ( ) ;
}
}
package multi . threaded . trains . model ;
import multi . threaded . trains . base . Resource ;
import multi . threaded . trains . utils . NumberUtils ;
public class RailTrack implements IRailTrack {
private static int railTrackNameCounterUniqueIdentifier = <num> ;
private IStation nextStation ;
private final String railTrackName ;
private double railTrackDistance = NumberUtils . getRandomRailTrackDistanceUnits ( ) ;
private RailTrack ( ) {
railTrackName = RAIL_TRACK_PREFIX + ++ railTrackNameCounterUniqueIdentifier ;
}
public static IRailTrack newRailTrack ( ) {
return new RailTrack ( ) ;
}
public IStation <unk> ( ) {
return this . nextStation ;
}
public double <unk> ( ) {
return this . railTrackDistance ;
}
public String getRailTrackName ( ) {
return this . railTrackName ;
}
@Override
public String getResourceName ( ) {
return getRailTrackName ( ) ;
}
@Override
public ResourceType getResourceType ( ) {
return Resource . ResourceType . RAIL_TRACK ;
}
@Override
public String toString ( ) {
return railTrackName ;
}
}
package multi . threaded . trains . utils ;
import java . io . IOException ;
import java . io . InputStream ;
import java . util . Properties ;
import multi . threaded . trains . base . MultithreadedTrainsException ;
import multi . threaded . trains . base . ValidationError ;
import org . apache . log4j . Logger ;
public class PropertiesLoader {
private static final Logger log = Logger . getLogger ( PropertiesLoader . class ) ;
private static Properties properties = new Properties ( ) ;
private PropertiesLoader ( ) { }
static {
try {
load ( ) ;
} catch ( MultithreadedTrainsException mte ) {
log . info ( mte . getMessage ( ) ) ;
}
}
private static void load ( ) throws MultithreadedTrainsException {
try {
InputStream in = PropertiesLoader . class . getClass ( ) . getResourceAsStream ( " ) ;
properties . load ( in ) ;
} catch ( IOException ioe ) {
throw new MultithreadedTrainsException ( ValidationError . CANNOT_LOAD_PROPERTIES ) ;
}
}
public static int getStationCargoCapacity ( ) {
return get ( PropertiesParams . STATIONS_CARGO_CAPACITY , ValidationError . CANNOT_FIND_STATIONS_CARGO_CAPACITY ) ;
}
public static int getTrainCargoCapacity ( ) {
return get ( PropertiesParams . TRAINS_CARGO_CAPACITY , ValidationError . CANNOT_FIND_TRAINS_CARGO_CAPACITY ) ;
}
public static int getTotalTrainNumber ( ) {
return get ( PropertiesParams . TRAINS_TOTAL_NUMBER , ValidationError . CANNOT_FIND_TRAINS_TOTAL_NUMBER ) ;
}
public static int getTotalStationNumber ( ) {
return get ( PropertiesParams . STATIONS_TOTAL_NUMBER , ValidationError . CANNOT_FIND_STATIONS_TOTAL_NUMBER ) ;
}
public static int getTrainCargoUnitLoadTime ( ) {
return get ( PropertiesParams . TRAINS_CARGO_UNIT_LOAD_TIME , ValidationError . CANNOT_FIND_TRAINS_CARGO_UNIT_LOAD_TIME ) ;
}
public static int getTrainCargoUnitUnloadTime ( ) {
return get ( PropertiesParams . TRAINS_CARGO_UNIT_UNLOAD_TIME , ValidationError . CANNOT_FIND_TRAINS_CARGO_UNIT_UNLOAD_TIME ) ;
}
public static int getTrainMaxSpeed ( ) {
return get ( PropertiesParams . TRAINS_MAX_SPEED , ValidationError . CANNOT_FIND_TRAINS_MAX_SPEED ) ;
}
public static int getRailTrackMaxDistanceUnit ( ) {
return get ( PropertiesParams . RAIL_TRACK_MAX_DISTANCE_UNIT , ValidationError . CANNOT_FIND_RAIL_TRACK_MAX_DISTANCE_UNIT ) ;
}
public static int getCargoGeneratorMaxSleepTime ( ) {
return get ( PropertiesParams . CARGO_GENERATOR_MAX_SLEEP_TIME , ValidationError . CANNOT_FIND_CARGO_GENERATOR_MAX_SLEEP_TIME ) ;
}
private static int get ( PropertiesParams property , ValidationError validation ) {
String propStr = properties . getProperty ( property . toString ( ) ) ;
if ( propStr == null ) {
log . warn ( validation ) ;
} else {
return Integer . parseInt ( propStr ) ;
}
return property . getDefaultValue ( ) ;
}
}
package multi . threaded . trains . model ;
import multi . threaded . trains . base . Resource ;
public abstract interface IRailTrack extends Resource {
public static final String RAIL_TRACK_PREFIX = " ;
}
package multi . threaded . trains . model ;
public interface ITrainStateAutomata {
public abstract void lockRailTrackAndCommute ( IRailTrack railTrack ) ;
public abstract void unloadTrainCargoToDestinationStation ( IStation station ) ;
public abstract void loadStationCargo ( IStation station ) ;
}
package multi . threaded . trains . model ;
import multi . threaded . trains . utils . PropertiesLoader ;
public interface ITrain extends ITrainStateAutomata , Runnable {
public static final String TRAIN_NAME_PREFIX = " ;
public static final int trainCargoCapacity = PropertiesLoader . getTrainCargoCapacity ( ) ;
public static final int trainCargoUnitLoadTime = PropertiesLoader . getTrainCargoUnitLoadTime ( ) ;
public static final int trainCargoUnitUnloadTime = PropertiesLoader . getTrainCargoUnitUnloadTime ( ) ;
public static final int <unk> = PropertiesLoader . getTrainMaxSpeed ( ) ;
public abstract String getTrainName ( ) ;
}
package multi . threaded . trains . base ;
public abstract interface Resource {
public abstract String getResourceName ( ) ;
public abstract ResourceType getResourceType ( ) ;
public enum ResourceType {
STATION , RAIL_TRACK ;
}
}
package multi . threaded . trains . model ;
import java . util . concurrent . CountDownLatch ;
import org . apache . log4j . Logger ;
import multi . threaded . trains . base . ValidationError ;
import multi . threaded . trains . utils . NumberUtils ;
public class CargoGenerator implements Runnable {
private static final Logger log = Logger . getLogger ( CargoGenerator . class ) ;
private static final String CARGO_GENERATOR_NAME = " ;
private static CargoGenerator cargoGenerator ;
private CountDownLatch latch ;
private CargoGenerator ( CountDownLatch latch ) {
this . latch = latch ;
}
public static CargoGenerator create ( CountDownLatch latch ) {
if ( cargoGenerator == null ) {
cargoGenerator = new CargoGenerator ( latch ) ;
}
return cargoGenerator ;
}
public static String getCargoGeneratorName ( ) {
return CARGO_GENERATOR_NAME ;
}
@Override
public void run ( ) {
try {
Thread . currentThread ( ) . setName ( CARGO_GENERATOR_NAME ) ;
latch . await ( ) ;
while ( true ) {
try {
Thread . sleep ( ( long ) ( NumberUtils . getCargoGeneratorRandomSleepTime ( ) * <num> ) ) ;
IStation randomCargoStation = Station . getStationByName ( NumberUtils . getRandomBaseNameStation ( ) ) ;
IStation randomDeliveryStation = Station . getStationByName ( NumberUtils . getRandomBaseNameStationWithoutStation ( randomCargoStation . getStationName ( ) ) ) ;
ICargo newStationCargo = Cargo . newCargo ( randomDeliveryStation ) ;
boolean successfullyAddedCargo = randomCargoStation . addStationCargo ( newStationCargo ) ;
if ( successfullyAddedCargo ) {
log . info ( " + randomCargoStation . getStationName ( ) + " + randomDeliveryStation . getStationName ( ) ) ;
} else {
log . info ( " + randomCargoStation . getStationName ( ) + " ) ;
}
} catch ( InterruptedException e ) {
log . error ( ValidationError . ERROR_WHILE_CARGO_GENERATOR_WAS_SLEEPING ) ;
}
}
} catch ( InterruptedException e1 ) {
log . error ( ValidationError . ERROR_WHILE_CARGO_GENERATOR_WAS_SLEEPING ) ;
}
}
}
package multi . threaded . trains . utils ;
import java . util . Random ;
import multi . threaded . trains . model . IStation ;
public class NumberUtils {
private static final Random random = new Random ( ) ;
public static int getNextIntRandomNum ( int max ) {
return random . nextInt ( max ) ;
}
public static double getRandomTrainSpeed ( ) {
return random . nextDouble ( ) * PropertiesLoader . getTrainMaxSpeed ( ) ;
}
public static double getRandomRailTrackDistanceUnits ( ) {
return random . nextDouble ( ) * PropertiesLoader . getRailTrackMaxDistanceUnit ( ) ;
}
public static double getCargoGeneratorRandomSleepTime ( ) {
return random . nextDouble ( ) * PropertiesLoader . getCargoGeneratorMaxSleepTime ( ) ;
}
public static String getRandomBaseNameStation ( ) {
return IStation . STATION_NAME_PREFIX + ( getNextIntRandomNum ( PropertiesLoader . getTotalStationNumber ( ) ) + <num> ) ;
}
public static String getRandomBaseNameStationWithoutStation ( String stationToAvoid ) {
String result = stationToAvoid ;
while ( result . equals ( stationToAvoid ) ) {
result = IStation . STATION_NAME_PREFIX + ( getNextIntRandomNum ( PropertiesLoader . getTotalStationNumber ( ) ) + <num> ) ;
}
return result ;
}
}
package multi . threaded . trains . model ;
import java . util . Map ;
import java . util . Queue ;
import java . util . concurrent . ConcurrentHashMap ;
import java . util . concurrent . ConcurrentLinkedQueue ;
import java . util . concurrent . LinkedBlockingDeque ;
import multi . threaded . trains . base . Resource ;
import multi . threaded . trains . utils . PropertiesLoader ;
public class Station implements IStation {
private static int stationNameCounterUniqueIdentifier = <num> ;
private final String stationName ;
private Queue < ICargo > stationCargo ;
private IRailTrack nextRailTrack ;
private Station ( Queue < ICargo > stationCargo ) {
stationName = STATION_NAME_PREFIX + ++ stationNameCounterUniqueIdentifier ;
this . stationCargo = stationCargo ;
}
private static Map < String , IStation > stationsByName = new ConcurrentHashMap < String , IStation > ( ) ;
public static IStation <unk> ( ) {
IStation newStation = new Station ( new LinkedBlockingDeque < ICargo > ( PropertiesLoader . getStationCargoCapacity ( ) ) ) ;
stationsByName . put ( newStation . getStationName ( ) , newStation ) ;
return newStation ;
}
public static IStation newConcurrentQueueCargoStation ( ) {
IStation newStation = new Station ( new ConcurrentLinkedQueue < ICargo > ( ) ) ;
stationsByName . put ( newStation . getStationName ( ) , newStation ) ;
return newStation ;
}
public static IStation getStationByName ( String stationName ) {
return stationsByName . get ( stationName ) ;
}
@Override
public boolean addStationCargo ( ICargo cargo ) {
return isStationCargoFull ( ) ? false : stationCargo . offer ( cargo ) ;
}
@Override
public ICargo loadToTrainStationCargo ( ) {
return stationCargo . poll ( ) ;
}
public IRailTrack <unk> ( ) {
return this . nextRailTrack ;
}
public boolean isStationCargoAvailable ( ) {
return ! stationCargo . isEmpty ( ) ;
}
private boolean isStationCargoFull ( ) {
return stationCargo . size ( ) == PropertiesLoader . getStationCargoCapacity ( ) ;
}
public String getStationName ( ) {
return this . stationName ;
}
public String getResourceName ( ) {
return getStationName ( ) ;
}
@Override
public ResourceType getResourceType ( ) {
return Resource . ResourceType . STATION ;
}
@Override
public String toString ( ) {
return stationName ;
}
}
package trabalhopoo ;
import java . util . Date ;
public class Dependente extends PessoaFisica {
private String sexo ;
private Date dataNascimento ;
private PessoaFisica pFisica ;
public Dependente ( ) {
}
public Dependente ( String sexo , Date dataNascimento ) {
this . sexo = sexo ;
this . dataNascimento = dataNascimento ;
}
public PessoaFisica <unk> ( ) {
return pFisica ;
}
public void setpFisica ( PessoaFisica pFisica ) {
this . pFisica = pFisica ;
}
public Date getDataNascimento ( ) {
return dataNascimento ;
}
public void setDataNascimento ( Date dataNascimento ) {
this . dataNascimento = dataNascimento ;
}
public String getSexo ( ) {
return sexo ;
}
public void setSexo ( String sexo ) {
this . sexo = sexo ;
}
}
package trabalhopoo ;
public class ReservaTelefone extends Reserva {
public ReservaTelefone ( ) {
}
}
package trabalhopoo ;
public interface InterfaceImprimir {
void imprimir ( ) ;
}
package trabalhopoo ;
import java . util . Date ;
public class <unk> {
public static void main ( String [ ] args ) {
PessoaFisica p = new PessoaFisica ( ) ;
p . setCpf ( " ) ;
p . setNome ( " ) ;
p . setEndereco ( " ) ;
p . setLogin ( " ) ;
p . setSenha ( " ) ;
System . out . println ( " + p . getNome ( ) ) ;
Dependente d = new Dependente ( ) ;
d . setpFisica ( p ) ;
d . setNome ( " ) ;
d . setDataNascimento ( new Date ( ) ) ;
d . setSexo ( " ) ;
System . out . println ( " + d . getNome ( ) + " + p . getNome ( ) ) ;
}
}
package trabalhopoo ;
import java . util . Date ;
public abstract class Reserva implements InterfaceImprimir {
private Date data ;
private String rota ;
public Reserva ( ) {
}
public void <unk> ( ) {
}
@Override
public void imprimir ( ) {
System . out . println ( " ) ;
}
public Date getData ( ) {
return data ;
}
public void setData ( Date data ) {
this . data = data ;
}
public String <unk> ( ) {
return rota ;
}
public void <unk> ( String rota ) {
this . rota = rota ;
}
}
package trabalhopoo ;
public class Passagem extends Reserva {
private int poltrona ;
private Double preco ;
private String classe ;
public Passagem ( ) {
}
public String <unk> ( ) {
return classe ;
}
public void <unk> ( String classe ) {
this . classe = classe ;
}
public int <unk> ( ) {
return poltrona ;
}
public void <unk> ( int poltrona ) {
this . poltrona = poltrona ;
}
public Double <unk> ( ) {
return preco ;
}
public void <unk> ( Double preco ) {
this . preco = preco ;
}
public void <unk> ( ) {
System . out . println ( " ) ;
}
@Override
public void imprimir ( ) {
System . out . println ( " ) ;
}
}
package trabalhopoo ;
class Fabricante {
private String cnpj ;
private String nome ;
private Aeronave aeronave ;
public Fabricante ( ) {
}
public Aeronave getAeronave ( ) {
return aeronave ;
}
public void setAeronave ( Aeronave aeronave ) {
this . aeronave = aeronave ;
}
public String getCnpj ( ) {
return cnpj ;
}
public void setCnpj ( String cnpj ) {
this . cnpj = cnpj ;
}
public String getNome ( ) {
return nome ;
}
public void setNome ( String nome ) {
this . nome = nome ;
}
}
package trabalhopoo ;
class Trecho extends Voo {
private int sequencial ;
public Trecho ( ) {
}
public int <unk> ( ) {
return sequencial ;
}
public void <unk> ( int sequencial ) {
this . sequencial = sequencial ;
}
}
package trabalhopoo ;
public class Aeronave {
private int codigo ;
private String descricao ;
private String modelo ;
private int capacidade ;
private Fabricante <unk> ;
public Aeronave ( ) {
}
public int <unk> ( ) {
return capacidade ;
}
public void <unk> ( int capacidade ) {
this . capacidade = capacidade ;
}
public int getCodigo ( ) {
return codigo ;
}
public void setCodigo ( int codigo ) {
this . codigo = codigo ;
}
public String getDescricao ( ) {
return descricao ;
}
public void setDescricao ( String descricao ) {
this . descricao = descricao ;
}
public String <unk> ( ) {
return modelo ;
}
public void <unk> ( String modelo ) {
this . modelo = modelo ;
}
}
package trabalhopoo ;
public class PessoaFisica extends Cliente {
private String cpf ;
public PessoaFisica ( ) {
}
public PessoaFisica ( String cpf ) {
this . cpf = cpf ;
}
public String <unk> ( ) {
return cpf ;
}
public void setCpf ( String cpf ) {
this . cpf = cpf ;
}
}
package trabalhopoo ;
public class Voo extends Cliente {
private int codigo ;
private String origem ;
private String destino ;
private Aeronave aeronave ;
private Trecho trecho ;
public Voo ( ) {
}
public int calculaDistancia ( int dist ) {
return dist ;
}
public void calculaDistancia ( ) {
}
public Aeronave getAeronave ( ) {
return aeronave ;
}
public void setAeronave ( Aeronave aeronave ) {
this . aeronave = aeronave ;
}
public int getCodigo ( ) {
return codigo ;
}
public void setCodigo ( int codigo ) {
this . codigo = codigo ;
}
public String <unk> ( ) {
return destino ;
}
public void <unk> ( String destino ) {
this . destino = destino ;
}
public String <unk> ( ) {
return origem ;
}
public void <unk> ( String origem ) {
this . origem = origem ;
}
public Trecho <unk> ( ) {
return trecho ;
}
public void <unk> ( Trecho trecho ) {
this . trecho = trecho ;
}
}
package trabalhopoo ;
public class ReservaWeb extends Reserva {
public ReservaWeb ( ) {
}
}
package trabalhopoo ;
public class PessoaJuridica extends Cliente {
private String cnpj ;
public PessoaJuridica ( ) {
}
public PessoaJuridica ( String cnpj ) {
this . cnpj = cnpj ;
}
public String getCnpj ( ) {
return cnpj ;
}
public void setCnpj ( String cnpj ) {
this . cnpj = cnpj ;
}
}
package trabalhopoo ;
import java . util . Date ;
public class Representante extends PessoaJuridica {
private Date dataNascimento ;
private PessoaJuridica pJuridica ;
public Representante ( ) {
}
public Representante ( Date dataNascimento , PessoaJuridica pJuridica ) {
this . dataNascimento = dataNascimento ;
this . pJuridica = pJuridica ;
}
public Date getDataNascimento ( ) {
return dataNascimento ;
}
public void setDataNascimento ( Date dataNascimento ) {
this . dataNascimento = dataNascimento ;
}
public PessoaJuridica <unk> ( ) {
return pJuridica ;
}
public void <unk> ( PessoaJuridica pJuridica ) {
this . pJuridica = pJuridica ;
}
}
package trabalhopoo ;
public class ResaervaBalcao extends Reserva {
public ResaervaBalcao ( ) {
}
}
package trabalhopoo ;
public abstract class Cliente {
private String nome ;
private String endereco ;
private String login ;
private String senha ;
public Cliente ( ) {
}
public Cliente ( String nome , String endereco , String login , String senha ) {
this . nome = nome ;
this . endereco = endereco ;
this . login = login ;
this . senha = senha ;
}
public String <unk> ( ) {
return endereco ;
}
public void setEndereco ( String endereco ) {
this . endereco = endereco ;
}
public String getLogin ( ) {
return login ;
}
public void setLogin ( String login ) {
this . login = login ;
}
public String getNome ( ) {
return nome ;
}
public void setNome ( String nome ) {
this . nome = nome ;
}
public String getSenha ( ) {
return senha ;
}
public void setSenha ( String senha ) {
this . senha = senha ;
}
}
package com . locustgaming . multiselectdemo . db ;
import java . sql . Timestamp ;
import java . util . Calendar ;
import android . content . ContentValues ;
import android . content . Context ;
import android . database . Cursor ;
import android . database . SQLException ;
import android . database . sqlite . SQLiteDatabase ;
public class DemoDBM
{
public static final String TABLENAME = " ;
public static final String ID = " ;
public static final String NAME = " ;
public static final String EUSR = " ;
public static final String EDATE = " ;
public static final String UUSR = " ;
public static final String UDATE = " ;
public static final String SEL = " ;
private final Context androidContext ;
private DemoDBH dbHelper ;
private SQLiteDatabase db ;
public DemoDBM ( Context ctx ) {
this . androidContext = ctx ;
}
public void open ( ) throws SQLException
{
dbHelper = new DemoDBH ( androidContext ) ;
db = dbHelper . getWritableDatabase ( ) ;
}
public void close ( )
{
db . close ( ) ;
dbHelper . close ( ) ;
}
public SQLiteDatabase getDB ( )
{
return db ;
}
public int insert ( String Name , int usr )
{
String timeStamp = new Timestamp ( Calendar . getInstance ( ) . getTimeInMillis ( ) ) . toString ( ) ;
ContentValues values = new ContentValues ( ) ;
values . put ( NAME , Name ) ;
values . put ( EUSR , usr ) ;
values . put ( EDATE , timeStamp ) ;
values . put ( UUSR , usr ) ;
values . put ( UDATE , timeStamp ) ;
return ( int ) db . insert ( TABLENAME , null , values ) ;
}
public Cursor getList ( int userId )
{
String [ ] columns = new String [ ] { ID , NAME , SEL } ;
String whereClause = EUSR + " + userId ;
Cursor c = db . query ( TABLENAME , columns , whereClause , null , null , null , null , null ) ;
c . moveToFirst ( ) ;
return c ;
}
public Cursor getSelectedList ( int userId )
{
String [ ] columns = new String [ ] { ID , NAME , SEL } ;
String whereClause = EUSR + " + userId + " + SEL + " ;
Cursor c = db . query ( TABLENAME , columns , whereClause , null , null , null , null , null ) ;
c . moveToFirst ( ) ;
return c ;
}
public boolean setChecked ( int itemId , int userId , boolean newVal )
{
String timeStamp = new Timestamp ( Calendar . getInstance ( ) . getTimeInMillis ( ) ) . toString ( ) ;
String whereClause ;
ContentValues values = new ContentValues ( ) ;
values . put ( UUSR , userId ) ;
values . put ( UDATE , timeStamp ) ;
values . put ( SEL , newVal ) ;
whereClause = ID + " + itemId ;
return db . update ( TABLENAME , values , whereClause , null ) > <num> ;
}
}
package com . locustgaming . multiselectdemo . db ;
import java . sql . Timestamp ;
import java . util . Calendar ;
import android . content . ContentValues ;
import android . content . Context ;
import android . database . sqlite . SQLiteDatabase ;
import android . database . sqlite . SQLiteOpenHelper ;
public class DemoDBH extends SQLiteOpenHelper
{
static final String DATABASE_NAME = " ;
static final int DATABASE_VERSION = <num> ;
static final String CREATE_ITEM = "
+ "
+ " ;
DemoDBH ( Context context ) {
super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ;
}
@Override
public void onCreate ( SQLiteDatabase db )
{
db . execSQL ( CREATE_ITEM ) ;
setupList ( db ) ;
}
@Override
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion )
{
}
private void setupList ( SQLiteDatabase db )
{
String [ ] items = new String [ ] { " , " , " , " } ;
String timeStamp = new Timestamp ( Calendar . getInstance ( ) . getTimeInMillis ( ) ) . toString ( ) ;
ContentValues values = new ContentValues ( ) ;
for ( int j = <num> ; j < <num> ; j ++ )
for ( int i = <num> ; i < items . length ; i ++ )
{
values . put ( " , items [ i ] ) ;
values . put ( " , <num> ) ;
values . put ( " , timeStamp ) ;
values . put ( " , <num> ) ;
values . put ( " , timeStamp ) ;
db . insert ( " , null , values ) ;
}
}
}
package com . locustgaming . multiselectdemo ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . app . Dialog ;
import android . content . DialogInterface ;
import android . database . Cursor ;
import android . os . Bundle ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . CheckBox ;
import android . widget . CompoundButton ;
import android . widget . CompoundButton . OnCheckedChangeListener ;
import android . widget . ListView ;
import android . widget . SimpleCursorAdapter ;
import android . widget . SimpleCursorAdapter . ViewBinder ;
import android . widget . TextView ;
import com . locustgaming . multiselectdemo . db . DemoDBM ;
public class MultiSelectDemoActivity extends Activity
{
protected Button showDialogButton ;
protected ListView selectedListView , multiListView ;
private DemoDBM demoDBM ;
private Cursor selectCur , multiCur ;
private SimpleCursorAdapter selectAdapter , multiAdapter ;
private int userId ;
@Override
public void onCreate ( Bundle savedInstanceState )
{
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
}
@Override
public void onResume ( )
{
super . onResume ( ) ;
userId = <num> ;
demoDBM = new DemoDBM ( this ) ;
setupListView ( ) ;
setupButton ( ) ;
}
private void setupButton ( )
{
showDialogButton = ( Button ) findViewById ( R . id . <unk> ) ;
showDialogButton . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v )
{
showDialog ( <num> ) ;
}
} ) ;
}
private void setupListView ( )
{
selectedListView = ( ListView ) findViewById ( R . id . <unk> ) ;
demoDBM . open ( ) ;
selectCur = demoDBM . getSelectedList ( userId ) ;
demoDBM . close ( ) ;
startManagingCursor ( selectCur ) ;
selectAdapter = new SimpleCursorAdapter ( this , R . layout . <unk> , selectCur , new String [ ] { DemoDBM . ID ,
DemoDBM . NAME } , new int [ ] { R . id . itemId , R . id . itemName } ) ;
selectedListView . setAdapter ( selectAdapter ) ;
}
@Override
protected Dialog onCreateDialog ( int id )
{
switch ( id ) {
case <num> :
LayoutInflater factory = LayoutInflater . from ( this ) ;
final View bindListDialog = factory . inflate ( R . layout . <unk> , null ) ;
multiListView = ( ListView ) bindListDialog . findViewById ( R . id . <unk> ) ;
return new AlertDialog . Builder ( MultiSelectDemoActivity . this ) . setTitle ( R . string . <unk> )
. setCancelable ( false ) . setView ( bindListDialog )
. setPositiveButton ( R . string . <unk> , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int whichButton )
{
setupListView ( ) ;
}
} ) . create ( ) ;
default :
return null ;
}
}
@Override
protected void onPrepareDialog ( final int id , final Dialog dialog , Bundle args )
{
demoDBM . open ( ) ;
multiCur = demoDBM . getList ( userId ) ;
startManagingCursor ( multiCur ) ;
multiAdapter = new SimpleCursorAdapter ( this , R . layout . <unk> , multiCur , new String [ ] { DemoDBM . ID ,
DemoDBM . NAME , DemoDBM . SEL } , new int [ ] { R . id . itemId , R . id . itemName , R . id . <unk> } ) ;
demoDBM . close ( ) ;
multiAdapter . setViewBinder ( new MyViewBinder ( ) ) ;
multiListView . setAdapter ( multiAdapter ) ;
}
public class MyViewBinder implements ViewBinder
{
@Override
public boolean setViewValue ( View view , Cursor cursor , int columnIndex )
{
int nCheckedIndex = cursor . getColumnIndex ( DemoDBM . SEL ) ;
if ( columnIndex == nCheckedIndex )
{
CheckBox cb = ( CheckBox ) view ;
boolean bChecked = ( cursor . getInt ( nCheckedIndex ) != <num> ) ;
cb . setChecked ( bChecked ) ;
cb . setOnCheckedChangeListener ( new MyOnCheckedChangeListener ( ) ) ;
return true ;
}
return false ;
}
}
public class MyOnCheckedChangeListener implements OnCheckedChangeListener
{
@Override
public void onCheckedChanged ( CompoundButton checkBox , boolean newVal )
{
View item = ( View ) checkBox . getParent ( ) ;
int itemId = Integer . valueOf ( ( ( TextView ) item . findViewById ( R . id . itemId ) ) . getText ( ) . toString ( ) ) ;
demoDBM . open ( ) ;
demoDBM . setChecked ( itemId , userId , newVal ) ;
demoDBM . close ( ) ;
}
}
package com . github . ippeiukai . icucharfilter . solr . analysis ;
import java . util . Map ;
import org . apache . lucene . analysis . CharStream ;
import org . apache . solr . analysis . BaseCharFilterFactory ;
import com . github . ippeiukai . icucharfilter . lucene . analysis . icu . ICUNormalizer2CharFilter ;
public class <unk> extends BaseCharFilterFactory {
private ICUNormalizer2CharFilter . Form form ;
@Override
public void init ( Map < String , String > args ) {
super . init ( args ) ;
String formStr = args . get ( " ) ;
if ( formStr != null )
form = ICUNormalizer2CharFilter . Form . valueOf ( formStr ) ;
}
@Override
public CharStream create ( CharStream in ) {
if ( form == null )
return new ICUNormalizer2CharFilter ( in ) ;
else
return new ICUNormalizer2CharFilter ( in , form ) ;
}
}
package com . github . ippeiukai . icucharfilter . lucene . analysis . icu ;
import java . io . IOException ;
import java . io . StringReader ;
import org . apache . lucene . analysis . BaseTokenStreamTestCase ;
import org . apache . lucene . analysis . CharStream ;
import org . apache . lucene . analysis . MockTokenizer ;
import org . apache . lucene . analysis . TokenStream ;
import org . apache . lucene . analysis . <unk> . NGramTokenizer ;
import org . junit . Test ;
import com . github . ippeiukai . icucharfilter . lucene . analysis . icu . ICUNormalizer2CharFilter ;
import com . ibm . icu . text . Normalizer2 ;
public class <unk> extends BaseTokenStreamTestCase {
@Test
public void <unk> ( ) throws IOException {
String input = " ;
Normalizer2 referenceNormalizer = Normalizer2 . getInstance ( null , " ,
Normalizer2 . Mode . COMPOSE ) ;
String expectedOutput = referenceNormalizer . normalize ( input ) ;
CharStream reader = new ICUNormalizer2CharFilter ( new StringReader ( input ) ,
ICUNormalizer2CharFilter . Form . NFKC_CF ) ;
char [ ] tempBuff = new char [ <num> ] ;
StringBuilder output = new StringBuilder ( ) ;
while ( true ) {
int length = reader . read ( tempBuff ) ;
if ( length ==  <num> ) {
break ;
}
output . append ( tempBuff , <num> , length ) ;
assertEquals (
output . toString ( ) ,
referenceNormalizer . normalize ( input . substring ( <num> ,
reader . <unk> ( output . length ( ) ) ) ) ) ;
}
assertEquals ( expectedOutput , output . toString ( ) ) ;
}
@Test
public void <unk> ( ) throws IOException {
String input = " ;
CharStream reader = new ICUNormalizer2CharFilter ( new StringReader ( input ) ,
ICUNormalizer2CharFilter . Form . NFKC ) ;
TokenStream tokenStream = new MockTokenizer ( reader , MockTokenizer . WHITESPACE , false ) ;
assertTokenStreamContents ( tokenStream ,
new String [ ] { " , " , " , " , " , " , " } ,
new int [ ] { <num> , <num> , <num> , <num> , <num> , <num> , <num> } ,
new int [ ] { <num> , <num> , <num> , <num> , <num> , <num> , <num> } ,
input . length ( ) ) ;
}
@Test
public void <unk> ( ) throws IOException {
String input = " ;
CharStream reader = new ICUNormalizer2CharFilter ( new StringReader ( input ) ,
ICUNormalizer2CharFilter . Form . NFKC_CF ) ;
TokenStream tokenStream = new NGramTokenizer ( reader , <num> , <num> ) ;
assertTokenStreamContents ( tokenStream ,
new String [ ] { " , " , " , " , " , " , " , " , " , " , " , " , " , " , " } ,
new int [ ] { <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> } ,
new int [ ] { <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> } ,
input . length ( )
) ;
}
}
package com . github . ippeiukai . icucharfilter . lucene . analysis . icu ;
import java . io . IOException ;
import java . io . Reader ;
import static java . lang . Math . * ;
import org . apache . lucene . analysis . BaseCharFilter ;
import org . apache . lucene . analysis . CharReader ;
import org . apache . lucene . analysis . CharStream ;
import com . ibm . icu . text . Normalizer2 ;
public class ICUNormalizer2CharFilter extends BaseCharFilter {
public static enum Form {
NFC ( Normalizer2 . getInstance ( null , " , Normalizer2 . Mode . COMPOSE ) ) ,
NFD ( Normalizer2 . getInstance ( null , " , Normalizer2 . Mode . DECOMPOSE ) ) ,
NFKC ( Normalizer2 . getInstance ( null , " , Normalizer2 . Mode . COMPOSE ) ) ,
NFKC_CF ( Normalizer2 . getInstance ( null , " , Normalizer2 . Mode . COMPOSE ) ) ,
<unk> ( Normalizer2 . getInstance ( null , " , Normalizer2 . Mode . DECOMPOSE ) ) ;
private Normalizer2 normalizer ;
private Form ( Normalizer2 normalizer ) {
this . normalizer = normalizer ;
}
}
private static final int IO_BUFFER_SIZE = <num> ;
private final Normalizer2 normalizer ;
private final StringBuilder inputBuffer ;
private final StringBuilder resultBuffer ;
private boolean inputFinished ;
private boolean afterQuickCheckYes ;
private int checkedInputBoundary ;
private int charCount ;
public ICUNormalizer2CharFilter ( CharStream in ) {
this ( in , Form . NFKC_CF ) ;
}
public ICUNormalizer2CharFilter ( Reader in , Form form ) {
this ( CharReader . get ( in ) , form ) ;
}
public ICUNormalizer2CharFilter ( CharStream in , Form form ) {
this ( in , form . normalizer ) ;
}
public ICUNormalizer2CharFilter ( CharStream in , Normalizer2 normalizer ) {
super ( in ) ;
if ( normalizer == null ) throw new NullPointerException ( " ) ;
this . normalizer = normalizer ;
inputBuffer = new StringBuilder ( ) ;
resultBuffer = new StringBuilder ( ) ;
resetFields ( ) ;
}
@Override
public void reset ( ) throws IOException {
super . reset ( ) ;
resetFields ( ) ;
}
private void resetFields ( ) {
inputBuffer . delete ( <num> , inputBuffer . length ( ) ) ;
checkedInputBoundary = <num> ;
resultBuffer . delete ( <num> , resultBuffer . length ( ) ) ;
inputFinished = false ;
afterQuickCheckYes = false ;
charCount = <num> ;
}
@Override
public void close ( ) throws IOException {
resetFields ( ) ;
super . close ( ) ;
}
@Override
public int read ( char [ ] cbuf , int off , int len ) throws IOException {
if ( off < <num> ) throw new IllegalArgumentException ( " ) ;
if ( off >= cbuf . length ) throw new IllegalArgumentException (
" ) ;
if ( len <= <num> ) throw new IllegalArgumentException ( " ) ;
while ( ! inputFinished || inputBuffer . length ( ) > <num> || resultBuffer . length ( ) > <num> ) {
int retLen ;
if ( resultBuffer . length ( ) > <num> ) {
retLen = outputFromResultBuffer ( cbuf , off , len ) ;
if ( retLen > <num> ) {
return retLen ;
}
}
int resLen = readAndNormalizeFromInput ( ) ;
if ( resLen > <num> ) {
retLen = outputFromResultBuffer ( cbuf , off , len ) ;
if ( retLen > <num> ) {
return retLen ;
}
}
readInputToBuffer ( ) ;
}
return  <num> ;
}
private final char [ ] tmpBuffer = new char [ IO_BUFFER_SIZE ] ;
private int readInputToBuffer ( ) throws IOException {
final int len = input . read ( tmpBuffer ) ;
if ( len ==  <num> ) {
inputFinished = true ;
return <num> ;
}
inputBuffer . append ( tmpBuffer , <num> , len ) ;
return len ;
}
private int readAndNormalizeFromInput ( ) {
if ( inputBuffer . length ( ) <= <num> ) {
afterQuickCheckYes = false ;
return <num> ;
}
if ( ! afterQuickCheckYes ) {
int resLen = readFromInputWhileSpanQuickCheckYes ( ) ;
afterQuickCheckYes = true ;
if ( resLen > <num> ) return resLen ;
}
int resLen = readFromIoNormalizeUptoBoundary ( resultBuffer ) ;
if ( resLen > <num> ) {
afterQuickCheckYes = false ;
}
return resLen ;
}
private int readFromInputWhileSpanQuickCheckYes ( ) {
int end = normalizer . <unk> ( inputBuffer ) ;
if ( end > <num> ) {
resultBuffer . append ( inputBuffer . subSequence ( <num> , end ) ) ;
inputBuffer . delete ( <num> , end ) ;
checkedInputBoundary = max ( checkedInputBoundary  end , <num> ) ;
charCount += end ;
}
return end ;
}
private int readFromIoNormalizeUptoBoundary ( StringBuilder dest ) {
if ( inputBuffer . length ( ) <= <num> ) {
return <num> ;
}
boolean foundBoundary = false ;
final int bufLen = inputBuffer . length ( ) ;
while ( checkedInputBoundary < bufLen  <num> ) {
++ checkedInputBoundary ;
if ( normalizer . <unk> ( inputBuffer
. charAt ( checkedInputBoundary ) ) ) {
foundBoundary = true ;
break ;
} else if ( normalizer . hasBoundaryAfter ( inputBuffer
. charAt ( checkedInputBoundary  <num> ) ) ) {
foundBoundary = true ;
break ;
}
}
if ( checkedInputBoundary == bufLen  <num> ) {
if ( normalizer . hasBoundaryAfter ( inputBuffer . charAt ( checkedInputBoundary ) )
|| inputFinished ) {
foundBoundary = true ;
++ checkedInputBoundary ;
}
}
if ( ! foundBoundary ) {
return <num> ;
}
return normalizeInputUpto ( checkedInputBoundary ) ;
}
private int normalizeInputUpto ( final int length ) {
final int destOrigLen = resultBuffer . length ( ) ;
normalizer . <unk> ( resultBuffer ,
inputBuffer . subSequence ( <num> , length ) ) ;
inputBuffer . delete ( <num> , length ) ;
checkedInputBoundary = max ( checkedInputBoundary  length , <num> ) ;
final int resultLength = resultBuffer . length ( )  destOrigLen ;
recordOffsetDiff ( length , resultLength ) ;
return resultLength ;
}
private void recordOffsetDiff ( int inputLength , int outputLength ) {
if ( inputLength == outputLength ) {
charCount += outputLength ;
return ;
}
final int diff = inputLength  outputLength ;
final int cumuDiff = <unk> ( ) ;
if ( diff < <num> ) {
for ( int i = <num> ; i <=  diff ; ++ i ) {
addOffCorrectMap ( charCount + i , cumuDiff  i ) ;
}
} else {
addOffCorrectMap ( charCount + Math . min ( <num> , outputLength ) , cumuDiff + diff ) ;
}
charCount += outputLength ;
}
private int outputFromResultBuffer ( char [ ] cbuf , int begin , int len ) {
len = min ( resultBuffer . length ( ) , len ) ;
resultBuffer . getChars ( <num> , len , cbuf , begin ) ;
if ( len > <num> ) {
resultBuffer . delete ( <num> , len ) ;
}
return len ;
}
@Override
public boolean markSupported ( ) {
return false ;
}
@Override
public void mark ( int readAheadLimit ) throws IOException {
throw new IOException ( " ) ;
}
import java . io . BufferedReader ;
import java . io . File ;
import java . io . FileReader ;
import java . io . IOException ;
public class Main {
public static void main ( String [ ] args ) {
File file = new File ( " ) ;
file . delete ( ) ;
try {
int delay = <num> ;
Thread . sleep ( delay ) ;
} catch ( Exception e ) { }
File f = new File ( " ) ;
BufferedReader entrada = null ;
try {
entrada = new BufferedReader ( new FileReader ( f ) ) ;
String linea ;
int a = <num> ;
while ( entrada . ready ( ) ) {
linea = entrada . readLine ( ) ;
Salida j = new Salida ( ) ;
String lineaGenerada = j . generaLinea ( linea ) ;
j . generaTXT ( lineaGenerada , " ) ;
}
entrada . close ( ) ;
} catch ( IOException e ) { System . out . println ( " + e ) ; }
}
}
import java . io . BufferedWriter ;
import java . io . FileWriter ;
import java . io . IOException ;
public class Salida {
public void generaTXT ( String linea , String nombreArchivo ) {
try {
BufferedWriter out = new BufferedWriter ( new FileWriter ( nombreArchivo , true ) ) ;
out . write ( linea ) ;
out . newLine ( ) ;
out . close ( ) ;
} catch ( IOException e ) { System . out . println ( e ) ; }
}
public String generaLinea ( String linea ) {
String a1 = linea . substring ( <num> , <num> ) ;
String a2 = linea . substring ( <num> , <num> ) ;
String a3 = linea . substring ( <num> , <num> ) ;
String a4 = linea . substring ( <num> , <num> ) ;
String a5 = linea . substring ( <num> , <num> ) ;
String a6 = linea . substring ( <num> , <num> ) ;
String a7 = linea . substring ( <num> , <num> ) ;
String a8 = linea . substring ( <num> , <num> ) ;
String a9 = linea . substring ( <num> , <num> ) ;
String a10 = linea . substring ( <num> , <num> ) ;
String a11 = linea . substring ( <num> , <num> ) ;
String a12 = linea . substring ( <num> , <num> ) ;
return a1 + " + a2 + " + a3 + " + a4 + " + a5 + " + a6 + " + a7 + " + a8 + " + a9 + " + a10 + " + a11 + " + a12 ;
}
}
package useful ;
import java . io . * ;
public class MyDataReader
{
private String marker ;
private BufferedReader theReader ;
public MyDataReader ( ) throws IOException
{
BufferedReader br ;
marker = " ;
br = new BufferedReader ( new InputStreamReader ( System . in ) ) ;
theReader = br ;
}
public String readLine ( ) throws IOException
{
String lineString = null ;
do {
lineString = theReader . readLine ( ) ;
if ( lineString == null )
{
return null ;
}
} while ( lineString . indexOf ( marker ) == <num> ) ;
if ( lineString . indexOf ( marker ) > <num> )
{
lineString = lineString . substring ( <num> , lineString . indexOf ( marker ) ) ;
}
return lineString ;
}
public String <unk> ( String mkr ) throws IOException
{
String prevMkr = " ;
prevMkr = marker ;
marker = mkr ;
return prevMkr ;
}
public void close ( ) throws IOException
{
theReader . close ( ) ;
}
}
package useful ;
import java . io . * ;
public class Useful
{
public static boolean <unk> ( String str )
{
boolean retval ;
retval = true ;
for ( int k = <num> ; k < str . length ( ) ; k ++ )
{
if ( ( str . charAt ( k ) < <num> ) || ( str . charAt ( k ) > <num> ) )
{
retval = false ;
}
}
return retval ;
}
public static String <unk> ( String incoming , String informat , String outFormat )
{
boolean isOutFormatValid = false ;
boolean isInFormatValid = false ;
boolean isMatch = false ;
boolean isCorrect = false ;
boolean isValidDay = false ;
boolean isValidMonth = false ;
String dayString = " ;
String monthString = " ;
String yearString = " ;
String retVal = " ;
String tempIn ;
int dateIndex = <num> ;
int k = <num> ;
int l = <num> ;
int i = <num> ;
String longMonthFormat = " ;
String intToAbrv = " ;
String [ ] dateFormatList = { " , " , " , " ,
" , " , " , " ,
" , " , " , " ,
" , " , " , " ,
" , " , " , " ,
" , " , " , " } ;
String [ ] abrvMonList = { " , " , " , " , " , " , " , " , " , " , " , " } ;
while ( i < dateFormatList . length && ! isOutFormatValid )
{
if ( outFormat . length ( ) == dateFormatList [ i ] . length ( ) )
{
if ( outFormat . equalsIgnoreCase ( dateFormatList [ i ] ) )
{
isOutFormatValid = true ;
}
}
i ++ ;
}
while ( l < dateFormatList . length && ! isInFormatValid )
{
if ( informat . length ( ) == dateFormatList [ l ] . length ( ) )
{
if ( informat . equalsIgnoreCase ( dateFormatList [ l ] ) )
{
dateIndex = l ;
isInFormatValid = true ;
}
}
l ++ ;
}
if ( isOutFormatValid && isInFormatValid ) {
if ( dateIndex >= <num> && dateIndex <= <num> || dateIndex >= <num> && dateIndex <= <num> )
{
if ( incoming . charAt ( <num> ) == informat . charAt ( <num> ) && incoming . charAt ( <num> ) == informat . charAt ( <num> ) && incoming . length ( ) == informat . length ( ) )
isMatch = true ;
}
else if ( dateIndex == <num> || dateIndex == <num> )
{
if ( incoming . length ( ) == informat . length ( ) )
isMatch = true ;
}
else if ( dateIndex >= <num> && dateIndex <= <num> )
{
if ( incoming . charAt ( <num> ) == informat . charAt ( <num> ) && incoming . charAt ( <num> ) == informat . charAt ( <num> ) && incoming . length ( ) == informat . length ( ) )
isMatch = true ;
}
else if ( dateIndex == <num> )
{
if ( incoming . length ( ) == informat . length ( ) )
isMatch = true ;
}
else if ( dateIndex >= <num> && dateIndex <= <num> )
{
if ( incoming . charAt ( <num> ) == informat . charAt ( <num> ) && incoming . charAt ( <num> ) == informat . charAt ( <num> ) && incoming . length ( ) == informat . length ( ) )
{
isMatch = true ;
tempIn = incoming . substring ( <num> , <num> ) . toUpperCase ( ) ;
while ( ! isCorrect && k <= incoming . length ( ) )
{
if ( tempIn . equalsIgnoreCase ( abrvMonList [ k ] ) && ! isCorrect )
{
isCorrect = true ;
isMatch = isCorrect ;
if ( ( k + <num> ) < <num> ) { intToAbrv = intToAbrv . concat ( " ) . concat ( Integer . toString ( k + <num> ) ) ; } else { intToAbrv = Integer . toString ( k + <num> ) ; }
}
else {
isCorrect = false ;
isMatch = isCorrect ;
} k ++ ;
}
}
}
else if ( dateIndex == <num> )
{
if ( incoming . length ( ) == informat . length ( ) )
{
isMatch = true ;
tempIn = incoming . substring ( <num> , <num> ) . toUpperCase ( ) ;
while ( ! isCorrect && k <= incoming . length ( ) )
{
if ( tempIn . equalsIgnoreCase ( abrvMonList [ k ] ) && ! isCorrect )
{
isCorrect = true ;
isMatch = isCorrect ;
if ( ( k + <num> ) < <num> ) { intToAbrv = intToAbrv . concat ( " ) . concat ( Integer . toString ( k + <num> ) ) ; } else { intToAbrv = Integer . toString ( k + <num> ) ; }
}
else {
isCorrect = false ;
isMatch = isCorrect ;
} k ++ ;
}
}
}
else if ( dateIndex >= <num> && dateIndex <= <num> )
{
if ( incoming . charAt ( <num> ) == informat . charAt ( <num> ) && incoming . charAt ( <num> ) == informat . charAt ( <num> ) && incoming . length ( ) == informat . length ( ) )
{
isMatch = true ;
tempIn = incoming . substring ( <num> , <num> ) . toUpperCase ( ) ;
while ( ! isCorrect && k <= incoming . length ( ) )
{
if ( tempIn . equalsIgnoreCase ( abrvMonList [ k ] ) && ! isCorrect )
{
isCorrect = true ;
isMatch = isCorrect ;
if ( ( k + <num> ) < <num> ) { intToAbrv = intToAbrv . concat ( " ) . concat ( Integer . toString ( k + <num> ) ) ; } else { intToAbrv = Integer . toString ( k + <num> ) ; }
}
else {
isCorrect = false ;
isMatch = isCorrect ;
} k ++ ;
}
}
}
else if ( dateIndex == <num> )
{
if ( incoming . length ( ) == informat . length ( ) )
{
isMatch = true ;
tempIn = incoming . substring ( <num> , <num> ) . toUpperCase ( ) ;
while ( ! isCorrect && k <= incoming . length ( ) )
{
if ( tempIn . equalsIgnoreCase ( abrvMonList [ k ] ) && ! isCorrect )
{
isCorrect = true ;
isMatch = isCorrect ;
if ( ( k + <num> ) < <num> ) { intToAbrv = intToAbrv . concat ( " ) . concat ( Integer . toString ( k + <num> ) ) ; } else { intToAbrv = Integer . toString ( k + <num> ) ; }
}
else {
isCorrect = false ;
isMatch = isCorrect ;
} k ++ ;
}
}
}
else if ( dateIndex >= <num> && dateIndex <= <num> )
{
if ( incoming . charAt ( <num> ) == informat . charAt ( <num> ) && incoming . charAt ( <num> ) == informat . charAt ( <num> ) && incoming . length ( ) == informat . length ( ) )
{
isMatch = true ;
tempIn = incoming . substring ( <num> , <num> ) . toUpperCase ( ) ;
while ( ! isCorrect && k <= incoming . length ( ) )
{
if ( tempIn . equalsIgnoreCase ( abrvMonList [ k ] ) && ! isCorrect )
{
isCorrect = true ;
isMatch = isCorrect ;
if ( ( k + <num> ) < <num> ) { intToAbrv = intToAbrv . concat ( " ) . concat ( Integer . toString ( k + <num> ) ) ; } else { intToAbrv = Integer . toString ( k + <num> ) ; }
}
else {
isCorrect = false ;
isMatch = isCorrect ;
} k ++ ;
}
}
}
else if ( dateIndex == <num> )
{
if ( incoming . length ( ) == informat . length ( ) )
{
isMatch = true ;
tempIn = incoming . substring ( <num> , <num> ) . toUpperCase ( ) ;
while ( ! isCorrect && k <= incoming . length ( ) )
{
if ( tempIn . equalsIgnoreCase ( abrvMonList [ k ] ) && ! isCorrect )
{
isCorrect = true ;
isMatch = isCorrect ;
if ( ( k + <num> ) < <num> ) { intToAbrv = intToAbrv . concat ( " ) . concat ( Integer . toString ( k + <num> ) ) ; } else { intToAbrv = Integer . toString ( k + <num> ) ; }
}
else {
isCorrect = false ;
isMatch = isCorrect ;
} k ++ ;
}
}
}
}
if ( isMatch )
{
dayString = incoming . substring ( informat . indexOf ( D' ) , informat . lastIndexOf ( D' ) + <num> ) ;
if ( Integer . parseInt ( dayString ) > <num> && Integer . parseInt ( dayString ) <= <num> )
isValidDay = true ;
if ( informat . indexOf ( N' ) !=  <num> )
{
monthString = intToAbrv ;
isValidMonth = true ;
}
else
{
monthString = incoming . substring ( informat . indexOf ( M' ) , informat . lastIndexOf ( M' ) + <num> ) ;
if ( Integer . parseInt ( monthString ) > <num> && Integer . parseInt ( monthString ) <= <num> )
isValidMonth = true ;
}
yearString = incoming . substring ( informat . indexOf ( Y' ) , informat . lastIndexOf ( Y' ) + <num> ) ;
if ( isValidDay && isValidMonth )
{
longMonthFormat = abrvMonList [ Integer . parseInt ( monthString )  <num> ] ;
outFormat = outFormat . replace ( " , dayString ) ;
outFormat = outFormat . replace ( " , monthString ) ;
outFormat = outFormat . replace ( " , longMonthFormat ) ;
outFormat = outFormat . replace ( " , yearString ) ;
retVal = outFormat ;
}
}
return retVal ;
}
public static int getData ( String [ ] prompts , StringBuffer sb , MyDataReader br , String sep )
throws IOException
{
int retval = <num> ;
int k = <num> ;
String buf ;
String padding = " ;
sb . append ( sep ) ;
for ( k = <num> ; k < prompts . length ; k ++ )
{
System . out . print ( ( prompts [ k ] + padding ) . substring ( <num> , <num> ) ) ;
System . out . flush ( ) ;
buf = br . readLine ( ) ;
if ( buf == null )
{
retval =  <num> ;
break ;
}
if ( buf . indexOf ( sep ) >= <num> )
{
retval =  <num> ;
break ;
}
if ( buf . equals ( " ) )
{
buf = " ;
}
sb . append ( buf + sep ) ;
}
return retval ;
}
}
package applications ;
import useful . * ;
import java . util . * ;
import business . * ;
import java . io . * ;
public class TestInventoryItem
{
private String [ ] myArgs ;
private MyDataReader br ;
private String buf ;
private String init ( String [ ] args )
throws IOException
{
String temp = " ;
System . out . println ( " + new Date ( <num> ) ) ;
if ( args . length > <num> )
{
myArgs = new String [ args . length ] ;
for ( int k = <num> ; k < args . length ; k ++ )
{
myArgs [ k ] = args [ k ] ;
}
System . out . println ( ) ;
}
else
{
System . err . println ( " ) ;
usage ( ) ;
}
br = new MyDataReader ( ) ;
return temp ;
}
private void run ( ) throws IOException
{
StringBuffer output = new StringBuffer ( <num> ) ;
StringBuffer allData = new StringBuffer ( <num> ) ;
StringBuffer data = new StringBuffer ( <num> ) ;
StringBuffer header = new StringBuffer ( <num> ) ;
String [ ] params = new String [ <num> ] ;
StringBuffer sb = new StringBuffer ( <num> ) ;
InventoryItem nemo ;
int counter = <num> ;
int err = <num> ;
int returned ;
nemo = new InventoryItem ( ) ;
do
{
buf = br . readLine ( ) ;
System . out . println ( " + buf ) ;
if ( ( buf == null ) || ( buf . startsWith ( " ) ) )
{
if ( buf == null )
{
System . out . print ( " ) ;
}
System . out . print ( " ) ;
}
if ( ( buf != null ) && ( buf . startsWith ( " ) ) )
{
sb . setLength ( <num> ) ;
output . setLength ( <num> ) ;
err = InventoryItem . getData ( sb , br , " ) ;
System . out . println ( " + err ) ;
output . append ( " + " + ++ counter + " ) ;
System . out . println ( " + " + sb ) ;
nemo = new InventoryItem ( ) ;
nemo . update ( sb ) ;
nemo . formatReportData_1 ( allData ) ;
System . out . println ( " + output + " ) ;
}
if ( buf . startsWith ( " ) )
{
output . setLength ( <num> ) ;
header . setLength ( <num> ) ;
nemo . formatReportHeadings_1 ( header ) ;
System . out . print ( header ) ;
System . out . print ( data . append ( allData ) ) ;
}
if ( buf . startsWith ( " ) )
{
returned = getParams ( params , <num> , br ) ;
String p2 = new String ( params [ <num> ] ) ;
System . out . println ( nemo . placeSalesOrder ( Integer . parseInt ( p2 ) ) ) ;
System . out . println ( " + returned ) ;
output . setLength ( <num> ) ;
header . setLength ( <num> ) ;
data . setLength ( <num> ) ;
nemo . formatReportHeadings_1 ( header ) ;
nemo . formatReportData_1 ( data ) ;
}
if ( buf . startsWith ( " ) )
{
returned = getParams ( params , <num> , br ) ;
String p2 = new String ( params [ <num> ] ) ;
System . out . println ( nemo . shipSalesOrder ( Integer . parseInt ( p2 ) ) ) ;
System . out . println ( " + returned ) ;
header . setLength ( <num> ) ;
data . setLength ( <num> ) ;
nemo . formatReportHeadings_1 ( header ) ;
nemo . formatReportData_1 ( data ) ;
}
if ( buf . startsWith ( " ) )
{
returned = getParams ( params , <num> , br ) ;
String p2 = new String ( params [ <num> ] ) ;
System . out . println ( nemo . recieveReplenishmentOrder ( Integer . parseInt ( p2 ) ) ) ;
System . out . println ( " + returned ) ;
header . setLength ( <num> ) ;
data . setLength ( <num> ) ;
nemo . formatReportHeadings_1 ( header ) ;
nemo . formatReportData_1 ( data ) ;
}
if ( buf . startsWith ( " ) )
{
returned = getParams ( params , <num> , br ) ;
String p2 = new String ( params [ <num> ] ) ;
System . out . println ( nemo . decreaseStock ( Integer . parseInt ( p2 ) ) ) ;
System . out . println ( " + returned ) ;
header . setLength ( <num> ) ;
data . setLength ( <num> ) ;
nemo . formatReportHeadings_1 ( header ) ;
nemo . formatReportData_1 ( data ) ;
}
if ( buf . startsWith ( " ) )
{
}
if ( buf . startsWith ( " ) )
{
returned = getParams ( params , <num> , br ) ;
String p2 = new String ( params [ <num> ] ) ;
System . out . println ( nemo . increaseStock ( Integer . parseInt ( p2 ) ) ) ;
System . out . println ( " + returned ) ;
header . setLength ( <num> ) ;
data . setLength ( <num> ) ;
nemo . formatReportHeadings_1 ( header ) ;
nemo . formatReportData_1 ( data ) ;
}
if ( buf . startsWith ( " ) )
{
System . out . println ( nemo . getPrimaryKey ( ) ) ;
System . out . println ( " ) ;
}
} while ( ( buf != null ) && ( ! buf . equals ( " ) ) ) ;
}
private int getParams ( String [ ] params , int pcount , MyDataReader br )
throws IOException
{
int retval = <num> ;
int k ;
for ( k = <num> ; k < pcount ; k ++ )
{
buf = br . readLine ( ) ;
if ( buf != null )
{
params [ k ] = new String ( buf ) ;
}
else
{
System . out . println ( " ) ;
retval =  <num> ;
break ;
}
}
return retval ;
}
private void usage ( )
{
System . err . println ( " +
" ) ;
}
private int wrap ( )
{
int retval = <num> ;
System . out . println ( " + " ) ;
return retval ;
}
public static void main ( String [ ] args )
throws IOException
{
TestInventoryItem theApp = new TestInventoryItem ( ) ;
theApp . init ( args ) ;
theApp . run ( ) ;
theApp . wrap ( ) ;
}
package business ;
import java . util . * ;
import java . text . SimpleDateFormat ;
import java . io . * ;
import useful . * ;
public class InventoryItem
{
private static String [ ] prompts =
{
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
"
} ;
private String inventoryId ;
private String description ;
private String pack ;
private int quantityInStock ;
private double unitPrice ;
private int reorderPoint ;
private int reorderQuantity ;
private int totalOrdered ;
private int totalSalesOrders ;
private Date lastUpdated ;
public InventoryItem ( )
{
String inventoryId = " ;
String description = " ;
String pack = " ;
lastUpdated = new Date ( <num> ) ;
}
public String decreaseStock ( int decAmount )
{
boolean placeReplenishStop = false ;
String msg = " ;
quantityInStock -= decAmount ;
lastUpdated = new Date ( <num> ) ;
msg = " + decAmount + " + inventoryId ;
do {
if ( ( ( quantityInStock + totalOrdered )  totalSalesOrders ) < reorderPoint )
{
msg += " + placeReplenishmentOrder ( ) ;
}
else
{
placeReplenishStop = true ;
}
} while ( ! placeReplenishStop ) ;
return msg ;
}
public int <unk> ( StringBuffer sb )
{
int retval = <num> ;
SimpleDateFormat form = new SimpleDateFormat ( " ) ;
String lastUp = form . format ( lastUpdated ) ;
sb . append ( " + " ) ;
sb . append ( " + " + inventoryId ) ;
sb . append ( " + " + description ) ;
sb . append ( " + " + pack ) ;
sb . append ( " + " + quantityInStock ) ;
sb . append ( " + " + unitPrice ) ;
sb . append ( " + " + reorderPoint ) ;
sb . append ( " + " + reorderQuantity ) ;
sb . append ( " + " + totalOrdered ) ;
sb . append ( " + " + totalSalesOrders ) ;
sb . append ( " + " + lastUp ) ;
sb . append ( " + " ) ;
return retval ;
}
public int formatReportData_1 ( StringBuffer sb )
{
int retval = <num> ;
SimpleDateFormat form = new SimpleDateFormat ( " ) ;
String lastUp = form . format ( lastUpdated ) ;
sb . append ( String . format ( " , inventoryId ) ) ;
sb . append ( String . format ( " , description ) ) ;
sb . append ( String . format ( " , pack ) ) ;
sb . append ( String . format ( " , reorderPoint ) ) ;
sb . append ( String . format ( " , reorderQuantity ) ) ;
sb . append ( String . format ( " , unitPrice ) ) ;
sb . append ( " ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( String . format ( " , lastUp ) ) ;
sb . append ( String . format ( " , totalOrdered ) ) ;
sb . append ( String . format ( " , quantityInStock ) ) ;
sb . append ( String . format ( " , totalSalesOrders ) ) ;
sb . append ( " ) ;
return retval ;
}
public int formatReportHeadings_1 ( StringBuffer sb )
{
int retval = <num> ;
sb . append ( " + String . format ( " , " ) . replace (  ' , -' ) + " ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( " ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( String . format ( " , " ) ) ;
sb . append ( " + String . format ( " , " ) . replace (  ' , -' ) + " ) ;
return retval ;
}
public static int getData ( StringBuffer sb , MyDataReader br , String separator )
throws IOException
{
int err = <num> ;
err = Useful . getData ( prompts , sb , br , separator ) ;
return err ;
}
public String getPrimaryKey ( )
{
return inventoryId ;
}
public String increaseStock ( int incAmount )
{
String msg = " ;
quantityInStock = quantityInStock + incAmount ;
lastUpdated = new Date ( <num> ) ;
msg = " + incAmount + " + inventoryId ;
return msg ;
}
private String placeReplenishmentOrder ( )
{
String msg = " ;
totalOrdered *= reorderQuantity ;
lastUpdated = new Date ( <num> ) ;
msg = " + reorderQuantity + " + inventoryId ;
return msg ;
}
public String placeSalesOrder ( int qtyOrdered )
{
String msg = " ;
totalOrdered *= qtyOrdered ;
lastUpdated = new Date ( <num> ) ;
msg = " + qtyOrdered + " + inventoryId ;
return msg ;
}
public String recieveReplenishmentOrder ( int qtyRecieved )
{
String msg = " ;
msg = " + qtyRecieved + " + inventoryId ;
totalOrdered -= qtyRecieved ;
msg += " + increaseStock ( qtyRecieved ) ;
lastUpdated = new Date ( <num> ) ;
return msg ;
}
public String shipSalesOrder ( int qtyShipped )
{
String msg = " ;
totalSalesOrders -= qtyShipped ;
msg = " + qtyShipped + " + inventoryId ;
msg += " + decreaseStock ( qtyShipped ) ;
lastUpdated = new Date ( <num> ) ;
return msg ;
}
public int update ( StringBuffer sb )
{
int err = <num> ;
String sep ;
StringTokenizer tk ;
String temp ;
sep = String . valueOf ( sb . charAt ( <num> ) ) ;
tk = new StringTokenizer ( sb . toString ( ) , sep ) ;
temp = tk . nextToken ( ) ;
if ( ! temp . equals ( " ) )
{
inventoryId = new String ( temp ) ;
}
temp = tk . nextToken ( ) ;
if ( ! temp . equals ( " ) )
{
description = new String ( temp ) ;
}
temp = tk . nextToken ( ) ;
if ( ! temp . equals ( " ) )
{
pack = new String ( temp ) ;
}
temp = tk . nextToken ( ) ;
if ( ! temp . equals ( " ) )
{
quantityInStock = new Integer ( Integer . parseInt ( temp ) ) ;
}
temp = tk . nextToken ( ) ;
if ( ! temp . equals ( " ) )
{
unitPrice = Double . parseDouble ( temp ) ;
}
temp = tk . nextToken ( ) ;
if ( ! temp . equals ( " ) )
{
reorderPoint = Integer . parseInt ( temp ) ;
}
temp = tk . nextToken ( ) ;
if ( ! temp . equals ( " ) )
{
reorderQuantity = Integer . parseInt ( temp ) ;
}
temp = tk . nextToken ( ) ;
if ( ! temp . equals ( " ) )
{
totalOrdered = Integer . parseInt ( temp ) ;
}
temp = tk . nextToken ( ) ;
if ( ! temp . equals ( " ) )
{
totalSalesOrders = Integer . parseInt ( temp ) ;
}
lastUpdated = new Date ( <num> ) ;
return err ;
}
}
package eclipse . project . overlay . views ;
import org . eclipse . jface . dialogs . MessageDialog ;
import org . eclipse . swt . SWT ;
import org . eclipse . swt . events . SelectionAdapter ;
import org . eclipse . swt . events . SelectionEvent ;
import org . eclipse . swt . events . SelectionListener ;
import org . eclipse . swt . layout . FillLayout ;
import org . eclipse . swt . layout . GridData ;
import org . eclipse . swt . layout . GridLayout ;
import org . eclipse . swt . layout . RowLayout ;
import org . eclipse . swt . widgets . Button ;
import org . eclipse . swt . widgets . Combo ;
import org . eclipse . swt . widgets . Composite ;
import org . eclipse . swt . widgets . FileDialog ;
import org . eclipse . swt . widgets . Group ;
import org . eclipse . swt . widgets . Label ;
import org . eclipse . swt . widgets . Shell ;
import org . eclipse . swt . widgets . Text ;
import org . eclipse . ui . part . ViewPart ;
public class MainViewPerso extends ViewPart {
public MainViewPerso ( ) {
}
@Override
public void createPartControl ( final Composite parent ) {
final Shell shell = parent . getShell ( ) ;
FillLayout myFillLayout = new FillLayout ( SWT . VERTICAL ) ;
parent . setLayout ( myFillLayout ) ;
Group groupVideo = new Group ( parent , SWT . NONE ) ;
groupVideo . setLayout ( new GridLayout ( <num> , false ) ) ;
groupVideo . setText ( " ) ;
Label videoSourceLabel = new Label ( groupVideo , SWT . NONE ) ;
videoSourceLabel . setText ( " ) ;
final Combo videoSourceValue = new Combo ( groupVideo , SWT . READ_ONLY ) ;
videoSourceValue . add ( " ) ;
videoSourceValue . add ( " ) ;
videoSourceValue . add ( " ) ;
GridData myGridData = new GridData ( GridData . FILL_HORIZONTAL ) ;
final Text sourceName = new Text ( groupVideo , SWT . BORDER ) ;
sourceName . setLayoutData ( myGridData ) ;
Button open = new Button ( groupVideo , SWT . PUSH ) ;
open . setText ( " ) ;
open . addSelectionListener ( new SelectionAdapter ( ) {
public void widgetSelected ( SelectionEvent event ) {
FileDialog dlg = new FileDialog ( shell , SWT . OPEN ) ;
dlg . setFilterExtensions ( new String [ ] { " , " , " } ) ;
String fn = dlg . open ( ) ;
if ( fn != null ) {
sourceName . setText ( fn ) ;
}
}
} ) ;
Group groupTraitement = new Group ( parent , SWT . NONE ) ;
groupTraitement . setLayout ( new GridLayout ( <num> , false ) ) ;
groupTraitement . setText ( " ) ;
Label videoTraitmentLabel = new Label ( groupTraitement , SWT . NONE ) ;
videoTraitmentLabel . setText ( " ) ;
final Combo videoTraitmentValue = new Combo ( groupTraitement , SWT . READ_ONLY ) ;
videoTraitmentValue . add ( " ) ;
videoTraitmentValue . add ( " ) ;
myGridData = new GridData ( GridData . FILL_HORIZONTAL ) ;
videoTraitmentValue . setLayoutData ( myGridData ) ;
Group groupSocial = new Group ( parent , SWT . NONE ) ;
groupSocial . setLayout ( new GridLayout ( <num> , false ) ) ;
groupSocial . setText ( " ) ;
Label networkTypeLabel = new Label ( groupSocial , SWT . NONE ) ;
networkTypeLabel . setText ( " ) ;
final Combo networkTypeValue = new Combo ( groupSocial , SWT . READ_ONLY ) ;
networkTypeValue . add ( " ) ;
networkTypeValue . add ( " ) ;
networkTypeValue . add ( " ) ;
myGridData = new GridData ( GridData . FILL_HORIZONTAL ) ;
networkTypeValue . setLayoutData ( myGridData ) ;
Group groupControl = new Group ( parent , SWT . NONE ) ;
groupControl . setLayout ( new GridLayout ( <num> , false ) ) ;
Button acceptButton = new Button ( groupControl , SWT . PUSH ) ;
acceptButton . setText ( " ) ;
Button cancelButton = new Button ( groupControl , SWT . PUSH ) ;
cancelButton . setText ( " ) ;
}
@Override
public void setFocus ( ) {
}
}
package com . mycompany . app ;
import junit . framework . Test ;
import junit . framework . TestCase ;
import junit . framework . TestSuite ;
public class AppTest
extends TestCase
{
public AppTest ( String testName )
{
super ( testName ) ;
}
public static Test suite ( )
{
return new TestSuite ( AppTest . class ) ;
}
public void testApp ( )
{
assertTrue ( true ) ;
}
}
package com . mycompany . app ;
public class App
{
public static void main ( String [ ] args )
{
System . out . println ( " ) ;
}
}
public class Main {
public static void main ( String [ ] args ) {
new Controller ( ) ;
}
}
import java . util . ArrayList ;
public class Card {
private final Suit suit ;
private final int value ;
private static final String [ ] names = new String [ ] { " , " , " , " , " , " , " , " , " , " , " , " , " , " , " } ;
public Card ( Suit suit , int value ) {
this . suit = suit ;
this . value = value ;
}
public Suit getSuit ( ) {
return this . suit ;
}
public int getValue ( ) {
return this . value ;
}
public static ArrayList < Card > getDeck ( ) {
ArrayList < Card > deck = new ArrayList < Card > ( <num> ) ;
deck . addAll ( getSuit ( Suit . CLUBS ) ) ;
deck . addAll ( getSuit ( Suit . DIAMONDS ) ) ;
deck . addAll ( getSuit ( Suit . HEARTS ) ) ;
deck . addAll ( getSuit ( Suit . SPADES ) ) ;
return deck ;
}
private static ArrayList < Card > getSuit ( Suit suit ) {
ArrayList < Card > rt = new ArrayList < Card > ( ) ;
for ( int i = <num> ; i < <num> ; i ++ ) {
rt . add ( new Card ( suit , i ) ) ;
}
return rt ;
}
@Override
public String toString ( ) {
return names [ value ] + " + suit ;
}
}
import java . util . ArrayList ;
public abstract class Participant {
private final ArrayList < Card > deck = new ArrayList < Card > ( ) ;
private final ArrayList < Card > hand = new ArrayList < Card > ( <num> ) ;
public abstract void turn ( ) ;
public void giveCard ( Card card ) {
deck . add ( card ) ;
}
public void <unk> ( ArrayList < Card > cards ) {
deck . addAll ( cards ) ;
}
public Card drawTopCard ( ) {
Card top = null ;
for ( Card c : deck ) {
if ( c == null ) {
break ;
}
top = c ;
}
deck . remove ( top ) ;
addToHand ( top ) ;
return top ;
}
private void addToHand ( Card card ) {
int size = hand . size ( ) ;
if ( size >= <num> ) {
for ( int i = <num> ; i < size ; i ++ ) {
if ( hand . get ( i ) == null ) {
hand . add ( i , card ) ;
Common . debug ( " + card + " + i ) ;
break ;
}
}
} else {
hand . add ( card ) ;
}
}
public ArrayList < Card > drawTopCards ( int amount ) {
Common . debug ( " + amount + " ) ;
ArrayList < Card > rt = new ArrayList < Card > ( amount ) ;
for ( int i = <num> ; i < amount ; i ++ ) {
rt . add ( drawTopCard ( ) ) ;
}
return rt ;
}
public ArrayList < Card > getHand ( ) {
return this . hand ;
}
public Card [ ] playCard ( int id ) {
Card played = hand . remove ( id ) ;
Card replacement = drawTopCard ( ) ;
return new Card [ ] { played , replacement } ;
}
}
import java . awt . Dimension ;
import java . awt . Rectangle ;
import java . awt . Toolkit ;
public class Common {
private static boolean debug = true ;
public static void print ( Object obj ) {
System . out . println ( obj . toString ( ) ) ;
}
public static void debug ( Object obj ) {
if ( debug ) {
System . out . println ( obj . toString ( ) ) ;
}
}
public static Rectangle getCentered ( int width , int height ) {
Dimension screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ;
int w = screenSize . width / <num> ;
int h = screenSize . height / <num> ;
return new Rectangle ( w  ( width / <num> ) , h  ( height / <num> ) , width , height ) ;
}
}
public class Computer extends Participant {
@Override
public void turn ( ) {
}
}
public enum Suit {
CLUBS ( CardColor . BLACK ) ,
SPADES ( CardColor . BLACK ) ,
HEARTS ( CardColor . RED ) ,
DIAMONDS ( CardColor . RED ) ;
private final CardColor color ;
Suit ( CardColor color ) {
this . color = color ;
}
public CardColor getColor ( ) {
return this . color ;
}
}
import java . awt . Container ;
import java . awt . Graphics2D ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import java . awt . image . BufferedImage ;
import java . io . File ;
import java . io . IOException ;
import javax . imageio . ImageIO ;
import javax . swing . ImageIcon ;
import javax . swing . JButton ;
import javax . swing . JFrame ;
import javax . swing . JPanel ;
public class View extends JFrame {
private static final long serialVersionUID =  <num> ;
private JButton [ ] cards = new JButton [ <num> ] ;
public View ( final Controller controller ) {
super ( " ) ;
setBounds ( Common . getCentered ( <num> , <num> ) ) ;
setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
Container con = this . getContentPane ( ) ;
JPanel pane = new JPanel ( ) ;
pane . setLayout ( null ) ;
con . add ( pane ) ;
cards [ <num> ] = new JButton ( ) ;
cards [ <num> ] . setBounds ( <num> , <num> , <num> , <num> ) ;
pane . add ( cards [ <num> ] ) ;
cards [ <num> ] . addActionListener ( new ActionListener ( ) {
@Override
public void actionPerformed ( ActionEvent e ) {
controller . cardClick ( <num> ) ;
} } ) ;
cards [ <num> ] = new JButton ( ) ;
cards [ <num> ] . setBounds ( <num> , <num> , <num> , <num> ) ;
pane . add ( cards [ <num> ] ) ;
cards [ <num> ] . addActionListener ( new ActionListener ( ) {
@Override
public void actionPerformed ( ActionEvent e ) {
controller . cardClick ( <num> ) ;
} } ) ;
cards [ <num> ] = new JButton ( ) ;
cards [ <num> ] . setBounds ( <num> , <num> , <num> , <num> ) ;
pane . add ( cards [ <num> ] ) ;
cards [ <num> ] . addActionListener ( new ActionListener ( ) {
@Override
public void actionPerformed ( ActionEvent e ) {
controller . cardClick ( <num> ) ;
} } ) ;
setVisible ( true ) ;
}
public void setCard ( int cardId , Card info ) {
try {
BufferedImage bi = ImageIO . read ( new File ( " ) ) ;
int x = <num> ;
int v = info . getValue ( ) ;
if ( v < <num> ) {
x = ( v  <num> ) * <num> ;
}
BufferedImage card = resizeImage ( bi . getSubimage ( x , <num> + info . getSuit ( ) . ordinal ( ) * <num> , <num> , <num> ) , <num> , <num> ) ;
cards [ cardId ] . setIcon ( new ImageIcon ( card ) ) ;
} catch ( IOException e ) {
Common . print ( " ) ;
}
}
public static BufferedImage resizeImage ( BufferedImage originalImage , int width , int height ) {
BufferedImage resizedImage = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ;
Graphics2D g = resizedImage . createGraphics ( ) ;
g . drawImage ( originalImage , <num> , <num> , width , height , null ) ;
g . dispose ( ) ;
return resizedImage ;
}
}
public class Player extends Participant {
@Override
public void turn ( ) {
}
}
import java . util . ArrayList ;
import java . util . Collections ;
public class Model {
private final Player player = new Player ( ) ;
private final Computer computer = new Computer ( ) ;
public Model ( ) {
deal ( ) ;
player . turn ( ) ;
}
private void deal ( ) {
ArrayList < Card > deck = Card . getDeck ( ) ;
Collections . shuffle ( deck ) ;
for ( int i = <num> ; i < deck . size ( ) ; i ++ ) {
Card c = deck . get ( i ) ;
if ( i % <num> == <num> ) {
player . giveCard ( c ) ;
} else {
computer . giveCard ( c ) ;
}
}
player . drawTopCards ( <num> ) ;
computer . drawTopCards ( <num> ) ;
}
public Player getPlayer ( ) {
return this . player ;
}
}
import java . util . ArrayList ;
public class Controller {
private final View view = new View ( this ) ;
private final Model model = new Model ( ) ;
public Controller ( ) {
ArrayList < Card > hand = model . getPlayer ( ) . getHand ( ) ;
for ( int i = <num> ; i < hand . size ( ) ; i ++ ) {
Card c = hand . get ( i ) ;
view . setCard ( i , c ) ;
}
}
public void cardClick ( int id ) {
Card [ ] move = model . getPlayer ( ) . playCard ( id ) ;
view . setCard ( id , move [ <num> ] ) ;
}
}
public enum CardColor {
BLACK ,
RED ;
}
package jxt . datova ;
import jxt . aplikacni . Predmet ;
import java . util . List ;
import java . util . LinkedList ;
import java . io . File ;
import javax . xml . parsers . SAXParser ;
import javax . xml . parsers . SAXParserFactory ;
import org . xml . sax . Attributes ;
import org . xml . sax . SAXException ;
import org . xml . sax . helpers . DefaultHandler ;
public class <unk> extends DefaultHandler {
boolean inDepartment , inSubject ;
Predmet p ;
List < Predmet > vysledek ;
public List < Predmet > getData ( File f ) {
vysledek = new LinkedList < Predmet > ( ) ;
try {
SAXParserFactory factory = SAXParserFactory . newInstance ( ) ;
SAXParser parser = factory . newSAXParser ( ) ;
parser . parse ( f , this ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
return vysledek ;
}
@Override
public void startElement ( String uri , String localName , String qName ,
Attributes attributes ) throws SAXException {
if ( qName . equals ( " ) )
p = new Predmet ( ) ;
else if ( qName . equals ( " ) )
inDepartment = true ;
else if ( qName . equals ( " ) )
inSubject = true ;
else if ( qName . equals ( " ) )
p . semestr = attributes . getValue ( " ) ;
}
@Override
public void endElement ( String uri , String localName , String qName )
throws SAXException {
if ( qName . equals ( " ) )
vysledek . add ( p ) ;
else if ( qName . equals ( " ) )
inDepartment = false ;
else if ( qName . equals ( " ) )
inSubject = false ;
}
@Override
public void characters ( char [ ] ch , int start , int length )
throws SAXException {
if ( inDepartment )
p . pracoviste = new String ( ch , start , length ) ;
else if ( inSubject )
p . nazev = new String ( ch , start , length ) ;
}
}
package jxt . aplikacni ;
public class Predmet {
public String pracoviste , nazev , semestr ;
@Override
public boolean equals ( Object o ) {
return pracoviste . equals ( ( ( Predmet ) o ) . pracoviste )
&& nazev . equals ( ( ( Predmet ) o ) . nazev )
&& semestr . equals ( ( ( Predmet ) o ) . semestr ) ;
}
@Override
public int hashCode ( ) {
return ( pracoviste + nazev + semestr ) . hashCode ( ) ;
}
}
package jxt ;
import jxt . aplikacni . * ;
import jxt . datova . * ;
import java . util . List ;
import java . util . LinkedList ;
import java . util . ArrayList ;
import java . util . Map ;
import java . util . HashMap ;
import java . util . Comparator ;
import java . util . Collections ;
import java . util . Locale ;
import java . io . File ;
import java . io . PrintWriter ;
import java . io . BufferedOutputStream ;
import java . io . FileOutputStream ;
import java . io . OutputStreamWriter ;
import java . io . FileNotFoundException ;
import java . io . UnsupportedEncodingException ;
import java . text . Collator ;
public class Hlavni {
public static void main ( String [ ] argv ) {
PrintWriter out ;
String inFile , outFile ;
HashMap < String , Integer > pracoviste ;
HashMap < Predmet , Object > predmety ;
List < Predmet > list ;
ArrayList < Map . Entry < String , Integer >> tmpList ;
int i ;
inFile = outFile = null ;
out = null ;
pracoviste = new HashMap < String , Integer > ( ) ;
predmety = new HashMap < Predmet , Object > ( ) ;
for ( String arg : argv ) {
if ( arg . charAt ( <num> ) == -' ) {
if ( arg . charAt ( <num> ) == i' )
inFile = arg . substring ( <num> ) ;
if ( arg . charAt ( <num> ) == o' )
outFile = arg . substring ( <num> ) ;
}
}
list = new TxtReader ( ) . getData ( new File ( inFile ) ) ;
for ( Predmet p : list ) {
if ( ! pracoviste . containsKey ( p . pracoviste ) )
pracoviste . put ( p . pracoviste , <num> ) ;
if ( ! predmety . containsKey ( p ) )
pracoviste . put ( p . pracoviste , pracoviste . get ( p . pracoviste ) + <num> ) ;
predmety . put ( p , null ) ;
}
tmpList =
new ArrayList < Map . Entry < String , Integer >> ( pracoviste . entrySet ( ) ) ;
Collections . sort ( tmpList , new Comparator < Map . Entry < String , Integer >> ( ) {
public int compare ( Map . Entry a , Map . Entry b ) {
int c = ( ( Integer ) a . getValue ( ) ) . compareTo (
( ( Integer ) b . getValue ( ) ) ) ;
if ( c != <num> )
return c ;
return Collator . getInstance ( new Locale ( " , " ) )
. compare ( a . getKey ( ) , b . getKey ( ) ) ;
}
} ) ;
try {
out = new PrintWriter (
new OutputStreamWriter (
new BufferedOutputStream (
new FileOutputStream ( outFile ) ) , " ) ) ;
out . printf ( " , list . size ( ) ) ;
out . printf ( " , predmety . size ( ) ) ;
out . printf ( " , pracoviste . size ( ) ) ;
i = <num> ;
for ( Map . Entry < String , Integer > entry : tmpList ) {
out . printf ( " ,
i , entry . getKey ( ) , entry . getValue ( ) ) ;
i ++ ;
}
} catch ( FileNotFoundException e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
} finally {
out . close ( ) ;
}
}
}
package jxt ;
import java . io . * ;
import java . util . * ;
import java . math . BigInteger ;
import javax . xml . bind . * ;
import jxt . aplikacni . Predmet ;
import jxtsp . * ;
import jxtrozvrh . * ;
public class Hlavni {
public static void main ( String [ ] args ) throws Exception {
String x , y , zvoleneOsobniCislo , outDir ;
x = y = zvoleneOsobniCislo = outDir = null ;
for ( String arg : args )
if ( arg . charAt ( <num> ) == -' ) {
if ( arg . charAt ( <num> ) == x' )
x = arg . substring ( <num> ) ;
if ( arg . charAt ( <num> ) == y' )
y = arg . substring ( <num> ) ;
if ( arg . charAt ( <num> ) == i' )
zvoleneOsobniCislo = arg . substring ( <num> ) ;
if ( arg . charAt ( <num> ) == d' )
outDir = arg . substring ( <num> ) ;
}
JAXBContext c = JAXBContext . newInstance ( " ) ;
Unmarshaller u = c . createUnmarshaller ( ) ;
JAXBElement < ? > rozvrhoveAkce = ( JAXBElement < ? > ) u . unmarshal (
new File ( y ) ) ;
JAXBElement < ? > predzapisoveAkce = ( JAXBElement < ? > ) u . unmarshal (
new File ( x ) ) ;
Map < BigInteger , Object > zapsane = new HashMap < BigInteger , Object > ( ) ;
Map < BigInteger , Predmet > index = new HashMap < BigInteger , Predmet > ( ) ;
for ( EventType event :
( ( <unk> ) predzapisoveAkce
. getValue ( ) ) . getEvent ( ) )
{
String osobniCislo = event . getParameters ( )
. getActor ( ) . <unk> ( ) ;
if ( osobniCislo . equals ( zvoleneOsobniCislo ) ) {
<unk> data = event . <unk> ( ) ;
BigInteger id = data . <unk> ( ) . getId ( ) ;
if ( data . getActivity ( ) == <unk> . INSERT )
zapsane . put ( id , null ) ;
else
zapsane . remove ( id ) ;
}
}
for ( <unk> activity :
( ( <unk> ) rozvrhoveAkce
. getValue ( ) ) . <unk> ( ) )
{
Predmet predmet = new Predmet ( ) ;
predmet . nazev = activity . getSubject ( ) . getValue ( ) ;
predmet . typ = activity . getSubject ( ) . getKind ( ) ;
if ( predmet . nazev == null || predmet . typ == null )
continue ;
if ( activity . getTime ( ) == null )
continue ;
predmet . den = activity . getTime ( ) . getDay ( ) ;
predmet . semestr = activity . getTime ( ) . <unk> ( ) ;
predmet . zacatek = activity . getTime ( ) . getStartTime ( ) ;
predmet . konec = activity . getTime ( ) . getEndTime ( ) ;
if ( predmet . den == null
|| predmet . semestr == null
|| predmet . zacatek == null
|| predmet . konec == null )
continue ;
if ( activity . getPlace ( ) == null )
continue ;
predmet . budova = activity . getPlace ( ) . <unk> ( ) ;
predmet . mistnost = activity . getPlace ( ) . <unk> ( ) ;
if ( predmet . budova == null || predmet . mistnost == null )
continue ;
index . put ( activity . getId ( ) , predmet ) ;
}
List < BigInteger > zapsanaId =
new LinkedList < BigInteger > ( zapsane . keySet ( ) ) ;
List < Predmet > predmety = new ArrayList < Predmet > ( zapsanaId . size ( ) ) ;
for ( BigInteger id : zapsanaId )
if ( index . get ( id ) != null )
predmety . add ( index . get ( id ) ) ;
Collections . sort ( predmety ) ;
File outDirFile = new File ( outDir ) ;
PrintWriter out = new PrintWriter (
new OutputStreamWriter (
new BufferedOutputStream (
new FileOutputStream (
new File ( outDirFile . getAbsolutePath ( ) ,
" + zvoleneOsobniCislo + " ) ) ) , " ) ) ;
for ( Predmet p : predmety )
out . printf ( " ,
p . nazev , p . typ . value ( ) , p . den . value ( ) ,
p . zacatek , p . konec , p . budova , p . mistnost ) ;
out . close ( ) ;
jxtrozvrh . ObjectFactory factory = new jxtrozvrh . ObjectFactory ( ) ;
<unk> student = factory . <unk> ( ) ;
student . <unk> ( zvoleneOsobniCislo ) ;
List < PredmetTyp > predmetyStudenta = student . <unk> ( ) ;
for ( Predmet p : predmety ) {
PredmetTyp predmet = factory . <unk> ( ) ;
predmet . <unk> ( p . nazev ) ;
predmet . setTyp ( <unk> . valueOf ( p . typ . toString ( ) ) ) ;
predmet . <unk> ( <unk> . valueOf ( p . den . toString ( ) ) ) ;
predmet . <unk> ( <unk> . valueOf ( p . semestr . toString ( ) ) ) ;
predmet . <unk> ( p . zacatek ) ;
predmet . <unk> ( p . konec ) ;
predmet . <unk> ( p . budova ) ;
predmet . <unk> ( p . mistnost ) ;
predmetyStudenta . add ( predmet ) ;
}
JAXBContext cm = JAXBContext . newInstance ( " ) ;
Marshaller m = cm . createMarshaller ( ) ;
m . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , true ) ;
m . setProperty ( Marshaller . <unk> , " ) ;
JAXBElement < ? > rozvrh = factory . <unk> ( student ) ;
m . marshal ( rozvrh , new FileOutputStream (
new File ( outDirFile . getAbsolutePath ( ) ,
" + zvoleneOsobniCislo + " ) ) ) ;
}
}
package jxt . datova ;
import jxt . aplikacni . Predmet ;
import java . util . List ;
import java . util . LinkedList ;
import java . util . StringTokenizer ;
import java . io . File ;
import java . io . BufferedReader ;
import java . io . InputStreamReader ;
import java . io . FileInputStream ;
import java . io . IOException ;
public class TxtReader {
public List < Predmet > getData ( File f ) {
LinkedList < Predmet > vysledek ;
BufferedReader r ;
StringTokenizer tok ;
String line ;
vysledek = new LinkedList < Predmet > ( ) ;
line = null ;
try {
r = new BufferedReader (
new InputStreamReader (
new FileInputStream ( f ) , " ) ) ;
while ( ( line = r . readLine ( ) ) != null ) {
tok = new StringTokenizer ( line , " ) ;
Predmet c = new Predmet ( ) ;
tok . nextToken ( ) ;
c . pracoviste = tok . nextToken ( ) ;
c . nazev = tok . nextToken ( ) ;
tok . nextToken ( ) ;
c . semestr = tok . nextToken ( ) ;
vysledek . add ( c ) ;
}
} catch ( IOException e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
return vysledek ;
}
}
package jxt . aplikacni ;
import javax . xml . <unk> . XMLGregorianCalendar ;
import java . text . Collator ;
import java . util . Locale ;
import jxtsp . * ;
public class Predmet implements Comparable < Predmet > {
public String nazev , budova , mistnost ;
public <unk> typ ;
public TermType semestr ;
public <unk> den ;
public XMLGregorianCalendar zacatek , konec ;
@Override
public int compareTo ( Predmet p ) {
int cmp ;
cmp = semestr . compareTo ( p . semestr ) ;
if ( cmp != <num> )
return cmp ;
cmp = den . compareTo ( p . den ) ;
if ( cmp != <num> )
return cmp ;
cmp = zacatek . compare ( p . zacatek ) ;
if ( cmp != <num> )
return cmp ;
cmp = typ . compareTo ( p . typ ) ;
if ( cmp != <num> )
return cmp ;
return Collator . getInstance ( new Locale ( " , " ) )
. compare ( nazev , p . nazev ) ;
}
}
package com . github . mumoshu . ssp . java . time ;
public interface <unk> {
void setHour ( Integer hour ) ;
Integer getHour ( ) ;
void <unk> ( Integer minute ) ;
Integer getMinute ( ) ;
}
package com . github . mumoshu . ssp . java . fruit ;
public abstract class Apple extends Fruit {
private final String v ;
protected Apple ( String v ) {
this . v = v ;
}
@Override
public String v ( ) {
return v ;
}
}
package com . github . mumoshu . ssp . java ;
public abstract class <unk> {
}
package com . github . mumoshu . ssp . java . <unk> ;
public class <unk> {
interface RationalTest {
Integer numerArg ( ) ;
Integer denomArg ( ) ;
}
public static void run ( ) {
new RationalTest ( ) {
@Override
public Integer numerArg ( ) {
return <num> ;
}
@Override
public Integer denomArg ( ) {
return <num> ;
}
} ;
}
}
package com . github . mumoshu . ssp . java ;
public interface Abstract < T > {
public T transform ( T t ) ;
public T initial ( ) ;
public void setCurrent ( T t ) ;
public T current ( ) ;
}
package com . github . mumoshu . ssp . java ;
public class Concrete implements Abstract < String > {
private String current = initial ( ) ;
@Override
public String transform ( String s ) {
return s + s ;
}
@Override
public String initial ( ) {
return " ;
}
@Override
public void setCurrent ( String s ) {
this . current = s ;
}
@Override
public String current ( ) {
return this . current ;
}
}
package com . github . mumoshu . ssp . java . fruit ;
public abstract class Fruit {
public abstract String v ( ) ;
public abstract String m ( ) ;
}
package com . voidberg . drupaldroid ;
import android . util . Log ;
import com . loopj . android . http . AsyncHttpClient ;
import com . loopj . android . http . AsyncHttpResponseHandler ;
import com . loopj . android . http . PersistentCookieStore ;
import com . loopj . android . http . RequestParams ;
import org . apache . http . entity . StringEntity ;
import org . apache . http . message . BasicHeader ;
import org . apache . http . protocol . HTTP ;
import org . json . JSONObject ;
import java . io . * ;
public class ServicesClient {
private String url ;
private String rootUrl ;
private String token ;
public static AsyncHttpClient client = new AsyncHttpClient ( ) ;
public ServicesClient ( String server , String base ) {
this . url = server + /' + base + /' ;
this . rootUrl = server + /' ;
this . token = " ;
client . setTimeout ( <num> ) ;
}
public String getToken ( ) {
return token ;
}
public void setToken ( String token ) {
this . token = token ;
}
private void setHeaders ( ) {
if ( ! token . equals ( " ) ) {
client . addHeader ( " , token ) ;
}
}
public void setCookieStore ( PersistentCookieStore cookieStore ) {
client . setCookieStore ( cookieStore ) ;
}
private String getAbsoluteUrl ( String relativeUrl ) {
return this . url + relativeUrl ;
}
private String getAbsoluteRootUrl ( String relativeUrl ) {
return this . rootUrl + relativeUrl ;
}
public void getRoot ( String url , RequestParams params , AsyncHttpResponseHandler responseHandler ) {
client . get ( getAbsoluteRootUrl ( url ) , params , responseHandler ) ;
}
public void get ( String url , RequestParams params , AsyncHttpResponseHandler responseHandler ) {
client . get ( getAbsoluteUrl ( url ) , params , responseHandler ) ;
}
public void post ( String url , RequestParams params , AsyncHttpResponseHandler responseHandler ) {
this . setHeaders ( ) ;
client . post ( getAbsoluteUrl ( url ) , params , responseHandler ) ;
}
public void post ( String url , JSONObject params , AsyncHttpResponseHandler responseHandler ) {
this . setHeaders ( ) ;
StringEntity se = null ;
try {
se = new StringEntity ( params . toString ( ) , HTTP . UTF_8 ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
}
se . setContentType ( new BasicHeader ( HTTP . CONTENT_TYPE , " ) ) ;
client . post ( null , getAbsoluteUrl ( url ) , se , " , responseHandler ) ;
}
public void put ( String url , RequestParams params , AsyncHttpResponseHandler responseHandler ) {
this . setHeaders ( ) ;
client . put ( getAbsoluteUrl ( url ) , params , responseHandler ) ;
}
public void put ( String url , JSONObject params , AsyncHttpResponseHandler responseHandler ) {
this . setHeaders ( ) ;
StringEntity se = null ;
try {
se = new StringEntity ( params . toString ( ) , HTTP . UTF_8 ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
}
se . setContentType ( new BasicHeader ( HTTP . CONTENT_TYPE , " ) ) ;
client . put ( null , getAbsoluteUrl ( url ) , se , " , responseHandler ) ;
}
public void getToken ( AsyncHttpResponseHandler responseHandler ) {
this . getRoot ( " , new RequestParams ( ) , responseHandler ) ;
}
}
package com . example . drupaldroid ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . app . ProgressDialog ;
import android . os . Bundle ;
import android . util . Log ;
import com . loopj . android . http . AsyncHttpResponseHandler ;
import com . voidberg . drupaldroid . ServicesClient ;
import com . voidberg . drupaldroid . UserServices ;
public class Login extends Activity {
Activity activity ;
ProgressDialog progressDialog ;
String url = " ;
String apiEndpoint = " ;
String drupalUser = " ;
String drupalPass = " ;
String TAG = " ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
activity = this ;
ServicesClient client ;
client = new ServicesClient ( url , apiEndpoint ) ;
UserServices us ;
us = new UserServices ( client ) ;
progressDialog = ProgressDialog . show ( activity , " , " , true , false ) ;
us . Login ( drupalUser , drupalPass , new AsyncHttpResponseHandler ( ) {
@Override
public void onSuccess ( String response ) {
Log . v ( TAG , response ) ;
new AlertDialog . Builder ( activity ) . setMessage ( " ) . setPositiveButton ( " , null ) . setCancelable ( true ) . create ( ) . show ( ) ;
}
@Override
public void onFailure ( Throwable e , String response ) {
Log . v ( TAG , e . getMessage ( ) ) ;
Log . v ( TAG , response ) ;
new AlertDialog . Builder ( activity ) . setMessage ( " ) . setPositiveButton ( " , null ) . setCancelable ( true ) . create ( ) . show ( ) ;
}
@Override
public void onFinish ( ) {
progressDialog . hide ( ) ;
progressDialog . dismiss ( ) ;
}
} ) ;
}
}
package com . voidberg . drupaldroid ;
import com . loopj . android . http . AsyncHttpResponseHandler ;
import org . json . JSONObject ;
public class SystemServices {
private ServicesClient client ;
public SystemServices ( ServicesClient c ) {
client = c ;
}
public void connect ( AsyncHttpResponseHandler responseHandler ) {
client . post ( " , new JSONObject ( ) , responseHandler ) ;
}
package com . voidberg . drupaldroid ;
import com . loopj . android . http . AsyncHttpResponseHandler ;
import org . json . JSONException ;
import org . json . JSONObject ;
public class UserServices {
private ServicesClient client ;
public UserServices ( ServicesClient c ) {
client = c ;
}
public void login ( String username , String password , AsyncHttpResponseHandler responseHandler ) {
JSONObject params = new JSONObject ( ) ;
try {
params . put ( " , username ) ;
params . put ( " , password ) ;
} catch ( JSONException e ) {
e . printStackTrace ( ) ;
}
client . post ( " , params , responseHandler ) ;
}
public void logout ( AsyncHttpResponseHandler responseHandler ) {
client . post ( " , new JSONObject ( ) , responseHandler ) ;
}
}
package test ;
import processing . core . PApplet ;
import controlP5 . ControlEvent ;
import controlP5 . ControlP5 ;
import controlP5 . MultiList ;
import controlP5 . MultiListButton ;
public class <unk> extends PApplet {
ControlP5 controlP5 ;
MultiList l ;
public void setup ( ) {
size ( <num> , <num> ) ;
frameRate ( <num> ) ;
this . controlP5 = new ControlP5 ( this ) ;
this . l = this . controlP5 . addMultiList ( " , <num> , <num> , <num> , <num> ) ;
MultiListButton b ;
b = this . l . add ( " , <num> ) ;
b . add ( " , <num> ) . setLabel ( " ) ;
b . add ( " , <num> ) . setLabel ( " ) ;
b = this . l . add ( " , <num> ) ;
int cnt = <num> ;
for ( int i = <num> ; i < <num> ; i ++ ) {
final MultiListButton c = b . add ( " + ( i + <num> ) , <num> + i + <num> ) ;
c . setLabel ( " + ( i + <num> ) ) ;
c . setColorBackground ( color ( <num> + ( <num> * i ) , <num> , <num> ) ) ;
if ( i == <num> ) {
c . setWidth ( <num> ) ;
c . setHeight ( <num> ) ;
}
cnt ++ ;
if ( i == <num> ) {
for ( int j = <num> ; j < <num> ; j ++ ) {
cnt ++ ;
MultiListButton d ;
d = c . add ( " + i + " + j , <num> + j + <num> ) ;
d . setLabel ( " + ( i + <num> ) + " + " + ( j + <num> ) ) ;
d . setColorBackground ( color ( <num> + ( <num> * j ) ,
( <num> + ( <num> * j ) ) / <num> , <num> ) ) ;
d . setId ( cnt ) ;
d . setWidth ( <num> ) ;
}
}
}
final MultiListButton cc = ( MultiListButton ) this . controlP5
. controller ( " ) ;
cc . setHeight ( <num> ) ;
}
public void controlEvent ( final ControlEvent theEvent ) {
println ( theEvent . controller ( ) . name ( ) + " + theEvent . value ( ) ) ;
}
public void draw ( ) {
background ( <num> ) ;
}
public void keyPressed ( ) {
if ( this . controlP5 . controller ( " ) != null ) {
println ( " ) ;
this . controlP5 . controller ( " ) . remove ( ) ;
}
}
static public void main ( String args [ ] ) {
PApplet . main ( new String [ ] { " , " } ) ;
}
package interactivetui ;
import processing . core . PApplet ;
import controlP5 . * ;
public class DoAction implements <unk> {
@Override
public void controlEvent ( <unk> theEvent ) {
PApplet . println ( theEvent . getAction ( ) ) ;
}
}
package interactivetui ;
import java . util . ArrayList ;
import processing . core . * ;
import org . json . * ;
public class Component {
String name ;
String imagePath ;
PImage image ;
ArrayList < Rfid > actionList = new ArrayList < Rfid > ( ) ;
Component ( ) {
}
Component ( JSONObject json ) {
name = json . getString ( " ) ;
imagePath = json . getString ( " ) ;
JSONArray actions = json . getJSONArray ( " ) ;
for ( int i = <num> ; i < actions . length ( ) ; i ++ ) {
JSONObject childJSONObject = actions . getJSONObject ( i ) ;
String rfidName = childJSONObject . getString ( " ) ;
String rfidId = childJSONObject . getString ( " ) ;
String rfidAction = childJSONObject . getString ( " ) ;
addRFID ( new Rfid ( rfidAction , rfidId , rfidName ) ) ;
}
}
void addRFID ( Rfid r ) {
actionList . add ( r ) ;
}
public Rfid getRfid ( String id ) {
for ( Rfid rfid : actionList ) {
if ( rfid . id == id ) {
return rfid ;
}
}
return null ;
}
public String toJsonString ( ) {
String jsonString = " ;
jsonString += " + this . name + " ;
jsonString += " + this . image + " ;
jsonString += " ;
for ( Rfid rfid : actionList ) {
jsonString += rfid . toJson ( ) + " ;
}
jsonString += " ;
return jsonString ;
}
void backup ( ) {
}
}
package interactivetui ;
import java . io . File ;
import java . util . ArrayList ;
import controlP5 . * ;
import processing . core . * ;
public class ActionPicker {
ControlP5 controlP5 ;
MultiList l ;
PApplet parent ;
DoAction <unk> = new DoAction ( ) ;
public ActionPicker ( PApplet p , ControlP5 c , int mouseX , int mouseY ) {
parent = p ;
controlP5 = c ;
l = controlP5 . addMultiList ( " , mouseX , mouseY , <num> , <num> ) ;
File [ ] folders = listFiles ( " ) ;
populateMenu ( folders , l ) ;
}
public String [ ] <unk> ( String dir ) {
File file = new File ( dir ) ;
if ( file . isDirectory ( ) ) {
String names [ ] = file . list ( ) ;
return names ;
} else {
return null ;
}
}
public File [ ] listFiles ( String dir ) {
File file = new File ( dir ) ;
if ( file . isDirectory ( ) ) {
File [ ] files = file . listFiles ( ) ;
return files ;
} else {
return null ;
}
}
public ArrayList < File > <unk> ( String dir ) {
ArrayList < File > fileList = new ArrayList < File > ( ) ;
recurseDir ( fileList , dir ) ;
return fileList ;
}
public void recurseDir ( ArrayList < File > a , String dir ) {
File file = new File ( dir ) ;
if ( file . isDirectory ( ) ) {
a . add ( file ) ;
File [ ] subfiles = file . listFiles ( ) ;
for ( int i = <num> ; i < subfiles . length ; i ++ ) {
recurseDir ( a , subfiles [ i ] . getAbsolutePath ( ) ) ;
}
} else {
if ( file . getName ( ) . charAt ( <num> ) != .' ) {
a . add ( file ) ;
}
}
}
public void populateMenu ( File [ ] folders , MultiList list ) {
for ( int i = <num> ; i < folders . length ; i ++ ) {
MultiListButton b ;
File f = folders [ i ] ;
b = l . add ( f . getName ( ) , i ) ;
File [ ] subfiles = f . listFiles ( ) ;
for ( int j = <num> ; j < subfiles . length ; j ++ ) {
recursivePopulateMenu ( subfiles [ j ] , b , j ) ;
}
}
}
public void recursivePopulateMenu ( File file , MultiListButton menu , int value ) {
if ( file . isDirectory ( ) ) {
if ( ! file . getName ( ) . endsWith ( " ) ) {
MultiListButton subMenu = menu . add ( file . getName ( ) , <num> ) ;
File [ ] subfiles = file . listFiles ( ) ;
for ( int i = <num> ; i < subfiles . length ; i ++ ) {
recursivePopulateMenu ( subfiles [ i ] , subMenu , <num> * value + i ) ;
}
}
else {
menu . add ( file . getAbsolutePath ( ) , <num> + value ) . setLabel ( file . getName ( ) ) ;
}
} else {
}
}
}
package interactivetui ;
import processing . core . PApplet ;
import processing . serial . * ;
import controlP5 . ControlEvent ;
import controlP5 . ControlP5 ;
public class InteractiveTUI extends PApplet {
ComponentList componentList ;
int canvasWidth = <num> ;
int canvasHeight = <num> ;
int shift = <num> ;
ControlP5 controlP5 ;
boolean ready = false ;
Serial arduino ;
private static final long serialVersionUID = <num> ;
public void setup ( ) {
size ( canvasWidth , canvasHeight ) ;
frameRate ( <num> ) ;
controlP5 = new ControlP5 ( this ) ;
arduino = new Serial ( this , Serial . list ( ) [ <num> ] , <num> ) ;
arduino . <unk> ( \n' ) ;
componentList = new ComponentList ( this ) ;
ready = true ;
}
public void draw ( )
{
background ( <num> ) ;
String s ;
if ( arduino . available ( ) > <num> ) {
println ( " ) ;
s = arduino . readStringUntil ( \n' ) ;
println ( s ) ;
}
}
public void <unk> ( Serial receiving ) {
println ( " ) ;
String inString = receiving . readStringUntil ( \n' ) ;
if ( inString != null ) {
inString = trim ( inString ) ;
println ( " + inString ) ;
for ( Component component : componentList ) {
for ( Rfid action : component . actionList ) {
if ( action . id . equals ( inString ) ) {
new ComponentUI ( this , controlP5 , component , <num> , <num> ) ;
open ( action . action ) ;
}
println ( " ) ;
}
}
}
}
public void controlEvent ( ControlEvent theEvent ) {
println ( " ) ;
if ( ready ) {
if ( theEvent . getController ( ) . getValue ( ) == <num> ) {
println ( " + theEvent . getController ( ) . getName ( ) + " + theEvent . getController ( ) . <unk> ( ) ) ;
ActionPicker ap = new ActionPicker ( this , controlP5 , mouseX , mouseY ) ;
} else {
if ( theEvent . getController ( ) . getId ( ) ==  <num> ) {
println ( theEvent . controller ( ) . name ( ) + " + theEvent . value ( ) ) ;
println ( " + theEvent . controller ( ) . getInfo ( ) ) ;
println ( theEvent . getName ( ) ) ;
}
}
}
}
public static void main ( String _args [ ] ) {
PApplet . main ( new String [ ] { interactivetui . InteractiveTUI . class . getName ( ) } ) ;
}
}
package interactivetui ;
import processing . core . PApplet ;
import processing . core . PImage ;
import controlP5 . ControlP5 ;
public class ComponentUI {
int xPos = <num> ;
int yPos = <num> ;
Component component ;
PApplet papplet ;
PImage img = null ;
ControlP5 cp5 ;
public ComponentUI ( PApplet p , ControlP5 controlP5 , Component c ) {
componentUIBuilder ( p , controlP5 , c ,  <num> ,  <num> ) ;
}
public ComponentUI ( PApplet p , ControlP5 controlP5 , Component c , int x , int y ) {
componentUIBuilder ( p , controlP5 , c , x , y ) ;
}
private void componentUIBuilder ( PApplet p , ControlP5 controlP5 , Component c , int x , int y ) {
component = c ;
papplet = p ;
cp5 = controlP5 ;
if ( component . imagePath != " ) {
img = papplet . loadImage ( component . imagePath ) ;
xPos = x ;
yPos = y ;
createUIelements ( ) ;
}
}
public void setPosition ( int x , int y ) {
xPos = x ;
yPos = y ;
}
public int getHeight ( ) {
if ( img != null ) {
return img . height ;
} else {
return <num> ;
}
}
public int getWidth ( ) {
if ( img != null ) {
return img . width ;
} else {
return <num> ;
}
}
private void createUIelements ( ) {
int numberOfRfid = component . actionList . size ( ) ;
int w = getWidth ( ) ;
int distance = ( int ) w / numberOfRfid ;
cp5 . addButton ( component . name )
. setValue ( <num> )
. setPosition ( xPos , yPos )
. setSize ( getWidth ( ) , getHeight ( ) )
. setImage ( img ) ;
papplet . image ( img , xPos , yPos ) ;
int num = <num> ;
for ( Rfid r : component . actionList ) {
if ( r . name != " ) {
cp5 . addButton ( r . name )
. setValue ( <num> )
. setPosition ( xPos + w , yPos + distance * num )
. setSize ( <num> , <num> )
. <unk> ( r . id ) ;
;
} else {
cp5 . addButton ( " + r . id )
. setValue ( <num> )
. setPosition ( xPos + w , yPos + distance * num )
. setSize ( <num> , <num> )
;
}
num ++ ;
}
}
}
package interactivetui ;
import java . io . BufferedReader ;
import java . io . FileOutputStream ;
import java . io . ObjectOutputStream ;
import java . util . ArrayList ;
import org . json . JSONArray ;
import org . json . JSONObject ;
import processing . core . PApplet ;
public class ComponentList extends ArrayList < Component > {
BufferedReader <unk> ;
String configFilePath = " ;
JSONObject myJsonObject ;
private static final long serialVersionUID = <num> ;
public ComponentList ( PApplet p ) {
String [ ] config = p . loadStrings ( configFilePath ) ;
String data = PApplet . join ( config , " ) ;
myJsonObject = new JSONObject ( data ) ;
JSONArray json = myJsonObject . getJSONArray ( " ) ;
for ( int i = <num> ; i < json . length ( ) ; i ++ ) {
JSONObject childJSONObject = json . getJSONObject ( i ) ;
this . add ( new Component ( childJSONObject ) ) ;
}
}
public Component <unk> ( String id ) {
for ( Component component : this ) {
Rfid rfid = component . getRfid ( id ) ;
if ( rfid != null ) {
return component ;
}
}
return null ;
}
public void <unk> ( String id , String action ) {
for ( Component component : this ) {
Rfid rfid = component . getRfid ( id ) ;
if ( rfid != null ) {
rfid . action = action ;
}
}
}
public void <unk> ( ) {
ObjectOutputStream outputStream = null ;
try {
outputStream = new ObjectOutputStream ( new FileOutputStream ( configFilePath ) ) ;
outputStream . writeObject ( myJsonObject . toString ( ) ) ;
outputStream . flush ( ) ;
outputStream . close ( ) ;
} catch ( Exception e ) {
System . err . println ( " + e ) ;
}
}
}
package interactivetui ;
public class Rfid {
String action = " ;
String id = " ;
String name = " ;
Rfid ( String actionPath , String identifier , String title ) {
action = actionPath ;
id = identifier ;
name = title ;
}
public String toJson ( ) {
String jsonString = " ;
jsonString += " + id + " ;
jsonString += " + action + " ;
jsonString += " + name + " ;
jsonString += " ;
return jsonString ;
}
}
package com . <unk> ;
import android . app . Activity ;
import android . content . Context ;
import android . location . Location ;
import android . location . LocationListener ;
import android . location . LocationManager ;
import android . os . Bundle ;
import android . widget . TextView ;
public class <unk> extends Activity {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
final TextView mTextView = ( TextView ) findViewById ( R . id . coords ) ;
mTextView . setText ( " ) ;
LocationManager locationManager = ( LocationManager ) this . getSystemService ( Context . LOCATION_SERVICE ) ;
LocationListener locationListener = new LocationListener ( ) {
public void onLocationChanged ( Location location ) {
mTextView . setText ( location + " ) ;
}
public void onStatusChanged ( String provider , int status , Bundle extras ) { }
public void onProviderEnabled ( String provider ) { }
public void onProviderDisabled ( String provider ) { }
} ;
locationManager . requestLocationUpdates ( LocationManager . NETWORK_PROVIDER , <num> , <num> , locationListener ) ;
}
package com . lukasz . push ;
import java . util . Calendar ;
import java . util . Date ;
import android . content . res . Configuration ;
import android . os . Bundle ;
import android . text . format . DateFormat ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . view . Window ;
import android . widget . CheckBox ;
import android . widget . TimePicker ;
import com . urbanairship . analytics . InstrumentedActivity ;
import com . urbanairship . push . PushManager ;
import com . urbanairship . push . PushPreferences ;
public class PushPreferencesActivity extends InstrumentedActivity {
CheckBox pushEnabled ;
CheckBox soundEnabled ;
CheckBox vibrateEnabled ;
CheckBox quietTimeEnabled ;
TimePicker startTime ;
TimePicker endTime ;
PushPreferences prefs = PushManager . shared ( ) . getPreferences ( ) ;
private void pushSettingsActive ( boolean b ) {
soundEnabled . setEnabled ( b ) ;
vibrateEnabled . setEnabled ( b ) ;
}
private void quietTimeSettingsActive ( boolean b ) {
startTime . setEnabled ( b ) ;
endTime . setEnabled ( b ) ;
}
@Override
public void onCreate ( Bundle icicle ) {
super . onCreate ( icicle ) ;
Window w = getWindow ( ) ;
w . requestFeature ( Window . <unk> ) ;
setContentView ( R . layout . push_preferences_dialog ) ;
pushEnabled = ( CheckBox ) findViewById ( R . id . push_enabled ) ;
soundEnabled = ( CheckBox ) findViewById ( R . id . sound_enabled ) ;
vibrateEnabled = ( CheckBox ) findViewById ( R . id . vibrate_enabled ) ;
quietTimeEnabled = ( CheckBox ) findViewById ( R . id . quiet_time_enabled ) ;
startTime = ( TimePicker ) findViewById ( R . id . start_time ) ;
endTime = ( TimePicker ) findViewById ( R . id . end_time ) ;
startTime . setIs24HourView ( DateFormat . is24HourFormat ( this ) ) ;
endTime . setIs24HourView ( DateFormat . is24HourFormat ( this ) ) ;
pushEnabled . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
pushSettingsActive ( ( ( CheckBox ) v ) . isChecked ( ) ) ;
}
} ) ;
quietTimeEnabled . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
quietTimeSettingsActive ( ( ( CheckBox ) v ) . isChecked ( ) ) ;
}
} ) ;
}
@Override
public void onStart ( ) {
super . onStart ( ) ;
boolean isPushEnabled = prefs . isPushEnabled ( ) ;
pushEnabled . setChecked ( isPushEnabled ) ;
soundEnabled . setChecked ( prefs . isSoundEnabled ( ) ) ;
vibrateEnabled . setChecked ( prefs . <unk> ( ) ) ;
pushSettingsActive ( isPushEnabled ) ;
boolean isQuietTimeEnabled = prefs . isQuietTimeEnabled ( ) ;
quietTimeEnabled . setChecked ( isQuietTimeEnabled ) ;
quietTimeSettingsActive ( isQuietTimeEnabled ) ;
Date [ ] interval = prefs . <unk> ( ) ;
if ( interval != null ) {
startTime . setCurrentHour ( interval [ <num> ] . getHours ( ) ) ;
startTime . setCurrentMinute ( interval [ <num> ] . getMinutes ( ) ) ;
endTime . setCurrentHour ( interval [ <num> ] . getHours ( ) ) ;
endTime . setCurrentMinute ( interval [ <num> ] . getMinutes ( ) ) ;
}
}
@Override
public void onStop ( ) {
super . onStop ( ) ;
boolean isPushEnabledInActivity = pushEnabled . isChecked ( ) ;
boolean isQuietTimeEnabledInActivity = quietTimeEnabled . isChecked ( ) ;
if ( isPushEnabledInActivity ) {
PushManager . enablePush ( ) ;
}
else {
PushManager . <unk> ( ) ;
}
prefs . <unk> ( soundEnabled . isChecked ( ) ) ;
prefs . <unk> ( vibrateEnabled . isChecked ( ) ) ;
prefs . <unk> ( isQuietTimeEnabledInActivity ) ;
if ( isQuietTimeEnabledInActivity ) {
Calendar cal = Calendar . getInstance ( ) ;
cal . set ( Calendar . HOUR_OF_DAY , startTime . getCurrentHour ( ) ) ;
cal . set ( Calendar . MINUTE , startTime . getCurrentMinute ( ) ) ;
Date startDate = cal . getTime ( ) ;
cal = Calendar . getInstance ( ) ;
cal . set ( Calendar . HOUR_OF_DAY , endTime . getCurrentHour ( ) ) ;
cal . set ( Calendar . MINUTE , endTime . getCurrentMinute ( ) ) ;
Date endDate = cal . getTime ( ) ;
prefs . <unk> ( startDate , endDate ) ;
}
}
@Override
public void onConfigurationChanged ( Configuration newConfig ) {
super . onConfigurationChanged ( newConfig ) ;
}
}
package com . lukasz . push ;
public final class R {
public static final class attr {
}
public static final class drawable {
public static final int ic_launcher = <num> ;
}
public static final class id {
public static final int end_time = <num> ;
public static final int icon = <num> ;
public static final int layout_root = <num> ;
public static final int message = <num> ;
public static final int push_enabled = <num> ;
public static final int push_preferences_button = <num> ;
public static final int quiet_time_enabled = <num> ;
public static final int sound_enabled = <num> ;
public static final int start_time = <num> ;
public static final int subject = <num> ;
public static final int vibrate_enabled = <num> ;
}
public static final class layout {
public static final int main = <num> ;
public static final int notification = <num> ;
public static final int push_preferences_dialog = <num> ;
}
public static final class string {
public static final int app_name = <num> ;
public static final int hello = <num> ;
}
}
package com . lukasz . push ;
public final class Manifest {
public static final class permission {
public static final String C2D_MESSAGE = " ;
}
}
package com . lukasz . push ;
import com . urbanairship . push . PushManager ;
import com . urbanairship . push . PushPreferences ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
public class Main extends Activity
{
PushPreferences prefs = PushManager . shared ( ) . getPreferences ( ) ;
@Override
public void onCreate ( Bundle savedInstanceState )
{
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
Button launchButton = ( Button ) findViewById ( R . id . push_preferences_button ) ;
launchButton . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
Intent intent = new Intent ( getBaseContext ( ) , PushPreferencesActivity . class ) ;
startActivity ( intent ) ;
}
} ) ;
}
package com . lukasz . push ;
import java . util . Arrays ;
import java . util . List ;
import java . util . Set ;
import android . content . BroadcastReceiver ;
import android . content . Context ;
import android . content . Intent ;
import android . util . Log ;
import com . urbanairship . UAirship ;
import com . urbanairship . push . PushManager ;
public class IntentReceiver extends BroadcastReceiver {
private static final String logTag = " ;
@Override
public void onReceive ( Context context , Intent intent ) {
Log . i ( logTag , " + intent . toString ( ) ) ;
String action = intent . getAction ( ) ;
if ( action . equals ( PushManager . <unk> ) ) {
int id = intent . getIntExtra ( PushManager . EXTRA_NOTIFICATION_ID , <num> ) ;
Log . i ( logTag , "
+ intent . getStringExtra ( PushManager . EXTRA_ALERT )
+ " + id + " ) ;
logPushExtras ( intent ) ;
} else if ( action . equals ( PushManager . <unk> ) ) {
Log . i ( logTag , " + intent . getStringExtra ( PushManager . EXTRA_ALERT ) ) ;
logPushExtras ( intent ) ;
Intent launch = new Intent ( Intent . ACTION_MAIN ) ;
launch . setClass ( UAirship . shared ( ) . getApplicationContext ( ) , Main . class ) ;
launch . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ;
UAirship . shared ( ) . getApplicationContext ( ) . startActivity ( launch ) ;
} else if ( action . equals ( PushManager . <unk> ) ) {
Log . i ( logTag , " + intent . getStringExtra ( PushManager . <unk> )
+ " + intent . getBooleanExtra ( PushManager . <unk> , false ) ) ;
}
}
private void logPushExtras ( Intent intent ) {
Set < String > keys = intent . getExtras ( ) . keySet ( ) ;
for ( String key : keys ) {
List < String > ignoredKeys = ( List < String > ) Arrays . asList (
" ,
" ,
PushManager . EXTRA_NOTIFICATION_ID ,
PushManager . <unk> ,
PushManager . EXTRA_ALERT ) ;
if ( ignoredKeys . contains ( key ) ) {
continue ;
}
Log . i ( logTag , " + key + " + intent . getStringExtra ( key ) + " ) ;
}
}
}
package com . lukasz . push ;
import android . app . Application ;
import android . util . Log ;
import com . urbanairship . AirshipConfigOptions ;
import com . urbanairship . Logger ;
import com . urbanairship . UAirship ;
import com . urbanairship . push . CustomPushNotificationBuilder ;
import com . urbanairship . push . PushManager ;
public class MyApplication extends Application {
@Override
public void onCreate ( ) {
super . onCreate ( ) ;
AirshipConfigOptions options = AirshipConfigOptions . <unk> ( this ) ;
UAirship . <unk> ( this , options ) ;
Logger . logLevel = Log . VERBOSE ;
CustomPushNotificationBuilder nb = new CustomPushNotificationBuilder ( ) ;
nb . <unk> = R . drawable . ic_launcher ;
nb . layout = R . layout . notification ;
nb . <unk> = R . drawable . ic_launcher ;
nb . <unk> = R . id . icon ;
nb . <unk> = R . id . subject ;
nb . <unk> = R . id . message ;
PushManager . shared ( ) . <unk> ( nb ) ;
PushManager . shared ( ) . <unk> ( IntentReceiver . class ) ;
PushManager . enablePush ( ) ;
}
}
package controllers ;
import play . * ;
import play . mvc . * ;
import views . html . * ;
public class Application extends Controller {
public static Result index ( ) {
return ok ( index . render ( " ) ) ;
}
package controllers ;
public class routes {
public static final controllers . ReverseApplication Application = new controllers . ReverseApplication ( ) ;
public static final controllers . ReverseAssets Assets = new controllers . ReverseAssets ( ) ;
public static class javascript {
public static final controllers . javascript . ReverseApplication Application = new controllers . javascript . ReverseApplication ( ) ;
public static final controllers . javascript . ReverseAssets Assets = new controllers . javascript . ReverseAssets ( ) ;
}
public static class ref {
public static final controllers . ref . ReverseApplication Application = new controllers . ref . ReverseApplication ( ) ;
public static final controllers . ref . ReverseAssets Assets = new controllers . ref . ReverseAssets ( ) ;
}
}
package com . crinqle . dlroom . cfa ;
import static com . crinqle . dlroom . Const . * ;
import com . crinqle . dlroom . * ;
public class BayerVNG implements Interpolation
{
private final static int N = <num> ;
private final static int S = <num> ;
private final static int E = <num> ;
private final static int W = <num> ;
private final static int NE = <num> ;
private final static int SW = <num> ;
private final static int NW = <num> ;
private final static int SE = <num> ;
private final static int GRAD_COUNT = <num> ;
private final static String [ ] GRAD_NAMES = { " , " , " , " , " , " , " , " } ;
private int [ ] f_grads = new int [ <num> ] ;
private RawRaster f_rr ;
private final int f_max ;
private AreaBandIterator [ ] f_abis ;
private int f_t ;
private int f_mask ;
private boolean f_debug = false ;
public BayerVNG ( RawRaster rr )
{
f_rr = rr ;
f_max = ( <num> << f_rr . getBits ( ) )  <num> ;
f_abis = f_rr . areaBandIterators ( <num> ) ;
}
public void setDebug ( boolean isOn ) { f_debug = isOn ; }
public void interpolate ( int mask )
{
f_mask = mask ;
if ( ( f_mask & ALL_MASK ) == ALL_MASK )
{
System . err . println ( " ) ;
setDebug ( false ) ;
}
System . out . println ( " + f_mask ) ;
if ( ( f_mask & R_MASK ) == R_MASK )
interpolateR ( ) ;
if ( ( f_mask & G_MASK ) == G_MASK )
interpolateG ( ) ;
if ( ( f_mask & H_MASK ) == H_MASK )
interpolateH ( ) ;
if ( ( f_mask & B_MASK ) == B_MASK )
interpolateB ( ) ;
}
private void interpolateR ( )
{
System . err . println ( " ) ;
int [ ] a ;
int gsum ;
int rsum ;
int bsum ;
int count ;
AreaBandIterator iter = f_abis [ R ] ;
while ( iter . next ( ) )
{
a = iter . getArea ( ) ;
final int x = iter . x ( ) ;
final int y = iter . y ( ) ;
computeCardinalGradients ( a ) ;
computeChromaGradients ( a ) ;
computeThreshold ( ) ;
count = <num> ;
rsum = <num> ;
gsum = <num> ;
bsum = <num> ;
if ( f_grads [ N ] < f_t )
{
rsum = ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum = a [ <num> ] ;
bsum = ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ S ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += a [ <num> ] ;
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ E ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += a [ <num> ] ;
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ W ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += a [ <num> ] ;
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ NE ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += a [ <num> ] ;
++ count ;
}
if ( f_grads [ SW ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += a [ <num> ] ;
++ count ;
}
if ( f_grads [ NW ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += a [ <num> ] ;
++ count ;
}
if ( f_grads [ SE ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += a [ <num> ] ;
++ count ;
}
gsum = ( int ) ( a [ <num> ] + ( ( gsum  rsum ) / ( float ) count ) ) ;
bsum = ( int ) ( a [ <num> ] + ( ( bsum  rsum ) / ( float ) count ) ) ;
if ( gsum < <num> ) gsum = <num> ;
else if ( gsum > f_max ) gsum = f_max ;
if ( bsum < <num> ) bsum = <num> ;
else if ( bsum > f_max ) bsum = f_max ;
f_rr . setSample ( x , y , G , gsum ) ;
f_rr . setSample ( x , y , B , bsum ) ;
}
}
private void interpolateG ( )
{
System . err . println ( " ) ;
int [ ] a ;
int gsum ;
int rsum ;
int bsum ;
int count ;
AreaBandIterator iter = f_abis [ G ] ;
while ( iter . next ( ) )
{
a = iter . getArea ( ) ;
final int x = iter . x ( ) ;
final int y = iter . y ( ) ;
computeCardinalGradients ( a ) ;
computeGreenGradients ( a ) ;
computeThreshold ( ) ;
count = <num> ;
rsum = <num> ;
gsum = <num> ;
bsum = <num> ;
if ( f_grads [ N ] < f_t )
{
rsum = ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum = ( a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum = a [ <num> ] ;
++ count ;
}
if ( f_grads [ S ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += a [ <num> ] ;
++ count ;
}
if ( f_grads [ E ] < f_t )
{
rsum += a [ <num> ] ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ W ] < f_t )
{
rsum += a [ <num> ] ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ NE ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ SW ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ NW ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ SE ] < f_t )
{
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
rsum = ( int ) ( a [ <num> ] + ( ( rsum  gsum ) / ( float ) count ) ) ;
bsum = ( int ) ( a [ <num> ] + ( ( bsum  gsum ) / ( float ) count ) ) ;
if ( rsum > f_max ) rsum = f_max ;
else if ( rsum < <num> ) rsum = <num> ;
if ( bsum > f_max ) bsum = f_max ;
else if ( bsum < <num> ) bsum = <num> ;
f_rr . setSample ( x , y , R , rsum ) ;
f_rr . setSample ( x , y , B , bsum ) ;
}
}
private void interpolateH ( )
{
System . err . println ( " ) ;
int [ ] a ;
int gsum ;
int rsum ;
int bsum ;
int count ;
AreaBandIterator iter = f_abis [ H ] ;
while ( iter . next ( ) )
{
a = iter . getArea ( ) ;
final int x = iter . x ( ) ;
final int y = iter . y ( ) ;
computeCardinalGradients ( a ) ;
computeGreenGradients ( a ) ;
computeThreshold ( ) ;
count = <num> ;
rsum = <num> ;
gsum = <num> ;
bsum = <num> ;
if ( f_grads [ N ] < f_t )
{
bsum = ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum = ( a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum = a [ <num> ] ;
++ count ;
}
if ( f_grads [ S ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += a [ <num> ] ;
++ count ;
}
if ( f_grads [ E ] < f_t )
{
bsum += a [ <num> ] ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ W ] < f_t )
{
bsum += a [ <num> ] ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ NE ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ SW ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ NW ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ SE ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
rsum = ( int ) ( a [ <num> ] + ( ( rsum  gsum ) / ( float ) count ) ) ;
bsum = ( int ) ( a [ <num> ] + ( ( bsum  gsum ) / ( float ) count ) ) ;
if ( rsum > f_max ) rsum = f_max ;
else if ( rsum < <num> ) rsum = <num> ;
if ( bsum > f_max ) bsum = f_max ;
else if ( bsum < <num> ) bsum = <num> ;
f_rr . setSample ( x , y , R , rsum ) ;
f_rr . setSample ( x , y , B , bsum ) ;
}
}
private void interpolateB ( )
{
System . err . println ( " ) ;
int [ ] a ;
int gsum ;
int rsum ;
int bsum ;
int count ;
AreaBandIterator iter = f_abis [ B ] ;
while ( iter . next ( ) )
{
a = iter . getArea ( ) ;
final int x = iter . x ( ) ;
final int y = iter . y ( ) ;
computeCardinalGradients ( a ) ;
computeChromaGradients ( a ) ;
computeThreshold ( ) ;
count = <num> ;
rsum = <num> ;
gsum = <num> ;
bsum = <num> ;
if ( f_grads [ N ] < f_t )
{
bsum = ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum = a [ <num> ] ;
rsum = ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ S ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += a [ <num> ] ;
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ E ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += a [ <num> ] ;
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ W ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += a [ <num> ] ;
rsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
++ count ;
}
if ( f_grads [ NE ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += a [ <num> ] ;
++ count ;
}
if ( f_grads [ SW ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += a [ <num> ] ;
++ count ;
}
if ( f_grads [ NW ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += a [ <num> ] ;
++ count ;
}
if ( f_grads [ SE ] < f_t )
{
bsum += ( a [ <num> ] + a [ <num> ] ) >> <num> ;
gsum += ( a [ <num> ] + a [ <num> ] + a [ <num> ] + a [ <num> ] ) >> <num> ;
rsum += a [ <num> ] ;
++ count ;
}
rsum = ( int ) ( a [ <num> ] + ( ( rsum  bsum ) / ( float ) count ) ) ;
gsum = ( int ) ( a [ <num> ] + ( ( gsum  bsum ) / ( float ) count ) ) ;
if ( rsum < <num> ) rsum = <num> ;
else if ( rsum > f_max ) rsum = f_max ;
if ( gsum < <num> ) gsum = <num> ;
else if ( gsum > f_max ) gsum = f_max ;
f_rr . setSample ( x , y , R , rsum ) ;
f_rr . setSample ( x , y , G , gsum ) ;
}
}
private void <unk> ( final int dx , final int dy )
{
final int xmax = dx + <num> ;
final int ymax = dy + <num> ;
for ( int b = <num> ; b < <num> ; ++ b )
{
for ( int x = ( dx  <num> ) ; x < xmax ; ++ x )
{
f_rr . setSample ( x , dy  <num> , b , <num> ) ;
f_rr . setSample ( x , dy + <num> , b , <num> ) ;
}
f_rr . setSample ( dx  <num> , dy , b , <num> ) ;
f_rr . setSample ( dx + <num> , dy , b , <num> ) ;
}
}
private void debug ( int x , int y , int r , int g , int b )
{
System . out . println ( " + x + " + y + " ) ;
debugGrads ( ) ;
System . out . println ( " + r + " + g + " + b + " ) ;
}
private void debugGrads ( )
{
System . out . println ( " + f_t ) ;
System . out . print ( " ) ;
for ( int i = <num> ; i < GRAD_COUNT ; ++ i )
System . out . print ( " + GRAD_NAMES [ i ] + " + f_grads [ i ] + " ) ;
System . out . println ( ) ;
System . out . print ( " ) ;
for ( int i = <num> ; i < GRAD_COUNT ; ++ i )
if ( f_grads [ i ] < f_t )
System . out . print ( " + GRAD_NAMES [ i ] ) ;
System . out . println ( ) ;
}
private void computeThreshold ( )
{
int max = <num> ;
int min = <num> ;
int v = <num> ;
int mask = <num> ;
for ( int i = <num> ; i < GRAD_COUNT ; ++ i )
{
v = f_grads [ i ] ;
if ( v > max )
max = v ;
if ( v < min )
min = v ;
}
f_t = min + ( min >> <num> ) + ( ( max  min ) >> <num> ) ;
if ( f_t == <num> )
++ f_t ;
}
private void computeCardinalGradients ( int [ ] a )
{
final int ns =
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
f_grads [ N ] =
ns +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
f_grads [ S ] =
ns +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
final int we =
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
f_grads [ W ] =
we +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
f_grads [ E ] =
we +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
}
private void computeChromaGradients ( int [ ] a )
{
final int news =
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
f_grads [ NE ] =
news +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
f_grads [ SW ] =
news +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
final int sewn =
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
f_grads [ SE ] =
sewn +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
f_grads [ NW ] =
sewn +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
( ( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) >> <num> ) ;
}
private void computeGreenGradients ( int [ ] a )
{
final int news =
Math . abs ( a [ <num> ]  a [ <num> ] ) ;
f_grads [ NE ] =
news +
( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) ;
f_grads [ SW ] =
news +
( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) ;
final int sewn =
Math . abs ( a [ <num> ]  a [ <num> ] ) ;
f_grads [ SE ] =
sewn +
( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) ;
f_grads [ NW ] =
sewn +
( Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) +
Math . abs ( a [ <num> ]  a [ <num> ] ) ) ;
}
public static void main ( String [ ] args )
{
RawRaster [ ] [ ] rra = com . crinqle . dlroom . test . InterpProf . createImages ( args ) ;
RawRaster rrR = rra [ <num> ] [ <num> ] ;
RawRaster rrG = rra [ <num> ] [ <num> ] ;
RawRaster rrH = rra [ <num> ] [ <num> ] ;
RawRaster rrB = rra [ <num> ] [ <num> ] ;
System . err . println ( " ) ;
ColorPanel cpR = new ColorPanel ( ) ;
cpR . setRawRaster ( rrR ) ;
ColorPanel cpG = new ColorPanel ( ) ;
cpG . setRawRaster ( rrG ) ;
ColorPanel cpH = new ColorPanel ( ) ;
cpH . setRawRaster ( rrH ) ;
ColorPanel cpB = new ColorPanel ( ) ;
cpB . setRawRaster ( rrB ) ;
javax . swing . JScrollPane scrollerR = new javax . swing . JScrollPane ( cpR ) ;
javax . swing . JScrollPane scrollerG = new javax . swing . JScrollPane ( cpG ) ;
javax . swing . JScrollPane scrollerH = new javax . swing . JScrollPane ( cpH ) ;
javax . swing . JScrollPane scrollerB = new javax . swing . JScrollPane ( cpB ) ;
javax . swing . JViewport vpR = scrollerR . getViewport ( ) ;
javax . swing . JViewport vpG = scrollerG . getViewport ( ) ;
javax . swing . JViewport vpH = scrollerH . getViewport ( ) ;
javax . swing . JViewport vpB = scrollerB . getViewport ( ) ;
BayerVNGFrame frame = new BayerVNGFrame ( ) ;
frame . registerViewport ( vpR ) ;
frame . registerViewport ( vpG ) ;
frame . registerViewport ( vpH ) ;
frame . registerViewport ( vpB ) ;
javax . swing . JPanel holder = new javax . swing . JPanel ( ) ;
holder . setLayout ( new java . awt . GridLayout ( <num> , <num> ) ) ;
holder . add ( scrollerR ) ;
holder . add ( scrollerG ) ;
holder . add ( scrollerH ) ;
holder . add ( scrollerB ) ;
frame . setContentPane ( holder ) ;
frame . pack ( ) ;
frame . setVisible ( true ) ;
}
}
class BayerVNGFrame extends javax . swing . JFrame implements javax . swing . event . ChangeListener
{
private java . util . List < javax . swing . JViewport > f_list = new java . util . LinkedList < javax . swing . JViewport > ( ) ;
BayerVNGFrame ( )
{
super ( " ) ;
setDefaultCloseOperation ( javax . swing . JFrame . EXIT_ON_CLOSE ) ;
}
void registerViewport ( javax . swing . JViewport viewport )
{
viewport . addChangeListener ( this ) ;
f_list . add ( viewport ) ;
}
public void stateChanged ( javax . swing . event . ChangeEvent evt )
{
Object obj = evt . getSource ( ) ;
javax . swing . JViewport viewport = null ;
if ( obj instanceof javax . swing . JViewport )
viewport = ( javax . swing . JViewport ) obj ;
else
return ;
java . awt . Point point = viewport . getViewPosition ( ) ;
for ( javax . swing . JViewport vp : f_list )
{
java . awt . Point p = vp . getViewPosition ( ) ;
if ( p . y != point . y || p . x != point . x )
vp . setViewPosition ( point ) ;
}
}
}
package com . crinqle . dlroom . cfa ;
import static com . crinqle . dlroom . Const . * ;
import com . crinqle . dlroom . * ;
public abstract class ColorFilterArray
{
protected final int f_fs ;
protected int f_bc ;
protected BandIterator [ ] f_bis = new BandIterator [ BAND_COUNT_MAX ] ;
protected AreaBandIterator [ ] f_abis = new AreaBandIterator [ BAND_COUNT_MAX ] ;
public static ColorFilterArray getInstance ( int filterSpec )
{
switch ( filterSpec )
{
case FILTER_BGGR :
case FILTER_GRBG :
case FILTER_GBRG :
case FILTER_RGGB :
return new BayerCFA ( filterSpec ) ;
case FILTER_GMCYMGCY :
case FILTER_CYGMCYMG :
case FILTER_CYMGYCGM :
case FILTER_YCMGCYGM :
default :
}
throw new RuntimeException ( " ) ;
}
protected ColorFilterArray ( int filterSpec ) { f_fs = filterSpec ; }
public int getBandCount ( ) { return f_bc ; }
public abstract ColorFilterArray arrayAtOffset ( int x , int y ) ;
public abstract Interpolation interpolation ( RawRaster rr ) ;
public abstract BandIterator [ ] bandIterators ( ImageData id ) ;
public abstract AreaBandIterator [ ] areaBandIterators ( ImageData id , int radius ) ;
}
package com . crinqle . dlroom ;
import java . awt . Color ;
public interface Const
{
public static final Color <unk> = new Color ( <num> , <num> , <num> ) ;
public static final Color <unk> = new Color ( <num> , <num> , <num> ) ;
int BAND_COUNT_MAX = <num> ;
int R = <num> ;
int G = <num> ;
int B = <num> ;
int H = <num> ;
String [ ] CHANNEL_NAME = { " , " , " , " } ;
String [ ] CHANNEL_NICKNAME = { " , " , " , " } ;
int FILTER_BGGR = <num> ;
int FILTER_GRBG = <num> ;
int FILTER_GBRG = <num> ;
int FILTER_RGGB = <num> ;
int FILTER_GMCYMGCY = <num> ;
int FILTER_CYGMCYMG = <num> ;
int FILTER_CYMGYCGM = <num> ;
int FILTER_YCMGCYGM = <num> ;
int R_MASK = <num> ;
int G_MASK = <num> << <num> ;
int H_MASK = G_MASK << <num> ;
int B_MASK = <num> << <num> ;
int ALL_MASK =  <num> ;
int SLIDER_SIZE = <num> ;
}
package com . crinqle . dlroom ;
import com . crinqle . dlroom . cfa . ColorFilterArray ;
import com . crinqle . dlroom . cfa . Interpolation ;
public class RawRaster extends ImageData implements Interpolation {
private CaptureData f_src ;
private boolean f_ii = false ;
public RawRaster ( int width , int height , int bandCount , int bits ) {
super ( width , height , bandCount , bits ) ;
f_src = null ;
}
public RawRaster ( CaptureData cd ) {
super ( cd . getWidth ( ) , cd . getHeight ( ) , cd . getCFA ( ) . getBandCount ( ) , cd
. getBits ( ) ) ;
f_src = cd ;
final int width = f_src . getWidth ( ) ;
final int height = f_src . getHeight ( ) ;
final int bits = f_src . getBits ( ) ;
ColorFilterArray cfa = f_src . getCFA ( ) ;
final int bandCount = cfa . getBandCount ( ) ;
super . zero ( ) ;
BandIterator [ ] iters = f_src . bandIterators ( ) ;
for ( int band = <num> ; band < bandCount ; ++ band ) {
BandIterator iter = iters [ band ] ;
System . err . println ( " + band + " ) ;
while ( iter . next ( ) )
setElem ( band , iter . index ( ) , iter . get ( ) ) ;
}
}
public void applyGamma ( double gamma ) {
gamma = <num> / gamma ;
final int imax = ( <num> << getBits ( ) )  <num> ;
final double dmax = ( double ) imax ;
int val ;
for ( int i = <num> ; i < f_total ; ++ i ) {
val = ( int ) ( Math . pow ( f_a [ i ] / dmax , gamma ) * dmax ) ;
if ( val < <num> )
val = <num> ;
if ( val > imax )
val = imax ;
f_a [ i ] = val ;
}
}
public void applyLUT ( LUT lut )
{
final int [ ] array = lut . array ( ) ;
for ( int i = <num> ; i < f_total ; ++ i )
f_a [ i ] = array [ f_a [ i ] ] ;
}
public void applyLUT ( LUT lut , RawRaster rr ) {
final int channel = lut . channel ( ) ;
final int [ ] array = lut . array ( ) ;
applyLUT ( channel , array , rr ) ;
}
private void applyLUT ( int channel , int [ ] array , RawRaster rr ) {
final int offset = channel * f_each ;
final int end = offset + f_each ;
for ( int i = offset ; i < end ; ++ i )
rr . f_a [ i ] = array [ f_a [ i ] ] ;
}
public RawRaster createCopy ( ) {
RawRaster rr = createBlankCopy ( ) ;
rr . f_src = f_src ;
rr . setData ( f_a ) ;
rr . setProfile ( getProfile ( ) ) ;
return rr ;
}
public RawRaster createBlankCopy ( ) {
RawRaster rr = new RawRaster ( getWidth ( ) , getHeight ( ) , getBandCount ( ) ,
getBits ( ) ) ;
rr . setProfile ( getProfile ( ) ) ;
return rr ;
}
public ImageInfo getImageInfo ( ) {
if ( f_src != null )
return f_src . getImageInfo ( ) ;
return null ;
}
public void setImageInfo ( ImageInfo info ) {
if ( f_src != null )
f_src . setImageInfo ( info ) ;
}
public RawRaster subraster ( int x , int y , int width , int height ) {
return new RawRaster ( f_src . subraster ( x , y , width , height ) ) ;
}
public RawRaster subraster ( int x , int y ) {
return new RawRaster ( f_src . subraster ( x , y ) ) ;
}
public void interpolate ( int mask ) {
if ( f_src != null ) {
Interpolation i = f_src . getCFA ( ) . interpolation ( this ) ;
i . interpolate ( mask ) ;
f_ii = true ;
}
}
public BandIterator [ ] bandIterators ( ) {
if ( f_src != null )
return f_src . bandIterators ( ) ;
return null ;
}
public AreaBandIterator [ ] areaBandIterators ( int radius ) {
if ( f_src != null )
return f_src . areaBandIterators ( radius ) ;
return null ;
}
public static void main ( String [ ] args ) {
if ( args . length < <num> ) {
System . err . println ( " ) ;
System . exit ( <num> ) ;
}
try {
com . crinqle . dlroom . codec . RawCodec codec = com . crinqle . dlroom . codec . RawCodec
. getInstance ( new java . io . File ( args [ <num> ] ) ) ;
CaptureData cd = codec . decode ( ) ;
RawRaster rr = new RawRaster ( cd ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
}
}
package com . crinqle . dlroom . codec ;
import java . util . * ;
public class HuffmanTree
{
private HuffmanNode root = new HuffmanNode ( ) ;
private HuffmanNode current = root ;
private int f_depth = <num> ;
public HuffmanTree ( short [ ] array , final int distributionCount )
{
int leafIndex = distributionCount ;
for ( int depth = <num> ; depth < distributionCount ; ++ depth )
{
final int count = array [ depth ] ;
for ( int j = <num> ; j < count ; ++ j )
{
final int leaf = array [ leafIndex ++ ] ;
final int target_depth = depth + <num> ;
HuffmanNode n = root . dfs ( leaf , target_depth , <num> ) ;
HuffmanNode tn = n ;
String path = " ;
while ( true )
{
HuffmanNode p = tn . f_parent ;
if ( p == null )
break ;
if ( tn == p . f_left )
path = " + path ;
else
path = " + path ;
tn = p ;
}
System . err . println ( " + target_depth + " + Integer . toHexString ( leaf ) + " + path ) ;
}
System . err . println ( ) ;
}
}
public int find ( int dir )
{
HuffmanNode n = current . left ( ) ;
if ( dir == <num> )
n = current . right ( ) ;
final int l = n . leaf ( ) ;
++ f_depth ;
if ( l >= <num> )
{
f_pathReset ( ) ;
}
else
{
current = n ;
}
return l ;
}
public String findLeaf ( int leaf )
{
return root . findLeaf ( leaf ,  <num> ) ;
}
private void f_pathReset ( )
{
current = root ;
f_depth = <num> ;
}
public static void main ( String [ ] args )
{
final int argc = args . length ;
if ( argc < <num> )
{
System . err . println ( " ) ;
System . exit ( <num> ) ;
}
final int tree_index = Integer . parseInt ( args [ <num> ] ) ;
final String path_string = args [ <num> ] ;
final int path_length = path_string . length ( ) ;
final int [ ] path = new int [ path_length ] ;
for ( int i = <num> ; i < path_length ; ++ i )
path [ i ] = ( path_string . charAt ( i ) == <num>  ) ? <num> : <num> ;
short src [ ] = null ;
switch ( tree_index )
{
case <num> :
src = StaticTree . FIRST_TREE [ <num> ] ;
break ;
case <num> :
src = StaticTree . FIRST_TREE [ <num> ] ;
break ;
case <num> :
src = StaticTree . FIRST_TREE [ <num> ] ;
break ;
case <num> :
src = StaticTree . SECOND_TREE [ <num> ] ;
break ;
case <num> :
src = StaticTree . SECOND_TREE [ <num> ] ;
break ;
case <num> :
src = StaticTree . SECOND_TREE [ <num> ] ;
break ;
default :
src = StaticTree . FIRST_TREE [ <num> ] ;
}
HuffmanTree tree = new HuffmanTree ( src , <num> ) ;
int leaf =  <num> ;
String <unk> = null ;
try
{
for ( int i = <num> ; i < path_length ; ++ i )
{
leaf = tree . find ( path [ i ] ) ;
if ( leaf >= <num> )
break ;
}
System . err . println ( leaf + " + Integer . toHexString ( leaf ) + " ) ;
}
catch ( Exception e )
{
System . err . println ( " + path_string ) ;
System . exit ( <num> ) ;
}
}
}
class HuffmanNode
{
HuffmanNode f_left = null ;
HuffmanNode f_right = null ;
int f_leaf =  <num> ;
final HuffmanNode f_parent ;
HuffmanNode ( ) { f_parent = null ; }
HuffmanNode ( HuffmanNode parent ) { f_parent = parent ; }
HuffmanNode dfs ( final int value , final int depth , final int d )
{
if ( d == depth )
{
if ( f_left == null && f_right == null && f_leaf < <num> )
{
f_leaf = value ;
return this ;
}
else
return null ;
}
else if ( f_leaf >= <num> )
return null ;
if ( f_left == null )
f_left = new HuffmanNode ( this ) ;
HuffmanNode ln = f_left . dfs ( value , depth , d + <num> ) ;
if ( ln != null )
return ln ;
if ( f_right == null )
f_right = new HuffmanNode ( this ) ;
HuffmanNode rn = f_right . dfs ( value , depth , d + <num> ) ;
return rn ;
}
int leaf ( )
{
return f_leaf ;
}
String findLeaf ( final int leaf , final int fd )
{
if ( f_leaf == leaf )
return f_findLeafString ( fd ) ;
if ( f_left != null )
{
String ls = f_left . findLeaf ( leaf , <num> ) ;
if ( ls . equals ( " ) != true )
return f_findLeafString ( fd ) + ls ;
}
if ( f_right != null )
{
String rs = f_right . findLeaf ( leaf , <num> ) ;
if ( rs . equals ( " ) != true )
return f_findLeafString ( fd ) + rs ;
}
return " ;
}
private String f_findLeafString ( final int fd ) { switch ( fd ) { case  <num> : return " ; case <num> : return " ; case <num> : return " ; } return " ; }
HuffmanNode left ( )
{
return f_left ;
}
HuffmanNode right ( )
{
return f_right ;
}
public String toString ( )
{
String ls = ( ( f_left == null ) ? " : Integer . toString ( f_left . f_leaf ) ) ;
String rs = ( ( f_right == null ) ? " : Integer . toString ( f_right . f_leaf ) ) ;
return f_leaf + " + ls + " + rs + " ;
}
}
package com . crinqle . dlroom . util ;
import java . io . * ;
import java . util . * ;
public class Prefs
{
private Hashtable < String , Hashtable < String , String >> f_hash = new Hashtable < String , Hashtable < String , String >> ( ) ;
private Hashtable < String , String > f_def = new Hashtable < String , String > ( ) ;
public static Prefs loadFromFile ( File file ) throws IOException
{
try
{
BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ;
Prefs prefs = new Prefs ( ) ;
String section = null ;
String line = null ;
while ( ( line = reader . readLine ( ) ) != null )
{
line = line . trim ( ) ;
if ( line . length ( ) == <num> )
continue ;
else if ( line . charAt ( <num> ) == #' )
continue ;
else if ( line . charAt ( <num> ) == [' )
{
final int ei = line . length ( )  <num> ;
section = line . substring ( <num> , ei ) ;
}
else
{
final int index = line . indexOf ( =' ) ;
if ( index < <num> )
continue ;
String property = line . substring ( <num> , index ) ;
String value = line . substring ( index + <num> ) ;
if ( property != null )
property = property . trim ( ) ;
if ( value != null )
value = value . trim ( ) ;
System . out . println ( " + section + " + property + " + value ) ;
if ( section == null )
prefs . put ( property , value ) ;
else
prefs . put ( section , property , value ) ;
}
}
return prefs ;
}
catch ( Exception e ) { }
return null ;
}
public String get ( String prop )
{
return ( String ) f_def . get ( prop ) ;
}
public void put ( String prop , String value )
{
f_def . put ( prop , value ) ;
}
public String get ( String section , String prop )
{
Hashtable < String , String > h = f_hash . get ( section ) ;
if ( h == null )
return null ;
return h . get ( prop ) ;
}
public void put ( String section , String prop , String value )
{
Hashtable < String , String > h = f_hash . get ( section ) ;
if ( h == null )
f_hash . put ( section , ( h = new Hashtable < String , String > ( ) ) ) ;
h . put ( prop , value ) ;
}
public static void main ( String [ ] args ) throws IOException
{
final int argc = args . length ;
try
{
for ( int i = <num> ; i < argc ; ++ i )
Prefs . loadFromFile ( new File ( args [ <num> ] ) ) ;
}
catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( <num> ) ; }
}
}
package com . crinqle . dlroom . event ;
public interface BitDepthChangeListener
{
void updateBits ( Object source , int bits ) ;
}
package com . crinqle . dlroom ;
public interface AreaBandIterator extends BandIterator
{
int [ ] getArea ( ) ;
void set ( int band , int val ) ;
}
package com . crinqle . dlroom ;
import java . awt . Event ;
public class MouseEvent {
private Event e ;
public synchronized void put ( Event e ) {
while ( this . e != null
&& ! ( this . e . id == Event . MOUSE_DRAG && e . id == Event . MOUSE_DRAG ) ) {
try {
wait ( ) ;
} catch ( InterruptedException ex ) {
System . err . println ( " + ex ) ;
}
}
this . e = e ;
notify ( ) ;
}
public synchronized Event get ( ) {
while ( e == null ) {
try {
wait ( ) ;
} catch ( InterruptedException ex ) {
System . err . println ( " + ex ) ;
}
}
notify ( ) ;
Event save = e ;
e = null ;
return save ;
}
}
package com . crinqle . dlroom . codec ;
public class StaticTree
{
public static final short FIRST_TREE [ ] [ ] = {
{ <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> } ,
{ <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> } ,
{ <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> }
} ;
public static final short SECOND_TREE [ ] [ ] = {
{ <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> } ,
{ <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> } ,
{ <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> }
} ;
}
package com . crinqle . dlroom . codec ;
import java . io . * ;
import com . crinqle . dlroom . util . * ;
public abstract class SeekableInputStream implements Seekable
{
protected final short [ ] f_a ;
protected final int f_len ;
protected int f_i = <num> ;
protected int f_have = <num> ;
protected SeekableInputStream ( final byte [ ] array )
{
f_len = array . length ;
f_a = new short [ f_len ] ;
for ( int i = <num> ; i < f_len ; ++ i )
f_a [ i ] = ( short ) ( ( array [ i ] < <num> ) ? <num> + array [ i ] : array [ i ] ) ;
}
public static SeekableInputStream getInstance ( final int order , final byte [ ] array )
{
SeekableInputStream s = null ;
if ( order == <num> )
s = new LSBSeekableInputStream ( array ) ;
else
s = new MSBSeekableInputStream ( array ) ;
return s ;
}
public long getPosition ( ) throws IOException
{
return f_i ;
}
public abstract int read4 ( ) throws IOException ;
public abstract int read2 ( ) throws IOException ;
public int bits ( int need ) throws Exception
{
final int <unk> = need ;
int <unk> = <num> ;
if ( need > <num> )
throw new Exception ( " ) ;
if ( need == <num> )
return <num> ;
if ( f_i >= this . f_len )
{
int ret = <num> ;
for ( int i = <num> ; i < need ; ++ i )
ret = ( ret << <num> ) | <num> ;
return ret ;
}
int value = f_cache ( ) ;
if ( need <= f_have )
{
if ( need == f_have )
{
f_resetCache ( need ) ;
}
else
{
value >>= ( f_have  need ) ;
f_have -= need ;
}
}
else
{
need -= f_have ;
f_resetCache ( need ) ;
while ( need > <num> )
{
if ( need < <num> )
{
value <<= need ;
value |= ( f_cache ( ) >> ( <num>  need ) ) ;
f_have -= need ;
}
else
{
value = ( value << <num> ) | f_cache ( ) ;
f_resetCache ( need ) ;
}
need -= <num> ;
}
}
return value ;
}
private boolean f_resetCache ( final int need )
{
if ( f_a [ f_i ] == <num> )
++ f_i ;
++ f_i ;
f_have = <num> ;
return false ;
}
private int f_cache ( )
{
final int v = f_a [ f_i ] ;
if ( f_have == <num> )
return v ;
final int shift = <num>  f_have ;
return ( ( ( v << shift ) & <num> ) >> shift ) ;
}
public long seek ( long n )
{
f_i = <num> ;
return skip ( n ) ;
}
public int skipBytes ( int n )
{
return ( int ) skip ( n ) ;
}
public int available ( ) { return f_len ; }
public void close ( ) { }
public void mark ( int readlimit ) { }
public boolean markSupported ( ) { return false ; }
public void reset ( ) { }
public long skip ( long n )
{
if ( ( f_i + n ) > f_len )
n = f_len  f_i ;
f_i += n ;
return n ;
}
public int read ( ) { return f_a [ f_i ++ ] ; }
public int read ( byte [ ] b )
{
return read ( b , <num> , b . length ) ;
}
public int read ( byte [ ] b , int offset , int length )
{
if ( length <= <num> ) return <num> ;
if ( length > b . length )
length = b . length ;
if ( ( f_i + length ) > f_len )
length = f_len  f_i ;
for ( int i = <num> ; i < length ; ++ i )
b [ i ] = ( byte ) f_a [ f_i + i ] ;
f_i += length ;
return length ;
}
public int readFully ( byte [ ] b , int offset , int length )
{
return read ( b , offset , length ) ;
}
public static void main ( String [ ] args )
{
long n = <num> ;
n |= <num> ;
n <<= <num> ;
n |= <num> ;
n <<= <num> ;
n |= <num> ;
n <<= <num> ;
n |= <num> ;
n <<= <num> ;
n |= <num> ;
n <<= <num> ;
n |= <num> ;
final int bitlength = <num> + <num> + <num> + <num> + <num> + <num> ;
final int shift = <num>  bitlength ;
n <<= shift ;
System . out . println ( " + n + " + Long . toBinaryString ( n ) + " ) ;
System . out . println ( " + n + " + Binary . toBinary ( n ) + " ) ;
int v = <num> ;
char c1 = ( char ) ( ( n >> <num> ) & <num> ) ;
char c2 = ( char ) ( ( n >> <num> ) & <num> ) ;
char c3 = ( char ) ( ( n >> <num> ) & <num> ) ;
char c4 = ( char ) ( ( n >> <num> ) & <num> ) ;
char c5 = ( char ) ( ( n >> <num> ) & <num> ) ;
char c6 = ( char ) ( ( n >> <num> ) & <num> ) ;
char c7 = ( char ) ( ( n >> <num> ) & <num> ) ;
char c8 = ( char ) ( ( n >> <num> ) & <num> ) ;
byte [ ] array = new byte [ ] { ( byte ) c1 , ( byte ) c2 , ( byte ) c3 , ( byte ) c4 , ( byte ) c5 , ( byte ) c6 , ( byte ) c7 , ( byte ) c8 } ;
for ( int i = <num> ; i < <num> ; ++ i )
System . out . println ( " + i + " + Binary . toBinary ( array [ i ] ) ) ;
System . out . println ( ) ;
MSBSeekableInputStream s = new MSBSeekableInputStream ( array ) ;
try
{
System . out . println ( " + s . bits ( <num> ) ) ;
int b = s . bits ( <num> ) ;
System . out . println ( " + b ) ;
System . out . println ( " + b + " + s . bits ( b ) ) ;
System . out . println ( " + s . bits ( <num> ) ) ;
b = s . bits ( <num> ) ;
System . out . println ( " + b ) ;
System . out . println ( " + b + " + s . bits ( b ) ) ;
System . out . println ( " + s . bits ( <num> ) ) ;
b = s . bits ( <num> ) ;
System . out . println ( " + b ) ;
System . out . println ( " + b + " + s . bits ( b ) ) ;
}
catch ( Exception e ) { System . err . println ( " + e . getMessage ( ) ) ; System . exit ( <num> ) ; }
}
}
class LSBSeekableInputStream extends SeekableInputStream
{
LSBSeekableInputStream ( byte [ ] array )
{
super ( array ) ;
}
public int read2 ( ) throws IOException
{
return ( read ( ) | ( read ( ) << <num> ) ) ;
}
public int read4 ( ) throws IOException
{
return ( read ( ) | ( read ( ) << <num> ) | ( read ( ) << <num> ) | ( read ( ) << <num> ) ) ;
}
}
class MSBSeekableInputStream extends SeekableInputStream
{
MSBSeekableInputStream ( byte [ ] array )
{
super ( array ) ;
}
public int read2 ( ) throws IOException
{
return ( ( read ( ) << <num> ) | ( read ( ) ) ) ;
}
public int read4 ( ) throws IOException
{
return ( ( read ( ) << <num> ) | ( read ( ) << <num> ) | ( read ( ) << <num> ) | ( read ( ) ) ) ;
}
}
package com . crinqle . dlroom ;
public class LUT
{
private final int f_chan ;
private final int f_max ;
private final int f_l ;
private float [ ] f_a ;
private int [ ] f_ia ;
public LUT ( int channel , float [ ] array , int targetMax )
{
f_chan = channel ;
f_max = targetMax ;
f_l = array . length ;
f_a = array ;
f_ia = new int [ f_l ] ;
int val ;
for ( int i = <num> ; i < f_l ; ++ i )
{
val = Math . round ( f_a [ i ] ) ;
if ( val > f_max )
f_ia [ i ] = f_max ;
else if ( val < <num> )
f_ia [ i ] = <num> ;
else
f_ia [ i ] = val ;
}
}
public LUT ( int channel , float [ ] array , float max , int targetMax )
{
f_chan = channel ;
f_max = targetMax ;
f_l = array . length ;
f_a = array ;
f_ia = new int [ f_l ] ;
int val ;
for ( int i = <num> ; i < f_l ; ++ i )
{
val = Math . round ( ( f_max * f_a [ i ] ) / max ) ;
if ( val > f_max )
f_ia [ i ] = f_max ;
else if ( val < <num> )
f_ia [ i ] = <num> ;
else
f_ia [ i ] = val ;
}
}
public int channel ( ) { return f_chan ; }
public int [ ] array ( ) { return f_ia ; }
public String toString ( )
{
StringBuffer buffer = new StringBuffer ( ) ;
buffer . append ( " ) ;
for ( int i = <num> ; i < f_ia . length ; ++ i )
buffer . append ( " + f_ia [ i ] ) ;
return buffer . toString ( ) ;
}
}
package com . crinqle . dlroom . cfa ;
import com . crinqle . dlroom . * ;
class BayerBandIterator implements BandIterator
{
private final int f_x1 ;
private final int f_y1 ;
private final int f_x2 ;
private final int f_y2 ;
private final int f_xs ;
private final int f_ys ;
protected ImageData f_id ;
protected final int f_r ;
protected final int f_w ;
protected final int f_h ;
protected final int f_total ;
protected final int f_wr ;
protected final int f_hr ;
protected int f_x = <num> ;
protected int f_y = <num> ;
protected int <unk> =  <num> ;
private int f_rmod = <num> ;
private int [ ] f_dx = new int [ <num> ] ;
BayerBandIterator ( ImageData id , int x1 , int y1 , int x2 , int y2 , int xstride , int ystride )
{
f_id = id ;
f_r = <num> ;
f_wr = f_w = f_id . getWidth ( ) ;
f_hr = f_h = f_id . getHeight ( ) ;
f_total = f_w * f_h ;
f_x1 = x1 ;
f_y1 = y1 ;
f_x2 = x2 ;
f_y2 = y2 ;
f_xs = xstride ;
f_ys = ystride ;
f_dx [ <num> ] = x1 ;
f_dx [ <num> ] = x2 ;
f_x = x1  f_xs ;
f_y = y1 ;
}
protected BayerBandIterator ( ImageData id , int x , int y , int radius )
{
if ( radius <= <num> )
throw new RuntimeException ( " ) ;
f_id = id ;
f_r = radius ;
f_w = f_id . getWidth ( ) ;
f_h = f_id . getHeight ( ) ;
f_total = f_w * f_h ;
f_wr = f_w  f_r ;
f_hr = f_h  f_r ;
f_xs = <num> ;
f_ys = <num> ;
while ( x < f_r )
x += f_xs ;
while ( y < f_r )
y += f_ys ;
f_x1 = x ;
f_y1 = y ;
f_x2 =  <num> ;
f_y2 =  <num> ;
f_dx [ <num> ] = f_x1 ;
f_dx [ <num> ] = f_x1 ;
f_x = f_x1  f_xs ;
f_y = f_y1 ;
}
public boolean next ( )
{
f_x += f_xs ;
if ( f_x >= f_wr )
{
f_y += f_ys ;
f_x = f_dx [ f_rmod ^= <num> ] ;
}
if ( f_y >= f_hr )
return false ;
return true ;
}
public boolean prev ( )
{
f_x -= f_xs ;
if ( f_x < f_r )
{
f_y -= f_ys ;
f_x = f_dx [ f_rmod ^= <num> ] ;
}
if ( f_y < f_r )
return false ;
return true ;
}
public int get ( ) { return f_id . getElem ( index ( ) ) ; }
public int index ( ) { return f_x + f_y * f_w ; }
public int x ( ) { return f_x ; }
public int y ( ) { return f_y ; }
public void set ( int val ) { f_id . setElem ( index ( ) , val ) ; }
}
package com . crinqle . dlroom . test ;
import static com . crinqle . dlroom . Const . * ;
import com . crinqle . dlroom . * ;
public class <unk> {
public static final int DIM = <num> * <num> ;
public static final int W = <num> * DIM ;
public static final int H = <num> * DIM ;
public static CaptureData <unk> ( ) {
CaptureData cd = new CaptureData ( DIM , DIM , FILTER_RGGB , <num> ) ;
for ( int y = <num> ; y < DIM ; ++ y )
for ( int x = <num> ; x < DIM ; ++ x )
cd . setSample ( x , y , <num> ) ;
return cd ;
}
public static CaptureData <unk> ( ) {
CaptureData cd = new CaptureData ( W , H , FILTER_RGGB , <num> ) ;
for ( int y = <num> ; y < H ; ++ y )
for ( int x = <num> ; x < W ; ++ x )
cd . setSample ( x , y , <num> ) ;
return cd ;
}
public static CaptureData <unk> ( ) {
CaptureData cd = new CaptureData ( W , H , FILTER_RGGB , <num> ) ;
setBlockBand ( cd , <num> , <num> , B , <num> ) ;
setBlockBand ( cd , DIM , <num> , G , <num> ) ;
setBlockBand ( cd , DIM , <num> , H , <num> ) ;
setBlockBand ( cd , DIM << <num> , <num> , R , <num> ) ;
setBlockBand ( cd , <num> , DIM , R , <num> ) ;
setBlockBand ( cd , <num> , DIM , G , <num> ) ;
setBlockBand ( cd , <num> , DIM , H , <num> ) ;
setBlockBand ( cd , DIM , DIM , R , <num> ) ;
setBlockBand ( cd , DIM , DIM , B , <num> ) ;
setBlockBand ( cd , DIM << <num> , DIM , G , <num> ) ;
setBlockBand ( cd , DIM << <num> , DIM , H , <num> ) ;
setBlockBand ( cd , DIM << <num> , DIM , B , <num> ) ;
makeGrayBlock ( cd , <num> , DIM << <num> , <num> ) ;
makeGrayBlock ( cd , DIM , DIM << <num> , <num>  <num> ) ;
makeGrayBlock ( cd , DIM << <num> , DIM << <num> , <num>  <num> ) ;
return cd ;
}
private static void setBlockBand ( CaptureData cd , int dx , int dy , int band ,
int value ) {
int cfa_dx = <num> ;
int cfa_dy = <num> ;
switch ( band ) {
case R :
break ;
case G :
cfa_dx = <num> ;
cfa_dy = <num> ;
break ;
case H :
cfa_dx = <num> ;
cfa_dy = <num> ;
break ;
case B :
cfa_dx = <num> ;
cfa_dy = <num> ;
break ;
default :
throw new RuntimeException ( " ) ;
}
final int xmax = dx + DIM ;
final int ymax = dy + DIM ;
for ( int y = dy + cfa_dy ; y < ymax ; y += <num> )
for ( int x = dx + cfa_dx ; x < xmax ; x += <num> )
cd . setSample ( x , y , value ) ;
}
public static CaptureData <unk> ( ) {
CaptureData cd = new CaptureData ( W , H , FILTER_RGGB , <num> ) ;
makeGrayBlock ( cd , <num> , <num> , <num> ) ;
makeGrayBlock ( cd , DIM , <num> , <num> ) ;
makeGrayBlock ( cd , <num> * DIM , <num> , <num> ) ;
makeGrayBlock ( cd , <num> , DIM , <num> ) ;
makeGrayBlock ( cd , <num> * DIM , DIM , <num> ) ;
makeGrayBlock ( cd , <num> , <num> * DIM , <num> ) ;
makeGrayBlock ( cd , DIM , <num> * DIM , <num> ) ;
makeGrayBlock ( cd , <num> * DIM , <num> * DIM , <num> ) ;
final int xmax = DIM << <num> ;
final int ymax = DIM << <num> ;
for ( int y = DIM ; y < ymax ; ++ y )
for ( int x = DIM ; x < xmax ; ++ x )
cd . setSample ( x , y , ( y > x ? <num> : ( ( y == x ) ? <num> : <num> ) ) ) ;
return cd ;
}
private static void makeGrayBlock ( CaptureData cd , int dx , int dy , int value ) {
if ( value > <num> || value < <num> )
throw new RuntimeException ( " + value ) ;
final int xmax = dx + DIM ;
final int ymax = dy + DIM ;
for ( int y = dy ; y < ymax ; ++ y )
for ( int x = dx ; x < xmax ; ++ x )
cd . setSample ( x , y , value ) ;
}
}
package com . crinqle . dlroom ;
import java . awt . color . ICC_Profile ;
import java . awt . image . DataBuffer ;
import java . awt . image . WritableRaster ;
import java . io . ByteArrayInputStream ;
import java . io . ByteArrayOutputStream ;
import java . io . DataInputStream ;
import java . io . File ;
import java . io . FileInputStream ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . OutputStream ;
import java . io . PushbackInputStream ;
import java . util . Arrays ;
import java . util . Calendar ;
import com . crinqle . dlroom . util . * ;
import static com . crinqle . dlroom . Const . * ;
public class ColorPPMFile {
public static final String MAGIC = " ;
public static final String ICC_HEADER = " ;
public static final String <unk> = " ;
public static final String <unk> = " ;
private int f_height ;
private int f_width ;
private ICC_Profile f_profile ;
private Calendar f_timeCreated ;
private Calendar f_timeConverted ;
private String f_make ;
private String f_model ;
public ColorPPMFile ( ) {
}
public int getHeight ( ) {
return f_height ;
}
public void setHeight ( int height ) {
f_height = height ;
}
public int getWidth ( ) {
return f_width ;
}
public void setWidth ( int width ) {
f_width = width ;
}
public String <unk> ( ) {
return f_make ;
}
public void <unk> ( String make ) {
f_make = make ;
}
public String getModel ( ) {
return f_model ;
}
public void setModel ( String model ) {
f_model = model ;
}
public Calendar <unk> ( ) {
return f_timeCreated ;
}
public void <unk> ( Calendar time ) {
f_timeCreated = time ;
}
public Calendar <unk> ( ) {
return f_timeConverted ;
}
public void <unk> ( Calendar time ) {
f_timeConverted = time ;
}
static public RawRaster decode ( byte [ ] array ) throws IOException , Exception {
ByteArrayInputStream stream = new ByteArrayInputStream ( array ) ;
return decode ( stream ) ;
}
static public RawRaster decode ( InputStream stream ) throws IOException ,
Exception {
return f_decode ( new PushbackInputStream ( stream ) ) ;
}
static public void encode ( RawRaster raster , OutputStream stream )
throws IOException {
final byte [ ] array = encode ( raster ) ;
final int length = array . length ;
stream . write ( array , <num> , length ) ;
}
static public void encode_OLD ( WritableRaster raster ,
ICC_Profile workingSpaceProfile , OutputStream stream )
throws IOException {
final byte [ ] array = encode_OLD ( raster , workingSpaceProfile ) ;
final int length = array . length ;
stream . write ( array , <num> , length ) ;
}
static public byte [ ] encode_OLD ( final WritableRaster raster ,
ICC_Profile workingSpaceProfile ) throws IOException {
System . err . println ( " + raster ) ;
final int height = raster . getHeight ( ) ;
final int width = raster . getWidth ( ) ;
final byte [ ] profileArray = workingSpaceProfile . getData ( ) ;
ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ;
String magicString = MAGIC + " ;
String profileString = " + ICC_HEADER ;
stream . write ( magicString . getBytes ( ) ) ;
stream . write ( profileString . getBytes ( ) ) ;
final byte [ ] encodedProfileArray = Base64Like . encode ( profileArray ) ;
final int epaLength = encodedProfileArray . length ;
stream . write ( encodedProfileArray ) ;
int rgb_max = <num> ;
DataBuffer buffer = raster . getDataBuffer ( ) ;
int sample ;
int r , g , b ;
for ( int bank = <num> ; bank < buffer . getNumBanks ( ) ; ++ bank ) {
for ( int k = <num> ; k < buffer . getSize ( ) ; ++ k ) {
sample = buffer . getElem ( bank , k ) ;
r = ( sample & <num> ) >> <num> ;
g = ( sample & <num> ) >> <num> ;
b = ( sample & <num> ) ;
if ( sample > rgb_max )
rgb_max = sample ;
}
}
System . err . println ( " + rgb_max ) ;
String header = " + width + " + height + " + rgb_max + " ;
stream . write ( header . getBytes ( ) ) ;
byte [ ] array = new byte [ width * <num> * <num> ] ;
final int length = array . length ;
for ( int y = <num> ; y < height ; ++ y ) {
Arrays . fill ( array , ( byte ) <num> ) ;
for ( int x = <num> ; x < width ; ++ x )
;
stream . write ( array , <num> , length ) ;
}
array = stream . toByteArray ( ) ;
stream . close ( ) ;
return array ;
}
static public byte [ ] encode ( final RawRaster raster ) throws IOException {
final ImageInfo info = raster . getImageInfo ( ) ;
final int height = info . height ;
final int width = info . width ;
final ICC_Profile workingSpaceProfile = raster . getProfile ( ) ;
final byte [ ] profileArray = workingSpaceProfile . getData ( ) ;
ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ;
String magicString = MAGIC + " ;
String profileString = " + ICC_HEADER ;
stream . write ( magicString . getBytes ( ) ) ;
stream . write ( profileString . getBytes ( ) ) ;
final byte [ ] encodedProfileArray = Base64Like . encode ( profileArray ) ;
final int epaLength = encodedProfileArray . length ;
stream . write ( encodedProfileArray ) ;
String header = " + width + " + height + " + info . rgb_max
+ " ;
stream . write ( header . getBytes ( ) ) ;
char [ ] values = null ;
byte [ ] array = null ;
boolean is2 = true ;
if ( info . rgb_max > <num> )
array = new byte [ width * <num> * <num> ] ;
else {
array = new byte [ width * <num> ] ;
is2 = false ;
}
final int length = array . length ;
for ( int y = <num> ; y < height ; ++ y ) {
Arrays . fill ( array , ( byte ) <num> ) ;
for ( int x = <num> ; x < width ; ++ x ) {
if ( is2 )
store16 ( array , x , y , raster ) ;
else
store8 ( array , x , y , raster ) ;
}
stream . write ( array , <num> , length ) ;
}
array = stream . toByteArray ( ) ;
stream . close ( ) ;
return array ;
}
static private RawRaster f_decode ( PushbackInputStream stream )
throws IOException , Exception {
ICC_Profile profile = null ;
ICC_Profile profileTemp = null ;
boolean commentFollows = false ;
int c ;
byte [ ] magicArray = new byte [ <num> ] ;
stream . read ( magicArray , <num> , <num> ) ;
if ( magicArray [ <num> ] != P'
|| ( magicArray [ <num> ] != <num>  && magicArray [ <num> ] != <num>  ) )
return null ;
commentFollows = f_skipWhitespace ( stream ) ;
if ( commentFollows ) {
profileTemp = f_parseComment ( stream ) ;
if ( profileTemp != null )
profile = profileTemp ;
}
;
final int width = Integer . parseInt ( f_readToken ( stream ) ) ;
commentFollows = f_skipWhitespace ( stream ) ;
if ( commentFollows ) {
profileTemp = f_parseComment ( stream ) ;
if ( profileTemp != null )
profile = profileTemp ;
}
;
final int height = Integer . parseInt ( f_readToken ( stream ) ) ;
commentFollows = f_skipWhitespace ( stream ) ;
if ( commentFollows ) {
profileTemp = f_parseComment ( stream ) ;
if ( profileTemp != null )
profile = profileTemp ;
}
;
final int rgb_max = Integer . parseInt ( f_readToken ( stream ) ) ;
stream . read ( ) ;
System . err . println ( " + new String ( magicArray ) ) ;
System . err . println ( " + width ) ;
System . err . println ( " + height ) ;
System . err . println ( " + rgb_max ) ;
System . err . println ( " + profile ) ;
ImageInfo info = new ImageInfo ( ) ;
info . width = width ;
info . height = height ;
info . rgb_max = rgb_max ;
RawRaster rr = new RawRaster ( info . width , info . height , <num> , <num> ) ;
f_readImageData ( rr , new DataInputStream ( stream ) ) ;
return rr ;
}
static void f_readImageData ( RawRaster raster , DataInputStream stream )
throws IOException {
final int <unk> = <num> ;
final int width = raster . getWidth ( ) ;
final int height = raster . getHeight ( ) ;
int [ ] rgb = new int [ <num> ] ;
int band ;
System . err . println ( " ) ;
for ( int y = <num> ; y < height ; ++ y ) {
for ( int x = <num> ; x < width ; ++ x ) {
raster . setSample ( x , y , R , stream . readUnsignedShort ( ) ) ;
raster . setSample ( x , y , G , stream . readUnsignedShort ( ) ) ;
raster . setSample ( x , y , B , stream . readUnsignedShort ( ) ) ;
}
}
}
static private boolean f_skipWhitespace ( PushbackInputStream stream )
throws IOException {
char c ;
while ( Character . isWhitespace ( c = ( char ) stream . read ( ) ) )
;
stream . unread ( c ) ;
if ( c == #' )
return true ;
return false ;
}
static private String f_readToken ( PushbackInputStream stream )
throws IOException {
StringBuffer buffer = new StringBuffer ( ) ;
char c ;
while ( Character . isWhitespace ( c = ( char ) stream . read ( ) ) == false )
buffer . append ( c ) ;
stream . unread ( c ) ;
return buffer . toString ( ) ;
}
static private ICC_Profile f_parseComment ( PushbackInputStream stream )
throws IOException {
StringBuffer buffer = new StringBuffer ( ) ;
char c ;
while ( ( c = ( char ) stream . read ( ) ) != \n' )
buffer . append ( c ) ;
String comment = buffer . toString ( ) ;
final int length = ICC_HEADER . length ( ) ;
final int index = comment . indexOf ( ICC_HEADER ) ;
if ( index >= <num> ) {
final int profileIndex = index + length ;
final String profileString = comment . substring ( profileIndex ) ;
final byte [ ] profileEncoding = profileString . getBytes ( ) ;
try {
final byte [ ] profileDecoding = Base64Like
. decode ( profileEncoding ) ;
ICC_Profile profile = ICC_Profile . getInstance ( profileDecoding ) ;
return profile ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
}
return null ;
}
static private void store16 ( byte [ ] array , int x , int y , RawRaster raster ) {
final int offset = x * <num> ;
final int r = raster . getSample ( x , y , <num> ) ;
final int g = raster . getSample ( x , y , <num> ) ;
final int b = raster . getSample ( x , y , <num> ) ;
array [ offset + <num> ] = ( byte ) ( r >> <num> ) ;
array [ offset + <num> ] = ( byte ) ( r & <num> ) ;
array [ offset + <num> ] = ( byte ) ( g >> <num> ) ;
array [ offset + <num> ] = ( byte ) ( g & <num> ) ;
array [ offset + <num> ] = ( byte ) ( b >> <num> ) ;
array [ offset + <num> ] = ( byte ) ( b & <num> ) ;
}
static private void store8 ( byte [ ] array , int x , int y , RawRaster raster ) {
final int offset = x * <num> ;
final int r = raster . getSample ( x , y , <num> ) ;
final int g = raster . getSample ( x , y , <num> ) ;
final int b = raster . getSample ( x , y , <num> ) ;
array [ offset + <num> ] = ( byte ) ( r & <num> ) ;
array [ offset + <num> ] = ( byte ) ( g & <num> ) ;
array [ offset + <num> ] = ( byte ) ( b & <num> ) ;
}
public static void main ( String [ ] args ) throws Exception {
ICC_Profile profile = ICC_Profile . getInstance ( args [ <num> ] ) ;
byte [ ] plain = profile . getData ( ) ;
byte [ ] encoding = Base64Like . encode ( plain ) ;
byte [ ] decoding = Base64Like . decode ( encoding ) ;
boolean equals = Arrays . equals ( plain , decoding ) ;
System . out . println ( " + new String ( encoding ) ) ;
if ( ! equals ) {
System . out . print ( " ) ;
for ( int i = <num> ; i < plain . length ; ++ i )
System . out . print ( " + plain [ i ] ) ;
System . out . println ( ) ;
System . out . print ( " ) ;
for ( int i = <num> ; i < decoding . length ; ++ i )
System . out . print ( " + decoding [ i ] ) ;
System . out . println ( ) ;
}
ICC_Profile <unk> = ICC_Profile . getInstance ( decoding ) ;
final int argc = args . length ;
for ( int i = <num> ; i < argc ; ++ i ) {
File file = new File ( args [ i ] ) ;
try {
if ( file . exists ( ) )
if ( file . isFile ( ) )
ColorPPMFile . decode ( new FileInputStream ( args [ i ] ) ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
}
}
}
package com . crinqle . dlroom ;
import java . awt . Color ;
import java . awt . Component ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseListener ;
import java . io . File ;
import java . util . Vector ;
import javax . swing . JList ;
import javax . swing . JPanel ;
import javax . swing . JTextField ;
import javax . swing . ListCellRenderer ;
import javax . swing . event . ListSelectionListener ;
public class FileListPanel extends JPanel implements MouseListener {
public static final Color DIR_SELECTED_COLOR = new Color ( <num> , <num> , <num> ) ;
public static final Color FILE_SELECTED_COLOR = new Color ( <num> , <num> , <num> ) ;
public static final int FILES = <num> ;
public static final int DIRS = <num> ;
public static final int ALL = <num> ;
private final int f_type ;
private File f_dir ;
private JList f_list = null ;
public FileListPanel ( File dir ) {
f_type = FILES ;
ctor ( dir ) ;
}
public FileListPanel ( File dir , int type ) {
f_type = type ;
ctor ( dir ) ;
}
private void ctor ( File dir ) {
f_dir = dir ;
f_list = new JList ( ) ;
f_list . addMouseListener ( this ) ;
Color selectedColor = null ;
switch ( f_type ) {
case FILES :
selectedColor = FILE_SELECTED_COLOR ;
break ;
case DIRS :
selectedColor = DIR_SELECTED_COLOR ;
break ;
}
f_list . setCellRenderer ( new FileRenderer ( selectedColor ) ) ;
updateFiles ( dir ) ;
setLayout ( new java . awt . GridLayout ( <num> , <num> ) ) ;
add ( f_list ) ;
}
public void mouseClicked ( MouseEvent evt ) {
if ( evt . getButton ( ) == MouseEvent . BUTTON3 )
updateFiles ( f_dir . getParentFile ( ) ) ;
}
public void mouseEntered ( MouseEvent evt ) {
}
public void mouseExited ( MouseEvent evt ) {
}
public void mousePressed ( MouseEvent evt ) {
}
public void mouseReleased ( MouseEvent evt ) {
}
public void mouseDragged ( MouseEvent evt ) {
}
public void mouseMoved ( MouseEvent evt ) {
}
public void addListSelectionListener ( ListSelectionListener l ) {
f_list . addListSelectionListener ( l ) ;
}
public void updateFiles ( File dir ) {
f_dir = new File ( dir . getAbsolutePath ( ) ) ;
File [ ] entries = f_dir . listFiles ( ) ;
final int count = entries . length ;
File parent = new File ( f_dir . getPath ( ) + File . separator + " ) ;
Vector < File > list = new Vector < File > ( ) ;
for ( int i = <num> ; i < count ; ++ i ) {
if ( entries [ i ] . isHidden ( ) )
continue ;
switch ( f_type ) {
case FILES :
if ( entries [ i ] . isFile ( ) ) {
String lcfilename = entries [ i ] . getName ( ) . toLowerCase ( ) ;
if ( lcfilename . endsWith ( " ) )
list . add ( entries [ i ] ) ;
}
break ;
case DIRS :
if ( entries [ i ] . isDirectory ( ) )
list . add ( entries [ i ] ) ;
break ;
}
}
f_list . setListData ( list ) ;
}
Object getSelectedValue ( ) {
return f_list . getSelectedValue ( ) ;
}
void setSelectedIndex ( int index ) {
f_list . setSelectedIndex ( index ) ;
}
}
class FileRenderer extends JTextField implements ListCellRenderer {
private final Color f_sc ;
public FileRenderer ( Color sc ) {
f_sc = sc ;
setOpaque ( true ) ;
setEditable ( false ) ;
}
public Component getListCellRendererComponent ( JList list , Object value ,
int index , boolean isSelected , boolean cellHasFocus ) {
if ( value instanceof File )
setText ( ( ( File ) value ) . getName ( ) ) ;
setBorder ( null ) ;
setBackground ( isSelected ? f_sc : Color . white ) ;
return this ;
}
}
package com . crinqle . dlroom ;
import java . awt . Color ;
import java . awt . Dimension ;
import java . awt . Graphics ;
import java . awt . Graphics2D ;
import java . awt . Point ;
import java . awt . color . ICC_Profile ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseListener ;
import java . awt . event . MouseMotionListener ;
import java . awt . image . BufferedImage ;
import java . awt . image . Raster ;
import java . awt . image . WritableRaster ;
import java . util . Collection ;
import java . util . Iterator ;
import java . util . LinkedList ;
import javax . swing . JFrame ;
import javax . swing . JPanel ;
import javax . swing . JScrollPane ;
import com . crinqle . dlroom . event . RawRasterSelectionListener ;
import static com . crinqle . dlroom . Const . * ;
public class ColorPanel extends JPanel implements MouseListener ,
MouseMotionListener {
private static final int TYPE_NONE = <num> ;
private static final int TYPE_DISPLAY = <num> ;
private static final int TYPE_PROOFING = <num> ;
private int f_t = TYPE_NONE ;
private ICC_Profile f_disp ;
private ICC_Profile f_proof ;
private RawRaster f_rr ;
private BufferedImage f_bi ;
private WritableRaster f_wr ;
private Collection < RawRasterSelectionListener > f_listeners = new LinkedList < RawRasterSelectionListener > ( ) ;
private int f_sx1 ;
private int f_sy1 ;
private int f_sx2 ;
private int f_sy2 ;
private RawRaster f_srr = null ;
private boolean f_isSelecting = false ;
private boolean f_isSelected = false ;
public ColorPanel ( ) {
addMouseListener ( this ) ;
addMouseMotionListener ( this ) ;
}
public void addRawRasterSelectionListener ( RawRasterSelectionListener l ) {
f_listeners . add ( l ) ;
}
private void fireRawRasterSelectionEvent ( ) {
if ( f_srr == null )
return ;
Iterator iter = f_listeners . iterator ( ) ;
while ( iter . hasNext ( ) )
( ( RawRasterSelectionListener ) iter . next ( ) ) . subrasterSelected ( this ,
f_srr ) ;
}
public void <unk> ( ICC_Profile displayProfile ) {
f_disp = displayProfile ;
f_t = TYPE_DISPLAY ;
}
public void <unk> ( ICC_Profile proofingProfile ,
ICC_Profile displayProfile ) {
f_proof = proofingProfile ;
f_disp = displayProfile ;
f_t = ( TYPE_PROOFING | TYPE_DISPLAY ) ;
}
public RawRaster <unk> ( ) {
return f_rr ;
}
public void setRawRaster ( RawRaster rr ) {
f_rr = rr ;
final int w = f_rr . getWidth ( ) ;
final int h = f_rr . getHeight ( ) ;
final int bits = f_rr . getBits ( ) ;
final int bc = f_rr . getBandCount ( ) ;
RawRaster copy = f_rr . createBlankCopy ( ) ;
if ( bits != <num> ) {
final int shift = Math . abs ( bits  <num> ) ;
for ( int y = <num> ; y < h ; ++ y )
for ( int x = <num> ; x < w ; ++ x ) {
copy . setSample ( x , y , R , f_rr . getSample ( x , y , R ) >> shift ) ;
copy . setSample ( x , y , G , f_rr . getSample ( x , y , G ) >> shift ) ;
copy . setSample ( x , y , B , f_rr . getSample ( x , y , B ) >> shift ) ;
}
}
f_bi = new BufferedImage ( w , h , BufferedImage . TYPE_INT_RGB ) ;
final int scanlineStride = w ;
final int [ ] bankIndices = { <num> , <num> , <num> } ;
final int [ ] bandOffsets = { <num> , <num> , <num> } ;
f_wr = Raster . <unk> ( copy , w , h , scanlineStride ,
bankIndices , bandOffsets , new Point ( <num> , <num> ) ) ;
f_bi . setData ( f_wr ) ;
setPreferredSize ( new Dimension ( w , h ) ) ;
repaint ( ) ;
}
public void mouseClicked ( MouseEvent evt ) {
final int x = evt . getX ( ) ;
final int y = evt . getY ( ) ;
}
public void mouseEntered ( MouseEvent evt ) {
}
public void mouseExited ( MouseEvent evt ) {
}
public void mousePressed ( MouseEvent evt ) {
f_sx1 = evt . getX ( ) ;
f_sy1 = evt . getY ( ) ;
}
public void mouseReleased ( MouseEvent evt ) {
f_sx2 = evt . getX ( ) ;
f_sy2 = evt . getY ( ) ;
repaint ( ) ;
if ( f_isSelecting ) {
System . out . println ( " + f_sx2 + "
+ f_sy2 + " ) ;
sortSelection ( ) ;
final int w = f_sx2  f_sx1 ;
final int h = f_sy2  f_sy1 ;
f_srr = f_rr . subraster ( f_sx1 , f_sy1 , w , h ) ;
f_isSelecting = false ;
f_isSelected = true ;
fireRawRasterSelectionEvent ( ) ;
}
}
public void mouseDragged ( MouseEvent evt ) {
f_isSelecting = true ;
f_isSelected = false ;
f_sx2 = evt . getX ( ) ;
f_sy2 = evt . getY ( ) ;
repaint ( ) ;
}
public void mouseMoved ( MouseEvent evt ) {
}
private void sortSelection ( ) {
int temp ;
if ( f_sx1 > f_sx2 ) {
temp = f_sx1 ;
f_sx1 = f_sx2 ;
f_sx2 = temp ;
}
if ( f_sy1 > f_sy2 ) {
temp = f_sy1 ;
f_sy1 = f_sy2 ;
f_sy2 = temp ;
}
}
public void paintComponent ( Graphics g ) {
Graphics2D g2d = ( Graphics2D ) g ;
g2d . drawRenderedImage ( f_bi , null ) ;
if ( f_isSelecting || f_isSelected ) {
if ( f_sx1 == f_sx2 && f_sy1 == f_sy2 )
return ;
int temp ;
int sx1 = f_sx1 ;
int sy1 = f_sy1 ;
int sx2 = f_sx2 ;
int sy2 = f_sy2 ;
if ( sx1 > sx2 ) {
temp = sx1 ;
sx1 = sx2 ;
sx2 = temp ;
}
if ( sy1 > sy2 ) {
temp = sy1 ;
sy1 = sy2 ;
sy2 = temp ;
}
g2d . <unk> ( Color . white ) ;
g2d . drawRect ( sx1 , sy1 , sx2  sx1 , sy2  sy1 ) ;
}
}
public static void main ( String [ ] args ) {
if ( args . length < <num> ) {
System . err . println ( " ) ;
System . exit ( <num> ) ;
}
try {
com . crinqle . dlroom . codec . RawCodec codec = com . crinqle . dlroom . codec . RawCodec
. getInstance ( new java . io . File ( args [ <num> ] ) ) ;
CaptureData cd = codec . decode ( ) ;
RawRaster rr = new RawRaster ( cd ) ;
ColorPanel cp = new ColorPanel ( ) ;
cp . setRawRaster ( rr ) ;
JScrollPane scroller = new JScrollPane ( cp ) ;
JFrame frame = new JFrame ( " ) ;
frame . setContentPane ( scroller ) ;
frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
frame . pack ( ) ;
frame . setVisible ( true ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
}
}
package com . crinqle . dlroom ;
import java . io . * ;
import java . util . * ;
import javax . swing . * ;
import com . crinqle . dlroom . util . * ;
public class DirListPanel extends EtchedTitledPanel
{
JList f_list = null ;
public DirListPanel ( File dir )
{
super ( " + dir . getPath ( ) ) ;
f_list = new JList ( ) ;
updateDirs ( dir ) ;
setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ;
add ( f_list ) ;
}
public void updateDirs ( File dir )
{
File [ ] entries = dir . listFiles ( ) ;
final int count = entries . length ;
Vector list = new Vector ( ) ;
for ( int i = <num> ; i < count ; ++ i )
if ( entries [ i ] . isDirectory ( ) )
list . add ( entries [ i ] ) ;
f_list . setListData ( list ) ;
}
}
package com . crinqle . dlroom . event ;
public interface LUTChangeListener {
void applyLUT ( Object source , com . crinqle . dlroom . LUT lut ) ;
}
package com . crinqle . dlroom . math ;
import java . awt . Canvas ;
import java . awt . Event ;
import java . awt . Graphics ;
import java . awt . Image ;
import com . crinqle . dlroom . MouseEvent ;
public class CurveCanvas extends Canvas implements Runnable {
Image offscreen ;
ControlCurve curve ;
MouseEvent mouseEvent ;
public CurveCanvas ( MouseEvent mouseEvent , ControlCurve curve ) {
this . mouseEvent = mouseEvent ;
this . curve = curve ;
}
public void paint ( Graphics g ) {
if ( offscreen == null ) {
offscreen = createImage ( size ( ) . width , size ( ) . height ) ;
}
Graphics og = offscreen . getGraphics ( ) ;
og . clearRect ( <num> , <num> , size ( ) . width , size ( ) . height ) ;
curve . paint ( og ) ;
g . drawImage ( offscreen , <num> , <num> , null ) ;
}
public void update ( Graphics g ) {
paint ( g ) ;
}
public void update ( ) {
update ( getGraphics ( ) ) ;
}
public void run ( ) {
for ( ; ; ) {
Event e = mouseEvent . get ( ) ;
if ( e . id == Event . MOUSE_DOWN ) {
if ( curve . selectPoint ( e . x , e . y ) ==  <num> ) {
curve . addPoint ( e . x , e . y ) ;
update ( ) ;
}
} else if ( e . id == Event . MOUSE_DRAG ) {
curve . setPoint ( e . x , e . y ) ;
update ( ) ;
} else if ( e . id == Event . MOUSE_UP ) {
if ( e . <unk> ( ) ) {
curve . removePoint ( ) ;
update ( ) ;
}
}
}
}
}
package com . crinqle . dlroom . math ;
import java . applet . Applet ;
import java . awt . BorderLayout ;
import java . awt . Color ;
import java . awt . Event ;
import java . util . NoSuchElementException ;
import java . util . StringTokenizer ;
import com . crinqle . dlroom . MouseEvent ;
public class <unk> extends Applet {
protected ControlCurve curve ;
protected Color bgcolor ;
protected MouseEvent mouseEvent ;
public void init ( ) {
Color bgcolor = getColorParameter ( " , null ) ;
if ( bgcolor != null ) {
setBackground ( bgcolor ) ;
}
try {
String curveName = getParameter ( " ) ;
if ( curveName == null ) {
curveName = " ;
}
curve = ( ControlCurve ) Class . forName ( curveName ) . newInstance ( ) ;
} catch ( ClassNotFoundException e ) {
System . err . println ( " + e . getMessage ( ) ) ;
} catch ( InstantiationException e ) {
System . err . println ( " + e . getMessage ( ) ) ;
} catch ( IllegalAccessException e ) {
System . err . println ( " + e . getMessage ( ) ) ;
}
String s = getParameter ( " ) ;
if ( s != null ) {
StringTokenizer st = new StringTokenizer ( s , " ) ;
try {
while ( st . hasMoreTokens ( ) ) {
int x = Integer . parseInt ( st . nextToken ( ) ) ;
int y = Integer . parseInt ( st . nextToken ( ) ) ;
curve . addPoint ( x , y ) ;
}
} catch ( NoSuchElementException e ) {
System . err . println ( "
+ e . getMessage ( ) ) ;
} catch ( NumberFormatException e ) {
System . err . println ( "
+ e . getMessage ( ) ) ;
}
}
setLayout ( new BorderLayout ( <num> , <num> ) ) ;
mouseEvent = new MouseEvent ( ) ;
CurveCanvas canvas = new CurveCanvas ( mouseEvent , curve ) ;
add ( " , canvas ) ;
Thread canvasThread = new Thread ( canvas ) ;
canvasThread . start ( ) ;
canvasThread . setPriority ( Thread . MIN_PRIORITY ) ;
}
public boolean handleEvent ( Event e ) {
if ( e . id == Event . MOUSE_DOWN || e . id == Event . MOUSE_DRAG
|| e . id == Event . MOUSE_UP ) {
mouseEvent . put ( e ) ;
return true ;
} else {
return false ;
}
}
protected Color getColorParameter ( String name , Color dfault ) {
String value = getParameter ( name ) ;
int intvalue ;
try {
intvalue = Integer . parseInt ( value , <num> ) ;
} catch ( NumberFormatException e ) {
return dfault ;
}
return new Color ( intvalue ) ;
}
}
package com . crinqle . dlroom ;
public interface BandIterator
{
boolean next ( ) ;
boolean prev ( ) ;
int get ( ) ;
int index ( ) ;
int x ( ) ;
int y ( ) ;
void set ( int value ) ;
}
package com . crinqle . dlroom . test ;
import static com . crinqle . dlroom . Const . B ;
import static com . crinqle . dlroom . Const . G ;
import static com . crinqle . dlroom . Const . H ;
import static com . crinqle . dlroom . Const . R ;
import java . awt . Color ;
import java . awt . Dimension ;
import java . awt . GridLayout ;
import javax . swing . JFrame ;
import javax . swing . JPanel ;
import com . crinqle . dlroom . AreaBandIterator ;
import com . crinqle . dlroom . CaptureData ;
import com . crinqle . dlroom . Const ;
import com . crinqle . dlroom . RawRaster ;
class <unk> {
public final static double GAMMA = ( <num> / <num> ) ;
public static JPanel showColorFilterArea ( int [ ] [ ] area , int bits , int band ) {
final int dim = area . length ;
final int shift = bits  <num> ;
final int r = dim >> <num> ;
final int max = <num> << bits ;
final int [ ] [ ] ba = new int [ <num> ] [ <num> ] ;
if ( ( r % <num> ) == <num> ) {
switch ( band ) {
case G :
ba [ <num> ] [ <num> ] = G ;
ba [ <num> ] [ <num> ] = R ;
ba [ <num> ] [ <num> ] = B ;
ba [ <num> ] [ <num> ] = H ;
break ;
case H :
ba [ <num> ] [ <num> ] = H ;
ba [ <num> ] [ <num> ] = B ;
ba [ <num> ] [ <num> ] = R ;
ba [ <num> ] [ <num> ] = G ;
break ;
case B :
ba [ <num> ] [ <num> ] = B ;
ba [ <num> ] [ <num> ] = H ;
ba [ <num> ] [ <num> ] = G ;
ba [ <num> ] [ <num> ] = R ;
break ;
case R :
ba [ <num> ] [ <num> ] = R ;
ba [ <num> ] [ <num> ] = G ;
ba [ <num> ] [ <num> ] = H ;
ba [ <num> ] [ <num> ] = B ;
break ;
}
}
else {
switch ( band ) {
case G :
ba [ <num> ] [ <num> ] = H ;
ba [ <num> ] [ <num> ] = B ;
ba [ <num> ] [ <num> ] = R ;
ba [ <num> ] [ <num> ] = G ;
break ;
case H :
ba [ <num> ] [ <num> ] = G ;
ba [ <num> ] [ <num> ] = R ;
ba [ <num> ] [ <num> ] = B ;
ba [ <num> ] [ <num> ] = H ;
break ;
case B :
ba [ <num> ] [ <num> ] = R ;
ba [ <num> ] [ <num> ] = G ;
ba [ <num> ] [ <num> ] = H ;
ba [ <num> ] [ <num> ] = B ;
break ;
case R :
ba [ <num> ] [ <num> ] = B ;
ba [ <num> ] [ <num> ] = H ;
ba [ <num> ] [ <num> ] = G ;
ba [ <num> ] [ <num> ] = R ;
break ;
}
}
JPanel panel = new JPanel ( ) ;
panel . setLayout ( new GridLayout ( dim , dim ) ) ;
Color c = null ;
for ( int y = <num> ; y < dim ; ++ y ) {
for ( int x = <num> ; x < dim ; ++ x ) {
int value = area [ y ] [ x ] ;
double f = value / ( double ) max ;
f = Math . pow ( f , GAMMA ) ;
value = ( int ) ( f * <num> ) ;
switch ( ba [ y % <num> ] [ x % <num> ] ) {
case G :
case H :
c = new Color ( <num> , value , <num> ) ;
break ;
case R :
c = new Color ( value , <num> , <num> ) ;
break ;
case B :
c = new Color ( <num> , <num> , value ) ;
break ;
default :
throw new RuntimeException (
" ) ;
}
panel . add ( makePanel ( c ) ) ;
}
}
return panel ;
}
public static JPanel <unk> ( int [ ] [ ] area , int bits , int band ) {
final int dim = area . length ;
final int shift = bits  <num> ;
final int r = dim >> <num> ;
final int max = <num> << bits ;
JPanel panel = new JPanel ( ) ;
panel . setLayout ( new GridLayout ( dim , dim ) ) ;
Color c = null ;
for ( int y = <num> ; y < dim ; ++ y ) {
for ( int x = <num> ; x < dim ; ++ x ) {
int value = area [ y ] [ x ] ;
double f = value / ( double ) max ;
f = Math . pow ( f , GAMMA ) ;
value = ( int ) ( f * <num> ) ;
panel . add ( makePanel ( new Color ( value , value , value ) ) ) ;
}
}
return panel ;
}
private static JPanel makePanel ( Color color ) {
JPanel p = new JPanel ( ) ;
final int size = <num> ;
p . setBackground ( color ) ;
p . setMaximumSize ( new Dimension ( size , size ) ) ;
p . setMinimumSize ( new Dimension ( size , size ) ) ;
p . setPreferredSize ( new Dimension ( size , size ) ) ;
return p ;
}
public static void main ( String [ ] args ) {
if ( args . length < <num> ) {
System . err
. println ( " ) ;
System . exit ( <num> ) ;
}
try {
com . crinqle . dlroom . codec . RawCodec codec = com . crinqle . dlroom . codec . RawCodec
. getInstance ( new java . io . File ( args [ <num> ] ) ) ;
final int radius = Integer . parseInt ( args [ <num> ] ) ;
final int diameter = radius * <num> + <num> ;
CaptureData cd = codec . decode ( ) ;
RawRaster rr = new RawRaster ( cd ) ;
AreaBandIterator [ ] abis = cd . areaBandIterators ( radius ) ;
AreaBandIterator abi = abis [ Const . R ] ;
int [ ] array = null ;
if ( abi . next ( ) ) {
array = abi . getArea ( ) ;
}
JPanel grid = showColorFilterArea ( array , <num> , Const . R ) ;
JFrame frame = new JFrame ( " ) ;
frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
frame . setContentPane ( grid ) ;
frame . pack ( ) ;
frame . setVisible ( true ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
}
}
package com . crinqle . dlroom ;
import java . awt . color . * ;
import java . awt . image . * ;
import static com . crinqle . dlroom . Const . * ;
public class ImageData extends DataBuffer
{
private static final int TYPE = DataBuffer . TYPE_INT ;
protected final int f_w ;
protected final int f_h ;
protected final int f_bits ;
protected final int f_each ;
protected final int f_total ;
protected int [ ] f_a ;
protected ICC_Profile f_profile = null ;
public static void println ( ImageData id )
{
final int w = id . f_w ;
final int h = id . f_h ;
final int each = id . f_each ;
final int banks = id . getNumBanks ( ) ;
final int [ ] a = id . f_a ;
for ( int bank = <num> ; bank < banks ; ++ bank )
{
final int offset = bank * each ;
System . out . print ( " + CHANNEL_NAME [ bank ] + " ) ;
for ( int y = <num> ; y < h ; ++ y )
{
for ( int x = <num> ; x < w ; ++ x )
System . out . print ( a [ offset + x + y * w ] + " ) ;
System . out . print ( " ) ;
}
}
}
public ImageData ( int width , int height , int bits )
{
super ( TYPE , width * height ) ;
f_w = width ;
f_h = height ;
f_bits = bits ;
f_total = f_each = width * height ;
f_a = new int [ f_total ] ;
}
public ImageData ( int width , int height , int numBanks , int bits )
{
super ( TYPE , width * height , numBanks ) ;
f_w = width ;
f_h = height ;
f_bits = bits ;
f_each = width * height ;
f_total = f_each * numBanks ;
f_a = new int [ f_total ] ;
}
public ImageData ( int width , int height , short [ ] data , int numBanks , int bits )
{
super ( TYPE , width * height , numBanks ) ;
if ( data . length != size )
throw new RuntimeException ( " ) ;
f_w = width ;
f_h = height ;
f_bits = bits ;
f_each = width * height ;
f_total = f_each * numBanks ;
f_a = new int [ f_total ] ;
for ( int i = <num> ; i < f_total ; ++ i )
f_a [ i ] = data [ i ] ;
}
protected ImageData ( ImageData id )
{
super ( TYPE , id . f_total , id . getNumBanks ( ) ) ;
f_w = id . f_w ;
f_h = id . f_h ;
f_bits = id . f_bits ;
f_each = id . f_each ;
f_total = id . f_total ;
f_a = new int [ f_total ] ;
if ( id . f_profile != null )
f_profile = id . getProfile ( ) ;
}
public int getHeight ( ) { return f_h ; }
public int getWidth ( ) { return f_w ; }
public int getBits ( ) { return f_bits ; }
public int getBandCount ( ) { return this . getNumBanks ( ) ; }
public ICC_Profile getProfile ( ) { return ICC_Profile . getInstance ( f_profile . getData ( ) ) ; }
public void setProfile ( ICC_Profile profile ) { f_profile = ICC_Profile . getInstance ( profile . getData ( ) ) ; }
public void zero ( ) { for ( int i = <num> ; i < f_total ; ++ i ) f_a [ i ] = <num> ; }
public int getSample ( int x , int y ) { return f_a [ x + y * f_w ] ; }
public int getSample ( int x , int y , int band ) { return f_a [ ( band * f_each ) + ( x + y * f_w ) ] ; }
public void setSample ( int x , int y , int val ) { f_a [ x + y * f_w ] = val ; }
public void setSample ( int x , int y , int band , int val ) { f_a [ ( band * f_each ) + ( x + y * f_w ) ] = val ; }
public ImageData subset ( int x , int y )
{
final int w = f_w  x ;
final int h = f_h  y ;
return subset ( x , y , w , h ) ;
}
public ImageData subset ( int x , int y , int width , int height )
{
final int banks = getNumBanks ( ) ;
ImageData id = new ImageData ( width , height , banks , f_bits ) ;
int bo =  f_each ;
int tbo =  id . f_each ;
for ( int bank = <num> ; bank < banks ; ++ bank )
{
bo += f_each ;
tbo += id . f_each ;
int offset = bo + ( y * f_w ) + ( x  f_w ) ;
int target = tbo  width ;
for ( int row = <num> ; row < height ; ++ row )
{
offset += f_w ;
target += width ;
System . arraycopy ( f_a , offset , id . f_a , target , width ) ;
}
}
return id ;
}
public int [ ] getData ( ) { return f_a ; }
public void setData ( int [ ] array )
{
final int l = array . length ;
if ( l != f_total )
throw new RuntimeException ( " ) ;
System . arraycopy ( array , <num> , f_a , <num> , l ) ;
}
public int getElem ( int bank , int i ) { return f_a [ bank * size + i ] ; }
public void setElem ( int bank , int i , int val ) { f_a [ bank * size + i ] = val ; }
}
package com . crinqle . dlroom . app ;
import java . awt . * ;
import java . awt . color . * ;
import java . awt . event . * ;
import java . awt . image . * ;
import java . awt . image . renderable . * ;
import java . io . * ;
import java . util . * ;
import javax . swing . * ;
import javax . swing . border . * ;
import javax . swing . event . * ;
import static com . crinqle . dlroom . Const . * ;
import com . crinqle . dlroom . * ;
import com . crinqle . dlroom . codec . * ;
import com . crinqle . dlroom . event . * ;
import com . crinqle . dlroom . math . * ;
import com . crinqle . dlroom . util . * ;
public class Main extends JFrame implements ActionListener , WindowListener , LUTChangeListener , ListSelectionListener , RawRasterSelectionListener
{
private JMenuItem f_newItem = new JMenuItem ( " , n' ) ;
private JMenuItem f_openItem = new JMenuItem ( " , o' ) ;
private JMenuItem f_saveItem = new JMenuItem ( " , s' ) ;
private JMenuItem f_saveAsItem = new JMenuItem ( " ) ;
private JMenuItem f_quitItem = new JMenuItem ( " , q' ) ;
private JMenuItem f_redoItem = new JMenuItem ( " , y' ) ;
private JMenuItem f_undoItem = new JMenuItem ( " , u' ) ;
private JMenuItem f_applyItem = new JMenuItem ( " ,  ' ) ;
private JMenuItem f_levelsItem = new JMenuItem ( " , l' ) ;
private JMenuItem f_curvesItem = new JMenuItem ( " , c' ) ;
private JMenuItem f_monProfItem = new JMenuItem ( " , m' ) ;
private JMenuItem f_imageWSItem = new JMenuItem ( " , i' ) ;
private JMenu f_rawMenu = new JMenu ( " ) ;
private JMenuItem f_biasItem = new JMenuItem ( " , b' ) ;
private JMenuItem f_interpItem = new JMenuItem ( " , i' ) ;
private final String f_prefsName = " ;
private Prefs f_prefs = null ;
private File f_workingDir = null ;
private String f_monProfilePath = null ;
private String f_wsProfilePath = null ;
private ICC_Profile f_monProfile = null ;
private ICC_Profile f_wsProfile = null ;
private RasterStack f_undoStack = new RasterStack ( ) ;
private RasterStack f_redoStack = new RasterStack ( ) ;
private RawRaster f_rr = null ;
private RawRaster f_rrtemp = null ;
private RawRaster f_srr = null ;
private Collection < BitDepthChangeListener > f_bdcls = new LinkedList < BitDepthChangeListener > ( ) ;
private JScrollPane f_scroller ;
private JDesktopPane f_desktop ;
private JInternalFrame f_frame ;
public Main ( )
{
super ( " ) ;
addWindowListener ( this ) ;
f_loadPreferences ( ) ;
f_initMenus ( ) ;
FileChooserPanel fileChooser = new FileChooserPanel ( f_workingDir ) ;
fileChooser . addListSelectionListener ( this ) ;
JPanel imagePanel = new JPanel ( ) ;
imagePanel . setLayout ( new GridLayout ( <num> , <num> ) ) ;
imagePanel . setBackground ( Color . white ) ;
imagePanel . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
f_scroller = new JScrollPane ( imagePanel ) ;
f_desktop = new JDesktopPane ( ) ;
f_desktop . setDragMode ( JDesktopPane . OUTLINE_DRAG_MODE ) ;
JSplitPane splitter = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT , false , fileChooser , f_desktop ) ;
add ( splitter ) ;
}
public void actionPerformed ( ActionEvent evt )
{
Object source = evt . getSource ( ) ;
if ( source == f_quitItem ) f_shutdown ( ) ;
else if ( source == f_newItem ) f_new ( ) ;
else if ( source == f_openItem ) f_openDialog ( ) ;
else if ( source == f_saveItem ) f_saveDialog ( ) ;
else if ( source == f_saveAsItem ) f_saveAsDialog ( ) ;
else if ( source == f_redoItem ) f_redo ( ) ;
else if ( source == f_undoItem ) f_undo ( ) ;
else if ( source == f_applyItem ) f_apply ( ) ;
else if ( source == f_levelsItem ) f_levelsDialog ( ) ;
else if ( source == f_curvesItem ) f_curvesDialog ( ) ;
else if ( source == f_monProfItem ) f_monProfDialog ( ) ;
else if ( source == f_imageWSItem ) f_imageWorkingSpaceDialog ( ) ;
else if ( source == f_biasItem ) { f_biasDialog ( ) ; }
else if ( source == f_interpItem ) { f_interpolate ( ) ; }
}
public void valueChanged ( ListSelectionEvent evt )
{
Object src = evt . getSource ( ) ;
if ( ! evt . getValueIsAdjusting ( ) )
{
if ( src instanceof JList )
{
JList list = ( JList ) src ;
Object obj = list . getSelectedValue ( ) ;
if ( obj instanceof File )
{
File file = ( File ) obj ;
if ( file . isFile ( ) )
{
System . err . println ( " + file + " ) ;
f_loadImage ( file ) ;
}
}
}
}
}
private void f_loadImage ( File file )
{
try
{
RawCodec codec = RawCodec . getInstance ( file ) ;
CaptureData cd = codec . decode ( ) ;
final int bits = cd . getBits ( ) ;
f_rr = new RawRaster ( cd ) ;
f_rr . setProfile ( f_wsProfile ) ;
f_rrtemp = null ;
f_undoStack . removeAllElements ( ) ;
f_redoStack . removeAllElements ( ) ;
fireBitDepthChangeEvent ( cd , bits ) ;
f_frame = new JInternalFrame ( file . getPath ( ) ) ;
f_desktop . add ( f_frame ) ;
f_displayImage ( ) ;
}
catch ( Exception e ) { e . printStackTrace ( ) ; f_shutdown ( ) ; }
}
public void addBitDepthChangeListener ( BitDepthChangeListener l ) { f_bdcls . add ( l ) ; }
public void fireBitDepthChangeEvent ( Object source , int bits ) { System . out . println ( " + bits ) ; Iterator iter = f_bdcls . iterator ( ) ; while ( iter . hasNext ( ) ) ( ( BitDepthChangeListener ) iter . next ( ) ) . updateBits ( source , bits ) ; }
public void applyLUT ( Object source , LUT lut )
{
if ( f_rr == null )
return ;
if ( f_rrtemp == null )
f_rrtemp = f_rr . createCopy ( ) ;
f_rr . applyLUT ( lut , f_rrtemp ) ;
f_displayImage ( f_rrtemp ) ;
}
public void subrasterSelected ( Object source , RawRaster rr ) { System . out . println ( " ) ; f_srr = rr ; }
public void windowClosing ( WindowEvent evt ) { f_shutdown ( ) ; }
public void windowClosed ( WindowEvent evt ) { f_shutdown ( ) ; }
public void windowOpened ( WindowEvent evt ) { }
public void windowIconified ( WindowEvent evt ) { }
public void windowDeiconified ( WindowEvent evt ) { }
public void windowActivated ( WindowEvent evt ) { }
public void windowDeactivated ( WindowEvent evt ) { }
private void f_loadPreferences ( )
{
String prefsPath = System . getProperty ( " ) + File . separator + f_prefsName ;
System . err . println ( " + prefsPath ) ;
try
{
f_prefs = Prefs . loadFromFile ( new File ( prefsPath ) ) ;
String wsPrefix = f_prefs . get ( " , " ) ;
String monPrefix = f_prefs . get ( " , " ) ;
String wsName = f_prefs . get ( " , " ) ;
String monName = f_prefs . get ( " , " ) ;
String wsPath = wsPrefix + File . separator + wsName ;
String monPath = monPrefix + File . separator + monName ;
String wdPath = f_prefs . get ( " , " ) ;
f_wsProfilePath = wsPath ;
f_monProfilePath = monPath ;
System . err . println ( " + f_wsProfilePath + " ) ;
System . err . println ( " + f_monProfilePath + " ) ;
f_wsProfile = ICC_Profile . getInstance ( f_wsProfilePath ) ;
f_monProfile = ICC_Profile . getInstance ( f_monProfilePath ) ;
f_workingDir = new File ( wdPath ) ;
}
catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( <num> ) ; }
}
private void f_initMenus ( )
{
JMenu fileMenu = new JMenu ( " ) ;
fileMenu . setMnemonic ( f' ) ;
fileMenu . add ( f_newItem ) ;
fileMenu . add ( f_openItem ) ;
fileMenu . add ( f_saveItem ) ;
fileMenu . add ( f_saveAsItem ) ;
fileMenu . addSeparator ( ) ;
fileMenu . add ( f_quitItem ) ;
f_newItem . addActionListener ( this ) ;
f_openItem . addActionListener ( this ) ;
f_saveItem . addActionListener ( this ) ;
f_saveAsItem . addActionListener ( this ) ;
f_quitItem . addActionListener ( this ) ;
f_newItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_N , InputEvent . CTRL_MASK ) ) ;
f_openItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_O , InputEvent . CTRL_MASK ) ) ;
f_saveItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_S , InputEvent . CTRL_MASK ) ) ;
f_quitItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_Q , InputEvent . CTRL_MASK ) ) ;
JMenu editMenu = new JMenu ( " ) ;
editMenu . setMnemonic ( e' ) ;
editMenu . add ( f_redoItem ) ;
editMenu . add ( f_undoItem ) ;
editMenu . addSeparator ( ) ;
editMenu . add ( f_applyItem ) ;
f_redoItem . addActionListener ( this ) ;
f_undoItem . addActionListener ( this ) ;
f_applyItem . addActionListener ( this ) ;
f_redoItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_Y , InputEvent . CTRL_MASK ) ) ;
f_undoItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_ESCAPE , <num> ) ) ;
f_applyItem . setAccelerator ( KeyStroke . getKeyStroke (  ' ) ) ;
JMenu colorMenu = new JMenu ( " ) ;
colorMenu . setMnemonic ( c' ) ;
colorMenu . add ( f_levelsItem ) ;
colorMenu . add ( f_curvesItem ) ;
colorMenu . addSeparator ( ) ;
colorMenu . add ( f_monProfItem ) ;
colorMenu . add ( f_imageWSItem ) ;
f_levelsItem . addActionListener ( this ) ;
f_curvesItem . addActionListener ( this ) ;
f_monProfItem . addActionListener ( this ) ;
f_imageWSItem . addActionListener ( this ) ;
f_levelsItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_L , InputEvent . CTRL_MASK ) ) ;
f_curvesItem . setAccelerator ( KeyStroke . getKeyStroke ( KeyEvent . VK_M , InputEvent . CTRL_MASK ) ) ;
f_rawMenu . setEnabled ( false ) ;
f_rawMenu . setMnemonic ( r' ) ;
f_rawMenu . add ( f_biasItem ) ;
f_rawMenu . add ( f_interpItem ) ;
f_biasItem . addActionListener ( this ) ;
f_interpItem . addActionListener ( this ) ;
f_biasItem . setAccelerator ( KeyStroke . getKeyStroke ( b' ) ) ;
f_interpItem . setAccelerator ( KeyStroke . getKeyStroke ( i' ) ) ;
JMenu spacerMenu = new JMenu ( ) ;
spacerMenu . setEnabled ( false ) ;
JMenuBar menuBar = new JMenuBar ( ) ;
menuBar . add ( fileMenu ) ;
menuBar . add ( editMenu ) ;
menuBar . add ( colorMenu ) ;
menuBar . add ( spacerMenu ) ;
menuBar . add ( f_rawMenu ) ;
setJMenuBar ( menuBar ) ;
}
private void <unk> ( )
{
FileChooserPanel fileChooser = new FileChooserPanel ( f_workingDir ) ;
fileChooser . addListSelectionListener ( this ) ;
final int bits = <num> ;
CurvePanel curveR = new CurvePanel ( R , bits ) ;
CurvePanel curveG = new CurvePanel ( G , bits ) ;
CurvePanel curveB = new CurvePanel ( B , bits ) ;
curveR . addLUTChangeListener ( this ) ;
curveG . addLUTChangeListener ( this ) ;
curveB . addLUTChangeListener ( this ) ;
JTabbedPane curveTabs = new JTabbedPane ( ) ;
curveTabs . add ( " , curveR ) ;
curveTabs . add ( " , curveG ) ;
curveTabs . add ( " , curveB ) ;
JPanel curvePanel = new EtchedTitledPanel ( " ) ;
curvePanel . add ( curveTabs ) ;
LevelSliderPanel levelR = new LevelSliderPanel ( R , bits ) ;
LevelSliderPanel levelG = new LevelSliderPanel ( G , bits ) ;
LevelSliderPanel levelB = new LevelSliderPanel ( B , bits ) ;
LevelSliderPanel levelH = new LevelSliderPanel ( H , bits ) ;
levelR . addLUTChangeListener ( this ) ;
levelG . addLUTChangeListener ( this ) ;
levelB . addLUTChangeListener ( this ) ;
levelH . addLUTChangeListener ( this ) ;
addBitDepthChangeListener ( curveR ) ;
addBitDepthChangeListener ( curveG ) ;
addBitDepthChangeListener ( curveB ) ;
addBitDepthChangeListener ( levelR ) ;
addBitDepthChangeListener ( levelG ) ;
addBitDepthChangeListener ( levelB ) ;
addBitDepthChangeListener ( levelH ) ;
JPanel levelPanel = new EtchedTitledPanel ( " ) ;
levelPanel . setLayout ( new GridLayout ( <num> , <num> ) ) ;
levelPanel . add ( levelR ) ;
levelPanel . add ( levelG ) ;
levelPanel . add ( levelB ) ;
levelPanel . add ( levelH ) ;
GridBagLayout bag = new GridBagLayout ( ) ;
GridBagConstraints gc = new GridBagConstraints ( ) ;
JPanel editPanel = new JPanel ( ) ;
editPanel . setLayout ( new BoxLayout ( editPanel , BoxLayout . Y_AXIS ) ) ;
editPanel . add ( fileChooser ) ;
editPanel . add ( curvePanel ) ;
editPanel . add ( levelPanel ) ;
JPanel imagePanel = new JPanel ( ) ;
imagePanel . setLayout ( new GridLayout ( <num> , <num> ) ) ;
imagePanel . setBackground ( Color . white ) ;
imagePanel . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
f_scroller = new JScrollPane ( imagePanel ) ;
JPanel content = new JPanel ( ) ;
content . setLayout ( new BorderLayout ( ) ) ;
content . add ( editPanel , BorderLayout . WEST ) ;
content . add ( f_scroller , BorderLayout . CENTER ) ;
add ( content ) ;
}
private void f_apply ( ) { if ( f_rrtemp != null ) { if ( f_rrtemp == null ) return ; f_push ( ) ; f_rr = f_rrtemp ; f_rrtemp = null ; } }
private void f_interpolate ( ) { if ( f_rr == null ) return ; try { f_push ( ) ; f_rr = f_rr . createCopy ( ) ; f_rr . interpolate ( ALL_MASK ) ; f_displayImage ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( <num> ) ; } }
private void f_push ( ) { f_undoStack . push ( f_rr ) ; }
private void f_undo ( ) { if ( f_undoStack . empty ( ) ) return ; f_redoStack . push ( f_rr ) ; f_rr = f_undoStack . pop ( ) ; f_displayImage ( ) ; }
private void f_redo ( ) { if ( f_redoStack . empty ( ) ) return ; f_undoStack . push ( f_rr ) ; f_rr = f_redoStack . pop ( ) ; f_displayImage ( ) ; }
private void f_displayImage ( RawRaster raster )
{
ColorPanel cp = new ColorPanel ( ) ;
cp . addRawRasterSelectionListener ( this ) ;
cp . setRawRaster ( raster ) ;
JViewport vp = f_scroller . getViewport ( ) ;
Point save = vp . getViewPosition ( ) ;
vp . setView ( cp ) ;
vp . setViewPosition ( save ) ;
f_frame . add ( f_scroller ) ;
try { f_frame . setMaximum ( true ) ; } catch ( Exception e ) { }
f_frame . setVisible ( true ) ;
}
private void f_displayImage ( ) { f_displayImage ( f_rr ) ; }
private void f_levelsDialog ( ) { System . out . println ( " ) ; }
private void f_curvesDialog ( ) { System . out . println ( " ) ; }
private void f_biasDialog ( ) { System . out . println ( " ) ; }
private void f_monProfDialog ( )
{
JFileChooser dialog = new JFileChooser ( " ) ;
int status = dialog . showOpenDialog ( this ) ;
if ( status != JFileChooser . APPROVE_OPTION )
return ;
final File file = dialog . getSelectedFile ( ) ;
final String filename = file . getPath ( ) ;
System . err . println ( " + filename + " ) ;
f_monProfilePath = filename ;
}
private void f_imageWorkingSpaceDialog ( )
{
JFileChooser dialog = new JFileChooser ( " ) ;
int status = dialog . showOpenDialog ( this ) ;
if ( status != JFileChooser . APPROVE_OPTION )
return ;
final File file = dialog . getSelectedFile ( ) ;
final String filename = file . getPath ( ) ;
System . err . println ( " + filename + " ) ;
f_wsProfilePath = filename ;
}
private void f_new ( )
{
if ( f_srr == null )
return ;
ICC_Profile profile = f_rr . getProfile ( ) ;
f_rr = f_srr ;
f_rr . setProfile ( profile ) ;
f_rrtemp = null ;
f_srr = null ;
f_undoStack . removeAllElements ( ) ;
f_redoStack . removeAllElements ( ) ;
fireBitDepthChangeEvent ( f_rr , f_rr . getBits ( ) ) ;
f_displayImage ( ) ;
}
private void f_openDialog ( )
{
if ( f_wsProfilePath == null )
f_imageWorkingSpaceDialog ( ) ;
JFileChooser dialog = new JFileChooser ( " ) ;
int status = dialog . showOpenDialog ( this ) ;
if ( status != JFileChooser . APPROVE_OPTION )
return ;
File file = dialog . getSelectedFile ( ) ;
final String filename = file . getPath ( ) + " ;
file = new File ( filename ) ;
System . err . println ( " + file . getPath ( ) + " ) ;
try
{
final long length = file . length ( ) ;
byte [ ] array = new byte [ ( int ) length ] ;
System . err . println ( " + length ) ;
System . err . println ( " + ( int ) length + " ) ;
DataInputStream stream = new DataInputStream ( new FileInputStream ( file ) ) ;
stream . readFully ( array ) ;
stream . close ( ) ;
f_rr = ColorPPMFile . decode ( array ) ;
f_rr . setProfile ( f_wsProfile ) ;
f_displayImage ( ) ;
}
catch ( Exception e ) { e . printStackTrace ( ) ; f_shutdown ( ) ; }
}
private void <unk> ( )
{
JFileChooser dialog = new JFileChooser ( " ) ;
int status = dialog . showSaveDialog ( this ) ;
if ( status != JFileChooser . APPROVE_OPTION )
return ;
final File file = dialog . getSelectedFile ( ) ;
final String filename = file . getPath ( ) + " ;
System . err . println ( " + filename + " ) ;
try
{
FileOutputStream stream = new FileOutputStream ( new File ( filename ) ) ;
ColorPPMFile . encode ( f_rr , stream ) ;
}
catch ( Exception e ) { e . printStackTrace ( ) ; f_shutdown ( ) ; }
}
private void f_saveDialog ( ) { f_saveAsDialog ( ) ; }
private void f_saveAsDialog ( )
{
JFileChooser dialog = new JFileChooser ( " ) ;
int status = dialog . showSaveDialog ( this ) ;
if ( status != JFileChooser . APPROVE_OPTION )
return ;
final File file = dialog . getSelectedFile ( ) ;
final String filename = file . getPath ( ) + " ;
System . err . println ( " + filename + " ) ;
try
{
System . err . println ( " + f_rr ) ;
FileOutputStream stream = new FileOutputStream ( new File ( filename ) ) ;
ColorPPMFile . encode ( f_rr , stream ) ;
}
catch ( Exception e ) { e . printStackTrace ( ) ; f_shutdown ( ) ; }
}
private void f_shutdown ( ) { dispose ( ) ; System . exit ( <num> ) ; }
public static void main ( String [ ] args )
{
Main app = new Main ( ) ;
app . setSize ( <num> , <num> ) ;
Methods . centerWindow ( app ) ;
app . setVisible ( true ) ;
}
private RawRaster <unk> ( RawRaster src )
{
return src ;
}
}
package com . crinqle . dlroom . event ;
public interface RawRasterSelectionListener
{
void subrasterSelected ( Object source , com . crinqle . dlroom . RawRaster rr ) ;
}
package com . crinqle . dlroom . test ;
import static com . crinqle . dlroom . Const . ALL_MASK ;
import static com . crinqle . dlroom . Const . B ;
import static com . crinqle . dlroom . Const . B_MASK ;
import static com . crinqle . dlroom . Const . G ;
import static com . crinqle . dlroom . Const . G_MASK ;
import static com . crinqle . dlroom . Const . H_MASK ;
import static com . crinqle . dlroom . Const . R ;
import static com . crinqle . dlroom . Const . R_MASK ;
import com . crinqle . dlroom . CaptureData ;
import com . crinqle . dlroom . RawRaster ;
public class InterpProf {
public static RawRaster [ ] [ ] createImages ( String [ ] args ) {
RawRaster [ ] [ ] rra = new RawRaster [ <num> ] [ <num> ] ;
if ( args . length < <num> ) {
System . err
. println ( " ) ;
System . exit ( <num> ) ;
}
try {
com . crinqle . dlroom . codec . RawCodec codec = com . crinqle . dlroom . codec . RawCodec
. getInstance ( new java . io . File ( args [ <num> ] ) ) ;
CaptureData cd = codec . decode ( ) ;
RawRaster rrR = new RawRaster ( cd ) ;
RawRaster rrG = new RawRaster ( cd ) ;
RawRaster rrH = new RawRaster ( cd ) ;
RawRaster rrB = new RawRaster ( cd ) ;
rrR . interpolate ( R_MASK ) ;
rrG . interpolate ( G_MASK | H_MASK ) ;
rrH . interpolate ( ALL_MASK ) ;
rrB . interpolate ( B_MASK ) ;
if ( args . length > <num> ) {
final double gamma = Double . parseDouble ( args [ <num> ] ) ;
System . err . println ( " + gamma + " ) ;
rrR . applyGamma ( gamma ) ;
rrG . applyGamma ( gamma ) ;
rrH . applyGamma ( gamma ) ;
rrB . applyGamma ( gamma ) ;
}
final int bits = cd . getBits ( ) ;
shift ( rrR , bits ) ;
shift ( rrG , bits ) ;
shift ( rrH , bits ) ;
shift ( rrB , bits ) ;
rra [ <num> ] [ <num> ] = rrR ;
rra [ <num> ] [ <num> ] = rrG ;
rra [ <num> ] [ <num> ] = rrH ;
rra [ <num> ] [ <num> ] = rrB ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
return rra ;
}
public static void main ( String [ ] args ) {
createImages ( args ) ;
}
private static void shift ( RawRaster rr , int bits ) {
if ( bits != <num> ) {
final int shift = Math . abs ( bits  <num> ) ;
final int w = rr . getWidth ( ) ;
final int h = rr . getHeight ( ) ;
System . err . println ( " ) ;
for ( int y = <num> ; y < h ; ++ y )
for ( int x = <num> ; x < w ; ++ x ) {
rr . setSample ( x , y , R , rr . getSample ( x , y , R ) >> <num> ) ;
rr . setSample ( x , y , G , rr . getSample ( x , y , G ) >> <num> ) ;
rr . setSample ( x , y , B , rr . getSample ( x , y , B ) >> <num> ) ;
}
}
}
}
package com . crinqle . dlroom ;
import java . awt . color . * ;
public class ImageInfo
{
public int order = <num> ;
public long timestamp = <num> ;
public float [ ] preMul = new float [ <num> ] ;
public int cameraRed = <num> ;
public int <unk> = <num> ;
public int cameraBlue = <num> ;
public int rgb_max = <num> ;
public int black = <num> ;
public int colors = <num> ;
public boolean <unk> = false ;
public boolean <unk> = false ;
public boolean <unk> = false ;
public int <unk> = <num> ;
public String make = " ;
public String model = " ;
public int height = <num> ;
public int width = <num> ;
public int filters = <num> ;
public int rawWidth = <num> ;
public int rawHeight = <num> ;
public ICC_Profile <unk> ;
public int table = <num> ;
}
package com . crinqle . dlroom ;
import java . util . * ;
public class RasterStack
{
private Stack < RawRaster > f_s = new Stack < RawRaster > ( ) ;
public boolean empty ( ) { return f_s . empty ( ) ; }
public void removeAllElements ( ) { f_s . removeAllElements ( ) ; }
public RawRaster peek ( )
{
try
{
return ( RawRaster ) f_s . peek ( ) ;
}
catch ( EmptyStackException e ) { System . err . println ( " ) ; return null ; }
}
public RawRaster pop ( )
{
return f_s . pop ( ) ;
}
public void push ( RawRaster rr )
{
f_s . add ( rr ) ;
}
public RawRaster first ( )
{
return f_s . firstElement ( ) ;
}
public RawRaster get ( int n )
{
return f_s . get ( n ) ;
}
}
package com . crinqle . dlroom . math ;
public class Cubic
{
private float a , b , c , d ;
public Cubic ( float a , float b , float c , float d )
{
this . a = a ;
this . b = b ;
this . c = c ;
this . d = d ;
}
public float eval ( float u ) { return ( ( ( d * u ) + c ) * u + b ) * u + a ; }
}
package com . crinqle . dlroom . math ;
import javax . swing . JFrame ;
import com . crinqle . dlroom . Const ;
import com . crinqle . dlroom . CurvePanel ;
public class SplineFrame extends JFrame {
public SplineFrame ( ) {
super ( " ) ;
int channel = Const . R ;
int dim = <num> ;
int bits = <num> ;
NatCubic f_c = new NatCubic ( channel , dim , bits ) ;
final int x0 = <num> ;
final int y0 = <num> ;
final int xf = <num> ;
final int yf = <num> ;
final int x1 = <num> ;
final int y1 = <num> ;
f_c . addPoint ( x0 , y0 ) ;
f_c . addPoint ( x1 , y1 ) ;
f_c . addPoint ( xf , yf ) ;
CurvePanel panel = new CurvePanel ( f_c ) ;
setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
setContentPane ( panel ) ;
}
public static void main ( String [ ] args ) {
SplineFrame frame = new SplineFrame ( ) ;
frame . pack ( ) ;
frame . setVisible ( true ) ;
}
}
package com . crinqle . dlroom . cms ;
import java . awt . color . * ;
public class <unk>
{
public int [ ] <unk> ( ICC_ProfileRGB input , ICC_ProfileRGB output , int [ ] data )
{
return new int [ <num> ] ;
}
public int [ ] <unk> ( ICC_ProfileRGB input , ICC_ProfileRGB output , int [ ] data )
{
return new int [ <num> ] ;
}
public int [ ] <unk> ( ICC_ProfileRGB input , ICC_ProfileRGB output , int [ ] data )
{
return new int [ <num> ] ;
}
private native int [ ] displayXform ( float [ ] input , float [ ] output , int [ ] data ) ;
private native int [ ] displayXform ( float [ ] input , double outGamma , float [ ] output , int [ ] data ) ;
private native int [ ] displayXform ( double <unk> , float [ ] input , double outGamma , float [ ] output , int [ ] data ) ;
}
package com . crinqle . dlroom ;
import java . awt . BorderLayout ;
import java . util . Collection ;
import java . util . LinkedList ;
import javax . swing . JPanel ;
import javax . swing . border . BevelBorder ;
import javax . swing . border . Border ;
import javax . swing . border . CompoundBorder ;
import javax . swing . border . EmptyBorder ;
import com . crinqle . dlroom . event . BitDepthChangeListener ;
import com . crinqle . dlroom . event . LUTChangeListener ;
import com . crinqle . dlroom . math . SplinePanel ;
public class CurvePanel extends JPanel implements LUTChangeListener ,
BitDepthChangeListener {
private SplinePanel f_sp ;
private Collection < LUTChangeListener > f_listeners = new LinkedList < LUTChangeListener > ( ) ;
public CurvePanel ( int channel , int bits ) {
f_sp = new SplinePanel ( channel , bits ) ;
f_sp . addLUTChangeListener ( this ) ;
JPanel <unk> = new JPanel ( ) ;
Border matte = new EmptyBorder ( <num> , <num> , <num> , <num> ) ;
Border etch = new BevelBorder ( BevelBorder . LOWERED ) ;
Border border = new CompoundBorder ( matte , etch ) ;
setBorder ( border ) ;
setLayout ( new BorderLayout ( ) ) ;
add ( f_sp , BorderLayout . CENTER ) ;
}
public void applyLUT ( Object source , LUT lut ) {
fireLUTChangeEvent ( lut ) ;
}
public void updateBits ( Object source , int bits ) {
f_sp . updateBits ( source , bits ) ;
}
public void addLUTChangeListener ( LUTChangeListener l ) {
f_listeners . add ( l ) ;
}
protected void fireLUTChangeEvent ( LUT lut ) {
for ( LUTChangeListener l : f_listeners )
l . applyLUT ( this , lut ) ;
}
}
package com . crinqle . dlroom . codec ;
import java . io . * ;
abstract class RawImageFile implements Seekable
{
protected RandomAccessFile f_rif ;
protected int f_order = <num> ;
RawImageFile ( File file ) throws IOException
{
f_rif = new RandomAccessFile ( file , " ) ;
}
public static RawImageFile getInstance ( File file ) throws IOException
{
RandomAccessFile raf = new RandomAccessFile ( file , " ) ;
RawImageFile rif = null ;
final int order = raf . readShort ( ) ;
if ( order == <num> )
rif = new LSBRawImageFile ( file ) ;
else
rif = new MSBRawImageFile ( file ) ;
rif . f_order = order ;
rif . skipBytes ( <num> ) ;
return rif ;
}
public int order ( ) { return f_order ; }
public long getPosition ( ) throws IOException { return f_rif . getFilePointer ( ) ; }
public long seek ( long n ) throws IOException { f_rif . seek ( n ) ; return n ; }
public int skipBytes ( int n ) throws IOException { return f_rif . skipBytes ( n ) ; }
public int bits ( int n ) throws Exception { throw new Exception ( " ) ; }
public int read ( ) throws IOException { return f_rif . read ( ) ; }
public int read ( byte [ ] b ) throws IOException { return f_rif . read ( b ) ; }
public int read ( byte [ ] b , int offset , int length ) throws IOException { return f_rif . read ( b , offset , length ) ; }
public int readFully ( byte [ ] b , int offset , int length ) throws IOException { f_rif . readFully ( b , offset , length ) ; return length ; }
}
class LSBRawImageFile extends RawImageFile
{
LSBRawImageFile ( File file ) throws IOException
{
super ( file ) ;
}
public int read2 ( ) throws IOException
{
final int a = read ( ) ;
final int b = read ( ) ;
return a | ( b << <num> ) ;
}
public int read4 ( ) throws IOException
{
final int a = read ( ) ;
final int b = read ( ) ;
final int c = read ( ) ;
final int d = read ( ) ;
return a | ( b << <num> ) | ( c << <num> ) | ( d << <num> ) ;
}
}
class MSBRawImageFile extends RawImageFile
{
MSBRawImageFile ( File file ) throws IOException
{
super ( file ) ;
}
public int read2 ( ) throws IOException
{
return f_rif . readShort ( ) ;
}
public int read4 ( ) throws IOException
{
return f_rif . readInt ( ) ;
}
}
package com . crinqle . dlroom . util ;
import java . awt . * ;
import javax . swing . * ;
public class Methods
{
public static void centerWindow ( Window w )
{
Toolkit kit = Toolkit . getDefaultToolkit ( ) ;
Dimension total = kit . getScreenSize ( ) ;
Dimension size = w . getSize ( ) ;
int x = ( total . width  size . width ) >> <num> ;
int y = ( total . height  size . height ) >> <num> ;
w . setLocation ( x , y ) ;
}
}
package com . crinqle . dlroom . codec ;
import java . awt . color . * ;
import java . io . * ;
import java . util . * ;
import static com . crinqle . dlroom . Const . * ;
import com . crinqle . dlroom . * ;
import com . crinqle . dlroom . util . * ;
class CanonEOSD30 extends RawCodec
{
public static final int BIT_DEPTH = <num> ;
public static final int <unk> = <num>  BIT_DEPTH ;
protected CaptureData f_cd = null ;
protected HuffmanTree f_ht1 = null ;
protected HuffmanTree f_ht2 = null ;
private int f_carry = <num> ;
private int f_pixelIndex = <num> ;
private int [ ] f_base = new int [ <num> ] ;
protected int <unk> = <num> ;
CanonEOSD30 ( RawImageFile rif , int size , ImageInfo info )
{
super ( rif , size , info ) ;
f_info . height = <num> ;
f_info . width = <num> ;
f_info . filters = <num> ;
f_info . rgb_max = <num> ;
f_info . preMul [ <num> ] = <num> ;
f_info . preMul [ <num> ] = <num> ;
f_info . preMul [ <num> ] = f_info . preMul [ <num> ] = <num> ;
System . err . println ( " + f_info . rawHeight ) ;
System . err . println ( " + f_info . rawWidth ) ;
System . err . println ( " + f_info . height ) ;
System . err . println ( " + f_info . width ) ;
System . err . println ( " + f_info . filters ) ;
System . err . println ( " + f_info . preMul [ <num> ] ) ;
System . err . println ( " + f_info . preMul [ <num> ] ) ;
System . err . println ( " + f_info . preMul [ <num> ] ) ;
System . err . println ( " + f_info . preMul [ <num> ] ) ;
}
public CaptureData decode ( )
{
f_cd = new CaptureData ( f_info . width , f_info . height , FILTER_RGGB , <num> ) ;
f_cd . setImageInfo ( f_info ) ;
final int table = ( f_info . table > <num> ) ? <num> : f_info . table ;
f_info . table = table ;
f_ht1 = new HuffmanTree ( StaticTree . FIRST_TREE [ table ] , <num> ) ;
f_ht2 = new HuffmanTree ( StaticTree . SECOND_TREE [ table ] , <num> ) ;
int black = <num> ;
int black_count = <num> ;
try
{
final byte [ ] array = new byte [ f_size ] ;
f_stream . seek ( <num> ) ;
f_stream . readFully ( array , <num> , f_size ) ;
f_stream = SeekableInputStream . getInstance ( f_info . order , array ) ;
int top = <num> ;
int left = <num> ;
switch ( f_info . rawWidth )
{
case <num> : top = <num> ; left = <num> ; break ;
case <num> : top = <num> ; left = <num> ; break ;
case <num> : top = <num> ; left = <num> ; break ;
case <num> : top = <num> ; left = <num> ; break ;
case <num> : top = <num> ; left = <num> ; break ;
}
final int lowbits = f_canonHasLowbits ( ) ;
if ( lowbits == <num> )
System . err . println ( " ) ;
if ( lowbits == <num> )
System . err . println ( " ) ;
System . err . println ( " + lowbits ) ;
final int hiLocation = <num> + lowbits * f_info . rawHeight * f_info . rawWidth / <num> ;
f_stream . seek ( hiLocation ) ;
int [ ] pixel = new int [ f_info . rawWidth * <num> ] ;
int unfuck_iter = <num> ;
System . err . println ( " + f_info . table + " ) ;
System . err . println ( " + hiLocation + " + f_stream . getPosition ( ) + " ) ;
for ( int row = <num> ; row < f_info . rawHeight ; row += <num> )
{
final long _before_save = f_stream . getPosition ( ) ;
f_unfuck ( pixel , f_info . rawWidth >> <num> , unfuck_iter ) ;
final long _after_save = f_stream . getPosition ( ) ;
System . err . println ( " + ( row ) + " + ( row + <num> ) + " + _before_save + " + _after_save + " + unfuck_iter ) ;
++ unfuck_iter ;
if ( lowbits != <num> )
{
final long save = f_stream . getPosition ( ) ;
f_stream . seek ( <num> + row * f_info . rawWidth / <num> ) ;
int pi = <num> ;
for ( int i = <num> ; i < f_info . rawWidth << <num> ; ++ i )
{
int c = f_stream . read ( ) ;
for ( int r = <num> ; r < <num> ; r += <num> )
{
pixel [ pi ] = ( pixel [ pi ] << <num> ) + ( ( c >> r ) & <num> ) ;
while ( pixel [ pi ] >= <num> )
pixel [ pi ] -= <num> ;
++ pi ;
}
}
f_stream . seek ( save ) ;
}
for ( int r = <num> ; r < <num> ; ++ r )
{
for ( int col = <num> ; col < f_info . rawWidth ; ++ col )
{
final int irow = row + r  top ;
if ( irow >= <num> && irow < f_info . height )
{
if ( col < left )
{
black += pixel [ r * f_info . rawWidth + col ] ;
++ black_count ;
}
else
{
final int i = irow * f_info . width + col  left ;
f_cd . setElem ( i , pixel [ r * f_info . rawWidth + col ] ) ;
}
}
}
}
}
}
catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( <num> ) ; }
System . err . println ( " + black + " + black_count + " ) ;
black = black / ( ( f_info . rawWidth  f_info . width ) * f_info . height ) ;
f_info . black = black ;
System . err . println ( " + black ) ;
f_blackScale ( ) ;
return f_cd ;
}
protected void f_blackScale ( )
{
final int black = f_info . black ;
final int rgb_max = f_info . rgb_max -= black ;
int value ;
int _total_max = <num> ;
int index = <num> ;
for ( int y = <num> ; y < f_info . height ; ++ y )
{
for ( int x = <num> ; x < f_info . width ; ++ x )
{
value = f_cd . getElem ( index )  black ;
if ( value == <num> )
continue ;
if ( value < <num> )
value = <num> ;
else if ( value > rgb_max )
value = rgb_max ;
f_cd . setElem ( index , value ) ;
if ( value > _total_max )
_total_max = value ;
++ index ;
}
}
System . err . println ( " + _total_max ) ;
}
protected void f_unfuck ( int [ ] pixel , final int count , final int iter ) throws Exception
{
HuffmanTree tree = f_ht1 ;
int pi = <num> ;
int [ ] diffbuf = new int [ <num> ] ;
int [ ] leaves = new int [ <num> ] ;
int token =  <num> ;
int zeros = <num> ;
int bitcount = <num> ;
int sign = <num> ;
int diff = <num> ;
for ( int j = <num> ; j < count ; ++ j )
{
tree = f_ht1 ;
for ( int i = <num> ; i < <num> ; ++ i )
{
diffbuf [ i ] = <num> ;
leaves [ i ] =  <num> ;
}
for ( int i = <num> ; i < <num> ; ++ i )
{
try
{
while ( ( token = tree . find ( f_stream . bits ( <num> ) ) ) < <num> )
;
tree = f_ht2 ;
if ( token == <num> && i > <num> )
break ;
if ( token == <num> )
continue ;
zeros = token >> <num> ;
bitcount = token & <num> ;
i += zeros ;
if ( bitcount == <num> )
continue ;
sign = f_stream . bits ( <num> ) ;
diff = f_stream . bits ( bitcount  <num> ) ;
if ( sign == <num> )
diff += <num> << ( bitcount  <num> ) ;
else
diff += (  <num> << bitcount ) + <num> ;
if ( i < <num> )
diffbuf [ i ] = diff ;
}
catch ( Exception e )
{
System . err . println ( ) ;
System . err . println ( " ) ;
System . err . println ( " + iter ) ;
System . err . println ( " + i ) ;
System . err . println ( " + token ) ;
System . err . println ( " ) ;
System . err . println ( ) ;
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
}
diffbuf [ <num> ] += f_carry ;
f_carry = diffbuf [ <num> ] ;
for ( int i = <num> ; i < <num> ; ++ i )
{
if ( f_pixelIndex ++ % f_info . rawWidth == <num> )
f_base [ <num> ] = f_base [ <num> ] = <num> ;
final int pii = pi + i ;
pixel [ pii ] = ( f_base [ i & <num> ] += diffbuf [ i ] ) ;
while ( pixel [ pii ] < <num> )
pixel [ pii ] += <num> ;
while ( pixel [ pii ] >= <num> )
pixel [ pii ] -= <num> ;
}
pi += <num> ;
}
}
private int f_canonHasLowbits ( ) throws Exception
{
byte [ ] test = new byte [ <num> ] ;
int ret = <num> ;
int i ;
f_stream . seek ( <num> ) ;
f_stream . readFully ( test , <num> , <num> ) ;
for ( i = <num> ; i < <num> ; ++ i )
{
if ( test [ i ] == <num> )
{
if ( test [ i + <num> ] != <num> )
return <num> ;
ret = <num> ;
}
}
return ret ;
}
}
package com . crinqle . dlroom . app ;
import javax . swing . * ;
public class Main2 extends JFrame
{
public Main2 ( )
{
}
public static void main ( String [ ] args )
{
Main2 f = new Main2 ( ) ;
f . setContentPane ( new JPanel ( ) ) ;
f . pack ( ) ;
f . setVisible ( true ) ;
}
}
package com . crinqle . dlroom . math ;
import java . awt . Color ;
import java . awt . Graphics ;
import java . awt . Polygon ;
public class NatCubic extends ControlCurve
{
final int <unk> = <num> ;
public NatCubic ( int channel , int dim , int bits ) { super ( channel , dim , bits ) ; }
Cubic [ ] calcNaturalCubic ( int n , int [ ] x )
{
float [ ] gamma = new float [ n + <num> ] ;
float [ ] delta = new float [ n + <num> ] ;
float [ ] D = new float [ n + <num> ] ;
int i ;
gamma [ <num> ] = <num> / <num> ;
for ( i = <num> ; i < n ; i ++ )
gamma [ i ] = <num> / ( <num>  gamma [ i  <num> ] ) ;
gamma [ n ] = <num> / ( <num>  gamma [ n  <num> ] ) ;
delta [ <num> ] = <num> * ( x [ <num> ]  x [ <num> ] ) * gamma [ <num> ] ;
for ( i = <num> ; i < n ; i ++ )
delta [ i ] = ( <num> * ( x [ i + <num> ]  x [ i  <num> ] )  delta [ i  <num> ] ) * gamma [ i ] ;
delta [ n ] = ( <num> * ( x [ n ]  x [ n  <num> ] )  delta [ n  <num> ] ) * gamma [ n ] ;
D [ n ] = delta [ n ] ;
for ( i = n  <num> ; i >= <num> ; i  )
D [ i ] = delta [ i ]  gamma [ i ] * D [ i + <num> ] ;
Cubic [ ] C = new Cubic [ n ] ;
for ( i = <num> ; i < n ; i ++ )
C [ i ] = new Cubic ( ( float ) x [ i ] , D [ i ] , <num> * ( x [ i + <num> ]  x [ i ] )  <num> * D [ i ]  D [ i + <num> ] , <num> * ( x [ i ]  x [ i + <num> ] ) + D [ i ] + D [ i + <num> ] ) ;
return C ;
}
public void paint ( Graphics g )
{
super . paint ( g ) ;
if ( pts . npoints >= <num> )
{
Cubic [ ] X = calcNaturalCubic ( pts . npoints  <num> , pts . xpoints ) ;
Cubic [ ] Y = calcNaturalCubic ( pts . npoints  <num> , pts . ypoints ) ;
Polygon p = new Polygon ( ) ;
p . addPoint ( Math . round ( X [ <num> ] . eval ( <num> ) ) ,
Math . round ( Y [ <num> ] . eval ( <num> ) ) ) ;
int ri = <num> ;
final float max = ( float ) f_dim  ( float ) <num> ;
final int total = f_scale * f_dim ;
final int startgap = f_scale * pts . xpoints [ <num> ] ;
if ( pts . xpoints [ <num> ] != <num> )
for ( ; ri < startgap ; ++ ri )
f_range [ ri ] = ( max  ( float ) pts . ypoints [ <num> ] ) ;
for ( int i = <num> ; i < X . length ; i ++ )
{
int steps = ( pts . xpoints [ i + <num> ]  pts . xpoints [ i ] ) * f_scale ;
if ( i == ( X . length  <num> ) )
steps += f_scale ;
for ( int j = <num> ; j <= steps ; j ++ )
{
float u = j / ( float ) steps ;
final float xfp = X [ i ] . eval ( u ) ;
final float yfp = Y [ i ] . eval ( u ) ;
final int xp = Math . round ( xfp ) ;
final int yp = Math . round ( yfp ) ;
p . addPoint ( xp , yp ) ;
f_range [ ri ++ ] = max  yfp ;
}
}
final int fi = pts . npoints  <num> ;
if ( pts . xpoints [ fi ] != max )
for ( ; ri < total ; ++ ri )
f_range [ ri ] = max  ( float ) pts . ypoints [ fi ] ;
g . setColor ( Color . gray ) ;
g . drawPolyline ( p . xpoints , p . ypoints , p . npoints ) ;
}
}
}
package com . crinqle . dlroom ;
import com . crinqle . dlroom . cfa . * ;
public class CaptureData extends ImageData
{
private ImageInfo f_info ;
private ColorFilterArray f_cfa ;
public CaptureData ( int width , int height , int filterSpec , int bits )
{
super ( width , height , bits ) ;
f_cfa = ColorFilterArray . getInstance ( filterSpec ) ;
}
public CaptureData ( ImageData id , ColorFilterArray cfa )
{
super ( id ) ;
f_cfa = cfa ;
setData ( id . f_a ) ;
}
public ColorFilterArray getCFA ( ) { return f_cfa ; }
public ImageInfo getImageInfo ( ) { return f_info ; }
public void setImageInfo ( ImageInfo info ) { f_info = info ; }
public BandIterator [ ] bandIterators ( ) { return f_cfa . bandIterators ( this ) ; }
public AreaBandIterator [ ] areaBandIterators ( int radius ) { return f_cfa . areaBandIterators ( this , radius ) ; }
public CaptureData subraster ( int x , int y )
{
return subraster ( subset ( x , y ) , x , y ) ;
}
public CaptureData subraster ( int x , int y , int width , int height )
{
return subraster ( subset ( x , y , width , height ) , x , y ) ;
}
private CaptureData subraster ( ImageData id , int x , int y ) { return new CaptureData ( id , f_cfa . arrayAtOffset ( x , y ) ) ; }
}
package com . crinqle . dlroom . math ;
import static com . crinqle . dlroom . Const . ALL_MASK ;
import static com . crinqle . dlroom . Const . SLIDER_SIZE ;
import java . awt . Color ;
import java . awt . Dimension ;
import java . awt . Graphics ;
import java . awt . Polygon ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseListener ;
import java . awt . event . MouseMotionListener ;
import java . util . Collection ;
import java . util . LinkedList ;
import javax . swing . JFrame ;
import javax . swing . JPanel ;
import com . crinqle . dlroom . LUT ;
import com . crinqle . dlroom . event . BitDepthChangeListener ;
import com . crinqle . dlroom . event . LUTChangeListener ;
public class SplinePanel extends JPanel implements MouseListener ,
MouseMotionListener , BitDepthChangeListener {
private ControlCurve f_c ;
private Polygon <unk> = new Polygon ( ) ;
private int f_index =  <num> ;
private LUT f_lut ;
private Collection < LUTChangeListener > f_listeners = new LinkedList < LUTChangeListener > ( ) ;
public SplinePanel ( int channel , int bits ) {
f_c = new NatCubic ( channel , SLIDER_SIZE , bits ) ;
addMouseListener ( this ) ;
addMouseMotionListener ( this ) ;
Dimension size = new Dimension ( SLIDER_SIZE , SLIDER_SIZE ) ;
setPreferredSize ( size ) ;
setMaximumSize ( size ) ;
setMinimumSize ( size ) ;
setBackground ( Color . white ) ;
}
public void addLUTChangeListener ( LUTChangeListener l ) {
f_listeners . add ( l ) ;
}
protected void fireLUTChangeEvent ( ) {
for ( LUTChangeListener l : f_listeners )
l . applyLUT ( this , f_lut ) ;
}
public LUT getLUT ( ) {
return f_lut ;
}
public void addPoint ( int x , int y ) {
if ( x < <num> || y < <num> || x >= SLIDER_SIZE || y >= SLIDER_SIZE )
return ;
f_c . addPoint ( x , <num>  y ) ;
refresh ( ) ;
}
public void updateBits ( Object source , int bits ) {
f_c . updateBits ( source , bits ) ;
}
public void mouseClicked ( MouseEvent evt ) {
}
public void mouseEntered ( MouseEvent evt ) {
}
public void mouseExited ( MouseEvent evt ) {
}
public void mousePressed ( MouseEvent evt ) {
final int x = evt . getX ( ) ;
final int y = evt . getY ( ) ;
f_index = f_c . selectPoint ( x , y ) ;
if ( evt . isShiftDown ( ) )
f_c . removePoint ( ) ;
else if ( f_index < <num> )
f_index = f_c . addPoint ( x , y ) ;
refresh ( ) ;
}
public void mouseReleased ( MouseEvent evt ) {
f_lut = f_c . getLUT ( ) ;
fireLUTChangeEvent ( ) ;
}
public void mouseDragged ( MouseEvent evt ) {
int x = evt . getX ( ) ;
int y = evt . getY ( ) ;
if ( x < <num> )
x = <num> ;
else if ( x > ( SLIDER_SIZE  <num> ) )
x = ( SLIDER_SIZE  <num> ) ;
if ( y < <num> )
y = <num> ;
else if ( y > ( SLIDER_SIZE  <num> ) )
y = ( SLIDER_SIZE  <num> ) ;
f_c . setPoint ( x , y ) ;
refresh ( ) ;
}
public void mouseMoved ( MouseEvent evt ) {
}
public void paintComponent ( Graphics g ) {
super . paintComponent ( g ) ;
f_c . paint ( g ) ;
}
private void refresh ( ) {
repaint ( ) ;
}
public static void main ( String [ ] args ) {
final int argc = args . length ;
int bits = <num> ;
if ( argc > <num> )
bits = Integer . parseInt ( args [ <num> ] ) ;
SplinePanel panel = new SplinePanel ( ALL_MASK , bits ) ;
JFrame frame = new JFrame ( " ) ;
frame . setContentPane ( panel ) ;
frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
frame . pack ( ) ;
frame . setVisible ( true ) ;
}
}
package com . crinqle . dlroom . util ;
import java . util . * ;
public class Base64Like
{
final public static byte PAD = =' ;
final public static byte [ ] CODES = { A' , B' , C' , D' , E' , F' , G' , H' ,
I' , J' , K' , L' , M' , N' , O' , P' ,
Q' , R' , S' , T' , U' , V' , W' , X' ,
Y' , Z' , a' , b' , c' , d' , e' , f' ,
g' , h' , i' , j' , k' , l' , m' , n' ,
o' , p' , q' , r' , s' , t' , u' , v' ,
w' , x' , y' , z' , <num>  , <num>  , <num>  , <num>  ,
4' , <num>  , <num>  , <num>  , <num>  , <num>  , +' , /' ,
=' } ;
final public static int [ ] SYMBOLS = {  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,
1 ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,
1 ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,
1 ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,
1 ,  <num> ,  <num> ,
62 ,
1 ,  <num> ,  <num> ,
<unk> ,
<unk> , <num> ,
54 , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
1 ,  <num> ,
1 , <num> ,  <num> ,  <num> ,  <num> ,
0 , <num> , <num> , <num> , <num> ,
5 , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
15 , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
25 ,
1 ,  <num> ,  <num> ,  <num> ,  <num> ,  <num> ,
26 , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> } ;
public static byte [ ] decode ( byte [ ] code ) throws Exception
{
final int ilen = code . length ;
final int olen = ( ilen >> <num> ) * <num> ;
int ii = <num> ;
int oi = <num> ;
byte [ ] plain = new byte [ olen ] ;
Arrays . fill ( plain , ( byte ) <num> ) ;
do
{
int a = SYMBOLS [ code [ ii ++ ] ] ;
int b = SYMBOLS [ code [ ii ++ ] ] ;
int c = SYMBOLS [ code [ ii ++ ] ] ;
int d = SYMBOLS [ code [ ii ++ ] ] ;
if ( a == <num> || b == <num> )
break ;
plain [ oi ++ ] = ( byte ) ( ( a << <num> ) | ( ( b & <num> ) >> <num> ) ) ;
if ( c == <num> )
break ;
plain [ oi ++ ] = ( byte ) ( ( ( b << <num> ) | ( ( c & <num> ) >> <num> ) ) ) ;
if ( d == <num> )
break ;
plain [ oi ++ ] = ( byte ) ( ( ( c & <num> ) << <num> ) | ( d & <num> ) ) ;
}
while ( ii < ilen ) ;
if ( oi != olen )
{
byte [ ] p = new byte [ oi ] ;
System . arraycopy ( plain , <num> , p , <num> , oi ) ;
return p ;
}
return plain ;
}
public static byte [ ] encode ( byte [ ] plain )
{
final int ilen = plain . length ;
final int mod3 = ilen % <num> ;
final int rem3 = <num>  mod3 ;
final int ilenPadded = ilen + rem3 ;
final int olen = ( ilenPadded * <num> ) / <num> ;
System . err . println ( " + ilen + " + olen + " ) ;
int oi = <num> ;
int ii = <num> ;
byte [ ] code = new byte [ olen ] ;
Arrays . fill ( code , ( byte ) <num> ) ;
while ( ii < ilen )
{
int x = ( plain [ ii ++ ] ) ;
if ( x < <num> ) x += <num> ;
code [ oi ++ ] = CODES [ x >> <num> ] ;
if ( ii < ilen )
{
int y = ( plain [ ii ++ ] ) ;
if ( y < <num> ) y += <num> ;
code [ oi ++ ] = CODES [ ( ( x & <num> ) << <num> ) | ( y >> <num> ) ] ;
if ( ii < ilen )
{
int z = ( plain [ ii ++ ] ) ;
if ( z < <num> ) z += <num> ;
code [ oi ++ ] = CODES [ ( ( y & <num> ) << <num> ) | ( z >> <num> ) ] ;
code [ oi ++ ] = CODES [ z & <num> ] ;
}
else
{
code [ oi ++ ] = CODES [ ( y & <num> ) << <num> ] ;
code [ oi ++ ] = CODES [ <num> ] ;
break ;
}
}
else
{
code [ oi ++ ] = CODES [ ( x & <num> ) << <num> ] ;
code [ oi ++ ] = CODES [ <num> ] ;
code [ oi ++ ] = CODES [ <num> ] ;
break ;
}
}
while ( oi < olen )
code [ oi ++ ] = PAD ;
return code ;
}
public static void main ( String [ ] args )
{
try
{
byte [ ] plain = new byte [ <num> ] ;
for ( int i = <num> ; i < <num> ; ++ i )
plain [ i ] = ( byte ) i ;
System . out . print ( " ) ;
for ( int i = <num> ; i < <num> ; ++ i )
System . out . print ( " + i ) ;
System . out . println ( ) ;
byte [ ] code = Base64Like . encode ( plain ) ;
String codeString = new String ( code ) ;
System . out . println ( " + codeString ) ;
byte [ ] recovered = Base64Like . decode ( code ) ;
System . out . print ( " ) ;
for ( int i = <num> ; i < <num> ; ++ i )
System . out . print ( " + i ) ;
System . out . println ( ) ;
for ( int i = <num> ; i < <num> ; ++ i )
if ( recovered [ i ] != plain [ i ] )
System . out . println ( " + recovered [ i ] + " + plain [ i ] + " + i ) ;
final int argc = args . length ;
for ( int i = <num> ; i < argc ; ++ i )
{
plain = args [ i ] . getBytes ( ) ;
byte [ ] encoding = Base64Like . encode ( plain ) ;
byte [ ] decoding = Base64Like . decode ( encoding ) ;
if ( Arrays . equals ( plain , decoding ) == false )
System . err . println ( " + new String ( plain ) + " + new String ( decoding ) + " ) ;
System . out . println ( " + i + " + new String ( decoding ) ) ;
}
}
catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( <num> ) ; }
}
}
package com . crinqle . dlroom . math ;
import java . awt . * ;
import com . crinqle . dlroom . * ;
import com . crinqle . dlroom . event . * ;
public abstract class ControlCurve implements BitDepthChangeListener
{
static final int EPSILON = <num> ;
private final int f_chan ;
protected final int f_dim ;
private int f_bits ;
protected int f_max ;
protected int f_scale ;
protected float [ ] f_range ;
protected Polygon pts ;
protected int selection =  <num> ;
public ControlCurve ( int channel , int dim , int bits )
{
f_chan = channel ;
f_dim = dim ;
f_bits = bits ;
f_max = <num> << f_bits ;
f_scale = f_max / f_dim ;
f_range = new float [ f_max ] ;
pts = new Polygon ( ) ;
pts . addPoint ( <num> , f_dim  <num> ) ;
pts . addPoint ( f_dim  <num> , <num> ) ;
}
public LUT getLUT ( ) { LUT lut = new LUT ( f_chan , f_range , ( float ) f_dim , f_max  <num> ) ; return lut ; }
public void updateBits ( Object source , int bits ) { f_bits = bits ; f_max = <num> << f_bits ; f_scale = f_max / f_dim ; f_range = new float [ f_max ] ; }
public void paint ( Graphics g )
{
int [ ] xs = pts . xpoints ;
int [ ] ys = pts . ypoints ;
int n = pts . npoints ;
if ( xs [ <num> ] != <num> )
g . drawLine ( xs [ <num> ] , ys [ <num> ] , <num> , ys [ <num> ] ) ;
if ( xs [ n  <num> ] != ( f_dim  <num> ) )
g . drawLine ( xs [ n  <num> ] , ys [ n  <num> ] , f_dim  <num> , ys [ n  <num> ] ) ;
for ( int i = <num> ; i < n ; i ++ )
{
final int x = xs [ i ] ;
final int y = ys [ i ] ;
g . fillRect ( x  <num> , y  <num> , <num> , <num> ) ;
}
}
public int selectPoint ( int x , int y )
{
int mind = Integer . MAX_VALUE ;
selection =  <num> ;
for ( int i = <num> ; i < pts . npoints ; i ++ )
{
int d = sqr ( pts . xpoints [ i ]  x ) + sqr ( pts . ypoints [ i ]  y ) ;
if ( d < mind && d < EPSILON )
{
mind = d ;
selection = i ;
}
}
return selection ;
}
static int sqr ( int x ) { return x * x ; }
public int addPoint ( int x , int y )
{
final int n = pts . npoints ;
int [ ] xs = pts . xpoints ;
int [ ] ys = pts . ypoints ;
pts . addPoint ( xs [ n  <num> ] , ys [ n  <num> ] ) ;
pts . xpoints [ n  <num> ] = x ;
pts . ypoints [ n  <num> ] = y ;
pts = sortPoints ( ) ;
return selectPoint ( x , y ) ;
}
public void setPoint ( int x , int y )
{
if ( selection >= <num> )
{
pts . xpoints [ selection ] = x ;
pts . ypoints [ selection ] = y ;
}
}
protected Polygon sortPoints ( )
{
Polygon p = new Polygon ( pts . xpoints , pts . ypoints , pts . npoints ) ;
int [ ] xs = p . xpoints ;
int [ ] ys = p . ypoints ;
final int n = p . npoints ;
int temp ;
for ( int j = <num> ; j < n ; ++ j )
for ( int i = ( j + <num> ) ; i < n ; ++ i )
{
if ( xs [ j ] > xs [ i ] )
{
temp = xs [ i ] ;
xs [ i ] = xs [ j ] ;
xs [ j ] = temp ;
temp = ys [ i ] ;
ys [ i ] = ys [ j ] ;
ys [ j ] = temp ;
}
}
return p ;
}
public void removePoint ( )
{
if ( selection >= <num> )
{
pts . npoints  ;
for ( int i = selection ; i < pts . npoints ; i ++ )
{
pts . xpoints [ i ] = pts . xpoints [ i + <num> ] ;
pts . ypoints [ i ] = pts . ypoints [ i + <num> ] ;
}
}
}
public String toString ( )
{
StringBuffer result = new StringBuffer ( ) ;
for ( int i = <num> ; i < pts . npoints ; i ++ )
result . append ( " + pts . xpoints [ i ] + " + pts . ypoints [ i ] ) ;
return result . toString ( ) ;
}
}
package com . crinqle . dlroom ;
import java . awt . Dimension ;
import java . awt . GridBagConstraints ;
import java . awt . GridBagLayout ;
import java . util . Collection ;
import java . util . LinkedList ;
import javax . swing . JLabel ;
import javax . swing . JPanel ;
import javax . swing . JSlider ;
import javax . swing . JSpinner ;
import javax . swing . JTextField ;
import javax . swing . SpinnerModel ;
import javax . swing . event . ChangeEvent ;
import javax . swing . event . ChangeListener ;
import com . crinqle . dlroom . event . BitDepthChangeListener ;
import com . crinqle . dlroom . event . LUTChangeListener ;
import static com . crinqle . dlroom . Const . * ;
public class LevelSliderPanel extends JPanel implements ChangeListener ,
BitDepthChangeListener {
private final int f_chan ;
private int f_bits ;
private int f_max ;
private JSlider f_sl ;
private JTextField f_tf ;
private JSpinner f_sp ;
private SpinnerModel <unk> ;
private LUT f_lut = null ;
private Collection < LUTChangeListener > f_listeners = new LinkedList < LUTChangeListener > ( ) ;
public LevelSliderPanel ( int channel , int bits ) {
f_chan = channel ;
f_bits = bits ;
f_max = <num> << f_bits ;
f_sl = new JSlider ( JSlider . VERTICAL ,  <num> , <num> , <num> ) ;
f_sl . addChangeListener ( this ) ;
f_sl . <unk> ( <num> ) ;
f_sl . setMajorTickSpacing ( <num> ) ;
f_sl . <unk> ( true ) ;
JLabel label = new JLabel ( CHANNEL_NICKNAME [ channel ] ) ;
label . setHorizontalAlignment ( JTextField . RIGHT ) ;
f_tf = new JTextField ( " ) ;
f_tf . setHorizontalAlignment ( JTextField . RIGHT ) ;
GridBagLayout bag = new GridBagLayout ( ) ;
GridBagConstraints gc = new GridBagConstraints ( ) ;
JPanel sliders = new JPanel ( ) ;
sliders . setLayout ( bag ) ;
gc . fill = GridBagConstraints . VERTICAL ;
gc . gridy = <num> ;
bag . setConstraints ( f_sl , gc ) ;
gc . fill = GridBagConstraints . NONE ;
gc . gridwidth = <num> ;
gc . gridy = <num> ;
bag . setConstraints ( label , gc ) ;
gc . gridy = <num> ;
bag . setConstraints ( f_tf , gc ) ;
sliders . add ( label ) ;
sliders . add ( f_sl ) ;
sliders . add ( f_tf ) ;
add ( sliders ) ;
setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
}
public void addLUTChangeListener ( LUTChangeListener l ) {
f_listeners . add ( l ) ;
}
protected void fireLUTChangeEvent ( ) {
for ( LUTChangeListener l : f_listeners )
l . applyLUT ( this , f_lut ) ;
}
public void updateBits ( Object source , int bits ) {
f_bits = bits ;
f_max = <num> << f_bits ;
}
public void stateChanged ( ChangeEvent evt ) {
Object obj = evt . getSource ( ) ;
if ( obj == f_sl ) {
final float val = <num> + ( float ) f_sl . getValue ( ) / <num> ;
String text = Float . toString ( val ) ;
if ( text . length ( ) > <num> )
text = text . substring ( <num> , <num> ) ;
else if ( text . length ( ) < <num> )
text = text + " ;
f_tf . setText ( text ) ;
final float [ ] array = new float [ f_max ] ;
for ( int i = <num> ; i < f_max ; ++ i )
array [ i ] = ( i * ( float ) val ) ;
final float max = array [ f_max  <num> ] ;
f_lut = new LUT ( f_chan , array , f_max  <num> ) ;
fireLUTChangeEvent ( ) ;
}
}
}
package com . crinqle . dlroom . cfa ;
import com . crinqle . dlroom . * ;
class BayerAreaBandIterator extends BayerBandIterator implements AreaBandIterator
{
private final int f_d ;
private int [ ] f_array ;
BayerAreaBandIterator ( ImageData id , int x , int y , int radius )
{
super ( id , x , y , radius ) ;
f_d = ( f_r * <num> ) + <num> ;
f_array = new int [ f_d * f_d ] ;
}
public int [ ] getArea ( )
{
final int dx = f_x  f_r ;
final int dy = f_y  f_r ;
int k = <num> ;
for ( int y = <num> ; y < f_d ; ++ y )
for ( int x = <num> ; x < f_d ; ++ x )
f_array [ k ++ ] = f_id . getElem ( ( x + dx ) + ( ( y + dy ) * f_w ) ) ;
return f_array ;
}
public void set ( int band , int val ) { f_id . setElem ( band * f_total + index ( ) , val ) ; }
}
package com . crinqle . dlroom . util ;
import javax . swing . * ;
import javax . swing . border . * ;
public class EtchedTitledPanel extends JPanel implements
com . crinqle . dlroom . Const {
public EtchedTitledPanel ( String title ) {
Border etch = new EtchedBorder ( EtchedBorder . LOWERED ) ;
Border name = new TitledBorder ( etch , title ) ;
this . setBorder ( name ) ;
}
}
package com . crinqle . dlroom . codec ;
import java . io . * ;
public interface Seekable
{
long getPosition ( ) throws IOException ;
int read4 ( ) throws IOException ;
int read2 ( ) throws IOException ;
long seek ( long n ) throws IOException ;
int skipBytes ( int n ) throws IOException ;
int bits ( int n ) throws Exception ;
int read ( ) throws IOException ;
int read ( byte [ ] b ) throws IOException ;
int read ( byte [ ] b , int offset , int length ) throws IOException ;
int readFully ( byte [ ] b , int offset , int length ) throws IOException ;
}
package com . crinqle . dlroom . cfa ;
public interface Interpolation
{
void interpolate ( int mask ) ;
}
package com . crinqle . dlroom . util ;
import java . util . * ;
public class Binary
{
public static int toInt ( String s )
{
final int length = ( s . length ( ) > <num> ) ? <num> : s . length ( ) ;
int n = <num> ;
for ( int i = <num> ; i < length ; ++ i )
n = ( ( n | ( ( s . charAt ( i ) == <num>  ) ? <num> : <num> ) ) << <num> ) ;
return n ;
}
public static String toBinary ( byte n )
{
String s = " ;
for ( int i = <num> ; i < <num> ; ++ i )
{
s = ( ( ( n & <num> ) == <num> ) ? " : " ) + s ;
n >>= <num> ;
}
return s ;
}
public static String toBinary ( short n )
{
String s = " ;
for ( int i = <num> ; i < <num> ; ++ i )
{
s = ( ( ( n & <num> ) == <num> ) ? " : " ) + s ;
n >>= <num> ;
}
return s ;
}
public static String toBinary ( char n )
{
String s = " ;
for ( int i = <num> ; i < <num> ; ++ i )
{
s = ( ( ( n & <num> ) == <num> ) ? " : " ) + s ;
n >>= <num> ;
}
return s ;
}
public static String toBinary ( int n )
{
String s = " ;
for ( int i = <num> ; i < <num> ; ++ i )
{
s = ( ( ( n & <num> ) == <num> ) ? " : " ) + s ;
n >>= <num> ;
}
return s ;
}
public static String toBinary ( long n )
{
String s = " ;
for ( int i = <num> ; i < <num> ; ++ i )
{
s = ( ( ( n & <num> ) == <num> ) ? " : " ) + s ;
n >>= <num> ;
}
return s ;
}
public static void main ( String args [ ] )
{
System . out . println ( " + toBinary ( ( byte ) <num> ) ) ;
System . out . println ( " + toBinary ( ( short ) <num> ) ) ;
System . out . println ( " + toBinary ( ( int ) <num> ) ) ;
System . out . println ( " + toBinary ( ( long ) <num> ) ) ;
}
}
package com . crinqle . dlroom . codec ;
import java . awt . color . * ;
import java . io . * ;
import java . util . * ;
import com . crinqle . dlroom . * ;
public abstract class RawCodec
{
protected Seekable f_stream ;
protected final int f_size ;
protected ImageInfo f_info ;
private static int [ ] f_table = new int [ <num> ] ;
private static int f_tableCount = <num> ;
public static int getTableCount ( ) { return f_tableCount ; }
public static int [ ] <unk> ( ) { return f_table ; }
RawCodec ( Seekable stream , int size , ImageInfo info )
{
f_stream = stream ;
f_size = size ;
f_info = info ;
}
public static RawCodec getInstance ( File file ) throws Exception
{
final int fsize = ( int ) file . length ( ) ;
RawImageFile rif = RawImageFile . getInstance ( file ) ;
RawCodec codecImpl = null ;
ImageInfo info = new ImageInfo ( ) ;
info . order = rif . order ( ) ;
final int hlen = rif . read4 ( ) ;
byte [ ] headBytes = new byte [ <num> ] ;
rif . read ( headBytes , <num> , <num> ) ;
final String head = new String ( headBytes ) ;
rif . seek ( <num> ) ;
final int magic = rif . read4 ( ) ;
if ( info . order == <num> || info . order == <num> )
{
if ( head . startsWith ( " ) )
{
sf_parseCiff ( rif , info , hlen , fsize  hlen ) ;
}
}
boolean <unk> = info . make . startsWith ( " ) ;
if ( info . model . equalsIgnoreCase ( " ) )
codecImpl = new CanonEOSD30 ( rif , fsize , info ) ;
return codecImpl ;
}
public abstract CaptureData decode ( ) ;
private static void sf_parseCiff ( RawImageFile file , ImageInfo info , final int offset , final int length ) throws IOException
{
int wbi = <num> ;
file . seek ( offset + ( length  <num> ) ) ;
final int tboff = file . read4 ( ) + offset ;
System . err . println ( " + tboff ) ;
file . seek ( tboff ) ;
final int nrecs = file . read2 ( ) ;
System . err . println ( " + nrecs ) ;
for ( int i = <num> ; i < nrecs ; ++ i )
{
final int type = file . read2 ( ) ;
final int len = file . read4 ( ) ;
final int roff = file . read4 ( ) ;
final int aoff = offset + roff ;
final int save = ( int ) file . getPosition ( ) ;
System . err . println ( ) ;
System . err . println ( " + i + " ) ;
System . err . println ( " + len ) ;
System . err . println ( " + roff ) ;
System . err . println ( " + aoff ) ;
System . err . println ( " + save ) ;
byte [ ] make = new byte [ <num> ] ;
byte [ ] model = new byte [ <num> ] ;
byte [ ] <unk> = new byte [ <num> ] ;
for ( int n = <num> ; n < <num> ; ++ n )
make [ i ] = model [ i ] = model [ <num> ] = <num> ;
switch ( type )
{
case <num> :
System . err . println ( " ) ;
file . seek ( aoff ) ;
file . readFully ( make , <num> , <num> ) ;
int l = <num> ;
while ( make [ ++ l ] != <num> )
;
info . make = new String ( make , <num> , l ) ;
file . seek ( aoff + info . make . length ( ) + <num> ) ;
file . readFully ( model , <num> , <num> ) ;
l = <num> ;
while ( model [ ++ l ] != <num> )
;
info . model = new String ( model , <num> , l ) . trim ( ) ;
break ;
case <num> :
System . err . println ( " ) ;
file . seek ( aoff + <num> ) ;
wbi = file . read2 ( ) ;
break ;
case <num> :
{
System . err . println ( " ) ;
file . seek ( aoff + <num> ) ;
final int a = file . read2 ( ) ;
final int b = file . read2 ( ) ;
final int c = file . read2 ( ) ;
final int d = file . read2 ( ) ;
System . err . println ( " + a ) ;
System . err . println ( " + b ) ;
System . err . println ( " + c ) ;
System . err . println ( " + d ) ;
if ( a == <num> )
info . cameraRed = <num> ;
else
info . cameraRed = b / a ;
if ( d == <num> )
info . cameraBlue = <num> ;
else
info . cameraBlue = c / d ;
System . err . println ( " + wbi + " + info . cameraRed + " + info . cameraBlue + " ) ;
break ;
}
case <num> :
System . err . println ( " ) ;
if ( info . model . equals ( " ) )
{
file . seek ( aoff + <num> ) ;
final int a = file . read2 ( ) ;
final int b = file . read2 ( ) ;
final int c = file . read2 ( ) ;
final int d = file . read2 ( ) ;
System . err . println ( " + a ) ;
System . err . println ( " + b ) ;
System . err . println ( " + c ) ;
System . err . println ( " + d ) ;
info . cameraRed = b / a ;
info . cameraBlue = c / d ;
if ( wbi == <num> )
info . cameraRed = info . cameraBlue = <num> ;
System . err . println ( " + wbi + " + info . cameraRed + " + info . cameraBlue + " ) ;
}
break ;
case <num> :
System . err . println ( " ) ;
file . seek ( aoff + <num> + ( wbi << <num> ) ) ;
info . cameraRed = file . read2 ( ) ;
info . cameraRed /= file . read2 ( ) ;
info . cameraBlue = file . read2 ( ) ;
info . cameraBlue = file . read2 ( ) / info . cameraBlue ;
break ;
case <num> :
System . err . println ( " ) ;
file . seek ( aoff + <num> ) ;
info . rawWidth = file . read2 ( ) ;
info . rawHeight = file . read2 ( ) ;
break ;
case <num> :
System . err . println ( " ) ;
file . seek ( aoff ) ;
info . timestamp = file . read4 ( ) ;
break ;
case <num> :
System . err . println ( " ) ;
file . seek ( aoff ) ;
info . table = file . read4 ( ) ;
System . err . println ( " + info . table ) ;
break ;
}
if ( type >> <num> == <num> || type >> <num> == <num> )
{
System . err . println ( " ) ;
sf_parseCiff ( file , info , aoff , len ) ;
}
file . seek ( save ) ;
}
}
public static void main ( String [ ] args )
{
try
{
RawCodec codec = RawCodec . getInstance ( new File ( args [ <num> ] ) ) ;
final Calendar start = Calendar . getInstance ( ) ;
CaptureData data = codec . decode ( ) ;
final Calendar stop = Calendar . getInstance ( ) ;
System . err . println ( " +
( ( stop . getTimeInMillis ( )  start . getTimeInMillis ( ) ) / <num> ) +
" ) ;
}
catch ( Exception e )
{
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
}
}
package com . crinqle . dlroom . cfa ;
import static com . crinqle . dlroom . Const . * ;
import com . crinqle . dlroom . * ;
class BayerCFA extends ColorFilterArray
{
BayerCFA ( int filterSpec )
{
super ( filterSpec ) ;
f_bc = <num> ;
}
public AreaBandIterator [ ] areaBandIterators ( ImageData id , int radius )
{
switch ( f_fs )
{
case FILTER_BGGR :
f_abis [ B ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ H ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ G ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ R ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
break ;
case FILTER_GRBG :
f_abis [ G ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ R ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ B ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ H ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
break ;
case FILTER_GBRG :
f_abis [ H ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ B ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ G ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ R ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
break ;
case FILTER_RGGB :
f_abis [ R ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ G ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ H ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
f_abis [ B ] = new BayerAreaBandIterator ( id , <num> , <num> , radius ) ;
break ;
}
return f_abis ;
}
public ColorFilterArray arrayAtOffset ( int dx , int dy )
{
final int xmod = dx % <num> ;
final int ymod = dy % <num> ;
if ( xmod == <num> && ymod == <num> )
return new BayerCFA ( f_fs ) ;
BayerCFA cfa = null ;
switch ( f_fs )
{
case FILTER_BGGR :
if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_GBRG ) ;
else if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_GRBG ) ;
else if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_RGGB ) ;
break ;
case FILTER_GRBG :
if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_RGGB ) ;
else if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_BGGR ) ;
else if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_GBRG ) ;
break ;
case FILTER_GBRG :
if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_BGGR ) ;
else if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_RGGB ) ;
else if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_GRBG ) ;
break ;
case FILTER_RGGB :
if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_GRBG ) ;
else if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_GBRG ) ;
else if ( xmod == <num> && ymod == <num> )
cfa = new BayerCFA ( FILTER_BGGR ) ;
break ;
}
return cfa ;
}
public BandIterator [ ] bandIterators ( ImageData id )
{
switch ( f_fs )
{
case FILTER_BGGR :
f_bis [ R ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
f_bis [ G ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
f_bis [ B ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
break ;
case FILTER_GRBG :
f_bis [ R ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
f_bis [ G ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
f_bis [ B ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
break ;
case FILTER_GBRG :
f_bis [ R ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
f_bis [ G ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
f_bis [ B ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
break ;
case FILTER_RGGB :
f_bis [ R ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
f_bis [ G ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
f_bis [ B ] = new BayerBandIterator ( id , <num> , <num> , <num> , <num> , <num> , <num> ) ;
break ;
}
return f_bis ;
}
public Interpolation interpolation ( RawRaster rr )
{
return new BayerVNG ( rr ) ;
}
}
package com . crinqle . dlroom ;
import java . awt . BorderLayout ;
import java . awt . Color ;
import java . awt . Dimension ;
import java . awt . GridLayout ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseListener ;
import java . io . File ;
import javax . swing . BoxLayout ;
import javax . swing . JLabel ;
import javax . swing . JList ;
import javax . swing . JPanel ;
import javax . swing . JScrollPane ;
import javax . swing . ScrollPaneConstants ;
import javax . swing . border . BevelBorder ;
import javax . swing . border . Border ;
import javax . swing . border . CompoundBorder ;
import javax . swing . border . EmptyBorder ;
import javax . swing . event . ListSelectionEvent ;
import javax . swing . event . ListSelectionListener ;
import com . crinqle . dlroom . util . EtchedTitledPanel ;
public class FileChooserPanel extends EtchedTitledPanel implements
ListSelectionListener , MouseListener {
private File f_dir ;
private FileListPanel f_dp ;
private FileListPanel f_fp ;
private JLabel f_dirLabel ;
public FileChooserPanel ( File dir ) {
super ( " ) ;
addMouseListener ( this ) ;
f_dir = dir ;
f_dp = new FileListPanel ( f_dir , FileListPanel . DIRS ) ;
f_dp . setSelectedIndex ( <num> ) ;
f_dp . addListSelectionListener ( this ) ;
dir = ( File ) f_dp . getSelectedValue ( ) ;
f_fp = new FileListPanel ( dir ) ;
f_dirLabel = new JLabel ( dir . toString ( ) ) ;
Border b1 = new EmptyBorder ( <num> , <num> , <num> , <num> ) ;
Border b2 = new BevelBorder ( BevelBorder . LOWERED ) ;
f_dirLabel . setBorder ( new CompoundBorder ( b1 , b2 ) ) ;
f_dirLabel . setHorizontalAlignment ( JLabel . CENTER ) ;
JScrollPane dpScroller = new JScrollPane ( f_dp ) ;
JScrollPane fpScroller = new JScrollPane ( f_fp ) ;
dpScroller
. setHorizontalScrollBarPolicy ( ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ;
dpScroller
. setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS ) ;
fpScroller
. setHorizontalScrollBarPolicy ( ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ;
fpScroller
. setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS ) ;
JLabel dpLabel = new JLabel ( " ) ;
JLabel fpLabel = new JLabel ( " ) ;
dpLabel . setBackground ( Color . gray ) ;
fpLabel . setBackground ( Color . gray ) ;
dpLabel . setHorizontalAlignment ( JLabel . CENTER ) ;
fpLabel . setHorizontalAlignment ( JLabel . CENTER ) ;
JPanel dpPanel = new JPanel ( ) ;
dpPanel . setLayout ( new BoxLayout ( dpPanel , BoxLayout . Y_AXIS ) ) ;
dpPanel . add ( dpLabel ) ;
dpPanel . add ( dpScroller ) ;
JPanel fpPanel = new JPanel ( ) ;
fpPanel . setLayout ( new BoxLayout ( fpPanel , BoxLayout . Y_AXIS ) ) ;
fpPanel . add ( fpLabel ) ;
fpPanel . add ( fpScroller ) ;
JPanel bothPanel = new JPanel ( ) ;
bothPanel . setLayout ( new GridLayout ( <num> , <num> ) ) ;
bothPanel . add ( dpPanel ) ;
bothPanel . add ( fpPanel ) ;
setLayout ( new BorderLayout ( ) ) ;
add ( f_dirLabel , BorderLayout . NORTH ) ;
add ( bothPanel ) ;
setMinimumSize ( new Dimension ( <num> , <num> ) ) ;
}
public void addListSelectionListener ( ListSelectionListener l ) {
f_fp . addListSelectionListener ( l ) ;
}
public void mouseClicked ( MouseEvent evt ) {
if ( evt . getButton ( ) == MouseEvent . BUTTON3 )
updateFiles ( f_dir . getParentFile ( ) ) ;
}
public void mouseEntered ( MouseEvent evt ) {
}
public void mouseExited ( MouseEvent evt ) {
}
public void mousePressed ( MouseEvent evt ) {
}
public void mouseReleased ( MouseEvent evt ) {
}
public void mouseDragged ( MouseEvent evt ) {
}
public void mouseMoved ( MouseEvent evt ) {
}
public void valueChanged ( ListSelectionEvent evt ) {
Object src = evt . getSource ( ) ;
if ( ! evt . getValueIsAdjusting ( ) ) {
if ( src instanceof JList ) {
JList list = ( JList ) src ;
Object obj = list . getSelectedValue ( ) ;
if ( obj != null )
if ( obj instanceof File )
updateFiles ( ( File ) obj ) ;
}
}
}
protected void updateFiles ( File file ) {
if ( file . isDirectory ( ) ) {
f_dir = file ;
f_dirLabel . setText ( file . toString ( ) ) ;
f_dp . updateFiles ( file ) ;
f_fp . updateFiles ( file ) ;
}
}
}
package net . sunnefa . lcarsclock . models ;
import java . text . SimpleDateFormat ;
import java . util . * ;
import net . sunnefa . lcarsclock . listeners . MyEventListener ;
public class ClockModel {
private List listeners = new ArrayList ( ) ;
Date clock_date ;
public ClockModel ( ) {
this . clock_date = new Date ( ) ;
Timer timer = new Timer ( ) ;
TimerTask time_task = new TimerTask ( ) {
@Override
public void run ( ) {
clock_date . setSeconds ( clock_date . getSeconds ( ) + <num> ) ;
ClockModel . this . dispatchEvent ( ) ;
}
} ;
timer . schedule ( time_task , <num> , <num> ) ;
}
public int get_seconds ( ) {
return this . clock_date . getSeconds ( ) ;
}
public int get_minutes ( ) {
return this . clock_date . getMinutes ( ) ;
}
public int get_hours ( ) {
return this . clock_date . getHours ( ) ;
}
public int get_date ( ) {
return this . clock_date . getDate ( ) ;
}
public String get_year ( ) {
SimpleDateFormat simple = new SimpleDateFormat ( " ) ;
return simple . format ( this . clock_date ) ;
}
public int get_month ( ) {
return this . clock_date . getMonth ( ) ;
}
public synchronized void addEventListener ( MyEventListener listener ) {
this . listeners . add ( listener ) ;
}
public synchronized void <unk> ( MyEventListener listener ) {
this . listeners . remove ( listener ) ;
}
public synchronized void dispatchEvent ( ) {
ChangeEventClass change_event = new ChangeEventClass ( this ) ;
Iterator i = this . listeners . iterator ( ) ;
while ( i . hasNext ( ) ) {
( ( MyEventListener ) i . next ( ) ) . handle_change ( change_event ) ;
}
}
private static class ChangeEventClass extends EventObject {
public ChangeEventClass ( Object o ) {
super ( o ) ;
}
}
}
package net . sunnefa . lcarsclock . views ;
import net . sunnefa . lcarsclock . controllers . ClockController ;
import net . sunnefa . lcarsclock . models . ClockModel ;
public class ControlsView {
public ControlsView ( ClockController <unk> , ClockModel clock_model ) {
}
}
package net . sunnefa . lcarsclock . views ;
import java . awt . Graphics ;
import java . awt . Graphics2D ;
import java . awt . Image ;
import java . awt . MediaTracker ;
import java . awt . geom . AffineTransform ;
import javax . swing . JPanel ;
public class RotatingImage extends JPanel {
private Image image ;
private double current_angle ;
public RotatingImage ( Image image ) {
this . set_image ( image ) ;
setOpaque ( false ) ;
}
public void set_image ( Image image ) {
this . image = image ;
MediaTracker mt = new MediaTracker ( this ) ;
mt . addImage ( image , <num> ) ;
try {
mt . waitForID ( <num> ) ;
} catch ( Exception e ) {
e . printStackTrace ( System . err ) ;
}
}
public void rotate ( ) {
this . current_angle -= <num> ;
if ( this . current_angle >= <num> ) {
current_angle = <num> ;
}
repaint ( ) ;
}
public void rotate ( int degrees ) {
this . current_angle = degrees ;
if ( this . current_angle >= <num> ) {
current_angle = <num> ;
}
repaint ( ) ;
}
@Override
protected void paintComponent ( Graphics g ) {
super . paintComponent ( g ) ;
Graphics2D g2d = ( Graphics2D ) g ;
AffineTransform origXform = g2d . getTransform ( ) ;
AffineTransform newXform = ( AffineTransform ) ( origXform . clone ( ) ) ;
int xRot = this . getWidth ( ) / <num> ;
int yRot = this . getHeight ( ) / <num> ;
newXform . rotate ( Math . toRadians ( this . current_angle ) , xRot , yRot ) ;
g2d . setTransform ( newXform ) ;
g2d . rotate ( Math . toRadians ( this . current_angle ) , xRot , yRot ) ;
int x = ( getWidth ( )  this . image . getWidth ( this ) ) / <num> ;
int y = ( getHeight ( )  this . image . getHeight ( this ) ) / <num> ;
g2d . drawImage ( this . image , x , y , this ) ;
g2d . setTransform ( origXform ) ;
}
}
package net . sunnefa . lcarsclock . controllers ;
import net . sunnefa . lcarsclock . models . ClockModel ;
public class ClockController {
public ClockController ( ClockModel clock_model ) {
}
}
package net . sunnefa . lcarsclock . views ;
import javax . swing . JPanel ;
import net . sunnefa . lcarsclock . models . ClockModel ;
public class AbstractClock extends JPanel {
protected ClockModel clock_model ;
public AbstractClock ( ClockModel clock_model ) {
this . clock_model = clock_model ;
}
}
package net . sunnefa . lcarsclock . views ;
import java . awt . BorderLayout ;
import java . awt . Image ;
import java . awt . Toolkit ;
import java . util . EventObject ;
import javax . swing . JPanel ;
import net . sunnefa . lcarsclock . listeners . MyEventListener ;
import net . sunnefa . lcarsclock . models . ClockModel ;
public class AnalogView extends AbstractClock {
private RotatingImage hour_hand ;
private RotatingImage minute_hand ;
private RotatingImage second_hand ;
public AnalogView ( ClockModel clock_model ) {
super ( clock_model ) ;
this . clock_model . addEventListener ( new MyEventListener ( ) {
@Override
public void handle_change ( EventObject e ) {
AnalogView . this . second_hand . rotate ( <num> * AnalogView . this . clock_model . get_seconds ( ) ) ;
}
} ) ;
Image hour_hand_image = Toolkit . getDefaultToolkit ( ) . getImage ( " ) ;
Image minute_hand_image = Toolkit . getDefaultToolkit ( ) . getImage ( " ) ;
Image second_hand_image = Toolkit . getDefaultToolkit ( ) . getImage ( " ) ;
setLayout ( null ) ;
this . hour_hand = new RotatingImage ( hour_hand_image ) ;
this . hour_hand . setBounds ( <num> , <num> , hour_hand_image . getWidth ( this ) , hour_hand_image . getHeight ( this ) ) ;
this . minute_hand = new RotatingImage ( minute_hand_image ) ;
this . minute_hand . setBounds ( <num> , <num> , minute_hand_image . getWidth ( this ) , minute_hand_image . getHeight ( this ) ) ;
this . second_hand = new RotatingImage ( second_hand_image ) ;
this . second_hand . setBounds ( <num> , <num> , second_hand_image . getWidth ( this ) , second_hand_image . getHeight ( this ) ) ;
this . add ( this . minute_hand ) ;
this . add ( this . second_hand ) ;
this . add ( this . hour_hand ) ;
}
}
package net . sunnefa . lcarsclock ;
public class <unk> {
public static void main ( String [ ] args ) {
LClock clock = new LClock ( ) ;
}
}
package net . sunnefa . lcarsclock ;
import java . awt . BorderLayout ;
import java . awt . Color ;
import java . awt . image . BufferedImage ;
import java . io . File ;
import java . io . IOException ;
import javax . imageio . ImageIO ;
import javax . swing . ImageIcon ;
import javax . swing . JFrame ;
import javax . swing . JLabel ;
import net . sunnefa . lcarsclock . models . ClockModel ;
import net . sunnefa . lcarsclock . views . AnalogView ;
import net . sunnefa . lcarsclock . views . DigitalView ;
class LClock {
JFrame app_window ;
JLabel app_label ;
BufferedImage label_image ;
public LClock ( ) {
try {
this . label_image = ImageIO . read ( new File ( " ) ) ;
} catch ( IOException ioe ) {
}
this . app_window = new JFrame ( " ) ;
this . app_window . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
this . app_window . setLayout ( new BorderLayout ( ) ) ;
this . app_window . setSize ( <num> , <num> ) ;
this . app_window . setBackground ( Color . black ) ;
this . app_window . setResizable ( false ) ;
this . app_label = new JLabel ( new ImageIcon ( label_image ) ) ;
ClockModel clock_model = new ClockModel ( ) ;
DigitalView digital_view = new DigitalView ( clock_model ) ;
digital_view . setBounds ( <num> , <num> , <num> , <num> ) ;
AnalogView analog = new AnalogView ( clock_model ) ;
analog . setBounds ( <num> , <num> , <num> , <num> ) ;
analog . setOpaque ( false ) ;
this . app_window . add ( analog ) ;
this . app_window . add ( digital_view ) ;
this . app_window . add ( app_label ) ;
this . app_window . setVisible ( true ) ;
}
private void console ( float msg ) {
System . out . println ( msg ) ;
}
package net . sunnefa . lcarsclock . views ;
import java . awt . Color ;
import java . awt . Font ;
import java . awt . GridLayout ;
import java . util . EventObject ;
import javax . swing . JLabel ;
import net . sunnefa . lcarsclock . listeners . MyEventListener ;
import net . sunnefa . lcarsclock . models . ClockModel ;
public class DigitalView extends AbstractClock {
JLabel time_label = new JLabel ( ) ;
JLabel date_label = new JLabel ( ) ;
JLabel star_label = new JLabel ( " , JLabel . CENTER ) ;
public DigitalView ( ClockModel clock_model ) {
super ( clock_model ) ;
this . clock_model . addEventListener ( new MyEventListener ( ) {
@Override
public void handle_change ( EventObject e ) {
String hours = DigitalView . this . clock_model . get_hours ( ) + " ;
String minutes = DigitalView . this . clock_model . get_minutes ( ) + " ;
String seconds = DigitalView . this . clock_model . get_seconds ( ) + " ;
if ( DigitalView . this . clock_model . get_hours ( ) < <num> ) {
hours = " + DigitalView . this . clock_model . get_hours ( ) ;
}
if ( DigitalView . this . clock_model . get_minutes ( ) < <num> ) {
minutes = " + DigitalView . this . clock_model . get_minutes ( ) ;
}
if ( DigitalView . this . clock_model . get_seconds ( ) < <num> ) {
seconds = " + DigitalView . this . clock_model . get_seconds ( ) ;
}
DigitalView . this . time_label . setText ( hours + " + minutes + " + seconds ) ;
}
} ) ;
GridLayout grid = new GridLayout ( <num> , <num> ) ;
grid . setHgap ( <num> ) ;
this . setLayout ( grid ) ;
this . time_label = new JLabel ( ) ;
this . time_label . setBounds ( <num> , <num> , <num> , <num> ) ;
this . set_font_color ( time_label ) ;
this . date_label = new JLabel ( ) ;
this . date_label . setText ( this . clock_model . get_date ( ) + " + this . clock_model . get_month ( ) + " + this . clock_model . get_year ( ) ) ;
this . set_font_color ( date_label ) ;
this . star_label = new JLabel ( " , JLabel . CENTER ) ;
this . star_label . setText ( " ) ;
this . set_font_color ( star_label ) ;
this . add ( this . time_label ) ;
this . add ( this . date_label ) ;
this . add ( this . star_label ) ;
}
private void set_font_color ( JLabel label ) {
label . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
label . setFont ( new Font ( " , Font . <unk> , <num> ) ) ;
}
}
package net . sunnefa . lcarsclock . listeners ;
import java . util . EventObject ;
public class MyEventListener {
public void handle_change ( EventObject e ) {
}
}
package com . feigdev . fragmentex ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . support . v4 . app . FragmentActivity ;
import android . support . v4 . app . FragmentTransaction ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . webkit . WebView ;
import android . webkit . WebViewClient ;
public class WebFragment extends Fragment {
int mNum ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
mNum = getArguments ( ) != null ? getArguments ( ) . getInt ( " ) : <num> ;
}
public static WebFragment newInstance ( int index ) {
WebFragment f = new WebFragment ( ) ;
Bundle args = new Bundle ( ) ;
args . putInt ( " , index ) ;
f . setArguments ( args ) ;
return f ;
}
@Override
public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) {
if ( container == null ) {
return null ;
}
View web = inflater . inflate ( R . layout . web , container , false ) ;
( ( WebView ) ( web . findViewById ( R . id . web_login ) ) ) . getSettings ( ) . setJavaScriptEnabled ( true ) ;
( ( WebView ) ( web . findViewById ( R . id . web_login ) ) ) . setWebViewClient ( new HelloWebViewClient ( ) ) ;
( ( WebView ) ( web . findViewById ( R . id . web_login ) ) ) . loadUrl ( " ) ;
return web ;
}
private class HelloWebViewClient extends WebViewClient {
@Override
public boolean shouldOverrideUrlLoading ( WebView view , String url ) {
view . loadUrl ( url ) ;
return true ;
}
}
}
package com . actionbarsherlock ;
public final class R {
public static final class array {
public static final int locations = <num> ;
}
public static final class attr {
public static final int abBackground = <num> ;
public static final int abBackgroundStacked = <num> ;
public static final int abCustomNavigationLayout = <num> ;
public static final int abDisplayOptions = <num> ;
public static final int abDivider = <num> ;
public static final int abHeight = <num> ;
public static final int abHomeLayout = <num> ;
public static final int abIcon = <num> ;
public static final int abIndeterminateProgressStyle = <num> ;
public static final int abItemPadding = <num> ;
public static final int abLogo = <num> ;
public static final int abNavigationMode = <num> ;
public static final int abProgressBarPadding = <num> ;
public static final int abProgressBarStyle = <num> ;
public static final int abSubtitle = <num> ;
public static final int abSubtitleTextStyle = <num> ;
public static final int abTitle = <num> ;
public static final int abTitleTextStyle = <num> ;
public static final int actionBarSize = <num> ;
public static final int actionBarTabBarStyle = <num> ;
public static final int actionBarTabStyle = <num> ;
public static final int actionBarTabTextStyle = <num> ;
public static final int actionButtonStyle = <num> ;
public static final int actionDropDownStyle = <num> ;
public static final int actionHomeButtonStyle = <num> ;
public static final int actionMenuTextAppearance = <num> ;
public static final int actionMenuTextColor = <num> ;
public static final int actionModeBackground = <num> ;
public static final int actionModeCloseButtonStyle = <num> ;
public static final int actionModeCloseDrawable = <num> ;
public static final int actionOverflowButtonStyle = <num> ;
public static final int actionSpinnerItemStyle = <num> ;
public static final int dropDownListViewStyle = <num> ;
public static final int dropdownListPreferredItemHeight = <num> ;
public static final int homeAsUpIndicator = <num> ;
public static final int popupMenuStyle = <num> ;
public static final int selectableItemBackground = <num> ;
public static final int windowActionBar = <num> ;
public static final int windowActionBarOverlay = <num> ;
public static final int windowActionModeOverlay = <num> ;
public static final int windowNoTitle = <num> ;
}
public static final class bool {
public static final int abs__config_allowActionMenuItemTextWithIcon = <num> ;
}
public static final class color {
public static final int abs__item_bg = <num> ;
public static final int abs__item_focused = <num> ;
public static final int abs__tab_text_color_dark = <num> ;
public static final int abs__tab_text_color_light = <num> ;
}
public static final class dimen {
public static final int abs__action_bar_default_height = <num> ;
public static final int abs__action_bar_subtitle_bottom_margin = <num> ;
public static final int abs__action_bar_subtitle_text_size = <num> ;
public static final int abs__action_bar_subtitle_top_margin = <num> ;
public static final int abs__action_bar_title_text_size = <num> ;
}
public static final class drawable {
public static final int abs__ab_solid_dark_holo = <num> ;
public static final int abs__ab_stacked_transparent_dark_holo = <num> ;
public static final int abs__ab_stacked_transparent_light_holo = <num> ;
public static final int abs__action_item_divider = <num> ;
public static final int abs__cab_background_holo_dark = <num> ;
public static final int abs__cab_background_holo_light = <num> ;
public static final int abs__cab_ic_close_focused_holo = <num> ;
public static final int abs__cab_ic_close_holo = <num> ;
public static final int abs__cab_ic_close_normal_holo = <num> ;
public static final int abs__cab_ic_close_pressed_holo = <num> ;
public static final int abs__ic_ab_back_holo_dark = <num> ;
public static final int abs__ic_ab_back_holo_light = <num> ;
public static final int abs__item_background_holo_dark = <num> ;
public static final int abs__item_background_holo_light = <num> ;
public static final int abs__list_focused_holo = <num> ;
public static final int abs__list_longpressed_holo = <num> ;
public static final int abs__list_pressed_holo_dark = <num> ;
public static final int abs__list_pressed_holo_light = <num> ;
public static final int abs__list_selector_background_transition_holo_dark = <num> ;
public static final int abs__list_selector_background_transition_holo_light = <num> ;
public static final int abs__list_selector_disabled_holo_dark = <num> ;
public static final int abs__list_selector_disabled_holo_light = <num> ;
public static final int abs__spinner_background_holo_dark = <num> ;
public static final int abs__spinner_background_holo_light = <num> ;
public static final int abs__spinner_default_holo_dark = <num> ;
public static final int abs__spinner_default_holo_light = <num> ;
public static final int abs__spinner_disabled_holo_dark = <num> ;
public static final int abs__spinner_disabled_holo_light = <num> ;
public static final int abs__spinner_focused_holo_dark = <num> ;
public static final int abs__spinner_focused_holo_light = <num> ;
public static final int abs__spinner_pressed_holo_dark = <num> ;
public static final int abs__spinner_pressed_holo_light = <num> ;
public static final int abs__tab_indicator_holo = <num> ;
public static final int abs__tab_selected_focused_holo = <num> ;
public static final int abs__tab_selected_holo = <num> ;
public static final int abs__tab_selected_pressed_focused_holo = <num> ;
public static final int abs__tab_selected_pressed_holo = <num> ;
public static final int abs__tab_unselected_focused_holo = <num> ;
public static final int abs__tab_unselected_holo = <num> ;
public static final int abs__tab_unselected_pressed_focused_holo = <num> ;
public static final int abs__tab_unselected_pressed_holo = <num> ;
public static final int ic_launcher = <num> ;
public static final int sample_thumb_0 = <num> ;
public static final int sample_thumb_1 = <num> ;
public static final int sample_thumb_2 = <num> ;
public static final int sample_thumb_3 = <num> ;
public static final int sample_thumb_4 = <num> ;
public static final int sample_thumb_5 = <num> ;
public static final int sample_thumb_6 = <num> ;
public static final int sample_thumb_7 = <num> ;
}
public static final class id {
public static final int abs__action_bar = <num> ;
public static final int abs__action_bar_container = <num> ;
public static final int abs__action_bar_subtitle = <num> ;
public static final int abs__action_bar_title = <num> ;
public static final int abs__action_menu_presenter = <num> ;
public static final int abs__actions = <num> ;
public static final int abs__content = <num> ;
public static final int abs__custom = <num> ;
public static final int abs__home = <num> ;
public static final int abs__home_wrapper = <num> ;
public static final int abs__imageButton = <num> ;
public static final int abs__iprogress = <num> ;
public static final int abs__nav_list = <num> ;
public static final int abs__nav_tabs = <num> ;
public static final int abs__nav_tabs_layout = <num> ;
public static final int abs__tab = <num> ;
public static final int abs__tab_custom = <num> ;
public static final int abs__tab_icon = <num> ;
public static final int abs__textButton = <num> ;
public static final int abs__up = <num> ;
public static final int homeAsUp = <num> ;
public static final int listMode = <num> ;
public static final int myGrid = <num> ;
public static final int myGrid_main = <num> ;
public static final int normal = <num> ;
public static final int showCustom = <num> ;
public static final int showHome = <num> ;
public static final int showTitle = <num> ;
public static final int tabMode = <num> ;
public static final int useLogo = <num> ;
public static final int web_login = <num> ;
public static final int web_login_main = <num> ;
public static final int wrap_content = <num> ;
}
public static final class integer {
public static final int abs__max_action_buttons = <num> ;
}
public static final class layout {
public static final int abs__action_bar = <num> ;
public static final int abs__action_bar_home = <num> ;
public static final int abs__action_bar_inline = <num> ;
public static final int abs__action_bar_tab_layout = <num> ;
public static final int abs__action_bar_title_item = <num> ;
public static final int abs__action_menu_item_layout = <num> ;
public static final int abs__action_menu_layout = <num> ;
public static final int abs__screen_action_bar = <num> ;
public static final int abs__screen_action_bar_overlay = <num> ;
public static final int abs__screen_simple = <num> ;
public static final int abs__simple_spinner_item = <num> ;
public static final int grid = <num> ;
public static final int main = <num> ;
public static final int web = <num> ;
}
public static final class string {
public static final int abs__tab_under_ab_tag = <num> ;
public static final int app_name = <num> ;
public static final int hello = <num> ;
}
public static final class style {
public static final int Internal_Widget_Sherlock_ActionBar = <num> ;
public static final int Internal_Widget_Sherlock_Light_ActionBar = <num> ;
public static final int TextAppearance_Widget_Subtitle = <num> ;
public static final int TextAppearance_Widget_Title = <num> ;
public static final int Theme_Sherlock = <num> ;
public static final int Theme_Sherlock_Light = <num> ;
public static final int Widget_Sherlock_ActionBar_TabBar = <num> ;
public static final int Widget_Sherlock_ActionBar_TabText = <num> ;
public static final int Widget_Sherlock_ActionBar_TabView = <num> ;
public static final int Widget_Sherlock_ActionButton = <num> ;
public static final int Widget_Sherlock_ActionButton_CloseMode = <num> ;
public static final int Widget_Sherlock_ActionButton_Home = <num> ;
public static final int Widget_Sherlock_ActionButton_Overflow = <num> ;
public static final int Widget_Sherlock_Light_ActionBar_TabBar = <num> ;
public static final int Widget_Sherlock_Light_ActionBar_TabText = <num> ;
public static final int Widget_Sherlock_Light_ActionBar_TabText_Inverse = <num> ;
public static final int Widget_Sherlock_Light_ActionBar_TabView = <num> ;
public static final int Widget_Sherlock_Light_ActionButton = <num> ;
public static final int Widget_Sherlock_Light_ActionButton_CloseMode = <num> ;
public static final int Widget_Sherlock_Light_ActionButton_Home = <num> ;
public static final int Widget_Sherlock_Light_ActionButton_Overflow = <num> ;
public static final int Widget_Sherlock_Light_ListPopupWindow = <num> ;
public static final int Widget_Sherlock_Light_ListView_DropDown = <num> ;
public static final int Widget_Sherlock_Light_PopupMenu = <num> ;
public static final int Widget_Sherlock_Light_Spinner = <num> ;
public static final int Widget_Sherlock_Light_TextView_SpinnerItem_ActionBar = <num> ;
public static final int Widget_Sherlock_ListPopupWindow = <num> ;
public static final int Widget_Sherlock_ListView_DropDown = <num> ;
public static final int Widget_Sherlock_PopupMenu = <num> ;
public static final int Widget_Sherlock_Spinner = <num> ;
public static final int Widget_Sherlock_TextView_SpinnerItem_ActionBar = <num> ;
}
public static final class styleable {
public static final int [ ] SherlockTheme = {
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num>
} ;
public static final int SherlockTheme_abBackground = <num> ;
public static final int SherlockTheme_abBackgroundStacked = <num> ;
public static final int SherlockTheme_abCustomNavigationLayout = <num> ;
public static final int SherlockTheme_abDisplayOptions = <num> ;
public static final int SherlockTheme_abDivider = <num> ;
public static final int SherlockTheme_abHeight = <num> ;
public static final int SherlockTheme_abHomeLayout = <num> ;
public static final int SherlockTheme_abIcon = <num> ;
public static final int SherlockTheme_abIndeterminateProgressStyle = <num> ;
public static final int SherlockTheme_abItemPadding = <num> ;
public static final int SherlockTheme_abLogo = <num> ;
public static final int SherlockTheme_abNavigationMode = <num> ;
public static final int SherlockTheme_abProgressBarPadding = <num> ;
public static final int SherlockTheme_abProgressBarStyle = <num> ;
public static final int SherlockTheme_abSubtitle = <num> ;
public static final int SherlockTheme_abSubtitleTextStyle = <num> ;
public static final int SherlockTheme_abTitle = <num> ;
public static final int SherlockTheme_abTitleTextStyle = <num> ;
public static final int SherlockTheme_actionBarSize = <num> ;
public static final int SherlockTheme_actionBarTabBarStyle = <num> ;
public static final int SherlockTheme_actionBarTabStyle = <num> ;
public static final int SherlockTheme_actionBarTabTextStyle = <num> ;
public static final int SherlockTheme_actionButtonStyle = <num> ;
public static final int SherlockTheme_actionDropDownStyle = <num> ;
public static final int SherlockTheme_actionHomeButtonStyle = <num> ;
public static final int SherlockTheme_actionMenuTextAppearance = <num> ;
public static final int SherlockTheme_actionMenuTextColor = <num> ;
public static final int SherlockTheme_actionModeBackground = <num> ;
public static final int SherlockTheme_actionModeCloseButtonStyle = <num> ;
public static final int SherlockTheme_actionModeCloseDrawable = <num> ;
public static final int SherlockTheme_actionOverflowButtonStyle = <num> ;
public static final int SherlockTheme_actionSpinnerItemStyle = <num> ;
public static final int SherlockTheme_dropDownListViewStyle = <num> ;
public static final int SherlockTheme_dropdownListPreferredItemHeight = <num> ;
public static final int SherlockTheme_homeAsUpIndicator = <num> ;
public static final int SherlockTheme_popupMenuStyle = <num> ;
public static final int SherlockTheme_selectableItemBackground = <num> ;
public static final int SherlockTheme_windowActionBar = <num> ;
public static final int SherlockTheme_windowActionBarOverlay = <num> ;
public static final int SherlockTheme_windowActionModeOverlay = <num> ;
public static final int SherlockTheme_windowNoTitle = <num> ;
} ;
}
package com . feigdev . fragmentex ;
public final class R {
public static final class array {
public static final int locations = <num> ;
}
public static final class attr {
public static final int abBackground = <num> ;
public static final int abBackgroundStacked = <num> ;
public static final int abCustomNavigationLayout = <num> ;
public static final int abDisplayOptions = <num> ;
public static final int abDivider = <num> ;
public static final int abHeight = <num> ;
public static final int abHomeLayout = <num> ;
public static final int abIcon = <num> ;
public static final int abIndeterminateProgressStyle = <num> ;
public static final int abItemPadding = <num> ;
public static final int abLogo = <num> ;
public static final int abNavigationMode = <num> ;
public static final int abProgressBarPadding = <num> ;
public static final int abProgressBarStyle = <num> ;
public static final int abSubtitle = <num> ;
public static final int abSubtitleTextStyle = <num> ;
public static final int abTitle = <num> ;
public static final int abTitleTextStyle = <num> ;
public static final int actionBarSize = <num> ;
public static final int actionBarTabBarStyle = <num> ;
public static final int actionBarTabStyle = <num> ;
public static final int actionBarTabTextStyle = <num> ;
public static final int actionButtonStyle = <num> ;
public static final int actionDropDownStyle = <num> ;
public static final int actionHomeButtonStyle = <num> ;
public static final int actionMenuTextAppearance = <num> ;
public static final int actionMenuTextColor = <num> ;
public static final int actionModeBackground = <num> ;
public static final int actionModeCloseButtonStyle = <num> ;
public static final int actionModeCloseDrawable = <num> ;
public static final int actionOverflowButtonStyle = <num> ;
public static final int actionSpinnerItemStyle = <num> ;
public static final int dropDownListViewStyle = <num> ;
public static final int dropdownListPreferredItemHeight = <num> ;
public static final int homeAsUpIndicator = <num> ;
public static final int popupMenuStyle = <num> ;
public static final int selectableItemBackground = <num> ;
public static final int windowActionBar = <num> ;
public static final int windowActionBarOverlay = <num> ;
public static final int windowActionModeOverlay = <num> ;
public static final int windowNoTitle = <num> ;
}
public static final class bool {
public static final int abs__config_allowActionMenuItemTextWithIcon = <num> ;
}
public static final class color {
public static final int abs__item_bg = <num> ;
public static final int abs__item_focused = <num> ;
public static final int abs__tab_text_color_dark = <num> ;
public static final int abs__tab_text_color_light = <num> ;
}
public static final class dimen {
public static final int abs__action_bar_default_height = <num> ;
public static final int abs__action_bar_subtitle_bottom_margin = <num> ;
public static final int abs__action_bar_subtitle_text_size = <num> ;
public static final int abs__action_bar_subtitle_top_margin = <num> ;
public static final int abs__action_bar_title_text_size = <num> ;
}
public static final class drawable {
public static final int abs__ab_solid_dark_holo = <num> ;
public static final int abs__ab_stacked_transparent_dark_holo = <num> ;
public static final int abs__ab_stacked_transparent_light_holo = <num> ;
public static final int abs__action_item_divider = <num> ;
public static final int abs__cab_background_holo_dark = <num> ;
public static final int abs__cab_background_holo_light = <num> ;
public static final int abs__cab_ic_close_focused_holo = <num> ;
public static final int abs__cab_ic_close_holo = <num> ;
public static final int abs__cab_ic_close_normal_holo = <num> ;
public static final int abs__cab_ic_close_pressed_holo = <num> ;
public static final int abs__ic_ab_back_holo_dark = <num> ;
public static final int abs__ic_ab_back_holo_light = <num> ;
public static final int abs__item_background_holo_dark = <num> ;
public static final int abs__item_background_holo_light = <num> ;
public static final int abs__list_focused_holo = <num> ;
public static final int abs__list_longpressed_holo = <num> ;
public static final int abs__list_pressed_holo_dark = <num> ;
public static final int abs__list_pressed_holo_light = <num> ;
public static final int abs__list_selector_background_transition_holo_dark = <num> ;
public static final int abs__list_selector_background_transition_holo_light = <num> ;
public static final int abs__list_selector_disabled_holo_dark = <num> ;
public static final int abs__list_selector_disabled_holo_light = <num> ;
public static final int abs__spinner_background_holo_dark = <num> ;
public static final int abs__spinner_background_holo_light = <num> ;
public static final int abs__spinner_default_holo_dark = <num> ;
public static final int abs__spinner_default_holo_light = <num> ;
public static final int abs__spinner_disabled_holo_dark = <num> ;
public static final int abs__spinner_disabled_holo_light = <num> ;
public static final int abs__spinner_focused_holo_dark = <num> ;
public static final int abs__spinner_focused_holo_light = <num> ;
public static final int abs__spinner_pressed_holo_dark = <num> ;
public static final int abs__spinner_pressed_holo_light = <num> ;
public static final int abs__tab_indicator_holo = <num> ;
public static final int abs__tab_selected_focused_holo = <num> ;
public static final int abs__tab_selected_holo = <num> ;
public static final int abs__tab_selected_pressed_focused_holo = <num> ;
public static final int abs__tab_selected_pressed_holo = <num> ;
public static final int abs__tab_unselected_focused_holo = <num> ;
public static final int abs__tab_unselected_holo = <num> ;
public static final int abs__tab_unselected_pressed_focused_holo = <num> ;
public static final int abs__tab_unselected_pressed_holo = <num> ;
public static final int ic_launcher = <num> ;
public static final int sample_thumb_0 = <num> ;
public static final int sample_thumb_1 = <num> ;
public static final int sample_thumb_2 = <num> ;
public static final int sample_thumb_3 = <num> ;
public static final int sample_thumb_4 = <num> ;
public static final int sample_thumb_5 = <num> ;
public static final int sample_thumb_6 = <num> ;
public static final int sample_thumb_7 = <num> ;
}
public static final class id {
public static final int abs__action_bar = <num> ;
public static final int abs__action_bar_container = <num> ;
public static final int abs__action_bar_subtitle = <num> ;
public static final int abs__action_bar_title = <num> ;
public static final int abs__action_menu_presenter = <num> ;
public static final int abs__actions = <num> ;
public static final int abs__content = <num> ;
public static final int abs__custom = <num> ;
public static final int abs__home = <num> ;
public static final int abs__home_wrapper = <num> ;
public static final int abs__imageButton = <num> ;
public static final int abs__iprogress = <num> ;
public static final int abs__nav_list = <num> ;
public static final int abs__nav_tabs = <num> ;
public static final int abs__nav_tabs_layout = <num> ;
public static final int abs__tab = <num> ;
public static final int abs__tab_custom = <num> ;
public static final int abs__tab_icon = <num> ;
public static final int abs__textButton = <num> ;
public static final int abs__up = <num> ;
public static final int homeAsUp = <num> ;
public static final int listMode = <num> ;
public static final int myGrid = <num> ;
public static final int myGrid_main = <num> ;
public static final int normal = <num> ;
public static final int showCustom = <num> ;
public static final int showHome = <num> ;
public static final int showTitle = <num> ;
public static final int tabMode = <num> ;
public static final int useLogo = <num> ;
public static final int web_login = <num> ;
public static final int web_login_main = <num> ;
public static final int wrap_content = <num> ;
}
public static final class integer {
public static final int abs__max_action_buttons = <num> ;
}
public static final class layout {
public static final int abs__action_bar = <num> ;
public static final int abs__action_bar_home = <num> ;
public static final int abs__action_bar_inline = <num> ;
public static final int abs__action_bar_tab_layout = <num> ;
public static final int abs__action_bar_title_item = <num> ;
public static final int abs__action_menu_item_layout = <num> ;
public static final int abs__action_menu_layout = <num> ;
public static final int abs__screen_action_bar = <num> ;
public static final int abs__screen_action_bar_overlay = <num> ;
public static final int abs__screen_simple = <num> ;
public static final int abs__simple_spinner_item = <num> ;
public static final int grid = <num> ;
public static final int main = <num> ;
public static final int web = <num> ;
}
public static final class string {
public static final int abs__tab_under_ab_tag = <num> ;
public static final int app_name = <num> ;
public static final int hello = <num> ;
}
public static final class style {
public static final int Internal_Widget_Sherlock_ActionBar = <num> ;
public static final int Internal_Widget_Sherlock_Light_ActionBar = <num> ;
public static final int TextAppearance_Widget_Subtitle = <num> ;
public static final int TextAppearance_Widget_Title = <num> ;
public static final int Theme_Sherlock = <num> ;
public static final int Theme_Sherlock_Light = <num> ;
public static final int Widget_Sherlock_ActionBar_TabBar = <num> ;
public static final int Widget_Sherlock_ActionBar_TabText = <num> ;
public static final int Widget_Sherlock_ActionBar_TabView = <num> ;
public static final int Widget_Sherlock_ActionButton = <num> ;
public static final int Widget_Sherlock_ActionButton_CloseMode = <num> ;
public static final int Widget_Sherlock_ActionButton_Home = <num> ;
public static final int Widget_Sherlock_ActionButton_Overflow = <num> ;
public static final int Widget_Sherlock_Light_ActionBar_TabBar = <num> ;
public static final int Widget_Sherlock_Light_ActionBar_TabText = <num> ;
public static final int Widget_Sherlock_Light_ActionBar_TabText_Inverse = <num> ;
public static final int Widget_Sherlock_Light_ActionBar_TabView = <num> ;
public static final int Widget_Sherlock_Light_ActionButton = <num> ;
public static final int Widget_Sherlock_Light_ActionButton_CloseMode = <num> ;
public static final int Widget_Sherlock_Light_ActionButton_Home = <num> ;
public static final int Widget_Sherlock_Light_ActionButton_Overflow = <num> ;
public static final int Widget_Sherlock_Light_ListPopupWindow = <num> ;
public static final int Widget_Sherlock_Light_ListView_DropDown = <num> ;
public static final int Widget_Sherlock_Light_PopupMenu = <num> ;
public static final int Widget_Sherlock_Light_Spinner = <num> ;
public static final int Widget_Sherlock_Light_TextView_SpinnerItem_ActionBar = <num> ;
public static final int Widget_Sherlock_ListPopupWindow = <num> ;
public static final int Widget_Sherlock_ListView_DropDown = <num> ;
public static final int Widget_Sherlock_PopupMenu = <num> ;
public static final int Widget_Sherlock_Spinner = <num> ;
public static final int Widget_Sherlock_TextView_SpinnerItem_ActionBar = <num> ;
}
public static final class styleable {
public static final int [ ] SherlockTheme = {
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num> , <num> , <num> , <num> ,
<num>
} ;
public static final int SherlockTheme_abBackground = <num> ;
public static final int SherlockTheme_abBackgroundStacked = <num> ;
public static final int SherlockTheme_abCustomNavigationLayout = <num> ;
public static final int SherlockTheme_abDisplayOptions = <num> ;
public static final int SherlockTheme_abDivider = <num> ;
public static final int SherlockTheme_abHeight = <num> ;
public static final int SherlockTheme_abHomeLayout = <num> ;
public static final int SherlockTheme_abIcon = <num> ;
public static final int SherlockTheme_abIndeterminateProgressStyle = <num> ;
public static final int SherlockTheme_abItemPadding = <num> ;
public static final int SherlockTheme_abLogo = <num> ;
public static final int SherlockTheme_abNavigationMode = <num> ;
public static final int SherlockTheme_abProgressBarPadding = <num> ;
public static final int SherlockTheme_abProgressBarStyle = <num> ;
public static final int SherlockTheme_abSubtitle = <num> ;
public static final int SherlockTheme_abSubtitleTextStyle = <num> ;
public static final int SherlockTheme_abTitle = <num> ;
public static final int SherlockTheme_abTitleTextStyle = <num> ;
public static final int SherlockTheme_actionBarSize = <num> ;
public static final int SherlockTheme_actionBarTabBarStyle = <num> ;
public static final int SherlockTheme_actionBarTabStyle = <num> ;
public static final int SherlockTheme_actionBarTabTextStyle = <num> ;
public static final int SherlockTheme_actionButtonStyle = <num> ;
public static final int SherlockTheme_actionDropDownStyle = <num> ;
public static final int SherlockTheme_actionHomeButtonStyle = <num> ;
public static final int SherlockTheme_actionMenuTextAppearance = <num> ;
public static final int SherlockTheme_actionMenuTextColor = <num> ;
public static final int SherlockTheme_actionModeBackground = <num> ;
public static final int SherlockTheme_actionModeCloseButtonStyle = <num> ;
public static final int SherlockTheme_actionModeCloseDrawable = <num> ;
public static final int SherlockTheme_actionOverflowButtonStyle = <num> ;
public static final int SherlockTheme_actionSpinnerItemStyle = <num> ;
public static final int SherlockTheme_dropDownListViewStyle = <num> ;
public static final int SherlockTheme_dropdownListPreferredItemHeight = <num> ;
public static final int SherlockTheme_homeAsUpIndicator = <num> ;
public static final int SherlockTheme_popupMenuStyle = <num> ;
public static final int SherlockTheme_selectableItemBackground = <num> ;
public static final int SherlockTheme_windowActionBar = <num> ;
public static final int SherlockTheme_windowActionBarOverlay = <num> ;
public static final int SherlockTheme_windowActionModeOverlay = <num> ;
public static final int SherlockTheme_windowNoTitle = <num> ;
} ;
}
package com . feigdev . fragmentex ;
import android . graphics . Point ;
import android . os . Bundle ;
import android . support . v4 . app . ActionBar ;
import android . support . v4 . app . FragmentActivity ;
import android . widget . ArrayAdapter ;
public class <unk> extends FragmentActivity implements ActionBar . OnNavigationListener {
Point imgSize ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
getSupportActionBar ( ) . setNavigationMode ( ActionBar . NAVIGATION_MODE_LIST ) ;
ArrayAdapter < CharSequence > list = ArrayAdapter . createFromResource ( this , R . array . locations , R . layout . abs__simple_spinner_item ) ;
list . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
getSupportActionBar ( ) . setListNavigationCallbacks ( list , this ) ;
}
@Override
public boolean onNavigationItemSelected ( int itemPosition , long itemId ) {
switch ( ( int ) itemId ) {
case <num> :
getSupportFragmentManager ( )
. beginTransaction ( )
. replace ( android . R . id . content , GridFragment . newInstance ( itemPosition ) )
. commit ( ) ;
break ;
case <num> :
getSupportFragmentManager ( )
. beginTransaction ( )
. replace ( android . R . id . content , WebFragment . newInstance ( itemPosition ) )
. commit ( ) ;
break ;
}
return true ;
}
package com . feigdev . fragmentex ;
import android . content . Context ;
import android . graphics . Point ;
import android . os . Bundle ;
import android . support . v4 . app . Fragment ;
import android . support . v4 . app . FragmentActivity ;
import android . support . v4 . app . FragmentTransaction ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . BaseAdapter ;
import android . widget . GridView ;
import android . widget . ImageView ;
public class GridFragment extends Fragment {
private Point imgSize ;
int mNum ;
public void setImgSize ( int x , int y ) {
imgSize . set ( x , y ) ;
}
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
mNum = getArguments ( ) != null ? getArguments ( ) . getInt ( " ) : <num> ;
}
public static GridFragment newInstance ( int index ) {
GridFragment f = new GridFragment ( ) ;
Bundle args = new Bundle ( ) ;
args . putInt ( " , index ) ;
f . setArguments ( args ) ;
return f ;
}
@Override
public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) {
if ( container == null ) {
return null ;
}
final View grid = inflater . inflate ( R . layout . grid , container , false ) ;
GridView g = ( GridView ) grid . findViewById ( R . id . myGrid ) ;
g . setAdapter ( new ImageAdapter ( getActivity ( ) ) ) ;
imgSize = new Point ( ) ;
int side = getActivity ( ) . getResources ( ) . getDisplayMetrics ( ) . widthPixels / <num> ;
setImgSize ( side , side ) ;
return grid ;
}
public class ImageAdapter extends BaseAdapter {
public ImageAdapter ( Context c ) {
mContext = c ;
}
public int getCount ( ) {
return mThumbIds . length ;
}
public Object getItem ( int position ) {
return position ;
}
public long getItemId ( int position ) {
return position ;
}
public View getView ( int position , View convertView , ViewGroup parent ) {
ImageView imageView ;
if ( convertView == null ) {
imageView = new ImageView ( mContext ) ;
imageView . setLayoutParams ( new GridView . LayoutParams ( imgSize . x , imgSize . y ) ) ;
imageView . setAdjustViewBounds ( true ) ;
imageView . setScaleType ( ImageView . ScaleType . CENTER_CROP ) ;
imageView . setPadding ( <num> , <num> , <num> , <num> ) ;
} else {
imageView = ( ImageView ) convertView ;
}
imageView . setImageResource ( mThumbIds [ position ] ) ;
return imageView ;
}
private Context mContext ;
private Integer [ ] mThumbIds = {
R . drawable . sample_thumb_0 , R . drawable . sample_thumb_1 ,
R . drawable . sample_thumb_2 , R . drawable . sample_thumb_3 ,
R . drawable . sample_thumb_4 , R . drawable . sample_thumb_5 ,
R . drawable . sample_thumb_6 , R . drawable . sample_thumb_7 ,
R . drawable . sample_thumb_0 , R . drawable . sample_thumb_1 ,
R . drawable . sample_thumb_2 , R . drawable . sample_thumb_3 ,
R . drawable . sample_thumb_4 , R . drawable . sample_thumb_5 ,
R . drawable . sample_thumb_6 , R . drawable . sample_thumb_7 ,
R . drawable . sample_thumb_0 , R . drawable . sample_thumb_1 ,
R . drawable . sample_thumb_2 , R . drawable . sample_thumb_3 ,
R . drawable . sample_thumb_4 , R . drawable . sample_thumb_5 ,
R . drawable . sample_thumb_6 , R . drawable . sample_thumb_7 ,
R . drawable . sample_thumb_0 , R . drawable . sample_thumb_1 ,
R . drawable . sample_thumb_2 , R . drawable . sample_thumb_3 ,
R . drawable . sample_thumb_4 , R . drawable . sample_thumb_5 ,
R . drawable . sample_thumb_6 , R . drawable . sample_thumb_7 ,
R . drawable . sample_thumb_0 , R . drawable . sample_thumb_1 ,
R . drawable . sample_thumb_2 , R . drawable . sample_thumb_3 ,
R . drawable . sample_thumb_4 , R . drawable . sample_thumb_5 ,
R . drawable . sample_thumb_6 , R . drawable . sample_thumb_7 ,
R . drawable . sample_thumb_0 , R . drawable . sample_thumb_1 ,
R . drawable . sample_thumb_2 , R . drawable . sample_thumb_3 ,
R . drawable . sample_thumb_4 , R . drawable . sample_thumb_5 ,
R . drawable . sample_thumb_6 , R . drawable . sample_thumb_7 ,
R . drawable . sample_thumb_0 , R . drawable . sample_thumb_1
} ;
}
}
package com . seeder ;
public class Reaper {
public boolean reap ( Weather weather ) {
return weather . shouldReap ( ) ;
}
}
package com . seeder ;
public class Weather {
private int temperature ;
private int humidity ;
private int wind ;
public Weather ( int temperature , int humidity , int wind ) {
this . temperature = temperature ;
this . humidity = humidity ;
this . wind = wind ;
}
public boolean shouldReap ( ) {
return temperature > <num> && humidity < <num> ;
}
public boolean shouldSeed ( ) {
return temperature > <num> ;
}
public boolean shouldPour ( ) {
return temperature > <num> && humidity < <num> && wind < <num> ;
}
public boolean shouldRaise ( ) {
return temperature > <num> && humidity < <num> && wind > <num> ;
}
}
package com . seeder ;
import org . junit . Test ;
import static org . hamcrest . core . Is . is ;
import static org . junit . Assert . assertThat ;
public class <unk> {
@Test
public void <unk> ( ) {
Seeder seeder = new Seeder ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean seed = seeder . seed ( weather ) ;
assertThat ( seed , is ( true ) ) ;
}
@Test
public void <unk> ( ) {
Seeder seeder = new Seeder ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean seed = seeder . seed ( weather ) ;
assertThat ( seed , is ( false ) ) ;
}
@Test
public void <unk> ( ) {
Reaper reaper = new Reaper ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean reap = reaper . reap ( weather ) ;
assertThat ( reap , is ( true ) ) ;
}
@Test
public void <unk> ( ) {
Reaper reaper = new Reaper ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean reap = reaper . reap ( weather ) ;
assertThat ( reap , is ( false ) ) ;
}
@Test
public void <unk> ( ) {
Reaper reaper = new Reaper ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean reap = reaper . reap ( weather ) ;
assertThat ( reap , is ( false ) ) ;
}
@Test
public void <unk> ( ) {
Water water = new Water ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean pour = water . pour ( weather ) ;
assertThat ( pour , is ( true ) ) ;
}
@Test
public void <unk> ( ) {
Water water = new Water ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean pour = water . pour ( weather ) ;
assertThat ( pour , is ( false ) ) ;
}
@Test
public void <unk> ( ) {
Water water = new Water ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean pour = water . pour ( weather ) ;
assertThat ( pour , is ( false ) ) ;
}
@Test
public void <unk> ( ) {
Water water = new Water ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean pour = water . pour ( weather ) ;
assertThat ( pour , is ( false ) ) ;
}
@Test
public void <unk> ( ) {
Raiser raiser = new Raiser ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean raise = raiser . raise ( weather ) ;
assertThat ( raise , is ( true ) ) ;
}
@Test
public void <unk> ( ) {
Raiser raiser = new Raiser ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean raise = raiser . raise ( weather ) ;
assertThat ( raise , is ( false ) ) ;
}
@Test
public void <unk> ( ) {
Raiser raiser = new Raiser ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean raise = raiser . raise ( weather ) ;
assertThat ( raise , is ( false ) ) ;
}
@Test
public void <unk> ( ) {
Raiser raiser = new Raiser ( ) ;
Weather weather = new Weather ( <num> , <num> , <num> ) ;
boolean raise = raiser . raise ( weather ) ;
assertThat ( raise , is ( false ) ) ;
}
}
package com . seeder ;
public class Seeder {
public boolean seed ( Weather weather ) {
return weather . shouldSeed ( ) ;
}
}
package com . seeder ;
public class Water {
public boolean pour ( Weather weather ) {
return weather . shouldPour ( ) ;
}
}
package com . seeder ;
public class Raiser {
public boolean raise ( Weather weather ) {
return weather . shouldRaise ( ) ;
}
}
package pitzik4 . geode ;
import java . io . File ;
import java . io . FileOutputStream ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . OutputStream ;
import java . net . HttpURLConnection ;
import java . net . MalformedURLException ;
import java . net . URL ;
import java . util . logging . Logger ;
import org . lwjgl . util . vector . Vector3f ;
import misson20000 . api . vorxel . VorxelSettings ;
import misson20000 . api . vorxel . Vorxel ;
public class Geode implements Tickable , Runnable {
private static File gamedir ;
private static final String nativedownload = " ;
public boolean closing = false ;
private int ticks = <num> ;
public long lifeTime = <num> ;
private int frames = <num> ;
public Logger log = Logger . getLogger ( " ) ;
private PlayerController pcont = new PlayerController ( this ) ;
public static final double TICKS_PER_MILLI = <num> / <num> ;
public static void main ( String [ ] args ) {
gamedir = new File ( " ) ;
File nativesf = new File ( " ) ;
if ( ! nativesf . exists ( ) ) {
nativesf . mkdir ( ) ;
String [ ] nativeslinux = { " , " , " , " , " , " } ;
String [ ] nativeswindows = { " , " , " , " , " , " } ;
String [ ] nativesmac = { " , " , " } ;
String [ ] nativesolaris = { " , " , " , " } ;
String os = System . getProperty ( " ) . toLowerCase ( ) ;
String [ ] natives ;
if ( os . startsWith ( " ) ) {
natives = nativeswindows ;
os = " ;
} else if ( os . startsWith ( " ) ) {
natives = nativesmac ;
os = " ;
} else if ( os . startsWith ( " ) ) {
natives = nativesolaris ;
os = " ;
} else if ( os . startsWith ( " ) ) {
natives = nativeslinux ;
os = " ;
} else {
natives = null ;
System . out . println ( " + os ) ;
System . exit ( <num> ) ;
}
for ( int i = <num> ; i < natives . length ; i ++ ) {
System . out . println ( " + natives [ i ] ) ;
File nativef = new File ( " + natives [ i ] ) ;
try {
nativef . createNewFile ( ) ;
} catch ( IOException e1 ) {
e1 . printStackTrace ( ) ;
}
URL url ;
HttpURLConnection conn ;
try {
url = new URL ( nativedownload + os + " + natives [ i ] ) ;
conn = ( HttpURLConnection ) url . openConnection ( ) ;
conn . setRequestMethod ( " ) ;
conn . connect ( ) ;
InputStream in = conn . getInputStream ( ) ;
OutputStream out = new FileOutputStream ( nativef ) ;
byte [ ] buffer = new byte [ <num> ] ;
int bufferSize ;
while ( ( bufferSize = in . read ( buffer , <num> , buffer . length ) ) !=  <num> )
{
out . write ( buffer , <num> , bufferSize ) ;
}
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
}
System . setProperty ( " , nativesf . getAbsolutePath ( ) ) ;
Geode game = new Geode ( ) ;
new Thread ( game ) . start ( ) ;
}
@Override
public void tick ( ) {
pcont . tick ( ) ;
Vorxel . tick ( ) ;
ticks ++ ;
lifeTime ++ ;
}
public void close ( ) {
closing = true ;
}
public void render ( ) {
frames ++ ;
}
@Override
public void run ( ) {
Vorxel . init ( new VorxelSettings ( ) , this ) ;
pcont . goTo ( new Vector3f ( <num> ,  <num> , <num> ) , <num> , <num> ) ;
long time = System . currentTimeMillis ( ) ;
long lastTime = time ;
long slowness = <num> ;
long lastSecond = time ;
double catchup = <num> ;
while ( ! closing ) {
time = System . currentTimeMillis ( ) ;
slowness = time  lastTime ;
lastTime = time ;
Vorxel . render ( ) ;
catchup += ( ( double ) slowness ) * TICKS_PER_MILLI ;
while ( catchup >= <num> ) {
tick ( ) ;
catchup  ;
}
if ( time >= lastSecond + <num> ) {
lastSecond += <num> ;
log . info ( " + frames + " + ticks ) ;
frames = ticks = <num> ;
}
slowness ++ ;
try {
Thread . sleep ( Math . round ( <num> / ( ( double ) slowness ) ) ) ;
} catch ( InterruptedException e ) { }
}
System . exit ( <num> ) ;
}
public PlayerController getPlayerController ( ) {
return pcont ;
}
}
package misson20000 . api . vorxel . renders ;
import org . lwjgl . opengl . GL11 ;
import misson20000 . api . vorxel . Vorxel ;
import misson20000 . api . vorxel . entities . Entity ;
import misson20000 . api . vorxel . models . Box ;
import misson20000 . api . vorxel . models . Face ;
public class RenderEntity {
public static void renderEntity ( Entity ent ) {
GL11 . glLoadIdentity ( ) ;
Vorxel . lookThrough ( ) ;
GL11 . glTranslatef ( <num>  ent . x , <num>  ent . y , <num>  ent . z ) ;
Box [ ] boxes = ent . getModel ( ) . getBoxes ( ) ;
for ( Box box : boxes ) {
box . render ( ) ;
}
}
}
package misson20000 . api . vorxel ;
import org . lwjgl . opengl . GL11 ;
import org . newdawn . slick . opengl . Texture ;
public class VTex implements Texture {
private int id ;
private int height ;
private int width ;
public VTex ( int id ) {
this . id = id ;
}
public void bind ( ) {
GL11 . glBindTexture ( GL11 . GL_TEXTURE_2D , id ) ;
}
@Override
public float getHeight ( ) {
return height ;
}
@Override
public int getImageHeight ( ) {
return height ;
}
@Override
public int getImageWidth ( ) {
return width ;
}
@Override
public byte [ ] <unk> ( ) {
return null ;
}
@Override
public int getTextureHeight ( ) {
return width ;
}
@Override
public int getTextureID ( ) {
return id ;
}
@Override
public String <unk> ( ) {
return null ;
}
@Override
public int getTextureWidth ( ) {
return width ;
}
@Override
public float getWidth ( ) {
return width ;
}
@Override
public boolean hasAlpha ( ) {
return false ;
}
@Override
public void release ( ) {
}
}
package misson20000 . api . vorxel ;
import java . nio . ByteBuffer ;
import java . nio . ByteOrder ;
import java . nio . FloatBuffer ;
import java . nio . IntBuffer ;
public class GLAllocator {
public static synchronized ByteBuffer createDirectByteBuffer ( int par0 )
{
ByteBuffer bytebuffer = ByteBuffer . allocateDirect ( par0 ) . order ( ByteOrder . nativeOrder ( ) ) ;
return bytebuffer ;
}
public static IntBuffer <unk> ( int par0 )
{
return createDirectByteBuffer ( par0 << <num> ) . asIntBuffer ( ) ;
}
public static FloatBuffer <unk> ( int par0 )
{
return createDirectByteBuffer ( par0 << <num> ) . asFloatBuffer ( ) ;
}
}
package misson20000 . api . vorxel . models ;
import java . io . File ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . io . IOException ;
import org . newdawn . slick . opengl . TextureLoader ;
import pitzik4 . geode . Geode ;
import misson20000 . api . vorxel . cubes . Cube ;
public class ModelHuman extends Model {
private final Box RARM = new Box ( ) ;
private final Box HEAD = new Box ( ) ;
private final Box BODY = new Box ( ) ;
private final Box LARM = new Box ( ) ;
private final Box RLEG = new Box ( ) ;
private final Box LLEG = new Box ( ) ;
private Face [ ] faces ;
private Box [ ] boxes ;
public ModelHuman ( ) {
loadTextures ( ) ;
boxes = new Box [ <num> ] ;
HEAD . pitch = <num> ;
RARM . pitch = <num> ;
LARM . pitch = <num>  <num> ;
boxes [ <num> ] = HEAD ;
boxes [ <num> ] = BODY ;
boxes [ <num> ] = LARM ;
boxes [ <num> ] = RARM ;
createHead ( ) ;
createBody ( ) ;
createLeftArm ( ) ;
createRightArm ( ) ;
}
private void <unk> ( ) {
faces [ <num> ] = new Face ( EnumFaceSide . TOP , RLEG . top , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
faces [ <num> ] = new Face ( EnumFaceSide . BOTTOM , RLEG . bottom , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
faces [ <num> ] = new Face ( EnumFaceSide . FRONT , RLEG . front , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
faces [ <num> ] = new Face ( EnumFaceSide . BACK , RLEG . back , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
faces [ <num> ] = new Face ( EnumFaceSide . RIGHT , RLEG . right , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
faces [ <num> ] = new Face ( EnumFaceSide . LEFT , RLEG . left , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
}
private void <unk> ( ) {
faces [ <num> ] = new Face ( EnumFaceSide . TOP , LLEG . top , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
faces [ <num> ] = new Face ( EnumFaceSide . BOTTOM , LLEG . bottom , <num> , <num> , <num> ,  <num> ,  <num> , <num> ) ;
faces [ <num> ] = new Face ( EnumFaceSide . FRONT , LLEG . front , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
faces [ <num> ] = new Face ( EnumFaceSide . BACK , LLEG . back , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
faces [ <num> ] = new Face ( EnumFaceSide . RIGHT , LLEG . right , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
faces [ <num> ] = new Face ( EnumFaceSide . LEFT , LLEG . left , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
}
private void createRightArm ( ) {
RARM . faces [ <num> ] = new Face ( EnumFaceSide . TOP , RARM . top , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
RARM . faces [ <num> ] = new Face ( EnumFaceSide . BOTTOM , RARM . bottom , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
RARM . faces [ <num> ] = new Face ( EnumFaceSide . FRONT , RARM . front , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
RARM . faces [ <num> ] = new Face ( EnumFaceSide . BACK , RARM . back , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
RARM . faces [ <num> ] = new Face ( EnumFaceSide . RIGHT , RARM . right , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
RARM . faces [ <num> ] = new Face ( EnumFaceSide . LEFT , RARM . left , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
}
private void createLeftArm ( ) {
LARM . faces [ <num> ] = new Face ( EnumFaceSide . TOP , LARM . top , <num> , <num> , <num> ,  <num> ,  <num> , <num> ) ;
LARM . faces [ <num> ] = new Face ( EnumFaceSide . BOTTOM , LARM . bottom , <num> , <num> , <num> ,  <num> ,  <num> , <num> ) ;
LARM . faces [ <num> ] = new Face ( EnumFaceSide . FRONT , LARM . front , <num> , <num> , <num> ,  <num> ,  <num> , <num> ) ;
LARM . faces [ <num> ] = new Face ( EnumFaceSide . BACK , LARM . back , <num> , <num> , <num> ,  <num> ,  <num> , <num> ) ;
LARM . faces [ <num> ] = new Face ( EnumFaceSide . RIGHT , LARM . right , <num> , <num> , <num> ,  <num> ,  <num> , <num> ) ;
LARM . faces [ <num> ] = new Face ( EnumFaceSide . LEFT , LARM . left , <num> , <num> , <num> ,  <num> ,  <num> , <num> ) ;
}
private void createBody ( ) {
BODY . faces [ <num> ] = new Face ( EnumFaceSide . TOP , BODY . top , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
BODY . faces [ <num> ] = new Face ( EnumFaceSide . BOTTOM , BODY . bottom , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
BODY . faces [ <num> ] = new Face ( EnumFaceSide . FRONT , BODY . front , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
BODY . faces [ <num> ] = new Face ( EnumFaceSide . BACK , BODY . back , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
BODY . faces [ <num> ] = new Face ( EnumFaceSide . RIGHT , BODY . right , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
BODY . faces [ <num> ] = new Face ( EnumFaceSide . LEFT , BODY . left , <num> , <num> , <num> , <num> ,  <num> , <num> ) ;
}
private void createHead ( ) {
HEAD . init ( <num> , <num> , <num> , <num> , <num> , <num> ) ;
}
@Override
public Face [ ] getFaces ( ) {
return faces ;
}
public void loadTextures ( ) {
try {
HEAD . top = TextureLoader . getTexture ( " , new FileInputStream ( new File ( " ) ) , true ) ;
HEAD . bottom = TextureLoader . getTexture ( " , new FileInputStream ( new File ( " ) ) , true ) ;
HEAD . front = TextureLoader . getTexture ( " , new FileInputStream ( new File ( " ) ) , true ) ;
HEAD . back = TextureLoader . getTexture ( " , new FileInputStream ( new File ( " ) ) , true ) ;
HEAD . left = TextureLoader . getTexture ( " , new FileInputStream ( new File ( " ) ) , true ) ;
HEAD . right = TextureLoader . getTexture ( " , new FileInputStream ( new File ( " ) ) , true ) ;
LARM . top = HEAD . bottom ;
LARM . bottom = HEAD . bottom ;
LARM . front = HEAD . bottom ;
LARM . back = HEAD . bottom ;
LARM . left = HEAD . bottom ;
LARM . right = HEAD . bottom ;
RARM . top = HEAD . bottom ;
RARM . bottom = HEAD . bottom ;
RARM . front = HEAD . bottom ;
RARM . back = HEAD . bottom ;
RARM . left = HEAD . bottom ;
RARM . right = HEAD . bottom ;
BODY . top = HEAD . bottom ;
BODY . bottom = HEAD . bottom ;
BODY . front = HEAD . bottom ;
BODY . back = HEAD . bottom ;
BODY . left = HEAD . bottom ;
BODY . right = HEAD . bottom ;
LLEG . top = HEAD . bottom ;
LLEG . bottom = HEAD . bottom ;
LLEG . front = HEAD . bottom ;
LLEG . back = HEAD . bottom ;
LLEG . left = HEAD . bottom ;
LLEG . right = HEAD . bottom ;
} catch ( FileNotFoundException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
@Override
public Box [ ] getBoxes ( ) {
return boxes ;
}
}
package misson20000 . api . vorxel . cubes ;
import misson20000 . api . vorxel . renders . Render ;
import org . newdawn . slick . opengl . Texture ;
public abstract class Cube {
public static final Cube air = new CubeAir ( ) ;
public static final Cube grass = new CubeGrass ( ) ;
public static final Cube dirt = new CubeDirt ( ) ;
public static final Cube water = new CubeWater ( ) ;
public Texture texture ;
public Texture toptexture ;
public int x ;
public int y ;
public int z ;
public Render getRender ( ) {
return Render . renderStandardCube ;
}
public abstract boolean isSolid ( ) ;
}
package pitzik4 . geode ;
import org . lwjgl . input . Mouse ;
import org . lwjgl . util . vector . Vector3f ;
public class PlayerController implements Tickable {
private Geode game ;
private Vector3f pos ;
private float pitch ;
private float yaw ;
public static float WALK_SPEED = <num> ;
public PlayerController ( Geode geode ) {
game = geode ;
}
@Override
public void tick ( ) {
yaw ( Mouse . getDX ( ) ) ;
pitch (  Mouse . getDY ( ) ) ;
if ( Control . MOVE_FORWARD . isDown ( ) ) {
walkForward ( WALK_SPEED ) ;
}
if ( Control . MOVE_BACK . isDown ( ) ) {
walkBackwards ( WALK_SPEED ) ;
}
if ( Control . MOVE_LEFT . isDown ( ) ) {
strafeLeft ( WALK_SPEED ) ;
}
if ( Control . MOVE_RIGHT . isDown ( ) ) {
strafeRight ( WALK_SPEED ) ;
}
if ( Control . MOVE_DOWN . isDown ( ) ) {
moveDown ( WALK_SPEED ) ;
}
if ( Control . MOVE_UP . isDown ( ) ) {
moveUp ( WALK_SPEED ) ;
}
}
private void moveDown ( float speed ) {
pos . y -= speed ;
}
private void moveUp ( float speed ) {
pos . y += speed ;
}
public void yaw ( float amount )
{
yaw += amount ;
}
public void pitch ( float amount )
{
pitch += amount ;
if ( pitch <  <num> || pitch > <num> ) {
pitch -= amount ;
}
}
public void walkForward ( float distance )
{
pos . x -= distance * ( float ) Math . sin ( Math . toRadians ( yaw ) ) ;
pos . z += distance * ( float ) Math . cos ( Math . toRadians ( yaw ) ) ;
}
public void walkBackwards ( float distance )
{
pos . x += distance * ( float ) Math . sin ( Math . toRadians ( yaw ) ) ;
pos . z -= distance * ( float ) Math . cos ( Math . toRadians ( yaw ) ) ;
}
public void strafeLeft ( float distance )
{
pos . x -= distance * ( float ) Math . sin ( Math . toRadians ( yaw  <num> ) ) ;
pos . z += distance * ( float ) Math . cos ( Math . toRadians ( yaw  <num> ) ) ;
}
public void strafeRight ( float distance )
{
pos . x -= distance * ( float ) Math . sin ( Math . toRadians ( yaw + <num> ) ) ;
pos . z += distance * ( float ) Math . cos ( Math . toRadians ( yaw + <num> ) ) ;
}
public void goTo ( Vector3f pos , float pitch , float yaw ) {
this . pos = pos ;
this . pitch = pitch ;
this . yaw = yaw ;
}
public float getPitch ( ) {
return pitch ;
}
public float getYaw ( ) {
return yaw ;
}
public float getX ( ) {
return pos . x ;
}
public float getY ( ) {
return pos . y ;
}
public float getZ ( ) {
return pos . z ;
}
}
package misson20000 . api . vorxel ;
import misson20000 . api . vorxel . cubes . Cube ;
import org . lwjgl . util . vector . Vector3f ;
public class World {
public float movespeed = <num> ;
private Cube [ ] [ ] [ ] spawn ;
public Vector3f getStartingPosition ( ) {
return new Vector3f (  <num> ,  <num> ,  <num> ) ;
}
public Cube [ ] [ ] [ ] getSpawn ( ) {
return spawn ;
}
public void createSpawn ( ) {
spawn = new Cube [ <num> ] [ <num> ] [ <num> ] ;
for ( int x = <num> ; x < <num> ; x ++ ) {
for ( int y = <num> ; y < <num> ; y ++ ) {
for ( int z = <num> ; z < <num> ; z ++ ) {
if ( y == <num> ) {
spawn [ x ] [ y ] [ z ] = Cube . grass ;
} else {
spawn [ x ] [ y ] [ z ] = Cube . air ;
}
}
}
}
}
public Cube getCubeAt ( int x , int y , int z ) {
return spawn [ x ] [ y ] [ z ] ;
}
public Cube getCubeAt ( double x , double y , double z ) {
return spawn [ ( int ) x ] [ ( int ) y ] [ ( int ) z ] ;
}
}
package misson20000 . api . vorxel . cubes ;
import misson20000 . api . vorxel . renders . Render ;
public class CubeGrass extends Cube {
@Override
public Render getRender ( ) {
return Render . renderGrass ;
}
@Override
public boolean isSolid ( ) {
return true ;
}
}
package misson20000 . api . vorxel . models ;
public class Point {
public float x ;
public float y ;
public float z ;
public Point ( float x , float y , float z ) {
this . x = x ;
this . y = y ;
this . z = z ;
}
}
package misson20000 . api . vorxel . cubes ;
import misson20000 . api . vorxel . renders . Render ;
public class CubeAir extends Cube {
@Override
public Render getRender ( ) {
return Render . renderNothing ;
}
@Override
public boolean isSolid ( ) {
return false ;
}
}
package misson20000 . api . vorxel . renders ;
import java . nio . ByteBuffer ;
import java . nio . DoubleBuffer ;
import org . lwjgl . opengl . GL11 ;
import misson20000 . api . vorxel . Vorxel ;
import misson20000 . api . vorxel . cubes . Cube ;
import static org . lwjgl . opengl . GL11 . * ;
public class RenderWater extends RenderStandardCube {
private static final int texSize = <num> ;
private int reflection = Cube . dirt . texture . getTextureID ( ) ;
private boolean rendering ;
@Override
public void render ( Cube c ) {
if ( ! rendering ) {
rendering = true ;
GL11 . glPushMatrix ( ) ;
glLoadIdentity ( ) ;
GL11 . glTranslatef ( <num>  c . x , <num>  c . y , <num>  c . z ) ;
glPushMatrix ( ) ;
glTranslatef ( <num> , <num> , <num> ) ;
glScalef ( <num> ,  <num> , <num> ) ;
double [ ] p = { <num> , <num> , <num> , <num> } ;
DoubleBuffer plane = ByteBuffer . allocateDirect ( <num> ) . <unk> ( ) ;
plane . put ( p ) ;
plane . position ( <num> ) ;
glEnable ( GL_CLIP_PLANE0 ) ;
<unk> ( GL_CLIP_PLANE0 , plane ) ;
Vorxel . renderScene ( ) ;
glDisable ( GL_CLIP_PLANE0 ) ;
glPopMatrix ( ) ;
glBindTexture ( GL_TEXTURE_2D , reflection ) ;
<unk> ( GL_TEXTURE_2D , <num> , <num> , <num> , <num> , <num> , texSize , texSize ) ;
GL11 . glBegin ( GL11 . GL_QUADS ) ;
renderTopFace ( ) ;
renderBottomFace ( ) ;
renderFrontFace ( ) ;
renderBackFace ( ) ;
renderLeftFace ( ) ;
renderRightFace ( ) ;
GL11 . glEnd ( ) ;
GL11 . glViewport ( <num> , <num> , <num> , <num> ) ;
GL11 . glPopMatrix ( ) ;
rendering = false ;
}
}
}
package misson20000 . api . vorxel . cubes ;
public class CubeDirt extends Cube {
@Override
public boolean isSolid ( ) {
return true ;
}
}
package misson20000 . api . vorxel ;
public class Location {
public Location ( int x2 , int y2 , int z2 ) {
x = x2 ;
y = y2 ;
z = z2 ;
}
public int x ;
public int y ;
public int z ;
}
package misson20000 . api . vorxel ;
public class Settings {
public int width = <num> ;
public int height = <num> ;
public boolean shouldTick = true ;
public float TICK_PER_MILLI = <num> / <num> ;
}
package misson20000 . api . vorxel . renders ;
import static org . lwjgl . opengl . GL11 . glVertex3f ;
import static org . lwjgl . opengl . GL11 . glTexCoord2f ;
import misson20000 . api . vorxel . cubes . Cube ;
import org . lwjgl . opengl . GL11 ;
public class RenderStandardCube extends Render {
@Override
public void render ( Cube c ) {
GL11 . glColor3f ( <num> , <num> , <num> ) ;
c . texture . bind ( ) ;
GL11 . glBegin ( GL11 . GL_QUADS ) ;
renderTopFace ( ) ;
renderBottomFace ( ) ;
renderFrontFace ( ) ;
renderBackFace ( ) ;
renderLeftFace ( ) ;
renderRightFace ( ) ;
GL11 . glEnd ( ) ;
}
protected void renderRightFace ( ) {
GL11 . glColor3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
}
protected void renderLeftFace ( ) {
GL11 . glColor3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
}
protected void renderBackFace ( ) {
GL11 . glColor3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
}
protected void renderFrontFace ( ) {
GL11 . glColor3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
}
protected void renderBottomFace ( ) {
GL11 . glColor3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
}
protected void renderTopFace ( ) {
GL11 . glColor3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( <num> , <num> , <num> ) ;
}
}
package misson20000 . api . vorxel ;
public interface Game extends Tickable {
}
package pitzik4 . geode ;
import org . lwjgl . input . Keyboard ;
public enum Control {
MOVE_LEFT ( Keyboard . KEY_A ) ,
MOVE_RIGHT ( Keyboard . KEY_D ) ,
MOVE_FORWARD ( Keyboard . KEY_W ) ,
MOVE_BACK ( Keyboard . KEY_S ) ,
JUMP ( Keyboard . KEY_SPACE ) ,
MOVE_DOWN ( Keyboard . <unk> ) ,
MOVE_UP ( Keyboard . <unk> ) ;
private int keyValue ;
private Control ( int keyValue ) {
this . keyValue = keyValue ;
}
public boolean isDown ( ) {
return Keyboard . isKeyDown ( keyValue ) ;
}
public int getKeyValue ( ) {
return keyValue ;
}
}
package misson20000 . api . vorxel . entities ;
import java . util . Random ;
import misson20000 . api . vorxel . models . Model ;
import misson20000 . api . vorxel . models . ModelHuman ;
public class EntityHuman extends Entity {
private Model model = new ModelHuman ( ) ;
private Random ai = new Random ( ) ;
@Override
public Model getModel ( ) {
return model ;
}
@Override
public void onTick ( ) {
if ( ( ai . nextInt ( <num> ) ) == <num> ) {
x += <num> ;
}
if ( ( ai . nextInt ( <num> ) ) == <num> ) {
z += <num> ;
}
}
}
package misson20000 . api . vorxel . renders ;
import java . util . ArrayList ;
import org . lwjgl . opengl . GL11 ;
import misson20000 . api . vorxel . Location ;
import misson20000 . api . vorxel . Vorxel ;
import misson20000 . api . vorxel . cubes . Cube ;
import misson20000 . api . vorxel . cubes . CubeWater ;
import misson20000 . api . vorxel . entities . Entity ;
public abstract class Render {
public static final Render renderStandardCube = new RenderStandardCube ( ) ;
public static final Render renderNothing = new RenderNothing ( ) ;
public static final Render renderGrass = new RenderGrass ( ) ;
public static final Render renderWater = new RenderWater ( ) ;
public abstract void render ( Cube c ) ;
public static void renderCube ( Cube c ) {
c . getRender ( ) . render ( c ) ;
}
public static void renderArray ( Cube [ ] [ ] [ ] cubes ) {
for ( int x = <num> ; x < <num> ; x ++ ) {
for ( int y = <num> ; y < <num> ; y ++ ) {
for ( int z = <num> ; z < <num> ; z ++ ) {
renderCube ( cubes [ x ] [ y ] [ z ] ) ;
GL11 . glTranslatef ( <num> , <num> , <num> ) ;
}
GL11 . glTranslatef ( <num> , <num> ,  <num> ) ;
}
GL11 . glTranslatef ( <num> ,  <num> , <num> ) ;
}
}
public static void renderEntities ( ArrayList < Entity > list ) {
for ( int i = <num> ; i < list . size ( ) ; i ++ ) {
RenderEntity . renderEntity ( list . get ( i ) ) ;
}
}
}
package misson20000 . api . vorxel . renders ;
import misson20000 . api . vorxel . cubes . Cube ;
public class RenderNothing extends Render {
@Override
public void render ( Cube c ) {
}
}
package pitzik4 . geode . blocks ;
import misson20000 . api . vorxel . cubes . Cube ;
public abstract class Block {
int id ;
public abstract Cube getCube ( ) ;
}
package pitzik4 . geode ;
import java . util . ArrayList ;
import misson20000 . api . vorxel . cubes . Cube ;
import misson20000 . api . vorxel . entities . Entity ;
import misson20000 . api . vorxel . entities . EntityHuman ;
import org . lwjgl . util . vector . Vector3f ;
public class World {
public float movespeed = <num> ;
private Cube [ ] [ ] [ ] spawn ;
public ArrayList < Entity > entities = new ArrayList < Entity > ( ) ;
public Vector3f getStartingPosition ( ) {
return new Vector3f (  <num> ,  <num> ,  <num> ) ;
}
public Cube [ ] [ ] [ ] getSpawn ( ) {
return spawn ;
}
public void createSpawn ( ) {
spawn = new Cube [ <num> ] [ <num> ] [ <num> ] ;
for ( int x = <num> ; x < <num> ; x ++ ) {
for ( int y = <num> ; y < <num> ; y ++ ) {
for ( int z = <num> ; z < <num> ; z ++ ) {
if ( y == <num> ) {
spawn [ x ] [ y ] [ z ] = Cube . grass ;
} else {
spawn [ x ] [ y ] [ z ] = Cube . air ;
}
}
}
}
spawnEntity ( new EntityHuman ( ) , <num> ,  <num> , <num> ) ;
}
private void spawnEntity ( Entity entity , int x , int y , int z ) {
entity . x = x ;
entity . y = y ;
entity . z = z ;
entities . add ( entity ) ;
}
public Cube getCubeAt ( int x , int y , int z ) {
return spawn [ x ] [ y ] [ z ] ;
}
public Cube getCubeAt ( double x , double y , double z ) {
return spawn [ ( int ) x ] [ ( int ) y ] [ ( int ) z ] ;
}
}
package misson20000 . api . vorxel ;
import misson20000 . api . vorxel . renders . Render ;
public class CubeGrass extends Cube {
@Override
public Render getRender ( ) {
return Vorxel . renderGrass ;
}
}
package misson20000 . api . vorxel . cubes ;
import misson20000 . api . vorxel . renders . Render ;
public class CubeWater extends Cube {
@Override
public Render getRender ( ) {
return Render . renderWater ;
}
@Override
public boolean isSolid ( ) {
return false ;
}
}
package misson20000 . api . vorxel ;
public class <unk> extends Thread {
private boolean stopping ;
private double TICKS_PER_MILLI ;
public void run ( ) {
long time = System . currentTimeMillis ( ) ;
long lastTime = time ;
double catchup = <num> ;
while ( ! stopping ) {
time = System . currentTimeMillis ( ) ;
long slowness = time  lastTime ;
lastTime = time ;
catchup += ( ( double ) slowness ) * TICKS_PER_MILLI ;
while ( catchup >= <num> ) {
tick ( ) ;
catchup  ;
}
if ( slowness > <num> ) {
try {
Thread . sleep ( <num> / slowness ) ;
} catch ( InterruptedException e ) { }
}
}
}
private void tick ( ) {
Vorxel . tick ( ) ;
}
}
package misson20000 . api . vorxel ;
import java . io . IOException ;
import java . nio . ByteBuffer ;
import java . nio . IntBuffer ;
import java . util . HashMap ;
import java . util . Random ;
import misson20000 . api . vorxel . cubes . Cube ;
import misson20000 . api . vorxel . models . ModelHuman ;
import misson20000 . api . vorxel . renders . Render ;
import org . lwjgl . LWJGLException ;
import org . lwjgl . input . Keyboard ;
import org . lwjgl . input . Mouse ;
import org . lwjgl . openal . AL ;
import org . lwjgl . opengl . Display ;
import org . lwjgl . opengl . DisplayMode ;
import org . lwjgl . opengl . GL11 ;
import org . lwjgl . opengl . <unk> ;
import org . lwjgl . util . glu . GLU ;
import org . lwjgl . util . vector . Vector3f ;
import org . newdawn . slick . opengl . Texture ;
import org . newdawn . slick . opengl . TextureLoader ;
import pitzik4 . geode . Geode ;
import pitzik4 . geode . World ;
public class Vorxel {
private static Geode game ;
private static boolean exit ;
public static float windz = <num> ;
public static float windx = <num> ;
@SuppressWarnings("unused")
private static float <unk> = <num> ; ;
@SuppressWarnings("unused")
private static float <unk> = <num> ;
@SuppressWarnings("unused")
private static Random random = new Random ( ) ;
private static World world ;
public static HashMap < Integer , Location > <unk> ;
public static Integer nextName = <num> ;
public static void init ( VorxelSettings set , Geode gamep ) {
world = new World ( ) ;
game = gamep ;
try {
DisplayMode d [ ] = Display . getAvailableDisplayModes ( ) ;
DisplayMode displayMode = d [ <num> ] ;
Display . setDisplayMode ( displayMode ) ;
Display . create ( ) ;
Mouse . create ( ) ;
Keyboard . create ( ) ;
GL11 . glEnable ( GL11 . GL_TEXTURE_2D ) ;
GL11 . glShadeModel ( GL11 . GL_SMOOTH ) ;
GL11 . glClearColor ( <num> , <num> , <num> , <num> ) ;
GL11 . <unk> ( <num> ) ;
GL11 . glEnable ( GL11 . GL_DEPTH_TEST ) ;
GL11 . glDepthFunc ( GL11 . GL_LEQUAL ) ;
GL11 . glMatrixMode ( GL11 . GL_PROJECTION ) ;
GL11 . glLoadIdentity ( ) ;
GLU . gluPerspective (
<unk> ,
( float ) displayMode . getWidth ( ) / ( float ) displayMode . getHeight ( ) ,
<unk> ,
<unk> ) ;
GL11 . glMatrixMode ( GL11 . GL_MODELVIEW ) ;
GL11 . glHint ( GL11 . GL_PERSPECTIVE_CORRECTION_HINT , GL11 . GL_NICEST ) ;
TextureHelper . init ( ) ;
Cube . dirt . texture = new VTex ( <num> ) ;
Cube . grass . texture = Cube . dirt . texture ;
Cube . grass . toptexture = new VTex ( <num> ) ;
Mouse . setGrabbed ( true ) ;
world . createSpawn ( ) ;
} catch ( LWJGLException e ) {
e . printStackTrace ( ) ;
}
}
public static void lookThrough ( )
{
GL11 . glRotatef ( game . getPlayerController ( ) . getPitch ( ) , <num> , <num> , <num> ) ;
GL11 . glRotatef ( game . getPlayerController ( ) . getYaw ( ) , <num> , <num> , <num> ) ;
GL11 . glTranslatef ( game . getPlayerController ( ) . getX ( ) , game . getPlayerController ( ) . getY ( ) , game . getPlayerController ( ) . getZ ( ) ) ;
}
public static void tick ( ) {
if ( Display . <unk> ( ) ) {
if ( Keyboard . isKeyDown ( Keyboard . KEY_ESCAPE ) ) {
exit = true ;
}
if ( Keyboard . isKeyDown ( Keyboard . <unk> ) ) {
Mouse . setGrabbed ( false ) ;
}
if ( Mouse . isButtonDown ( <num> ) ) {
Mouse . setGrabbed ( true ) ;
}
Display . update ( ) ;
if ( Display . isCloseRequested ( ) || exit ) {
game . close ( ) ;
Display . destroy ( ) ;
}
}
for ( int i = <num> ; i < world . entities . size ( ) ; i ++ ) {
world . entities . get ( i ) . onTick ( ) ;
}
}
public static void render ( ) {
GL11 . glClearColor ( <num> , <num> / <num> , <num> , <num> ) ;
GL11 . glClear ( GL11 . GL_COLOR_BUFFER_BIT | GL11 . GL_DEPTH_BUFFER_BIT ) ;
GL11 . glColor3f ( <num> , <num> , <num> ) ;
GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MAG_FILTER , GL11 . GL_NEAREST ) ;
GL11 . glLoadIdentity ( ) ;
lookThrough ( ) ;
Render . renderArray ( world . getSpawn ( ) ) ;
Render . renderEntities ( world . entities ) ;
Display . update ( ) ;
}
private static void <unk> ( ) {
}
private static void <unk> ( ) {
IntBuffer buffer = ByteBuffer . allocateDirect ( nextName ) . asIntBuffer ( ) ;
GL11 . <unk> ( buffer ) ;
GL11 . glRenderMode ( GL11 . <unk> ) ;
GL11 . glMatrixMode ( GL11 . GL_PROJECTION ) ;
GL11 . glPushMatrix ( ) ;
GL11 . glLoadIdentity ( ) ;
GLU . <unk> ( Mouse . getX ( ) , Mouse . getY ( ) , <num> , <num> , buffer ) ;
GL11 . glRenderMode ( GL11 . <unk> ) ;
}
public static void renderScene ( ) {
game . render ( ) ;
GL11 . glColor3f ( <num> , <num> , <num> ) ;
GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MAG_FILTER , GL11 . GL_NEAREST ) ;
Render . renderArray ( world . getSpawn ( ) ) ;
GL11 . glLoadIdentity ( ) ;
Display . update ( ) ;
}
}
package misson20000 . api . vorxel ;
import java . awt . image . BufferedImage ;
import java . io . File ;
import java . io . IOException ;
import java . nio . ByteBuffer ;
import javax . imageio . ImageIO ;
import org . lwjgl . opengl . GL11 ;
public class TextureHelper {
private static final int TEX_WIDTH = <num> ;
private static final int TEX_HEIGHT = <num> ;
private static final String TEX_FILE_NAME = " ;
private static ByteBuffer imageData ;
public static void init ( ) {
imageData = GLAllocator . createDirectByteBuffer ( <num> ) ;
try {
BufferedImage img = ImageIO . read ( new File ( TEX_FILE_NAME ) ) ;
BufferedImage [ ] [ ] tex = new BufferedImage [ <num> ] [ <num> ] ;
int i = <num> ;
for ( int y = <num> ; y < TEX_HEIGHT * <num> ; y += TEX_HEIGHT ) {
for ( int x = <num> ; x < TEX_WIDTH * <num> ; x += TEX_WIDTH ) {
loadTexture ( img . getSubimage ( x , y , TEX_WIDTH , TEX_HEIGHT ) , i ) ;
i ++ ;
}
}
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
public static void loadTexture ( BufferedImage buf , int id ) {
GL11 . glBindTexture ( GL11 . GL_TEXTURE_2D , id ) ;
GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MIN_FILTER , GL11 . GL_NEAREST ) ;
GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MAG_FILTER , GL11 . GL_NEAREST ) ;
GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_S , GL11 . GL_CLAMP ) ;
GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_T , GL11 . GL_CLAMP ) ;
GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_S , GL11 . GL_REPEAT ) ;
GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_T , GL11 . GL_REPEAT ) ;
int i = buf . getWidth ( ) ;
int j = buf . getHeight ( ) ;
int ai [ ] = new int [ i * j ] ;
byte abyte0 [ ] = new byte [ i * j * <num> ] ;
buf . getRGB ( <num> , <num> , i , j , ai , <num> , i ) ;
for ( int k = <num> ; k < ai . length ; k ++ )
{
int i1 = ai [ k ] >> <num> & <num> ;
int k1 = ai [ k ] >> <num> & <num> ;
int i2 = ai [ k ] >> <num> & <num> ;
int k2 = ai [ k ] & <num> ;
abyte0 [ k * <num> + <num> ] = ( byte ) k1 ;
abyte0 [ k * <num> + <num> ] = ( byte ) i2 ;
abyte0 [ k * <num> + <num> ] = ( byte ) k2 ;
abyte0 [ k * <num> + <num> ] = ( byte ) i1 ;
}
imageData . clear ( ) ;
imageData . put ( abyte0 ) ;
imageData . position ( <num> ) . limit ( abyte0 . length ) ;
GL11 . glTexImage2D ( GL11 . GL_TEXTURE_2D , <num> , GL11 . GL_RGBA , i , j , <num> , GL11 . GL_RGBA , GL11 . GL_UNSIGNED_BYTE , imageData ) ;
}
}
package misson20000 . api . vorxel ;
public interface Tickable {
public void tick ( ) ;
}
package misson20000 . api . vorxel . models ;
public abstract class Model {
public abstract Face [ ] getFaces ( ) ;
public abstract Box [ ] getBoxes ( ) ;
}
package misson20000 . api . vorxel . models ;
import org . lwjgl . opengl . GL11 ;
import org . newdawn . slick . opengl . Texture ;
public class Face {
public static final int TOP = <num> ;
public static final int BOTTOM = <num> ;
public static final int FRONT = <num> ;
public static final int BACK = <num> ;
public static final int LEFT = <num> ;
public static final int RIGHT = <num> ;
public Texture texture ;
public Point [ ] points = new Point [ <num> ] ;
private EnumFaceSide which ;
private float x ;
private float y ;
private float z ;
public Face ( EnumFaceSide which , Texture tex ) {
texture = tex ;
this . which = which ;
if ( which . equals ( EnumFaceSide . TOP ) ) initTop ( ) ;
if ( which . equals ( EnumFaceSide . BOTTOM ) ) initBottom ( ) ;
if ( which . equals ( EnumFaceSide . LEFT ) ) initLeft ( ) ;
if ( which . equals ( EnumFaceSide . RIGHT ) ) initRight ( ) ;
if ( which . equals ( EnumFaceSide . FRONT ) ) initFront ( ) ;
if ( which . equals ( EnumFaceSide . BACK ) ) initBack ( ) ;
}
public Face ( EnumFaceSide which , Texture tex , float width , float height , float depth , float x , float y , float z ) {
texture = tex ;
this . which = which ;
this . x = x ;
this . y = y ;
this . z = z ;
if ( which . equals ( EnumFaceSide . TOP ) ) initTop ( width , height , depth ) ;
if ( which . equals ( EnumFaceSide . BOTTOM ) ) initBottom ( width , height , depth ) ;
if ( which . equals ( EnumFaceSide . LEFT ) ) initLeft ( width , height , depth ) ;
if ( which . equals ( EnumFaceSide . RIGHT ) ) initRight ( width , height , depth ) ;
if ( which . equals ( EnumFaceSide . FRONT ) ) initFront ( width , height , depth ) ;
if ( which . equals ( EnumFaceSide . BACK ) ) initBack ( width , height , depth ) ;
}
private void initBack ( float width , float height , float depth ) {
points [ <num> ] = new Point ( x + width , y + height , z ) ;
points [ <num> ] = new Point ( x , y + height , z ) ;
points [ <num> ] = new Point ( x , y , z ) ;
points [ <num> ] = new Point ( x + width , y , z ) ;
}
private void initFront ( float width , float height , float depth ) {
points [ <num> ] = new Point ( x + width , y + height , z + depth ) ;
points [ <num> ] = new Point ( x , y + height , z + depth ) ;
points [ <num> ] = new Point ( x , y , z + depth ) ;
points [ <num> ] = new Point ( x + width , y , z + depth ) ;
}
private void initRight ( float width , float height , float depth ) {
points [ <num> ] = new Point ( width + x , y + height , z + depth ) ;
points [ <num> ] = new Point ( width + x , y + height , z ) ;
points [ <num> ] = new Point ( width + x , y , z ) ;
points [ <num> ] = new Point ( width + x , y , z + depth ) ;
}
private void initLeft ( float width , float height , float depth ) {
points [ <num> ] = new Point ( x , y + height , z + depth ) ;
points [ <num> ] = new Point ( x , y + height , z ) ;
points [ <num> ] = new Point ( x , y , z ) ;
points [ <num> ] = new Point ( x , y , z + depth ) ;
}
private void initBottom ( float width , float height , float depth ) {
points [ <num> ] = new Point ( x + width , y , z + depth ) ;
points [ <num> ] = new Point ( x , y , z + depth ) ;
points [ <num> ] = new Point ( x , y , z ) ;
points [ <num> ] = new Point ( x + width , y , z ) ;
}
private void initTop ( float width , float height , float depth ) {
points [ <num> ] = new Point ( width + x , y , depth + z ) ;
points [ <num> ] = new Point ( x , y , depth + z ) ;
points [ <num> ] = new Point ( x , y , z ) ;
points [ <num> ] = new Point ( width + x , y , z ) ;
}
private void initRight ( ) {
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
}
private void initLeft ( ) {
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
}
private void initBack ( ) {
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
}
private void initFront ( ) {
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
}
private void initBottom ( ) {
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
}
private void initTop ( ) {
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
points [ <num> ] = new Point ( <num> , <num> , <num> ) ;
}
public void render ( ) {
GL11 . glColor3f ( <num> , <num> , <num> ) ;
GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MAG_FILTER , GL11 . GL_NEAREST ) ;
texture . bind ( ) ;
GL11 . glBegin ( GL11 . GL_QUADS ) ;
GL11 . glTexCoord2f ( <num> , <num> ) ;
GL11 . glVertex3f ( points [ <num> ] . x , points [ <num> ] . y , points [ <num> ] . z ) ;
GL11 . glTexCoord2f ( <num> , <num> ) ;
GL11 . glVertex3f ( points [ <num> ] . x , points [ <num> ] . y , points [ <num> ] . z ) ;
GL11 . glTexCoord2f ( <num> , <num> ) ;
GL11 . glVertex3f ( points [ <num> ] . x , points [ <num> ] . y , points [ <num> ] . z ) ;
GL11 . glTexCoord2f ( <num> , <num> ) ;
GL11 . glVertex3f ( points [ <num> ] . x , points [ <num> ] . y , points [ <num> ] . z ) ;
GL11 . glEnd ( ) ;
}
}
package misson20000 . api . vorxel . models ;
public enum EnumFaceSide {
TOP , BOTTOM , FRONT , BACK , LEFT , RIGHT
}
package misson20000 . api . vorxel . renders ;
import static org . lwjgl . opengl . GL11 . glTexCoord2f ;
import static org . lwjgl . opengl . GL11 . glVertex3f ;
import org . lwjgl . opengl . GL11 ;
import misson20000 . api . vorxel . Vorxel ;
import misson20000 . api . vorxel . cubes . Cube ;
public class RenderGrass extends RenderStandardCube {
@Override
public void render ( Cube c ) {
GL11 . glColor3f ( <num> , <num> , <num> ) ;
GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MAG_FILTER , GL11 . GL_NEAREST ) ;
c . toptexture . bind ( ) ;
GL11 . glBegin ( GL11 . GL_QUADS ) ;
renderTopFace ( ) ;
renderGrassBlade ( <num> , <num> ) ;
renderGrassBlade ( <num> , <num> ) ;
renderGrassBlade ( <num> , <num> ) ;
renderGrassBlade ( <num> , <num> ) ;
renderGrassBlade ( <num> , <num> ) ;
renderGrassBlade ( <num> , <num> ) ;
renderGrassBlade ( <num> , <num> ) ;
renderGrassBlade ( <num> , <num> ) ;
renderGrassBlade ( <num> , <num> ) ;
renderGrassBlade ( <num> , <num> ) ;
GL11 . glEnd ( ) ;
c . texture . bind ( ) ;
GL11 . glBegin ( GL11 . GL_QUADS ) ;
renderBottomFace ( ) ;
renderFrontFace ( ) ;
renderBackFace ( ) ;
renderLeftFace ( ) ;
renderRightFace ( ) ;
GL11 . glEnd ( ) ;
}
private void renderGrassBlade ( float x , float z ) {
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( x + Vorxel . windx , <num> , z + Vorxel . windz ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( x + Vorxel . windx , <num> , z + Vorxel . windz  <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( x , <num> , z  <num> ) ;
glTexCoord2f ( <num> , <num> ) ;
glVertex3f ( x , <num> , z ) ;
}
}
package misson20000 . api . vorxel ;
import misson20000 . api . vorxel . renders . Render ;
import org . newdawn . slick . opengl . Texture ;
public class Cube {
public Texture texture ;
public Texture toptexture ;
public Render getRender ( ) {
return Vorxel . renderStandardCube ;
}
}
package pitzik4 . geode ;
public interface Tickable {
public void tick ( ) ;
}
package misson20000 . api . vorxel . models ;
import org . newdawn . slick . opengl . Texture ;
import static org . lwjgl . opengl . GL11 . * ;
public class Box {
public Texture top ;
public Texture bottom ;
public Texture front ;
public Texture back ;
public Texture left ;
public Texture right ;
public Texture texture ;
public Face [ ] faces = new Face [ <num> ] ;
public float pitch = <num> ;
public float yaw = <num> ;
public float twist = <num> ;
public void render ( ) {
glRotatef ( pitch , <num> , <num> , <num> ) ;
glRotatef ( yaw , <num> , <num> , <num> ) ;
glRotatef ( twist , <num> , <num> , <num> ) ;
faces [ <num> ] . render ( ) ;
faces [ <num> ] . render ( ) ;
faces [ <num> ] . render ( ) ;
faces [ <num> ] . render ( ) ;
faces [ <num> ] . render ( ) ;
faces [ <num> ] . render ( ) ;
glRotatef ( <num>  pitch , <num> , <num> , <num> ) ;
glRotatef ( <num>  yaw , <num> , <num> , <num> ) ;
glRotatef ( <num>  twist , <num> , <num> , <num> ) ;
}
public void init ( float x , float y , float z , float w , float h , float d ) {
faces [ <num> ] = new Face ( EnumFaceSide . TOP , top , w , h , d , x , y , z ) ;
faces [ <num> ] = new Face ( EnumFaceSide . BOTTOM , bottom , w , h , d , x , y , z ) ;
faces [ <num> ] = new Face ( EnumFaceSide . FRONT , front , w , h , d , x , y , z ) ;
faces [ <num> ] = new Face ( EnumFaceSide . BACK , back , w , h , d , x , y , z ) ;
faces [ <num> ] = new Face ( EnumFaceSide . LEFT , left , w , h , d , x , y , z ) ;
faces [ <num> ] = new Face ( EnumFaceSide . RIGHT , right , w , h , d , x , y , z ) ;
}
public void init ( double x , double y , double z , double d , double e , double f ) {
init ( ( float ) x , ( float ) y , ( float ) z , ( float ) d , ( float ) e , ( float ) f ) ;
}
}
package misson20000 . api . vorxel . entities ;
import misson20000 . api . vorxel . models . Model ;
public abstract class Entity {
public int x ;
public int y ;
public int z ;
public abstract Model getModel ( ) ;
public void onTick ( ) {
}
}
package pitzik4 . geode . blocks ;
import misson20000 . api . vorxel . cubes . Cube ;
public class <unk> extends Block {
@Override
public Cube getCube ( ) {
return Cube . grass ;
}
}
package misson20000 . api . vorxel ;
public class VorxelSettings {
public int width = <num> ;
public int height = <num> ;
public boolean shouldTick = true ;
public float TICK_PER_MILLI = <num> / <num> ;
}
import java . io . IOException ;
import java . util . zip . <unk> ;
import java . util . zip . Deflater ;
import java . util . zip . Inflater ;
import org . apache . commons . lang3 . RandomStringUtils ;
import org . <unk> . <unk> . Snappy ;
public class <unk> {
final static int LOOP_COUNT = <num> ;
public static void main ( String [ ] args ) {
final String str = RandomStringUtils . <unk> ( <num> ) ;
compressSnappy ( str ) ;
compressZip ( str ) ;
}
private static void compressZip ( final String str ) {
final long <unk> = System . currentTimeMillis ( ) ;
final Inflater inflater = new Inflater ( ) ;
final Deflater deflater = new Deflater ( ) ;
for ( int i = <num> ; i < LOOP_COUNT ; i ++ ) {
deflater . setInput ( str . getBytes ( ) ) ;
deflater . finish ( ) ;
final byte [ ] output = new byte [ <num> ] ;
final int compLength = deflater . <unk> ( output ) ;
deflater . reset ( ) ;
System . out . println ( compLength ) ;
}
}
private static void compressSnappy ( final String str ) {
try {
final long <unk> = System . currentTimeMillis ( ) ;
for ( int i = <num> ; i < LOOP_COUNT ; i ++ ) {
byte [ ] snappyByte = Snappy . compress ( str ) ;
System . out . println ( snappyByte . length ) ;
}
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
}
package sample ;
import junit . framework . Test ;
import junit . framework . TestCase ;
import junit . framework . TestSuite ;
public class AppTest
extends TestCase
{
public AppTest ( String testName )
{
super ( testName ) ;
}
public static Test suite ( )
{
return new TestSuite ( AppTest . class ) ;
}
public void testApp ( )
{
assertTrue ( true ) ;
}
}
package sample ;
import casmi . Applet ;
import casmi . AppletRunner ;
import casmi . KeyEvent ;
import casmi . MouseButton ;
import casmi . MouseStatus ;
import casmi . graphics . color . Color ;
import casmi . graphics . color . RGBColor ;
import casmi . graphics . element . Rect ;
public class App extends Applet {
private Rect r ;
private Color c = new RGBColor ( " ) ;
@Override
public void setup ( ) {
setSize ( <num> , <num> ) ;
<unk> ( <num> ) ;
r = new Rect ( <num> , <num> ) ;
r . setPosition ( <num> , <num> ) ;
r . setFillColor ( c ) ;
addObject ( r ) ;
}
@Override
public void update ( ) {
long value = System . currentTimeMillis ( ) ;
double rot = value % ( <num> * <num> ) ;
r . setRotation ( rot / <num> , <num> , <num> , <num> ) ;
c . setAlpha ( ( Math . sin ( value / <num> ) + <num> ) / <num> ) ;
r . setFillColor ( c ) ;
}
@Override
public void exit ( ) {
}
@Override
public void mouseEvent ( MouseStatus status , MouseButton button ) {
}
@Override
public void keyEvent ( KeyEvent event ) {
if ( event == KeyEvent . PRESSED ) {
if ( getKeyCode ( ) == <num> ) {
System . exit ( <num> ) ;
}
}
}
public static void main ( String [ ] args ) {
AppletRunner . run ( " , " ) ;
}
package com . mms . mcm . activities ;
import java . util . List ;
import org . ksoap2 . serialization . SoapObject ;
import android . app . Activity ;
import android . app . Dialog ;
import android . app . ProgressDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . DialogInterface . OnCancelListener ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . ImageView ;
import android . widget . ListView ;
import android . widget . TextView ;
import android . widget . AdapterView . OnItemClickListener ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . custom . HomeWorksAdapter ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . model . HomeWorkProjectsResponse ;
import com . mms . mcm . model . Projects ;
import com . mms . mcm . network . NetworkCallback ;
import com . mms . mcm . network . Parser ;
import com . mms . mcm . network . SoapServiceManager ;
public class HomeWorkProjectsActivity extends Activity implements OnItemClickListener {
private AuthenticateResponse authenticateResponse ;
protected String TAG ;
private ListView listview ;
protected List < Projects > prjctsList ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_home_work_projects ) ;
initializeViews ( ) ;
MihirApp app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
SoapServiceManager manager = SoapServiceManager . getInstance ( HomeWorkProjectsActivity . this ) ;
showDialog ( Constants . PROGRESSDIALOG ) ;
manager . sendGetHomeWorkProjectsRequest ( authenticateResponse . getStudent_ID ( ) , callback ) ;
}
private void initializeViews ( ) {
listview = ( ListView ) findViewById ( R . id . home_work_projects_listview ) ;
listview . setOnItemClickListener ( HomeWorkProjectsActivity . this ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
}
@Override
protected Dialog onCreateDialog ( int id ) {
switch ( id ) {
case Constants . PROGRESSDIALOG :
final ProgressDialog progressDialog = new ProgressDialog (
HomeWorkProjectsActivity . this ) ;
progressDialog . setMessage ( " ) ;
progressDialog . show ( ) ;
progressDialog . setOnCancelListener ( new OnCancelListener ( ) {
@Override
public void onCancel ( DialogInterface dialog ) {
if ( ! progressDialog . isShowing ( ) ) {
progressDialog . show ( ) ;
}
}
} ) ;
return progressDialog ;
default :
break ;
}
return super . onCreateDialog ( id ) ;
}
private NetworkCallback < Object > callback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object object ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
try
{
Log . v ( TAG , object . toString ( ) ) ;
HomeWorkProjectsResponse response = Parser . parseHomeWorkProjectsResponse ( ( SoapObject ) object ) ;
if ( response . getErrorMsg ( ) . equals ( " ) )
{
prjctsList = response . getProjectsList ( ) ;
if ( prjctsList != null && prjctsList . size ( ) > <num> )
{
listview . setAdapter ( new HomeWorksAdapter ( HomeWorkProjectsActivity . this ,  <num> , prjctsList ) ) ;
}
}
}
catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
@Override
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Log . v ( TAG , errorMessge ) ;
}
} ;
public void onItemClick ( AdapterView < ? > arg0 , View arg1 , int arg2 , long arg3 ) {
Intent intent = new Intent ( HomeWorkProjectsActivity . this , ProjectDetailsActivity . class ) ;
intent . putExtra ( " , prjctsList . get ( arg2 ) ) ;
intent . putExtra ( " , " ) ;
startActivity ( intent ) ;
}
}
package com . mms . mcm . activities ;
import java . util . List ;
import android . app . Activity ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . ImageView ;
import android . widget . ListView ;
import android . widget . TextView ;
import android . widget . AdapterView . OnItemClickListener ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . BookSearchAdapter ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . model . Books ;
public class BookSearchActivity extends Activity implements OnItemClickListener {
private static List < Books > booksList ;
private static String isbn ;
private ListView searchListView ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
private AuthenticateResponse authenticateResponse ;
static String book_id ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_book_search ) ;
initializeViews ( ) ;
MihirApp app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
searchListView . setAdapter ( new BookSearchAdapter ( BookSearchActivity . this ,  <num> , booksList , " ) ) ;
searchListView . setOnItemClickListener ( BookSearchActivity . this ) ;
}
private void initializeViews ( ) {
searchListView = ( ListView ) findViewById ( R . id . books_search_listview ) ;
( ( TextView ) findViewById ( R . id . isbn_no ) ) . setText ( " + isbn ) ;
( ( TextView ) findViewById ( R . id . book_id ) ) . setText ( " + book_id ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
}
public static List < Books > setBooksList ( List < Books > booksList , String isbn , String book_id )
{
BookSearchActivity . booksList = booksList ;
BookSearchActivity . isbn = isbn ;
BookSearchActivity . book_id = book_id ;
return BookSearchActivity . booksList ;
}
@Override
public void onItemClick ( AdapterView < ? > arg0 , View arg1 , int arg2 , long arg3 ) {
}
}
package com . mms . mcm . model ;
import java . util . List ;
public class HomeWorkProjectsResponse {
private String errorMsg ;
private String studentName ;
private String campus_Id ;
private List < Projects > projectsList ;
public String getErrorMsg ( ) {
return errorMsg ;
}
public void setErrorMsg ( String errorMsg ) {
this . errorMsg = errorMsg ;
}
public String <unk> ( ) {
return studentName ;
}
public void setStudentName ( String studentName ) {
this . studentName = studentName ;
}
public String <unk> ( ) {
return campus_Id ;
}
public void setCampus_Id ( String campusId ) {
campus_Id = campusId ;
}
public List < Projects > getProjectsList ( ) {
return projectsList ;
}
public void setProjectsList ( List < Projects > projectsList ) {
this . projectsList = projectsList ;
}
}
package com . mms . mcm . network ;
import java . util . ArrayList ;
import java . util . List ;
import org . ksoap2 . serialization . SoapObject ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . model . BookSearchResponse ;
import com . mms . mcm . model . Books ;
import com . mms . mcm . model . BooksOnHoldResponse ;
import com . mms . mcm . model . BooksOnPossessionResponse ;
import com . mms . mcm . model . CampusCalendarResponse ;
import com . mms . mcm . model . GradesResponse ;
import com . mms . mcm . model . HomeWorkProjectsResponse ;
import com . mms . mcm . model . NotificationResponse ;
import com . mms . mcm . model . Projects ;
import com . mms . mcm . model . Semester ;
public class Parser {
public static final AuthenticateResponse parseAuthenticateResponse (
SoapObject object ) {
AuthenticateResponse authenticateResponse = new AuthenticateResponse ( ) ;
authenticateResponse . setAuthenticateMSG ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setUserType ( authenticateResponse
. getAuthenticateMSG ( ) . trim ( ) . equals ( " ) ? Constants . STUDENT
: <num> ) ;
authenticateResponse
. setStudent_ID ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setCampusName ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setCampus_ID ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse
. setStudent_Name ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setCampus_Registration_Number ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setCampus_Student_Id ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setFee_Due ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse
. setFee_DueDate ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setCredits_Acheived ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setcGPA ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setStudent_Campus_Number ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setStudent_Doctor_Number ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setCampus_Police_number ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setCampus_Local_number ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setCampus_Emmergency_Number ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
authenticateResponse . setCampusShortName ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
return authenticateResponse ;
}
public static final NotificationResponse parseNotificationReponse ( SoapObject object )
{
NotificationResponse notificationResponse = new NotificationResponse ( ) ;
notificationResponse . setErrorMessage ( object . hasProperty ( " ) ? object . getPropertyAsString ( " ) : " ) ;
if ( object . hasProperty ( " ) )
{
SoapObject notificationListSoapObject = ( SoapObject ) object . getProperty ( " ) ;
List < Projects > notificationList = getList ( notificationListSoapObject ) ;
notificationResponse . setNotificationList ( notificationList ) ;
}
return notificationResponse ;
}
public static final CampusCalendarResponse parseCampusCalenderReponse ( SoapObject object )
{
CampusCalendarResponse response = new CampusCalendarResponse ( ) ;
response . setErrorMessage ( object . hasProperty ( " ) ? object . getPropertyAsString ( " ) : " ) ;
if ( object . hasProperty ( " ) )
{
SoapObject campusCalendarListSoapObject = ( SoapObject ) object . getProperty ( " ) ;
List < Projects > notificationList = getList ( campusCalendarListSoapObject ) ;
response . setProjectsList ( notificationList ) ;
}
return response ;
}
private static List < Projects > getList ( SoapObject notificationListSoapObject ) {
Projects projects ;
List < Projects > projectsList = new ArrayList < Projects > ( ) ;
for ( int i = <num> ; i < notificationListSoapObject . getPropertyCount ( ) ; i ++ ) {
projects = new Projects ( ) ;
SoapObject notificationSoapObject = ( SoapObject ) notificationListSoapObject
. getProperty ( i ) ;
projects . setCourse_Code ( notificationSoapObject
. hasProperty ( " ) ? notificationSoapObject
. getPropertyAsString ( " ) : " ) ;
projects . setCourse_Name ( notificationSoapObject
. hasProperty ( " ) ? notificationSoapObject
. getPropertyAsString ( " ) : " ) ;
projects
. setNotification_Id ( notificationSoapObject
. hasProperty ( " ) ? notificationSoapObject
. getPropertyAsString ( " )
: " ) ;
projects
. setNotifications_Title ( notificationSoapObject
. hasProperty ( " ) ? notificationSoapObject
. getPropertyAsString ( " )
: " ) ;
projects
. setNotifications_DueTime ( notificationSoapObject
. hasProperty ( " ) ? notificationSoapObject
. getPropertyAsString ( " )
: " ) ;
projects
. setNotifications_Details ( notificationSoapObject
. hasProperty ( " ) ? notificationSoapObject
. getPropertyAsString ( " )
: " ) ;
projects
. setNotifications_Comments ( notificationSoapObject
. hasProperty ( " ) ? notificationSoapObject
. getPropertyAsString ( " )
: " ) ;
projects
. setNotifications_Type ( notificationSoapObject
. hasProperty ( " ) ? notificationSoapObject
. getPropertyAsString ( " )
: " ) ;
projects . setCourse_Grade ( notificationSoapObject
. hasProperty ( " ) ? notificationSoapObject
. getPropertyAsString ( " ) : " ) ;
projects . setSemister_Name ( notificationSoapObject
. hasProperty ( " ) ? notificationSoapObject
. getPropertyAsString ( " ) : " ) ;
projectsList . add ( projects ) ;
}
return projectsList ;
}
public static final String parseRegister ( SoapObject object ) {
String message = " ;
if ( object . hasProperty ( " ) ) {
message = object . getPropertyAsString ( " ) ;
} else if ( object . hasProperty ( " ) ) {
message = object . getPropertyAsString ( " ) ;
}
return message ;
}
public static final String parseChangePwd ( SoapObject object ) {
String message = " ;
if ( object . hasProperty ( " ) ) {
message = object . getPropertyAsString ( " ) ;
}
return message ;
}
public static final String parseComplaintCellResponse ( SoapObject object ) {
String message = " ;
if ( object . hasProperty ( " ) ) {
message = object . getPropertyAsString ( " ) ;
}
return message ;
}
public static final GradesResponse parseGradesResponse ( SoapObject object ) {
GradesResponse gradesResponse = new GradesResponse ( ) ;
List < Semester > semesterList = null ;
gradesResponse . setErrorMsg ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
gradesResponse . setCampus_ID ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
gradesResponse
. setStudent_Name ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
if ( gradesResponse . getErrorMsg ( ) . equals ( " ) ) {
semesterList = new ArrayList < Semester > ( ) ;
for ( int i = <num> ; i < object . getPropertyCount ( ) ; i ++ ) {
SoapObject soapObject = ( SoapObject ) object . getProperty ( i ) ;
semesterList . add ( new Semester ( soapObject ) ) ;
}
gradesResponse . setSemesters ( semesterList ) ;
}
return gradesResponse ;
}
public static final HomeWorkProjectsResponse parseHomeWorkProjectsResponse (
SoapObject object ) {
HomeWorkProjectsResponse homeWorkProjectsResponse = new HomeWorkProjectsResponse ( ) ;
List < Projects > home_work_prjctslist ;
Projects projects ;
homeWorkProjectsResponse . setErrorMsg ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
homeWorkProjectsResponse . setCampus_Id ( object
. hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
homeWorkProjectsResponse
. setStudentName ( object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ) ;
if ( object . hasProperty ( " ) ) {
home_work_prjctslist = new ArrayList < Projects > ( ) ;
SoapObject projectsListSoapObject = ( SoapObject ) object
. getProperty ( " ) ;
homeWorkProjectsResponse . setProjectsList ( getList ( projectsListSoapObject ) ) ;
}
return homeWorkProjectsResponse ;
}
public static final String <unk> ( SoapObject object ) {
return object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ;
}
public static final BookSearchResponse parseBookSearchResponse (
SoapObject object )
{
List < Books > booksList = null ;
Books books ;
BookSearchResponse bookSearchResponse = new BookSearchResponse ( ) ;
if ( object . hasProperty ( " ) )
{
bookSearchResponse . setErrorMsg ( object . getPropertyAsString ( " ) ) ;
}
else if ( object . hasProperty ( " ) )
{
bookSearchResponse . setErrorMsg ( object . getPropertyAsString ( " ) ) ;
}
else if ( object . hasProperty ( " ) )
{
bookSearchResponse . setErrorMsg ( object . getPropertyAsString ( " ) ) ;
}
else
{
bookSearchResponse . setErrorMsg ( " ) ;
}
if ( object . hasProperty ( " ) )
{
booksList = new ArrayList < Books > ( ) ;
for ( int i = <num> ; i < object . getPropertyCount ( ) ; i ++ )
{
books = new Books ( ) ;
SoapObject bookSoapObject = ( SoapObject ) object . getProperty ( i ) ;
books . setBook_ID ( bookSoapObject . hasProperty ( " ) ? bookSoapObject . getPropertyAsString ( " ) : " ) ;
books . setBook_Hold_Count ( bookSoapObject . hasProperty ( " ) ? bookSoapObject . getPropertyAsString ( " ) : " ) ;
books . setBook_REF_Number ( bookSoapObject . hasProperty ( " ) ? bookSoapObject . getPropertyAsString ( " ) : " ) ;
books . setBook_Return_Date ( bookSoapObject . hasProperty ( " ) ? bookSoapObject . getPropertyAsString ( " ) : " ) ;
books . setBook_Status ( bookSoapObject . hasProperty ( " ) ? bookSoapObject . getPropertyAsString ( " ) : " ) ;
books . setBook_Title ( bookSoapObject . hasProperty ( " ) ? bookSoapObject . getPropertyAsString ( " ) : " ) ;
booksList . add ( books ) ;
}
}
bookSearchResponse . setBooksList ( booksList ) ;
return bookSearchResponse ;
}
public static final BooksOnHoldResponse <unk> (
SoapObject object ) {
BooksOnHoldResponse booksOnHoldResponse = new BooksOnHoldResponse ( ) ;
return booksOnHoldResponse ;
}
public static final BooksOnPossessionResponse <unk> (
SoapObject object ) {
BooksOnPossessionResponse booksOnPossessionResponse = new BooksOnPossessionResponse ( ) ;
return booksOnPossessionResponse ;
}
public static final String <unk> ( SoapObject object ) {
return object . hasProperty ( " ) ? object
. getPropertyAsString ( " ) : " ;
}
}
package com . mms . mcm . model ;
import java . util . List ;
public class NotificationResponse {
private String errorMessage ;
private List < Projects > notificationList ;
public String getErrorMessage ( ) {
return errorMessage ;
}
public void setErrorMessage ( String errorMessage ) {
this . errorMessage = errorMessage ;
}
public List < Projects > getNotificationList ( ) {
return notificationList ;
}
public void setNotificationList ( List < Projects > notificationList ) {
this . notificationList = notificationList ;
}
}
package com . mms . mcm . custom ;
import java . util . List ;
import android . content . Context ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . ArrayAdapter ;
import android . widget . Button ;
import android . widget . TextView ;
import com . mms . mcm . R ;
import com . mms . mcm . model . Books ;
public class BookSearchAdapter extends ArrayAdapter < Books > {
private Context context ;
private List < Books > booksList ;
private String isFrom ;
public BookSearchAdapter ( Context context , int textViewResourceId ,
List < Books > objects , String isFrom ) {
super ( context , textViewResourceId , objects ) ;
this . context = context ;
this . booksList = objects ;
this . isFrom = isFrom ;
}
public long getItemId ( int position ) {
return position ;
}
public int getCount ( ) {
return booksList . size ( ) ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
ViewHolder holder ;
if ( convertView == null ) {
convertView = LayoutInflater . from ( context ) . inflate ( R . layout . books_in_possession_list_layout ,
null ) ;
holder = new ViewHolder ( ) ;
holder . refno = ( TextView ) convertView
. findViewById ( R . id . ref_no ) ;
holder . book_status = ( TextView ) convertView
. findViewById ( R . id . book_status ) ;
holder . holdcount0 = ( TextView ) convertView
. findViewById ( R . id . hold_count0 ) ;
holder . holdcount1 = ( TextView ) convertView
. findViewById ( R . id . hold_count1 ) ;
holder . return_date_tv = ( TextView ) convertView . findViewById ( R . id . returndate_tv ) ;
holder . return_date = ( TextView ) convertView . findViewById ( R . id . return_date ) ;
holder . title = ( TextView ) convertView . findViewById ( R . id . book_title ) ;
convertView . setTag ( holder ) ;
} else {
holder = ( ViewHolder ) convertView . getTag ( ) ;
}
Books book = booksList . get ( position ) ;
if ( isFrom . equalsIgnoreCase ( " ) )
{
holder . holdcount0 . setVisibility ( View . GONE ) ;
holder . title . setVisibility ( View . GONE ) ;
}
else if ( isFrom . equalsIgnoreCase ( " ) )
{
holder . return_date_tv . setVisibility ( View . GONE ) ;
holder . return_date . setVisibility ( View . GONE ) ;
holder . book_status . setVisibility ( View . GONE ) ;
holder . holdcount1 . setVisibility ( View . GONE ) ;
}
else if ( isFrom . equalsIgnoreCase ( " ) )
{
holder . book_status . setVisibility ( View . GONE ) ;
holder . holdcount1 . setVisibility ( View . GONE ) ;
holder . holdcount0 . setVisibility ( View . VISIBLE ) ;
}
holder . refno . setText ( " + book . getBook_REF_Number ( ) ) ;
holder . book_status . setText ( book . getBook_Status ( ) ) ;
holder . holdcount0 . setText ( book . getBook_Hold_Count ( ) ) ;
holder . title . setText ( book . getBook_Title ( ) ) ;
holder . return_date . setText ( book . getBook_Return_Date ( ) ) ;
holder . holdcount1 . setText ( book . getBook_Hold_Count ( ) ) ;
return convertView ;
}
private static class ViewHolder {
private TextView refno ;
private TextView book_status ;
private TextView return_date ;
private TextView holdcount0 ;
private TextView holdcount1 ;
private TextView title ;
private Button button ;
private TextView return_date_tv ;
}
}
package com . mms . mcm . activities ;
import java . util . List ;
import org . ksoap2 . serialization . SoapObject ;
import android . app . Activity ;
import android . app . Dialog ;
import android . app . ProgressDialog ;
import android . content . DialogInterface ;
import android . content . DialogInterface . OnCancelListener ;
import android . os . Bundle ;
import android . util . Log ;
import android . widget . ImageView ;
import android . widget . ListView ;
import android . widget . TextView ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . BookSearchAdapter ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . model . BookSearchResponse ;
import com . mms . mcm . model . Books ;
import com . mms . mcm . network . NetworkCallback ;
import com . mms . mcm . network . Parser ;
import com . mms . mcm . network . SoapServiceManager ;
public class BooksOnHoldActivity extends Activity {
protected static final String TAG = null ;
private AuthenticateResponse authenticateResponse ;
private ListView listview ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_book_hold ) ;
initializeviews ( ) ;
MihirApp app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
SoapServiceManager manager = SoapServiceManager . getInstance ( BooksOnHoldActivity . this ) ;
showDialog ( Constants . PROGRESSDIALOG ) ;
manager . sendBooksOnHoldRequest ( authenticateResponse . getStudent_ID ( ) , callback ) ;
}
private void initializeviews ( ) {
listview = ( ListView ) findViewById ( R . id . books_hold_listview ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
}
final NetworkCallback < Object > callback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object responseObj ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
List < Books > booksList ;
try {
SoapObject responceObject = ( SoapObject ) responseObj ;
BookSearchResponse response = Parser
. parseBookSearchResponse ( responceObject ) ;
if ( response . getErrorMsg ( ) . trim ( ) . equals ( " ) ) {
booksList = response . getBooksList ( ) ;
if ( booksList != null && booksList . size ( ) > <num> ) {
listview . setAdapter ( new BookSearchAdapter ( BooksOnHoldActivity . this ,  <num> , booksList , " ) ) ;
}
} else {
Utils . showDialog ( response . getErrorMsg ( ) ,
BooksOnHoldActivity . this , true ) ;
}
} catch ( ClassCastException cce ) {
Utils . showToast ( " ,
BooksOnHoldActivity . this ) ;
Log . v ( TAG , cce . getMessage ( ) ) ;
}
}
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Utils . showToast ( " ,
BooksOnHoldActivity . this ) ;
}
} ;
@Override
protected Dialog onCreateDialog ( int id ) {
switch ( id ) {
case Constants . PROGRESSDIALOG :
final ProgressDialog progressDialog = new ProgressDialog (
BooksOnHoldActivity . this ) ;
progressDialog . setMessage ( " ) ;
progressDialog . show ( ) ;
progressDialog . setOnCancelListener ( new OnCancelListener ( ) {
@Override
public void onCancel ( DialogInterface dialog ) {
if ( ! progressDialog . isShowing ( ) ) {
progressDialog . show ( ) ;
}
}
} ) ;
return progressDialog ;
default :
break ;
}
return super . onCreateDialog ( id ) ;
}
}
package com . mms . mcm . network ;
import android . os . Handler ;
import android . os . Message ;
import com . mms . mcm . custom . Constants ;
public class MihirHandler extends Handler {
private NetworkCallback < Object > callback ;
public MihirHandler ( NetworkCallback < Object > callback )
{
this . callback = callback ;
}
public void handleMessage ( Message msg ) {
super . handleMessage ( msg ) ;
if ( msg . what == Constants . SUCCESS )
{
Object object = msg . obj ;
callback . onSuccess ( object ) ;
}
else if ( msg . what == Constants . FAILURE )
{
Object object = msg . obj ;
callback . onFailure ( object . toString ( ) ) ;
}
}
}
package com . mms . mcm . activities ;
import org . ksoap2 . serialization . SoapObject ;
import android . app . Activity ;
import android . app . Dialog ;
import android . app . ProgressDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . DialogInterface . OnCancelListener ;
import android . net . Uri ;
import android . os . Bundle ;
import android . text . TextUtils ;
import android . util . Log ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . TextView ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . network . NetworkCallback ;
import com . mms . mcm . network . Parser ;
import com . mms . mcm . network . SoapServiceManager ;
public class RegisterActivity extends Activity implements OnClickListener {
private static final String TAG = " ;
private String from ;
private EditText mmsId ;
private Button button ;
private TextView headerText ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_forgotpwd_signup ) ;
initializeViews ( ) ;
Bundle bundle = getIntent ( ) . getExtras ( ) ;
if ( bundle != null ) {
from = bundle . getString ( " ) ;
if ( " . equals ( from ) ) {
headerText . setText ( " ) ;
button . setText ( " ) ;
} else if ( " . equals ( from ) ) {
headerText . setText ( " ) ;
button . setText ( " ) ;
}
} else {
return ;
}
}
private void initializeViews ( ) {
mmsId = ( EditText ) findViewById ( R . id . signup_edittext_mmsid ) ;
button = ( Button ) findViewById ( R . id . signup_btn_register ) ;
button . setOnClickListener ( RegisterActivity . this ) ;
headerText = ( TextView ) findViewById ( R . id . signup_headertext ) ;
findViewById ( R . id . mms_ad_image ) . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
startActivity ( new Intent ( Intent . ACTION_VIEW , Uri . parse ( " ) ) ) ;
}
} ) ;
}
public void onClick ( View v ) {
switch ( v . getId ( ) ) {
case R . id . signup_btn_register :
String userid = mmsId . getText ( ) . toString ( ) ;
SoapServiceManager serviceManager = SoapServiceManager
. getInstance ( RegisterActivity . this ) ;
if ( TextUtils . isEmpty ( userid ) ) {
Utils . showDialog ( Constants . FIELDSREQUIRED ,
RegisterActivity . this , false ) ;
} else {
showDialog ( Constants . PROGRESSDIALOG ) ;
if ( from . equalsIgnoreCase ( " ) ) {
serviceManager . sendregisterRequest ( userid , callback ) ;
} else if ( from . equalsIgnoreCase ( " ) ) {
serviceManager . sendforgotPasswordRequest ( userid , callback ) ;
}
}
break ;
default :
break ;
}
}
NetworkCallback < Object > callback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object object ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
try
{
String msg = Parser . parseRegister ( ( SoapObject ) object ) ;
Utils . showDialog ( msg , RegisterActivity . this , false ) ;
}
catch ( ClassCastException cce )
{
Utils . showToast ( " , RegisterActivity . this ) ;
Log . v ( TAG , cce . getMessage ( ) ) ;
}
catch ( Exception e )
{
Log . v ( TAG , e . getMessage ( ) ) ;
}
}
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Log . v ( TAG , errorMessge ) ;
}
} ;
NetworkCallback < Object > adcallback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object object ) {
}
public void onFailure ( String errorMessge ) {
Log . v ( TAG , errorMessge ) ;
}
} ;
protected Dialog onCreateDialog ( int id ) {
switch ( id ) {
case Constants . PROGRESSDIALOG :
final ProgressDialog progressDialog = new ProgressDialog (
RegisterActivity . this ) ;
progressDialog . setMessage ( " ) ;
progressDialog . show ( ) ;
progressDialog . setOnCancelListener ( new OnCancelListener ( ) {
@Override
public void onCancel ( DialogInterface dialog ) {
if ( ! progressDialog . isShowing ( ) ) {
progressDialog . show ( ) ;
}
}
} ) ;
return progressDialog ;
}
return super . onCreateDialog ( id ) ;
}
}
package com . mms . mcm . activities ;
import java . util . List ;
import org . ksoap2 . serialization . SoapObject ;
import android . app . Dialog ;
import android . app . ProgressDialog ;
import android . app . TabActivity ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . DialogInterface . OnCancelListener ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . ArrayAdapter ;
import android . widget . ImageView ;
import android . widget . ListView ;
import android . widget . TabHost ;
import android . widget . TextView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . TabHost . OnTabChangeListener ;
import android . widget . TabHost . TabSpec ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . model . CampusCalendarResponse ;
import com . mms . mcm . model . NotificationResponse ;
import com . mms . mcm . model . Projects ;
import com . mms . mcm . network . NetworkCallback ;
import com . mms . mcm . network . Parser ;
import com . mms . mcm . network . SoapServiceManager ;
public class NotificationsActivity extends TabActivity implements OnTabChangeListener , OnItemClickListener {
protected static final String TAG = null ;
private TabHost tabHost ;
private SoapServiceManager manager ;
private List < Projects > prjctsList ;
private AuthenticateResponse authenticateResponse ;
private ListView notificationListView ;
private ListView campusCalendarListView ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_layout_notifications ) ;
initializeViews ( ) ;
MihirApp app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
manager = SoapServiceManager . getInstance ( NotificationsActivity . this ) ;
tabHost = getTabHost ( ) ;
setupTab ( " , R . id . campus_calendar ) ;
setupTab ( " , R . id . notification ) ;
tabHost . setCurrentTab ( <num> ) ;
if ( tabHost . getCurrentTab ( ) == <num> )
{
showDialog ( Constants . PROGRESSDIALOG ) ;
manager . sendGetCampusCalenderDetailsRequest ( authenticateResponse . getCampus_ID ( ) , authenticateResponse . getStudent_ID ( ) , campuscalendarCallBack ) ;
}
tabHost . setOnTabChangedListener ( NotificationsActivity . this ) ;
}
private void setupTab ( String string , int id ) {
TabSpec spec = tabHost . newTabSpec ( string ) . setContent ( id ) . setIndicator ( makeTab ( string ) ) ;
tabHost . addTab ( spec ) ;
}
private View makeTab ( String tag ) {
int bgId ;
if ( " . equalsIgnoreCase ( tag ) ) {
bgId = R . drawable . left_tab_indicator ;
} else {
bgId = R . drawable . right_tab_indicator ;
}
View tabView = LayoutInflater . from ( NotificationsActivity . this ) . inflate (
R . layout . tab_indicator , null ) ;
tabView . setBackgroundResource ( bgId ) ;
TextView tabText = ( TextView ) tabView . findViewById ( R . id . text ) ;
tabText . setText ( tag ) ;
return tabView ;
}
private void initializeViews ( ) {
notificationListView = ( ListView ) findViewById ( R . id . notifications_listview ) ;
campusCalendarListView = ( ListView ) findViewById ( R . id . campus_calendar_listview ) ;
notificationListView . setOnItemClickListener ( NotificationsActivity . this ) ;
campusCalendarListView . setOnItemClickListener ( NotificationsActivity . this ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
}
public void onTabChanged ( String arg0 ) {
if ( tabHost . getCurrentTab ( ) == <num> )
{
showDialog ( Constants . PROGRESSDIALOG ) ;
manager . sendGetCampusCalenderDetailsRequest ( authenticateResponse . getCampus_ID ( ) , authenticateResponse . getStudent_ID ( ) , campuscalendarCallBack ) ;
}
else if ( tabHost . getCurrentTab ( ) == <num> )
{
showDialog ( Constants . PROGRESSDIALOG ) ;
manager . sendGetNotificationDetailsRequest ( authenticateResponse . getStudent_ID ( ) , callback ) ;
}
}
private NetworkCallback < Object > callback = new NetworkCallback < Object > ( ) {
private List < Projects > prjctsList ;
public void onSuccess ( Object object ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
try
{
Log . v ( TAG , object . toString ( ) ) ;
NotificationResponse response = Parser . parseNotificationReponse ( ( SoapObject ) object ) ;
if ( response . getErrorMessage ( ) . equals ( " ) )
{
prjctsList = response . getNotificationList ( ) ;
if ( prjctsList != null && prjctsList . size ( ) > <num> )
{
notificationListView . setAdapter ( new ArrayAdapter < Projects > ( NotificationsActivity . this , R . layout . layout_dietcarelisttext , prjctsList ) ) ;
notificationListView . setOnItemClickListener ( new OnItemClickListener ( ) {
@Override
public void onItemClick ( AdapterView < ? > arg0 ,
View arg1 , int arg2 , long arg3 ) {
Intent intent = new Intent ( NotificationsActivity . this , ProjectDetailsActivity . class ) ;
intent . putExtra ( " , prjctsList . get ( arg2 ) ) ;
intent . putExtra ( " , " ) ;
startActivity ( intent ) ;
}
} ) ;
}
}
else
{
Utils . showDialog ( response . getErrorMessage ( ) , NotificationsActivity . this , false ) ;
}
}
catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
@Override
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Log . v ( TAG , errorMessge ) ;
}
} ;
private NetworkCallback < Object > campuscalendarCallBack = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object object ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
try
{
Log . v ( TAG , object . toString ( ) ) ;
CampusCalendarResponse response = Parser . parseCampusCalenderReponse ( ( SoapObject ) object ) ;
if ( response . getErrorMessage ( ) . equals ( " ) )
{
prjctsList = response . getProjectsList ( ) ;
if ( prjctsList != null && prjctsList . size ( ) > <num> )
{
campusCalendarListView . setAdapter ( new ArrayAdapter < Projects > ( NotificationsActivity . this , android . R . layout . simple_list_item_1 , prjctsList ) ) ;
campusCalendarListView . setOnItemClickListener ( new OnItemClickListener ( ) {
@Override
public void onItemClick ( AdapterView < ? > arg0 ,
View arg1 , int arg2 , long arg3 ) {
Intent intent = new Intent ( NotificationsActivity . this , ProjectDetailsActivity . class ) ;
intent . putExtra ( " , prjctsList . get ( arg2 ) ) ;
intent . putExtra ( " , " ) ;
startActivity ( intent ) ;
}
} ) ;
}
}
else
{
Utils . showDialog ( response . getErrorMessage ( ) , NotificationsActivity . this , false ) ;
}
}
catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
@Override
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Log . v ( TAG , errorMessge ) ;
}
} ;
@Override
protected Dialog onCreateDialog ( int id ) {
switch ( id ) {
case Constants . PROGRESSDIALOG :
final ProgressDialog progressDialog = new ProgressDialog (
NotificationsActivity . this ) ;
progressDialog . setMessage ( " ) ;
progressDialog . show ( ) ;
progressDialog . setOnCancelListener ( new OnCancelListener ( ) {
@Override
public void onCancel ( DialogInterface dialog ) {
if ( ! progressDialog . isShowing ( ) ) {
progressDialog . show ( ) ;
}
}
} ) ;
return progressDialog ;
default :
break ;
}
return super . onCreateDialog ( id ) ;
}
@Override
public void onItemClick ( AdapterView < ? > arg0 , View arg1 , int arg2 , long arg3 ) {
Intent intent = new Intent ( NotificationsActivity . this , ProjectDetailsActivity . class ) ;
intent . putExtra ( " , prjctsList . get ( arg2 ) ) ;
startActivity ( intent ) ;
}
}
package com . mms . mcm . network ;
import java . util . concurrent . ThreadFactory ;
import java . util . concurrent . atomic . AtomicInteger ;
public class NamedThreadFactory implements ThreadFactory {
AtomicInteger integer = new AtomicInteger ( <num> ) ;
String id ;
public NamedThreadFactory ( String id )
{
this . id = id ;
}
public Thread newThread ( Runnable r ) {
String threadName = id + " + integer . getAndIncrement ( ) ;
return new Thread ( r , threadName ) ;
}
}
package com . mms . mcm . network ;
import org . ksoap2 . SoapEnvelope ;
import org . ksoap2 . serialization . SoapObject ;
import org . ksoap2 . serialization . SoapSerializationEnvelope ;
import org . ksoap2 . transport . HttpTransportSE ;
import android . os . Handler ;
import android . os . Message ;
import android . util . Log ;
import com . mms . mcm . custom . Constants ;
public final class SoapConn {
private static final String TAG = " ;
private static final String URL = " ;
private static HttpTransportSE httpTransportSE ;
public static void callWebService ( String actionName , SoapObject request ,
Handler mihirHandler ) {
try {
SoapSerializationEnvelope envelope = new SoapSerializationEnvelope (
SoapEnvelope . <unk> ) ;
envelope . <unk> ( request ) ;
envelope . <unk> = false ;
envelope . <unk> = request ;
envelope . <unk> = SoapSerializationEnvelope . <unk> ;
int timeout = <num> ;
httpTransportSE = new HttpTransportSE ( URL ,
timeout ) ;
httpTransportSE . debug = true ;
Log . v ( " , request . toString ( ) ) ;
httpTransportSE . call ( actionName , envelope ) ;
Object object = envelope . <unk> ;
if ( object != null ) {
Log . v ( TAG , " + object . toString ( ) ) ;
Message . obtain ( mihirHandler , Constants . SUCCESS , object )
. sendToTarget ( ) ;
} else {
Message . obtain ( mihirHandler , Constants . FAILURE , object )
. sendToTarget ( ) ;
}
} catch ( Exception e ) {
Message . obtain ( mihirHandler , Constants . FAILURE , e . getMessage ( ) )
. sendToTarget ( ) ;
e . printStackTrace ( ) ;
}
finally
{
httpTransportSE . reset ( ) ;
}
}
}
package com . mms . mcm . activities ;
import java . util . ArrayList ;
import java . util . List ;
import org . ksoap2 . serialization . SoapObject ;
import android . app . Activity ;
import android . app . Dialog ;
import android . app . ProgressDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . DialogInterface . OnCancelListener ;
import android . net . Uri ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . LayoutInflater ;
import android . view . Menu ;
import android . view . MenuItem ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . EditText ;
import android . widget . ImageView ;
import android . widget . LinearLayout ;
import android . widget . TextView ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . network . NetworkCallback ;
import com . mms . mcm . network . Parser ;
import com . mms . mcm . network . SoapServiceManager ;
public class ComplaintCellActivity extends Activity implements OnClickListener {
private static final String TAG = null ;
private LinearLayout complaintNamesLayout ;
private EditText description ;
private Integer i = <num> ;
private AuthenticateResponse authenticateResponse ;
private ImageView addButton ;
private TextView campusEmergencyNo ;
private TextView campusPoliceNo ;
private TextView localPoliceNo ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_complaint_cell ) ;
MihirApp app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
initializeViews ( ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
}
private void initializeViews ( ) {
addButton = ( ImageView ) findViewById ( R . id . action_bar_image_add ) ;
addButton . setVisibility ( View . VISIBLE ) ;
addButton . setOnClickListener ( ComplaintCellActivity . this ) ;
complaintNamesLayout = ( LinearLayout ) findViewById ( R . id . layout_linearlayout_campus_cell_names ) ;
description = ( EditText ) findViewById ( R . id . complaint_description ) ;
campusEmergencyNo = ( TextView ) findViewById ( R . id . campus_emergency_no ) ;
campusPoliceNo = ( TextView ) findViewById ( R . id . campus_police_no ) ;
localPoliceNo = ( TextView ) findViewById ( R . id . local_police_no ) ;
campusPoliceNo . setText ( authenticateResponse . getCampus_Police_number ( ) ) ;
localPoliceNo . setText ( authenticateResponse . getCampus_Local_number ( ) ) ;
campusEmergencyNo . setText ( authenticateResponse . getCampus_Emmergency_Number ( ) ) ;
campusPoliceNo . setOnClickListener ( this ) ;
localPoliceNo . setOnClickListener ( this ) ;
campusEmergencyNo . setOnClickListener ( this ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
findViewById ( R . id . complaint_cell_btn_send ) . setOnClickListener ( ComplaintCellActivity . this ) ;
}
final NetworkCallback < Object > callback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object object ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
try
{
String msg = Parser . parseComplaintCellResponse ( ( SoapObject ) object ) ;
Utils . showDialog ( msg , ComplaintCellActivity . this , false ) ;
}
catch ( ClassCastException cce )
{
Utils . showToast ( " , ComplaintCellActivity . this ) ;
Log . v ( TAG , cce . getMessage ( ) ) ;
}
catch ( Exception e )
{
Log . v ( TAG , e . getMessage ( ) ) ;
}
}
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Log . v ( TAG , errorMessge ) ;
}
} ;
public void onClick ( View v ) {
switch ( v . getId ( ) ) {
case R . id . action_bar_image_add :
if ( complaintNamesLayout . getChildCount ( ) < <num> )
{
addView ( ) ;
}
else
{
Utils . showToast ( " , ComplaintCellActivity . this ) ;
}
break ;
case R . id . layout_complaint_cell_image_removename :
complaintNamesLayout . removeView ( ( View ) v . getParent ( ) ) ;
break ;
case R . id . complaint_cell_btn_send :
submitComplaint ( ) ;
break ;
case R . id . campus_emergency_no :
makecall ( campusEmergencyNo . getText ( ) . toString ( ) ) ;
break ;
case R . id . campus_police_no :
makecall ( campusPoliceNo . getText ( ) . toString ( ) ) ;
break ;
case R . id . local_police_no :
makecall ( localPoliceNo . getText ( ) . toString ( ) ) ;
break ;
default :
break ;
}
}
@Override
protected Dialog onCreateDialog ( int id ) {
switch ( id ) {
case Constants . PROGRESSDIALOG :
final ProgressDialog progressDialog = new ProgressDialog (
ComplaintCellActivity . this ) ;
progressDialog . setMessage ( " ) ;
progressDialog . show ( ) ;
progressDialog . setOnCancelListener ( new OnCancelListener ( ) {
@Override
public void onCancel ( DialogInterface dialog ) {
if ( ! progressDialog . isShowing ( ) ) {
progressDialog . show ( ) ;
}
}
} ) ;
return progressDialog ;
default :
break ;
}
return super . onCreateDialog ( id ) ;
}
private void makecall ( String string ) {
startActivity ( new Intent ( Intent . <unk> , Uri . parse ( " + string ) ) ) ;
}
private void submitComplaint ( ) {
boolean b = true ;
int count = complaintNamesLayout . getChildCount ( ) ;
List < String > names = new ArrayList < String > ( ) ;
for ( int i = <num> ; i < count ; i ++ ) {
View v = complaintNamesLayout . getChildAt ( i ) ;
EditText et = ( EditText ) v . findViewById ( R . id . layout_complaint_cell_edittext_name ) ;
if ( et . getText ( ) . toString ( ) . trim ( ) . equals ( " ) )
{
b = false ;
et . setError ( " ) ;
}
else
{
names . add ( et . getText ( ) . toString ( ) ) ;
}
}
if ( description . getText ( ) . toString ( ) . trim ( ) . equals ( " ) )
{
b = false ;
description . setError ( " ) ;
}
if ( b )
{
showDialog ( Constants . PROGRESSDIALOG ) ;
SoapServiceManager manager = SoapServiceManager . getInstance ( ComplaintCellActivity . this ) ;
manager . sendComplaintCellDetailsRequest ( authenticateResponse . getStudent_ID ( ) , names , description . getText ( ) . toString ( ) , callback ) ;
}
}
private void addView ( ) {
View view = LayoutInflater . from ( ComplaintCellActivity . this )
. inflate ( R . layout . complaint_cell_name_layout , null ) ;
ImageView removeNameBtn = ( ImageView ) view
. findViewById ( R . id . layout_complaint_cell_image_removename ) ;
removeNameBtn . setVisibility ( View . VISIBLE ) ;
removeNameBtn . setOnClickListener ( ComplaintCellActivity . this ) ;
complaintNamesLayout . addView ( view ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
menu . add ( Menu . NONE , Menu . FIRST , Menu . NONE , " ) ;
menu . add ( Menu . NONE , Menu . FIRST + <num> , Menu . NONE , " ) ;
return true ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
if ( item . getItemId ( ) == <num> ) {
submitComplaint ( ) ;
return true ;
} else if ( item . getItemId ( ) == <num> ) {
addView ( ) ;
return true ;
} else {
return false ;
}
}
}
package com . mms . mcm . activities ;
import com . mms . mcm . model . AuthenticateResponse ;
import android . app . Application ;
public final class MihirApp extends Application {
private AuthenticateResponse authenticateResponse ;
private boolean isloggedin = false ;
private static MihirApp app ;
public boolean isIsloggedin ( ) {
return isloggedin ;
}
public static MihirApp getInstance ( )
{
return app == null ? app = new MihirApp ( ) : app ;
}
public void setIsloggedin ( boolean isloggedin ) {
this . isloggedin = isloggedin ;
}
public AuthenticateResponse getCurUserInfo ( ) {
return authenticateResponse ;
}
public void setCurUserInfo ( AuthenticateResponse response ) {
authenticateResponse = response ;
}
}
package com . mms . mcm . activities ;
import java . util . List ;
import org . ksoap2 . serialization . SoapObject ;
import android . app . Activity ;
import android . app . Dialog ;
import android . app . ProgressDialog ;
import android . content . DialogInterface ;
import android . content . DialogInterface . OnCancelListener ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . ImageView ;
import android . widget . TableLayout ;
import android . widget . TableRow ;
import android . widget . TextView ;
import android . widget . ViewFlipper ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . model . Course ;
import com . mms . mcm . model . GradesResponse ;
import com . mms . mcm . model . Semester ;
import com . mms . mcm . network . NetworkCallback ;
import com . mms . mcm . network . Parser ;
import com . mms . mcm . network . SoapServiceManager ;
public class GradesActivity extends Activity implements OnClickListener {
protected static final String TAG = " ;
private ViewFlipper flipper ;
private Button prevButton ;
private Button nextButton ;
private List < Semester > list ;
private TextView examName ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
private TextView gpa ;
private MihirApp app ;
private AuthenticateResponse authenticateResponse ;
protected GradesResponse gradesResponse ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_grades ) ;
app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
initializeViews ( ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
SoapServiceManager manager = SoapServiceManager
. getInstance ( GradesActivity . this ) ;
showDialog ( Constants . PROGRESSDIALOG ) ;
manager . sendGetGradesRequest ( authenticateResponse . getStudent_ID ( ) ,
callback ) ;
}
final NetworkCallback < Object > callback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object responseObj ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
try {
if ( responseObj instanceof SoapObject )
{
Log . v ( TAG , " ) ;
}
else
{
Log . v ( TAG , " ) ;
}
gradesResponse = Parser . parseGradesResponse ( ( SoapObject ) responseObj ) ;
if ( gradesResponse . getErrorMsg ( ) . equals ( " ) )
{
processResposne ( gradesResponse ) ;
}
else
{
Utils . showDialog ( gradesResponse . getErrorMsg ( ) , GradesActivity . this , true ) ;
}
}
catch ( ClassCastException cce )
{
Utils . showToast ( " , GradesActivity . this ) ;
cce . printStackTrace ( ) ;
}
catch ( Exception e )
{
e . printStackTrace ( ) ;
}
}
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Utils . showToast ( " ,
GradesActivity . this ) ;
}
} ;
private void initializeViews ( ) {
flipper = ( ViewFlipper ) findViewById ( R . id . viewflipper ) ;
examName = ( TextView ) findViewById ( R . id . marks_tv_examName ) ;
gpa = ( TextView ) findViewById ( R . id . gpa ) ;
prevButton = ( Button ) findViewById ( R . id . marks_btn_prevButton ) ;
prevButton . setOnClickListener ( GradesActivity . this ) ;
nextButton = ( Button ) findViewById ( R . id . marks_btn_nextbutton ) ;
nextButton . setOnClickListener ( GradesActivity . this ) ;
findViewById ( R . id . sharebutton ) . setOnClickListener ( GradesActivity . this ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
}
private void processResposne ( GradesResponse gradesResponse ) {
list = gradesResponse . getSemesters ( ) ;
for ( int i = ( list . size ( )  <num> ) ; i >= <num> ; i  ) {
Semester semester = list . get ( i ) ;
if ( semester != null )
{
flipper . addView ( getView ( semester ) ) ;
}
setSemesterName ( ) ;
}
}
private View getView ( Semester semester ) {
TableLayout layout ;
View v = LayoutInflater . from ( GradesActivity . this ) . inflate (
R . layout . sample , null ) ;
layout = ( TableLayout ) v . findViewById ( R . id . marks_row_parent ) ;
List < Course > courseList = semester . getCourseList ( ) ;
if ( courseList != null ) {
for ( int i = <num> ; i < courseList . size ( ) ; i ++ ) {
View view = LayoutInflater . from ( GradesActivity . this ) . inflate (
R . layout . layout_grades_data , null ) ;
TableRow row = ( TableRow ) view . findViewById ( R . id . marks_row ) ;
( ( TextView ) row . findViewById ( R . id . course_code ) )
. setText ( courseList . get ( i ) . getCourseCode ( ) ) ;
( ( TextView ) row . findViewById ( R . id . course_name ) )
. setText ( courseList . get ( i ) . getCourseName ( ) ) ;
( ( TextView ) row . findViewById ( R . id . course_grade ) )
. setText ( courseList . get ( i ) . getCourseGrade ( ) ) ;
layout . addView ( row ) ;
}
}
return layout ;
}
@Override
protected Dialog onCreateDialog ( int id ) {
switch ( id ) {
case Constants . PROGRESSDIALOG :
final ProgressDialog progressDialog = new ProgressDialog (
GradesActivity . this ) ;
progressDialog . setMessage ( " ) ;
progressDialog . show ( ) ;
progressDialog . setOnCancelListener ( new OnCancelListener ( ) {
@Override
public void onCancel ( DialogInterface dialog ) {
if ( ! progressDialog . isShowing ( ) ) {
progressDialog . show ( ) ;
}
}
} ) ;
return progressDialog ;
default :
break ;
}
return super . onCreateDialog ( id ) ;
}
private void setSemesterName ( ) {
if ( list != null ) {
int index = flipper . getChildCount ( )
( flipper . getDisplayedChild ( ) + <num> ) ;
Semester term = list . get ( index ) ;
examName . setText ( term . getSemesterName ( ) ) ;
gpa . setText ( " + term . getGpa ( ) ) ;
}
}
public void onClick ( View v ) {
switch ( v . getId ( ) ) {
case R . id . marks_btn_prevButton :
nextButton . setEnabled ( true ) ;
int count = flipper . getChildCount ( ) ;
int index = flipper . getDisplayedChild ( ) ;
if ( index + <num> == count ) {
prevButton . setEnabled ( false ) ;
nextButton . setEnabled ( true ) ;
}
flipper . showNext ( ) ;
setSemesterName ( ) ;
break ;
case R . id . marks_btn_nextbutton :
prevButton . setEnabled ( true ) ;
int count1 = flipper . getChildCount ( ) ;
int index1 = flipper . getDisplayedChild ( ) ;
if ( index1 + ( count1  <num> ) == count1 ) {
nextButton . setEnabled ( false ) ;
prevButton . setEnabled ( true ) ;
}
flipper . showPrevious ( ) ;
setSemesterName ( ) ;
break ;
case R . id . sharebutton :
composeText ( ) ;
default :
break ;
}
}
private void composeText ( ) {
int index = flipper . getChildCount ( )
( flipper . getDisplayedChild ( ) + <num> ) ;
Semester term = list . get ( index ) ;
String text = " + authenticateResponse . getStudent_Name ( ) + "
+ " + term . getSemesterName ( ) + " +
" + " ;
for ( Course course : term . getCourseList ( ) )
{
text += course . getCourseName ( ) + " + course . getCourseGrade ( ) + " ;
}
String subject = authenticateResponse . getStudent_Name ( ) + " + term . getSemesterName ( ) + " ;
Utils . sendMail ( text , subject , GradesActivity . this ) ;
}
}
package com . mms . mcm . model ;
import java . util . List ;
public class GradesResponse {
private String errorMsg ;
private String Student_Name ;
private String Campus_ID ;
private List < Semester > semesters ;
public String getStudent_Name ( ) {
return Student_Name ;
}
public void setStudent_Name ( String studentName ) {
Student_Name = studentName ;
}
public String getCampus_ID ( ) {
return Campus_ID ;
}
public void setCampus_ID ( String campusID ) {
Campus_ID = campusID ;
}
public List < Semester > getSemesters ( ) {
return semesters ;
}
public void setSemesters ( List < Semester > semesters ) {
this . semesters = semesters ;
}
public String getErrorMsg ( ) {
return errorMsg ;
}
public void setErrorMsg ( String errorMsg ) {
this . errorMsg = errorMsg ;
}
}
package com . mms . mcm . model ;
import java . util . List ;
public class BooksOnHoldResponse {
String errorMessage ;
List < Books > booksList ;
public String getErrorMessage ( ) {
return errorMessage ;
}
public void setErrorMessage ( String errorMessage ) {
this . errorMessage = errorMessage ;
}
public List < Books > getBooksList ( ) {
return booksList ;
}
public void setBooksList ( List < Books > booksList ) {
this . booksList = booksList ;
}
}
package com . mms . mcm . model ;
import java . util . List ;
public class BookSearchResponse {
private String errorMsg ;
private List < Books > booksList ;
public String getErrorMsg ( ) {
return errorMsg ;
}
public void setErrorMsg ( String errorMsg ) {
this . errorMsg = errorMsg ;
}
public List < Books > getBooksList ( ) {
return booksList ;
}
public void setBooksList ( List < Books > booksList ) {
this . booksList = booksList ;
}
}
package com . mms . mcm . activities ;
import org . ksoap2 . serialization . SoapObject ;
import android . app . Activity ;
import android . app . Dialog ;
import android . app . ProgressDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . DialogInterface . OnCancelListener ;
import android . net . Uri ;
import android . os . Bundle ;
import android . text . TextUtils ;
import android . util . Log ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . EditText ;
import android . widget . ImageView ;
import android . widget . TextView ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . network . NetworkCallback ;
import com . mms . mcm . network . Parser ;
import com . mms . mcm . network . SoapServiceManager ;
public class ChangePwdActivity extends Activity implements OnClickListener {
protected static final String TAG = " ;
private EditText mmsId ;
private EditText oldPwd ;
private EditText newPwd ;
private EditText confPwd ;
private AuthenticateResponse authenticateResponse ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_change_password ) ;
initializeViews ( ) ;
MihirApp app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
}
private void initializeViews ( ) {
mmsId = ( EditText ) findViewById ( R . id . changepwd_edittext_mmsid ) ;
oldPwd = ( EditText ) findViewById ( R . id . change_pwd_edittext_oldpwd ) ;
newPwd = ( EditText ) findViewById ( R . id . change_pwd_edittext_newpwd ) ;
confPwd = ( EditText ) findViewById ( R . id . change_pwd_edittext_confpwd ) ;
findViewById ( R . id . change_pwd_btn_change ) . setOnClickListener ( ChangePwdActivity . this ) ;
findViewById ( R . id . mms_ad_image ) . setOnClickListener ( this ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
}
public void onClick ( View v ) {
switch ( v . getId ( ) ) {
case R . id . change_pwd_btn_change :
SoapServiceManager manager = SoapServiceManager . getInstance ( ChangePwdActivity . this ) ;
if ( isEmpty ( mmsId ) || isEmpty ( oldPwd ) || isEmpty ( newPwd ) || isEmpty ( confPwd ) )
{
Utils . showDialog ( Constants . FIELDSREQUIRED , ChangePwdActivity . this , false ) ;
}
else if ( ! TextUtils . equals ( newPwd . getText ( ) . toString ( ) . trim ( ) , confPwd . getText ( ) . toString ( ) . trim ( ) ) )
{
Utils . showDialog ( Constants . FIELDSNOTMATCH , ChangePwdActivity . this , false ) ;
}
else if ( TextUtils . equals ( oldPwd . getText ( ) . toString ( ) . trim ( ) , newPwd . getText ( ) . toString ( ) . trim ( ) ) )
{
Utils . showDialog ( " , ChangePwdActivity . this , false ) ;
}
else
{ showDialog ( Constants . PROGRESSDIALOG ) ;
manager . sendchangePasswordRequest ( mmsId . getText ( ) . toString ( ) , oldPwd . getText ( ) . toString ( ) , newPwd . getText ( ) . toString ( ) , callback ) ;
}
break ;
case R . id . mms_ad_image :
startActivity ( new Intent ( Intent . ACTION_VIEW , Uri . parse ( " ) ) ) ;
break ;
default :
break ;
}
}
final NetworkCallback < Object > callback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object object ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
try
{
String msg = Parser . parseChangePwd ( ( SoapObject ) object ) ;
Utils . showDialog ( msg , ChangePwdActivity . this , false ) ;
}
catch ( ClassCastException cce )
{
Utils . showToast ( " , ChangePwdActivity . this ) ;
Log . v ( TAG , cce . getMessage ( ) ) ;
}
catch ( Exception e )
{
Log . v ( TAG , e . getMessage ( ) ) ;
}
}
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Log . v ( TAG , errorMessge ) ;
}
} ;
NetworkCallback < Object > adcallback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object object ) {
}
public void onFailure ( String errorMessge ) {
Log . v ( TAG , errorMessge ) ;
}
} ;
private Boolean isEmpty ( EditText editText )
{
return TextUtils . isEmpty ( editText . getText ( ) . toString ( ) ) ;
}
protected Dialog onCreateDialog ( int id ) {
switch ( id ) {
case Constants . PROGRESSDIALOG :
final ProgressDialog progressDialog = new ProgressDialog ( ChangePwdActivity . this ) ;
progressDialog . setMessage ( " ) ;
progressDialog . show ( ) ;
progressDialog . setOnCancelListener ( new OnCancelListener ( ) {
@Override
public void onCancel ( DialogInterface dialog ) {
if ( ! progressDialog . isShowing ( ) )
{
progressDialog . show ( ) ;
}
}
} ) ;
return progressDialog ;
default :
break ;
}
return super . onCreateDialog ( id ) ;
}
}
package com . mms . mcm . model ;
public class BooksOnPossessionResponse {
}
package com . mms . mcm . activities ;
import android . app . Activity ;
import android . os . Bundle ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . ImageView ;
import android . widget . TableRow ;
import android . widget . TextView ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . model . Projects ;
public class ProjectDetailsActivity extends Activity implements OnClickListener {
private AuthenticateResponse authenticateResponse ;
private Projects project ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
private String isFrom ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_projects_details ) ;
MihirApp app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
findViewById ( R . id . sharebutton ) . setOnClickListener ( ProjectDetailsActivity . this ) ;
Bundle bundle = getIntent ( ) . getExtras ( ) ;
if ( bundle != null && bundle . containsKey ( " ) )
{
project = ( Projects ) bundle . get ( " ) ;
isFrom = bundle . getString ( " ) ;
if ( isFrom . equalsIgnoreCase ( " ) )
{
( ( TableRow ) findViewById ( R . id . notification_title_table_row ) ) . setVisibility ( View . GONE ) ;
( ( TableRow ) findViewById ( R . id . notification_type_table_row ) ) . setVisibility ( View . VISIBLE ) ;
}
else if ( isFrom . equalsIgnoreCase ( " ) )
{
( ( TableRow ) findViewById ( R . id . notification_title_table_row ) ) . setVisibility ( View . VISIBLE ) ;
( ( TableRow ) findViewById ( R . id . notification_type_table_row ) ) . setVisibility ( View . GONE ) ;
}
( ( TextView ) findViewById ( R . id . course_code ) ) . setText ( project . getCourse_Code ( ) ) ;
( ( TextView ) findViewById ( R . id . course_name ) ) . setText ( project . getCourse_Name ( ) ) ;
( ( TextView ) findViewById ( R . id . course_grade ) ) . setText ( project . getCourse_Grade ( ) ) ;
( ( TextView ) findViewById ( R . id . semester_name ) ) . setText ( project . getSemister_Name ( ) ) ;
( ( TextView ) findViewById ( R . id . notification_type ) ) . setText ( project . getNotifications_Type ( ) ) ;
( ( TextView ) findViewById ( R . id . notification_title ) ) . setText ( project . getNotifications_Title ( ) ) ;
( ( TextView ) findViewById ( R . id . notification_due_time ) ) . setText ( project . getNotifications_DueTime ( ) ) ;
( ( TextView ) findViewById ( R . id . notification_details ) ) . setText ( project . getNotifications_Details ( ) ) ;
( ( TextView ) findViewById ( R . id . notification_comments ) ) . setText ( project . getNotifications_Comments ( ) ) ;
}
}
@Override
public void onClick ( View v ) {
switch ( v . getId ( ) ) {
case R . id . sharebutton :
composeMailContent ( ) ;
break ;
default :
break ;
}
}
private void composeMailContent ( ) {
String mailText = " + authenticateResponse . getStudent_Name ( ) + "
+ " + project . getCourse_Code ( ) + "
+ " + project . getCourse_Name ( ) + "
+ " + project . getCourse_Grade ( ) + "
+ " + project . getSemister_Name ( ) + "
+ " + project . getNotification_Id ( ) + "
+ " + project . getNotifications_Comments ( ) + "
+ " + project . getNotifications_Details ( ) + "
+ " + project . getNotifications_DueTime ( ) + "
+ " + project . getNotifications_Title ( ) + "
+ " + project . getNotifications_Type ( ) + " ;
String subject = authenticateResponse . getStudent_Name ( ) + " ;
Utils . sendMail ( mailText , subject , ProjectDetailsActivity . this ) ;
}
}
package com . mms . mcm . network ;
@SuppressWarnings("hiding")
public interface NetworkCallback < Object > {
void onSuccess ( Object object ) ;
void onFailure ( String errorMessge ) ;
}
package com . mms . mcm . activities ;
import java . util . List ;
import org . ksoap2 . serialization . SoapObject ;
import android . app . Activity ;
import android . app . Dialog ;
import android . app . ProgressDialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . DialogInterface . OnCancelListener ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . view . inputmethod . InputMethodManager ;
import android . widget . AdapterView ;
import android . widget . ArrayAdapter ;
import android . widget . EditText ;
import android . widget . ImageView ;
import android . widget . ListView ;
import android . widget . TextView ;
import android . widget . AdapterView . OnItemClickListener ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . model . BookSearchResponse ;
import com . mms . mcm . model . Books ;
import com . mms . mcm . network . NetworkCallback ;
import com . mms . mcm . network . Parser ;
import com . mms . mcm . network . SoapServiceManager ;
public class LibraryActivity extends Activity implements OnClickListener ,
OnItemClickListener {
protected static final String TAG = " ;
private ListView librarylistview ;
private String [ ] library_items = { " , " } ;
private EditText isbnNo ;
private EditText book_id ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
private AuthenticateResponse authenticateResponse ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_library ) ;
initializeViews ( ) ;
MihirApp app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
librarylistview = ( ListView ) findViewById ( R . id . list ) ;
librarylistview . setAdapter ( new ArrayAdapter < String > (
LibraryActivity . this , R . layout . layout_dietcarelisttext ,
library_items ) ) ;
librarylistview . setOnItemClickListener ( LibraryActivity . this ) ;
}
private void initializeViews ( ) {
isbnNo = ( EditText ) findViewById ( R . id . isbnno ) ;
book_id = ( EditText ) findViewById ( R . id . mms_book_id ) ;
findViewById ( R . id . book_search ) . setOnClickListener ( LibraryActivity . this ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
}
protected void onResume ( ) {
super . onResume ( ) ;
}
public void onClick ( View v ) {
switch ( v . getId ( ) ) {
case R . id . book_search :
if ( isbnNo . getText ( ) . toString ( ) . trim ( ) . equals ( " )
|| book_id . getText ( ) . toString ( ) . trim ( ) . equals ( " ) ) {
Utils . showDialog ( Constants . FIELDSREQUIRED ,
LibraryActivity . this , false ) ;
} else {
searchBooks ( ) ;
}
break ;
default :
break ;
}
}
private void searchBooks ( ) {
showDialog ( Constants . PROGRESSDIALOG ) ;
SoapServiceManager manager = SoapServiceManager
. getInstance ( LibraryActivity . this ) ;
manager . sendBooksOnSearchRequest ( book_id . getText ( ) . toString ( ) . trim ( ) ,
isbnNo . getText ( ) . toString ( ) . trim ( ) , callback ) ;
}
final NetworkCallback < Object > callback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object responseObj ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
List < Books > booksList ;
try {
SoapObject responceObject = ( SoapObject ) responseObj ;
BookSearchResponse response = Parser
. parseBookSearchResponse ( responceObject ) ;
if ( response . getErrorMsg ( ) . trim ( ) . equals ( " ) ) {
booksList = response . getBooksList ( ) ;
if ( booksList != null && booksList . size ( ) > <num> ) {
BookSearchActivity . setBooksList ( booksList , isbnNo
. getText ( ) . toString ( ) , book_id . getText ( )
. toString ( ) ) ;
startActivity ( new Intent ( LibraryActivity . this ,
BookSearchActivity . class ) ) ;
}
} else {
Utils . showDialog ( response . getErrorMsg ( ) ,
LibraryActivity . this , true ) ;
}
} catch ( ClassCastException cce ) {
Utils . showToast ( " ,
LibraryActivity . this ) ;
Log . v ( TAG , cce . getMessage ( ) ) ;
}
}
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Utils . showToast ( " ,
LibraryActivity . this ) ;
}
} ;
@Override
protected Dialog onCreateDialog ( int id ) {
switch ( id ) {
case Constants . PROGRESSDIALOG :
final ProgressDialog progressDialog = new ProgressDialog (
LibraryActivity . this ) ;
progressDialog . setMessage ( " ) ;
progressDialog . show ( ) ;
progressDialog . setOnCancelListener ( new OnCancelListener ( ) {
@Override
public void onCancel ( DialogInterface dialog ) {
if ( ! progressDialog . isShowing ( ) ) {
progressDialog . show ( ) ;
}
}
} ) ;
return progressDialog ;
default :
break ;
}
return super . onCreateDialog ( id ) ;
}
public void onItemClick ( AdapterView < ? > arg0 , View arg1 , int arg2 , long arg3 ) {
InputMethodManager imm = ( InputMethodManager ) getSystemService ( Context . INPUT_METHOD_SERVICE ) ;
imm . hideSoftInputFromWindow ( librarylistview . getApplicationWindowToken ( ) , <num> ) ;
if ( arg2 == <num> )
{
startActivity ( new Intent ( LibraryActivity . this , BooksOnHoldActivity . class ) ) ;
}
else if ( arg2 == <num> )
{
startActivity ( new Intent ( LibraryActivity . this , BooksOnPossessionActivity . class ) ) ;
}
}
}
package com . mms . mcm ;
public final class R {
public static final class array {
public static final int library_items = <num> ;
}
public static final class attr {
}
public static final class drawable {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int ic_input_add = <num> ;
public static final int ic_launcher = <num> ;
public static final int icon = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int left_tab_indicator = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int logo = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int mms_ad = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int right_tab_indicator = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
}
public static final class id {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int action_bar_image_add = <num> ;
public static final int action_bar_signout = <num> ;
public static final int action_bar_tv_patient_name = <num> ;
public static final int action_tv_hospital_name = <num> ;
public static final int <unk> = <num> ;
public static final int book_id = <num> ;
public static final int book_search = <num> ;
public static final int book_status = <num> ;
public static final int book_title = <num> ;
public static final int books_hold_listview = <num> ;
public static final int books_possession_listview = <num> ;
public static final int books_search_listview = <num> ;
public static final int campus_calendar = <num> ;
public static final int campus_calendar_listview = <num> ;
public static final int campus_emergency_no = <num> ;
public static final int campus_police_no = <num> ;
public static final int change_pwd_btn_change = <num> ;
public static final int change_pwd_edittext_confpwd = <num> ;
public static final int change_pwd_edittext_newpwd = <num> ;
public static final int change_pwd_edittext_oldpwd = <num> ;
public static final int changepwd_edittext_mmsid = <num> ;
public static final int complaint_cell_btn_send = <num> ;
public static final int complaint_description = <num> ;
public static final int course_code = <num> ;
public static final int course_grade = <num> ;
public static final int course_name = <num> ;
public static final int credits_achieved = <num> ;
public static final int <unk> = <num> ;
public static final int gpa = <num> ;
public static final int hold_count0 = <num> ;
public static final int hold_count1 = <num> ;
public static final int home_tv_complaint_cell = <num> ;
public static final int home_tv_grades = <num> ;
public static final int home_tv_homework_projects = <num> ;
public static final int home_tv_library = <num> ;
public static final int home_tv_myaccount = <num> ;
public static final int home_tv_notifications = <num> ;
public static final int home_work_projects_listview = <num> ;
public static final int imageView1 = <num> ;
public static final int <unk> = <num> ;
public static final int isbn_no = <num> ;
public static final int isbnno = <num> ;
public static final int layout_complaint_cell_edittext_name = <num> ;
public static final int layout_complaint_cell_image_removename = <num> ;
public static final int layout_linearlayout_campus_cell_names = <num> ;
public static final int <unk> = <num> ;
public static final int linearLayout1 = <num> ;
public static final int list = <num> ;
public static final int local_police_no = <num> ;
public static final int login_btn_forgotpwd = <num> ;
public static final int login_btn_login = <num> ;
public static final int login_btn_register = <num> ;
public static final int login_checkbox_rememberme = <num> ;
public static final int login_edittext_password = <num> ;
public static final int login_edittext_username = <num> ;
public static final int marks_btn_nextbutton = <num> ;
public static final int marks_btn_prevButton = <num> ;
public static final int marks_row = <num> ;
public static final int marks_row_parent = <num> ;
public static final int marks_tv_examName = <num> ;
public static final int <unk> = <num> ;
public static final int mms_ad_image = <num> ;
public static final int mms_book_id = <num> ;
public static final int myacc_cgpa = <num> ;
public static final int myacc_duetime = <num> ;
public static final int myacc_feedue = <num> ;
public static final int <unk> = <num> ;
public static final int myaccount_btn_changepwd = <num> ;
public static final int <unk> = <num> ;
public static final int myaccount_spinner_logouttime = <num> ;
public static final int myaccount_tv_username = <num> ;
public static final int notification = <num> ;
public static final int notification_comments = <num> ;
public static final int notification_details = <num> ;
public static final int notification_due_time = <num> ;
public static final int notification_title = <num> ;
public static final int notification_title_table_row = <num> ;
public static final int notification_type = <num> ;
public static final int notification_type_table_row = <num> ;
public static final int notifications_listview = <num> ;
public static final int numbers_spinner = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int projects_course_code = <num> ;
public static final int projects_due_date = <num> ;
public static final int <unk> = <num> ;
public static final int ref_no = <num> ;
public static final int return_date = <num> ;
public static final int returndate_tv = <num> ;
public static final int school_logo = <num> ;
public static final int semester_name = <num> ;
public static final int sharebutton = <num> ;
public static final int signup_btn_register = <num> ;
public static final int signup_edittext_mmsid = <num> ;
public static final int signup_headertext = <num> ;
public static final int <unk> = <num> ;
public static final int text = <num> ;
public static final int viewflipper = <num> ;
}
public static final class layout {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int books_in_possession_list_layout = <num> ;
public static final int complaint_cell_name_layout = <num> ;
public static final int home_work_projects_list_layout = <num> ;
public static final int layout_book_hold = <num> ;
public static final int layout_book_search = <num> ;
public static final int layout_books_in_possession = <num> ;
public static final int layout_change_password = <num> ;
public static final int layout_complaint_cell = <num> ;
public static final int layout_dietcarelisttext = <num> ;
public static final int layout_forgotpwd_signup = <num> ;
public static final int layout_grades = <num> ;
public static final int layout_grades_data = <num> ;
public static final int layout_home = <num> ;
public static final int layout_home_work_projects = <num> ;
public static final int layout_layout_notifications = <num> ;
public static final int layout_library = <num> ;
public static final int layout_login = <num> ;
public static final int layout_myaccount = <num> ;
public static final int layout_projects_details = <num> ;
public static final int mms_ad = <num> ;
public static final int sample = <num> ;
public static final int <unk> = <num> ;
public static final int sharebutton = <num> ;
public static final int splash = <num> ;
public static final int tab_indicator = <num> ;
}
public static final class string {
public static final int <unk> = <num> ;
public static final int app_name = <num> ;
public static final int book_id = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int change = <num> ;
public static final int <unk> = <num> ;
public static final int course_code = <num> ;
public static final int course_name = <num> ;
public static final int description = <num> ;
public static final int <unk> = <num> ;
public static final int grade = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int isbn_no = <num> ;
public static final int login = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int register = <num> ;
public static final int <unk> = <num> ;
public static final int search = <num> ;
public static final int send = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int username = <num> ;
}
public static final class style {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
}
}
package com . mms . mcm . custom ;
public final class Constants {
public static final int SUCCESS = <num> ;
public static final int FAILURE = <num> ;
public static final int PROGRESSDIALOG = <num> ;
public static final int STATUS = <num> ;
public static final String FIELDSREQUIRED = " ;
public static final String FIELDSNOTMATCH = " ;
public static final int INVALIDUSER = <num> ;
public static final int STUDENT = <num> ;
}
package com . mms . mcm . custom ;
import android . content . Context ;
import android . util . AttributeSet ;
import android . view . View ;
import android . view . ViewGroup ;
public class DashboardLayout extends ViewGroup {
private static final int UNEVEN_GRID_PENALTY_MULTIPLIER = <num> ;
private int mMaxChildWidth = <num> ;
private int mMaxChildHeight = <num> ;
public DashboardLayout ( Context context ) {
super ( context , null ) ;
}
public DashboardLayout ( Context context , AttributeSet attrs ) {
super ( context , attrs , <num> ) ;
}
public DashboardLayout ( Context context , AttributeSet attrs , int defStyle ) {
super ( context , attrs , defStyle ) ;
}
@Override
protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) {
mMaxChildWidth = <num> ;
mMaxChildHeight = <num> ;
int childWidthMeasureSpec = MeasureSpec . makeMeasureSpec (
MeasureSpec . getSize ( widthMeasureSpec ) , MeasureSpec . AT_MOST ) ;
int childHeightMeasureSpec = MeasureSpec . makeMeasureSpec (
MeasureSpec . getSize ( widthMeasureSpec ) , MeasureSpec . AT_MOST ) ;
final int count = getChildCount ( ) ;
for ( int i = <num> ; i < count ; i ++ ) {
final View child = getChildAt ( i ) ;
if ( child . getVisibility ( ) == GONE ) {
continue ;
}
child . measure ( childWidthMeasureSpec , childHeightMeasureSpec ) ;
mMaxChildWidth = Math . max ( mMaxChildWidth , child . getMeasuredWidth ( ) ) ;
mMaxChildHeight = Math . max ( mMaxChildHeight , child . getMeasuredHeight ( ) ) ;
}
childWidthMeasureSpec = MeasureSpec . makeMeasureSpec (
mMaxChildWidth , MeasureSpec . EXACTLY ) ;
childHeightMeasureSpec = MeasureSpec . makeMeasureSpec (
mMaxChildHeight , MeasureSpec . EXACTLY ) ;
for ( int i = <num> ; i < count ; i ++ ) {
final View child = getChildAt ( i ) ;
if ( child . getVisibility ( ) == GONE ) {
continue ;
}
child . measure ( childWidthMeasureSpec , childHeightMeasureSpec ) ;
}
setMeasuredDimension (
resolveSize ( mMaxChildWidth , widthMeasureSpec ) ,
resolveSize ( mMaxChildHeight , heightMeasureSpec ) ) ;
}
@Override
protected void onLayout ( boolean changed , int l , int t , int r , int b ) {
int width = r  l ;
int height = b  t ;
final int count = getChildCount ( ) ;
int visibleCount = <num> ;
for ( int i = <num> ; i < count ; i ++ ) {
final View child = getChildAt ( i ) ;
if ( child . getVisibility ( ) == GONE ) {
continue ;
}
++ visibleCount ;
}
if ( visibleCount == <num> ) {
return ;
}
int bestSpaceDifference = Integer . MAX_VALUE ;
int spaceDifference ;
int hSpace = <num> ;
int vSpace = <num> ;
int cols = <num> ;
int rows ;
while ( true ) {
rows = ( visibleCount  <num> ) / cols + <num> ;
hSpace = ( ( width  mMaxChildWidth * cols ) / ( cols + <num> ) ) ;
vSpace = ( ( height  mMaxChildHeight * rows ) / ( rows + <num> ) ) ;
spaceDifference = Math . abs ( vSpace  hSpace ) ;
if ( rows * cols != visibleCount ) {
spaceDifference *= UNEVEN_GRID_PENALTY_MULTIPLIER ;
}
if ( spaceDifference < bestSpaceDifference ) {
bestSpaceDifference = spaceDifference ;
if ( rows == <num> ) {
break ;
}
} else {
cols ;
rows = ( visibleCount  <num> ) / cols + <num> ;
hSpace = ( ( width  mMaxChildWidth * cols ) / ( cols + <num> ) ) ;
vSpace = ( ( height  mMaxChildHeight * rows ) / ( rows + <num> ) ) ;
break ;
}
++ cols ;
}
hSpace = Math . max ( <num> , hSpace ) ;
vSpace = Math . max ( <num> , vSpace ) ;
width = ( width  hSpace * ( cols + <num> ) ) / cols ;
height = ( height  vSpace * ( rows + <num> ) ) / rows ;
int left , top ;
int col , row ;
int visibleIndex = <num> ;
for ( int i = <num> ; i < count ; i ++ ) {
final View child = getChildAt ( i ) ;
if ( child . getVisibility ( ) == GONE ) {
continue ;
}
row = visibleIndex / cols ;
col = visibleIndex % cols ;
left = hSpace * ( col + <num> ) + width * col ;
top = vSpace * ( row + <num> ) + height * row ;
child . layout ( left , top ,
( hSpace == <num> && col == cols  <num> ) ? r : ( left + width ) ,
( vSpace == <num> && row == rows  <num> ) ? b : ( top + height ) ) ;
++ visibleIndex ;
}
}
}
package com . mms . mcm . network ;
import java . util . List ;
import java . util . concurrent . ExecutorService ;
import java . util . concurrent . Executors ;
import org . ksoap2 . serialization . PropertyInfo ;
import org . ksoap2 . serialization . SoapObject ;
import android . content . Context ;
public final class SoapServiceManager {
private final static String NAMESPACE = " ;
private static final String SOAP_ACTION_REGISTRATION = " ;
private static final String SOAP_ACTION_FORGOTPASSWORD = " ;
private static final String SOAP_ACTION_CHANGEPASSWORD = " ;
private static final String SOAP_ACTION_AUTHENTICATE = " ;
private static final String SOAP_ACTION_GETGRADES = " ;
private static final String SOAP_ACTION_GETHOMEWORKPROJECTS = " ;
private static final String SOAP_ACTION_GETNOTIFICATIONS = " ;
private static final String SOAP_ACTION_GETCAMPUSCALENDER = " ;
private static final String SOAP_ACTION_MAKECOMPLAINTS = " ;
private static final String SOAP_ACTION_BOOKSONSEARCH = " ;
private static final String SOAP_ACTION_BOOKSPOSSESSION = " ;
private static final String SOAP_ACTION_BOOKS_ON_HOLD = " ;
private static SoapServiceManager serviceManager ;
private static ExecutorService executorService ;
public static SoapServiceManager getInstance ( Context context ) {
return serviceManager == null ? serviceManager = new SoapServiceManager (
context )
: serviceManager ;
}
public SoapServiceManager ( Context context ) {
executorService = Executors . newSingleThreadExecutor ( ) ;
}
public void sendGetGradesRequest ( String student_Id , NetworkCallback < Object > callback )
{
String methodName = " ;
final String actionName = SOAP_ACTION_GETGRADES ;
final SoapObject requestObj = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( student_Id ) ;
requestObj . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , requestObj , handler ) ;
}
} ) ;
}
public void sendGetHomeWorkProjectsRequest ( String student_Id ,
NetworkCallback < Object > callback ) {
String methodName = " ;
final String actionName = SOAP_ACTION_GETHOMEWORKPROJECTS ;
final SoapObject requestObj = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( student_Id ) ;
requestObj . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , requestObj , handler ) ;
}
} ) ;
}
public void sendGetNotificationDetailsRequest ( String student_Id ,
NetworkCallback < Object > callback ) {
String methodName = " ;
final String actionName = SOAP_ACTION_GETNOTIFICATIONS ;
final SoapObject requestObj = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( student_Id ) ;
requestObj . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , requestObj , handler ) ;
}
} ) ;
}
public void sendGetCampusCalenderDetailsRequest ( String campus_Id , String student_Id ,
NetworkCallback < Object > callback ) {
String methodName = " ;
final String actionName = SOAP_ACTION_GETCAMPUSCALENDER ;
final SoapObject requestObj = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( campus_Id ) ;
requestObj . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( student_Id ) ;
requestObj . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , requestObj , handler ) ;
}
} ) ;
}
public void sendComplaintCellDetailsRequest ( String student_ID , List < String > studentNames , String complaintDescription ,
NetworkCallback < Object > callback ) {
String names [ ] = { " , " , " , " , " } ;
for ( int i = <num> ; i < studentNames . size ( ) ; i ++ )
{
names [ i ] = studentNames . get ( i ) ;
}
String methodName = " ;
final String actionName = SOAP_ACTION_MAKECOMPLAINTS ;
final SoapObject requestObj = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( student_ID ) ;
requestObj . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( names [ <num> ] ) ;
requestObj . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( names [ <num> ] ) ;
requestObj . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( names [ <num> ] ) ;
requestObj . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( names [ <num> ] ) ;
requestObj . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( names [ <num> ] ) ;
requestObj . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( complaintDescription ) ;
requestObj . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , requestObj , handler ) ;
}
} ) ;
}
public void sendBooksOnSearchRequest ( String book_MMS_ID , String book_IBSN_NO ,
NetworkCallback < Object > callback ) {
String methodName = " ;
final String actionName = SOAP_ACTION_BOOKSONSEARCH ;
final SoapObject requestObj = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( book_MMS_ID ) ;
requestObj . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( book_IBSN_NO ) ;
requestObj . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , requestObj , handler ) ;
}
} ) ;
}
public void sendBooksOnHoldRequest ( String student_ID ,
NetworkCallback < Object > callback ) {
String methodName = " ;
final String actionName = SOAP_ACTION_BOOKS_ON_HOLD ;
final SoapObject requestObj = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( student_ID ) ;
requestObj . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , requestObj , handler ) ;
}
} ) ;
}
public void sendBooksOnPossessionRequest ( String student_ID ,
NetworkCallback < Object > callback ) {
String methodName = " ;
final String actionName = SOAP_ACTION_BOOKSPOSSESSION ;
final SoapObject requestObj = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . setNamespace ( NAMESPACE ) ;
info . setName ( " ) ;
info . setValue ( Integer . parseInt ( student_ID ) ) ;
requestObj . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , requestObj , handler ) ;
}
} ) ;
}
public void sendregisterRequest ( String mmsId ,
NetworkCallback < Object > callback ) {
String methodName = " ;
final String actionName = SOAP_ACTION_REGISTRATION ;
final SoapObject request = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . namespace = NAMESPACE ;
info . name = " ;
info . setValue ( mmsId ) ;
request . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , request , handler ) ;
}
} ) ;
}
public void sendforgotPasswordRequest ( String mmsId ,
NetworkCallback < Object > callback ) {
String methodName = " ;
final String actionName = SOAP_ACTION_FORGOTPASSWORD ;
final SoapObject request = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . namespace = NAMESPACE ;
info . name = " ;
info . setValue ( mmsId ) ;
request . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , request , handler ) ;
}
} ) ;
}
public void sendchangePasswordRequest ( String mmsId , String oldPwd ,
String newPwd , NetworkCallback < Object > callback ) {
String methodName = " ;
final String actionName = SOAP_ACTION_CHANGEPASSWORD ;
final SoapObject request = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . namespace = NAMESPACE ;
info . name = " ;
info . setValue ( mmsId ) ;
request . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . namespace = NAMESPACE ;
info . name = " ;
info . setValue ( oldPwd ) ;
request . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . namespace = NAMESPACE ;
info . name = " ;
info . setValue ( newPwd ) ;
request . addProperty ( info ) ;
final MihirHandler handler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn . callWebService ( actionName , request , handler ) ;
}
} ) ;
}
public void sendAuthenticateRequest ( String mmsId , String password ,
String deviceId , NetworkCallback < Object > callback ) {
String methodName = " ;
final String actionName = SOAP_ACTION_AUTHENTICATE ;
final SoapObject requestObject = new SoapObject ( NAMESPACE , methodName ) ;
PropertyInfo info = new PropertyInfo ( ) ;
info . namespace = NAMESPACE ;
info . name = " ;
info . setValue ( mmsId ) ;
requestObject . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . namespace = NAMESPACE ;
info . name = " ;
info . setValue ( password ) ;
requestObject . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . namespace = NAMESPACE ;
info . name = " ;
info . setValue ( deviceId ) ;
requestObject . addProperty ( info ) ;
info = new PropertyInfo ( ) ;
info . namespace = NAMESPACE ;
info . name = " ;
info . setValue ( <num> ) ;
requestObject . addProperty ( info ) ;
final MihirHandler mihirHandler = new MihirHandler ( callback ) ;
executorService . execute ( new Runnable ( ) {
public void run ( ) {
SoapConn
. callWebService ( actionName , requestObject , mihirHandler ) ;
}
} ) ;
}
}
package com . mms . mcm . model ;
import java . util . ArrayList ;
import java . util . List ;
import org . ksoap2 . serialization . SoapObject ;
public class Semester {
String semesterName = " ;
String gpa = " ;
List < Course > courseList ;
public String getGpa ( ) {
return gpa ;
}
public void <unk> ( String gpa ) {
this . gpa = gpa ;
}
public Semester ( SoapObject soapObject ) {
courseList = new ArrayList < Course > ( ) ;
semesterName = soapObject . getPropertyAsString ( " ) ;
gpa = soapObject . getPropertyAsString ( " ) ;
for ( int i = <num> ; i < soapObject . getPropertyCount ( ) ; i ++ ) {
SoapObject courseObject = ( SoapObject ) soapObject . getProperty ( i ) ;
courseList . add ( new Course ( courseObject ) ) ;
}
}
public String getSemesterName ( ) {
return semesterName ;
}
public void setSemesterName ( String semesterName ) {
this . semesterName = semesterName ;
}
public List < Course > getCourseList ( ) {
return courseList ;
}
public void <unk> ( List < Course > courseList ) {
this . courseList = courseList ;
}
}
package com . mms . mcm . model ;
import java . io . Serializable ;
public class AuthenticateResponse implements Serializable {
private static final long serialVersionUID = <num> ;
String authenticateMSG ;
int userType ;
String student_ID ;
String campus_ID ;
String student_Name ;
String campusName ;
String campusShortName ;
String campus_Registration_Number ;
String campus_Student_Id ;
String logo_URL ;
String fee_Due ;
String fee_DueDate ;
String credits_Acheived ;
String cGPA ;
String student_Campus_Number ;
String student_Doctor_Number = " ;
String campus_Police_number = " ;
String campus_Local_number = " ;
String campus_Emmergency_Number = " ;
public String getCampusShortName ( ) {
return campusShortName ;
}
public void setCampusShortName ( String campusShortName ) {
this . campusShortName = campusShortName ;
}
public String <unk> ( ) {
return campusName ;
}
public void setCampusName ( String campusName ) {
this . campusName = campusName ;
}
public String <unk> ( ) {
return logo_URL ;
}
public void <unk> ( String logoURL ) {
logo_URL = logoURL ;
}
public String getAuthenticateMSG ( ) {
return authenticateMSG ;
}
public void setAuthenticateMSG ( String authenticateMSG ) {
this . authenticateMSG = authenticateMSG ;
}
public int getUserType ( ) {
return userType ;
}
public void setUserType ( int userType ) {
this . userType = userType ;
}
public String getStudent_ID ( ) {
return student_ID ;
}
public void setStudent_ID ( String studentID ) {
student_ID = studentID ;
}
public String getCampus_ID ( ) {
return campus_ID ;
}
public void setCampus_ID ( String campusID ) {
campus_ID = campusID ;
}
public String getStudent_Name ( ) {
return student_Name ;
}
public void setStudent_Name ( String studentName ) {
student_Name = studentName ;
}
public String <unk> ( ) {
return campus_Registration_Number ;
}
public void setCampus_Registration_Number ( String campusRegistrationNumber ) {
campus_Registration_Number = campusRegistrationNumber ;
}
public String <unk> ( ) {
return campus_Student_Id ;
}
public void setCampus_Student_Id ( String campusStudentId ) {
campus_Student_Id = campusStudentId ;
}
public String getFee_Due ( ) {
return fee_Due ;
}
public void setFee_Due ( String feeDue ) {
fee_Due = feeDue ;
}
public String getFee_DueDate ( ) {
return fee_DueDate ;
}
public void setFee_DueDate ( String feeDueDate ) {
fee_DueDate = feeDueDate ;
}
public String getCredits_Acheived ( ) {
return credits_Acheived ;
}
public void setCredits_Acheived ( String creditsAcheived ) {
credits_Acheived = creditsAcheived ;
}
public String getcGPA ( ) {
return cGPA ;
}
public void setcGPA ( String cGPA ) {
this . cGPA = cGPA ;
}
public String <unk> ( ) {
return student_Campus_Number ;
}
public void setStudent_Campus_Number ( String studentCampusNumber ) {
student_Campus_Number = studentCampusNumber ;
}
public String <unk> ( ) {
return student_Doctor_Number ;
}
public void setStudent_Doctor_Number ( String studentDoctorNumber ) {
student_Doctor_Number = studentDoctorNumber ;
}
public String getCampus_Police_number ( ) {
return campus_Police_number ;
}
public void setCampus_Police_number ( String campusPoliceNumber ) {
campus_Police_number = campusPoliceNumber ;
}
public String getCampus_Local_number ( ) {
return campus_Local_number ;
}
public void setCampus_Local_number ( String campusLocalNumber ) {
campus_Local_number = campusLocalNumber ;
}
public String getCampus_Emmergency_Number ( ) {
return campus_Emmergency_Number ;
}
public void setCampus_Emmergency_Number ( String campusEmmergencyNumber ) {
campus_Emmergency_Number = campusEmmergencyNumber ;
}
}
package com . mms . mcm . model ;
public class Books {
private String Book_ID ;
private String Book_REF_Number ;
private String Book_Title ;
private String Book_Status ;
private String Book_Return_Date ;
private String Book_Hold_Count ;
public String <unk> ( ) {
return Book_ID ;
}
public String toString ( ) {
return Book_Title ;
}
public void setBook_ID ( String bookID ) {
Book_ID = bookID ;
}
public String getBook_REF_Number ( ) {
return Book_REF_Number ;
}
public void setBook_REF_Number ( String bookREFNumber ) {
Book_REF_Number = bookREFNumber ;
}
public String getBook_Title ( ) {
return Book_Title ;
}
public void setBook_Title ( String bookTitle ) {
Book_Title = bookTitle ;
}
public String getBook_Status ( ) {
return Book_Status ;
}
public void setBook_Status ( String bookStatus ) {
Book_Status = bookStatus ;
}
public String getBook_Return_Date ( ) {
return Book_Return_Date ;
}
public void setBook_Return_Date ( String bookReturnDate ) {
Book_Return_Date = bookReturnDate ;
}
public String getBook_Hold_Count ( ) {
return Book_Hold_Count ;
}
public void setBook_Hold_Count ( String bookHoldCount ) {
Book_Hold_Count = bookHoldCount ;
}
}
package com . mms . mcm . custom ;
import java . io . InputStream ;
import java . net . URL ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . app . AlertDialog . Builder ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . graphics . drawable . Drawable ;
import android . util . Log ;
import android . widget . ImageView ;
import android . widget . TextView ;
import android . widget . Toast ;
import com . mms . mcm . model . AuthenticateResponse ;
public final class Utils {
private static final String TAG = null ;
public static Drawable drawable ;
private static int counter ;
public static final void showDialog ( String msg , final Context context ,
final Boolean tobeFinish ) {
AlertDialog . Builder builder = new Builder ( context ) ;
builder . setMessage ( msg ) ;
builder . setPositiveButton ( " , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int which ) {
if ( tobeFinish ) {
Activity activity = ( Activity ) context ;
activity . finish ( ) ;
}
dialog . dismiss ( ) ;
}
} ) ;
builder . create ( ) . show ( ) ;
}
public static final void setActionBar ( TextView campusName ,
TextView studentName , AuthenticateResponse curUser , ImageView logo ) {
campusName . setText ( curUser . getCampusShortName ( ) ) ;
if ( studentName != null ) {
studentName . setText ( curUser . getStudent_Name ( ) ) ;
}
try {
if ( drawable != null ) {
} else {
}
} catch ( Exception e ) {
}
}
public static final void sendMail ( String mailContent , String subject ,
Context context ) {
Log . v ( TAG , mailContent ) ;
Intent intent = new Intent ( Intent . ACTION_SEND ) ;
intent . setType ( " ) ;
intent . putExtra ( Intent . EXTRA_TEXT , mailContent ) ;
intent . putExtra ( Intent . EXTRA_SUBJECT , subject ) ;
context . startActivity ( Intent . createChooser ( intent , " ) ) ;
}
public static final void showToast ( String msg , Context context ) {
Toast . makeText ( context , msg , Toast . LENGTH_SHORT ) . show ( ) ;
}
public static Drawable <unk> ( String logo_url ) {
counter = <num> ;
if ( logo_url != null ) {
try {
URL url = new URL ( logo_url ) ;
Log . v ( TAG , " + ( counter ++ ) ) ;
InputStream inputStream = ( InputStream ) url . getContent ( ) ;
drawable = Drawable . createFromStream ( inputStream , " ) ;
return drawable ;
} catch ( Exception e ) {
Log . v ( TAG , " ) ;
}
}
return drawable ;
}
}
package com . mms . mcm . activities ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . util . Log ;
import com . mms . mcm . R ;
public class SplashActivity extends Activity {
protected static final String TAG = " ;
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . splash ) ;
Thread t = new Thread ( ) {
public void run ( ) {
super . run ( ) ;
try {
sleep ( <num> ) ;
}
catch ( InterruptedException ie )
{
Log . v ( TAG , ie . getMessage ( ) ) ;
}
catch ( Exception e )
{
Log . v ( TAG , e . getMessage ( ) ) ;
}
finally
{
startActivity ( new Intent ( SplashActivity . this , LoginActivity . class ) ) ;
finish ( ) ;
}
}
} ;
t . start ( ) ;
}
package com . mms . mcm . activities ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . io . FileOutputStream ;
import java . io . IOException ;
import java . io . ObjectInputStream ;
import java . io . ObjectOutputStream ;
import java . io . StreamCorruptedException ;
import org . ksoap2 . serialization . SoapObject ;
import android . app . Activity ;
import android . app . Dialog ;
import android . app . ProgressDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . content . DialogInterface . OnCancelListener ;
import android . net . Uri ;
import android . os . Bundle ;
import android . telephony . TelephonyManager ;
import android . text . TextUtils ;
import android . util . Log ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . CheckBox ;
import android . widget . EditText ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . network . NetworkCallback ;
import com . mms . mcm . network . Parser ;
import com . mms . mcm . network . SoapServiceManager ;
public class LoginActivity extends Activity implements OnClickListener {
private static final String TAG = " ;
public static final String USERNAME = " ;
public static final String LOGOUTTIME = " ;
public static final String <unk> = " ;
private MihirApp app ;
public static SharedPreferences mMyPrefs ;
private EditText mUserName ;
private EditText mPassword ;
private CheckBox mrememberMe ;
private AuthenticateResponse authenticate ;
private Boolean rememberme = false ;
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_login ) ;
initializeViews ( ) ;
app = ( MihirApp ) getApplication ( ) ;
mMyPrefs = this . getSharedPreferences ( " , MODE_WORLD_WRITEABLE ) ;
mUserName . setText ( mMyPrefs . getString ( USERNAME , " ) ) ;
Long logoutTime = mMyPrefs . getLong ( LOGOUTTIME , <num> ) ;
if ( logoutTime > System . currentTimeMillis ( ) ) {
ObjectInputStream ois = null ;
FileInputStream fileInputStream = null ;
try {
fileInputStream = openFileInput ( " ) ;
ois = new ObjectInputStream ( fileInputStream ) ;
Object object = ois . readObject ( ) ;
Log . v ( TAG , " ) ;
if ( object instanceof AuthenticateResponse )
{
AuthenticateResponse authenticateResponse = ( AuthenticateResponse ) object ;
processResponseResult ( authenticateResponse ) ;
}
} catch ( FileNotFoundException e1 ) {
e1 . printStackTrace ( ) ;
} catch ( StreamCorruptedException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
} catch ( ClassNotFoundException e ) {
e . printStackTrace ( ) ;
}
catch ( NullPointerException npe )
{
Log . v ( TAG , " ) ;
}
finally
{
try
{
if ( fileInputStream != null )
{
fileInputStream . close ( ) ;
fileInputStream = null ;
}
if ( ois != null )
{
ois . close ( ) ;
ois = null ;
}
}
catch ( IOException e )
{
e . printStackTrace ( ) ;
}
}
}
}
private void initializeViews ( ) {
mUserName = ( EditText ) findViewById ( R . id . login_edittext_username ) ;
mPassword = ( EditText ) findViewById ( R . id . login_edittext_password ) ;
mrememberMe = ( CheckBox ) findViewById ( R . id . login_checkbox_rememberme ) ;
findViewById ( R . id . login_btn_login ) . setOnClickListener (
LoginActivity . this ) ;
findViewById ( R . id . login_btn_forgotpwd ) . setOnClickListener (
LoginActivity . this ) ;
findViewById ( R . id . login_btn_register ) . setOnClickListener (
LoginActivity . this ) ;
findViewById ( R . id . mms_ad_image ) . setOnClickListener ( this ) ;
}
public void onClick ( View v ) {
switch ( v . getId ( ) ) {
case R . id . login_btn_login :
SoapServiceManager serviceManager = SoapServiceManager
. getInstance ( LoginActivity . this ) ;
String userName = mUserName . getText ( ) . toString ( ) . trim ( ) ;
String password = mPassword . getText ( ) . toString ( ) . trim ( ) ;
if ( mrememberMe . isChecked ( ) ) {
rememberme = true ;
} else {
rememberme = false ;
}
if ( TextUtils . isEmpty ( userName ) || TextUtils . isEmpty ( password ) ) {
Utils . showDialog ( Constants . FIELDSREQUIRED , LoginActivity . this ,
false ) ;
}
else {
showDialog ( Constants . PROGRESSDIALOG ) ;
String deviceId = getDeiviceID ( ) ;
serviceManager . sendAuthenticateRequest ( userName , password ,
deviceId , callback ) ;
}
break ;
case R . id . login_btn_forgotpwd :
Intent intent = new Intent ( LoginActivity . this ,
RegisterActivity . class ) ;
intent . putExtra ( " , " ) ;
startActivity ( intent ) ;
break ;
case R . id . login_btn_register :
intent = new Intent ( LoginActivity . this , RegisterActivity . class ) ;
intent . putExtra ( " , " ) ;
startActivity ( intent ) ;
break ;
case R . id . mms_ad_image :
startActivity ( new Intent ( Intent . ACTION_VIEW , Uri
. parse ( " ) ) ) ;
break ;
default :
break ;
}
}
private String getDeiviceID ( ) {
TelephonyManager manager = ( TelephonyManager ) getSystemService ( TELEPHONY_SERVICE ) ;
String deviceId = manager . getDeviceId ( ) ;
return deviceId != null ? deviceId : " ;
}
final NetworkCallback < Object > callback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object responseObj ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
FileOutputStream fileOutputStream = null ;
ObjectOutputStream objectOutputStream = null ;
try {
SoapObject responceObject = ( SoapObject ) responseObj ;
authenticate = Parser . parseAuthenticateResponse ( responceObject ) ;
fileOutputStream = openFileOutput ( " , MODE_PRIVATE ) ;
objectOutputStream = new ObjectOutputStream ( fileOutputStream ) ;
objectOutputStream . writeObject ( authenticate ) ;
fileOutputStream . flush ( ) ;
int userType = authenticate . getUserType ( ) ;
if ( userType != Constants . INVALIDUSER ) {
rememberMe ( ) ;
}
processResponseResult ( authenticate ) ;
} catch ( ClassCastException cce ) {
Utils . showToast ( " ,
LoginActivity . this ) ;
Log . v ( TAG , cce . getMessage ( ) ) ;
}
catch ( IOException ioe )
{
ioe . printStackTrace ( ) ;
}
finally {
try {
if ( objectOutputStream != null ) {
objectOutputStream . close ( ) ;
objectOutputStream = null ;
}
if ( fileOutputStream != null )
{
fileOutputStream . close ( ) ;
fileOutputStream = null ;
}
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
}
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Utils . showToast ( " ,
LoginActivity . this ) ;
}
} ;
NetworkCallback < Object > adcallback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object object ) {
}
public void onFailure ( String errorMessge ) {
Log . v ( TAG , errorMessge ) ;
}
} ;
@Override
protected Dialog onCreateDialog ( int id ) {
switch ( id ) {
case Constants . PROGRESSDIALOG :
final ProgressDialog progressDialog = new ProgressDialog (
LoginActivity . this ) ;
progressDialog . setMessage ( " ) ;
progressDialog . show ( ) ;
progressDialog . setOnCancelListener ( new OnCancelListener ( ) {
@Override
public void onCancel ( DialogInterface dialog ) {
if ( ! progressDialog . isShowing ( ) ) {
progressDialog . show ( ) ;
}
}
} ) ;
return progressDialog ;
default :
break ;
}
return super . onCreateDialog ( id ) ;
}
private void rememberMe ( ) {
mMyPrefs = this . getSharedPreferences ( " , MODE_WORLD_WRITEABLE ) ;
SharedPreferences . Editor prefsEditor = mMyPrefs . edit ( ) ;
if ( rememberme ) {
prefsEditor . putString ( LoginActivity . USERNAME , mUserName . getText ( )
. toString ( ) ) ;
}
prefsEditor . putLong ( LoginActivity . LOGOUTTIME , ( System
. currentTimeMillis ( ) + ( <num> * <num> * <num> * <num> * <num> ) ) ) ;
prefsEditor . commit ( ) ;
}
private void processResponseResult ( AuthenticateResponse authenticate ) {
int userType = authenticate . getUserType ( ) ;
if ( authenticate . getAuthenticateMSG ( ) . equalsIgnoreCase ( " ) ) {
switch ( userType ) {
case Constants . STUDENT :
app . setIsloggedin ( true ) ;
app . setCurUserInfo ( authenticate ) ;
startActivity ( new Intent ( LoginActivity . this , HomeActivity . class ) ) ;
finish ( ) ;
break ;
}
} else {
Utils . showDialog ( authenticate . getAuthenticateMSG ( ) , LoginActivity . this ,
false ) ;
app . setIsloggedin ( false ) ;
}
}
protected void onRestart ( ) {
super . onRestart ( ) ;
Log . v ( TAG , " ) ;
if ( app . isIsloggedin ( ) )
{
finish ( ) ;
}
}
protected void onResume ( ) {
super . onResume ( ) ;
Log . v ( TAG , " ) ;
}
protected void onStart ( ) {
super . onStart ( ) ;
Log . v ( TAG , " ) ;
}
protected void onPause ( ) {
super . onPause ( ) ;
Log . v ( TAG , " ) ;
}
package com . mms . mcm . model ;
import java . util . List ;
public class CampusCalendarResponse {
private String errorMessage ;
private List < Projects > projectsList ;
public String getErrorMessage ( ) {
return errorMessage ;
}
public void setErrorMessage ( String errorMessage ) {
this . errorMessage = errorMessage ;
}
public List < Projects > getProjectsList ( ) {
return projectsList ;
}
public void setProjectsList ( List < Projects > projectsList ) {
this . projectsList = projectsList ;
}
}
package com . mms . mcm . activities ;
import android . app . Activity ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . net . Uri ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . AdapterView ;
import android . widget . ArrayAdapter ;
import android . widget . ImageView ;
import android . widget . Spinner ;
import android . widget . TextView ;
import android . widget . AdapterView . OnItemSelectedListener ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . network . NetworkCallback ;
public class MyAccountActivity extends Activity implements OnClickListener ,
OnItemSelectedListener {
private static final String TAG = null ;
private String [ ] days_hours = { " , " , " } ;
private Spinner spinner ;
private Spinner number_spinner ;
private AuthenticateResponse authenticateResponse ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
private SharedPreferences mMyPrefs ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_myaccount ) ;
MihirApp app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
initializeViews ( ) ;
ArrayAdapter < String > adapter = new ArrayAdapter < String > ( this ,
android . R . layout . simple_spinner_item , days_hours ) ;
adapter
. setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
spinner . setAdapter ( adapter ) ;
mMyPrefs = this . getSharedPreferences ( " , MODE_WORLD_WRITEABLE ) ;
int mode = mMyPrefs . getInt ( " , <num> ) ;
int number = mMyPrefs . getInt ( " , <num> ) ;
spinner . setSelection ( mode ) ;
number_spinner . setSelection ( number ) ;
}
private void initializeViews ( ) {
findViewById ( R . id . myaccount_btn_changepwd ) . setOnClickListener (
MyAccountActivity . this ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
findViewById ( R . id . mms_ad_image ) . setOnClickListener ( this ) ;
spinner = ( Spinner ) findViewById ( R . id . myaccount_spinner_logouttime ) ;
number_spinner = ( Spinner ) findViewById ( R . id . numbers_spinner ) ;
spinner . setOnItemSelectedListener ( this ) ;
number_spinner . setOnItemSelectedListener ( this ) ;
( ( TextView ) findViewById ( R . id . myaccount_tv_username ) )
. setText ( getUserName ( ) ) ;
( ( TextView ) findViewById ( R . id . credits_achieved ) )
. setText ( authenticateResponse . getCredits_Acheived ( ) ) ;
( ( TextView ) findViewById ( R . id . myacc_cgpa ) ) . setText ( authenticateResponse
. getcGPA ( ) ) ;
( ( TextView ) findViewById ( R . id . myacc_feedue ) )
. setText ( authenticateResponse . getFee_Due ( ) ) ;
( ( TextView ) findViewById ( R . id . myacc_duetime ) )
. setText ( authenticateResponse . getFee_DueDate ( ) ) ;
}
private String getUserName ( ) {
return authenticateResponse . getStudent_Name ( ) ;
}
final NetworkCallback < Object > adcallback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object object ) {
}
public void onFailure ( String errorMessge ) {
}
} ;
public void onClick ( View v ) {
switch ( v . getId ( ) ) {
case R . id . myaccount_btn_changepwd :
startActivity ( new Intent ( MyAccountActivity . this ,
ChangePwdActivity . class ) ) ;
break ;
case R . id . mms_ad_image :
startActivity ( new Intent ( Intent . ACTION_VIEW , Uri
. parse ( " ) ) ) ;
break ;
default :
break ;
}
}
public void onItemSelected ( AdapterView < ? > arg0 , View arg1 , int arg2 , long id ) {
if ( arg0 . getItemAtPosition ( arg2 ) . toString ( ) . equals ( " ) ) {
number_spinner . setVisibility ( View . VISIBLE ) ;
String days [ ] = new String [ <num> ] ;
for ( int i = <num> ; i < <num> ; i ++ ) {
days [ i ] = String . valueOf ( i + <num> ) ;
}
ArrayAdapter < String > adapter = new ArrayAdapter < String > (
MyAccountActivity . this ,
android . R . layout . simple_spinner_item , days ) ;
adapter
. setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
number_spinner . setAdapter ( adapter ) ;
}
else if ( arg0 . getItemAtPosition ( arg2 ) . toString ( ) . equals ( " ) ) {
number_spinner . setVisibility ( View . VISIBLE ) ;
String days [ ] = new String [ <num> ] ;
for ( int i = <num> ; i < <num> ; i ++ ) {
days [ i ] = String . valueOf ( i + <num> ) ;
}
ArrayAdapter < String > adapter = new ArrayAdapter < String > (
MyAccountActivity . this ,
android . R . layout . simple_spinner_item , days ) ;
adapter
. setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
number_spinner . setAdapter ( adapter ) ;
Log . v ( TAG , " ) ;
} else if ( arg0 . getItemAtPosition ( arg2 ) . toString ( ) . equals ( " ) ) {
number_spinner . setVisibility ( View . GONE ) ;
Log . v ( TAG , " ) ;
}
editPreferences ( ) ;
}
public void onNothingSelected ( AdapterView < ? > arg0 ) {
}
@Override
protected void onPause ( ) {
super . onPause ( ) ;
Log . v ( TAG , " ) ;
}
private void editPreferences ( ) {
int number = <num> ;
Long logoutTime = <num> ;
if ( spinner . getSelectedItem ( ) . toString ( ) . equalsIgnoreCase ( " ) ) {
number = <num> ;
logoutTime = System . currentTimeMillis ( )
+ Long . valueOf ( number_spinner . getSelectedItem ( ) . toString ( ) )
* <num> * <num> * <num> * <num> ;
} else if ( spinner . getSelectedItem ( ) . toString ( ) . equalsIgnoreCase (
" ) ) {
number = <num> ;
if ( number_spinner . getSelectedItem ( ) != null ) {
logoutTime = System . currentTimeMillis ( )
+ Long . valueOf ( number_spinner . getSelectedItem ( )
. toString ( ) ) * <num> * <num> * <num> ;
}
} else if ( spinner . getSelectedItem ( ) . toString ( ) . equalsIgnoreCase (
" ) ) {
number = <num> ;
logoutTime = System . currentTimeMillis ( ) + <num> * <num> * <num> * <num> * <num> ;
}
LoginActivity . mMyPrefs = this . getSharedPreferences ( " ,
MODE_WORLD_WRITEABLE ) ;
SharedPreferences . Editor prefsEditor = LoginActivity . mMyPrefs . edit ( ) ;
prefsEditor . putInt ( " , number ) ;
prefsEditor . putInt ( " , Integer . parseInt ( number_spinner . getSelectedItem ( ) != null ? number_spinner . getSelectedItem ( ) . toString ( ) : " ) ) ;
prefsEditor . putLong ( LoginActivity . LOGOUTTIME , logoutTime ) ;
prefsEditor . commit ( ) ;
}
}
package com . mms . mcm . activities ;
import java . util . List ;
import org . ksoap2 . serialization . SoapObject ;
import android . app . Activity ;
import android . app . Dialog ;
import android . app . ProgressDialog ;
import android . content . DialogInterface ;
import android . content . DialogInterface . OnCancelListener ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . WindowManager ;
import android . widget . ImageView ;
import android . widget . ListView ;
import android . widget . TextView ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . BookSearchAdapter ;
import com . mms . mcm . custom . Constants ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
import com . mms . mcm . model . BookSearchResponse ;
import com . mms . mcm . model . Books ;
import com . mms . mcm . network . NetworkCallback ;
import com . mms . mcm . network . Parser ;
import com . mms . mcm . network . SoapServiceManager ;
public class BooksOnPossessionActivity extends Activity {
protected static final String TAG = null ;
private AuthenticateResponse authenticateResponse ;
private ListView listview ;
private TextView studentName ;
private TextView campusName ;
private ImageView logo ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_books_in_possession ) ;
initializeviews ( ) ;
getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_STATE_ALWAYS_HIDDEN ) ;
MihirApp app = ( MihirApp ) getApplication ( ) ;
authenticateResponse = app . getCurUserInfo ( ) ;
Utils . setActionBar ( campusName , studentName , authenticateResponse , null ) ;
SoapServiceManager manager = SoapServiceManager . getInstance ( BooksOnPossessionActivity . this ) ;
showDialog ( Constants . PROGRESSDIALOG ) ;
manager . sendBooksOnPossessionRequest ( authenticateResponse . getStudent_ID ( ) , callback ) ;
}
private void initializeviews ( ) {
listview = ( ListView ) findViewById ( R . id . books_possession_listview ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
}
final NetworkCallback < Object > callback = new NetworkCallback < Object > ( ) {
public void onSuccess ( Object responseObj ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
List < Books > booksList ;
try {
SoapObject responceObject = ( SoapObject ) responseObj ;
BookSearchResponse response = Parser
. parseBookSearchResponse ( responceObject ) ;
if ( response . getErrorMsg ( ) . trim ( ) . equals ( " ) ) {
booksList = response . getBooksList ( ) ;
if ( booksList != null && booksList . size ( ) > <num> ) {
listview . setAdapter ( new BookSearchAdapter ( BooksOnPossessionActivity . this ,  <num> , booksList , " ) ) ;
}
} else {
Utils . showDialog ( response . getErrorMsg ( ) ,
BooksOnPossessionActivity . this , true ) ;
}
} catch ( ClassCastException cce ) {
Utils . showToast ( " ,
BooksOnPossessionActivity . this ) ;
Log . v ( TAG , cce . getMessage ( ) ) ;
}
}
public void onFailure ( String errorMessge ) {
removeDialog ( Constants . PROGRESSDIALOG ) ;
Utils . showToast ( " ,
BooksOnPossessionActivity . this ) ;
}
} ;
@Override
protected Dialog onCreateDialog ( int id ) {
switch ( id ) {
case Constants . PROGRESSDIALOG :
final ProgressDialog progressDialog = new ProgressDialog (
BooksOnPossessionActivity . this ) ;
progressDialog . setMessage ( " ) ;
progressDialog . show ( ) ;
progressDialog . setOnCancelListener ( new OnCancelListener ( ) {
@Override
public void onCancel ( DialogInterface dialog ) {
if ( ! progressDialog . isShowing ( ) ) {
progressDialog . show ( ) ;
}
}
} ) ;
return progressDialog ;
default :
break ;
}
return super . onCreateDialog ( id ) ;
}
}
package com . mms . mcm . model ;
import java . util . ArrayList ;
import java . util . List ;
import android . os . Parcel ;
import android . os . Parcelable ;
public class Projects implements Parcelable {
private String Semister_Name ;
private String Course_Code ;
private String Course_Name ;
private String Course_Grade ;
private String Notification_Id ;
private String Notifications_Type ;
private String Notifications_Title ;
private String Notifications_DueTime ;
private String Notifications_Details ;
private String Notifications_Comments ;
public String getSemister_Name ( ) {
return Semister_Name ;
}
public void setSemister_Name ( String semisterName ) {
Semister_Name = semisterName ;
}
public String getCourse_Code ( ) {
return Course_Code ;
}
public void setCourse_Code ( String courseCode ) {
Course_Code = courseCode ;
}
public String getCourse_Name ( ) {
return Course_Name ;
}
public void setCourse_Name ( String courseName ) {
Course_Name = courseName ;
}
public String getCourse_Grade ( ) {
return Course_Grade ;
}
public void setCourse_Grade ( String courseGrade ) {
Course_Grade = courseGrade ;
}
public String getNotification_Id ( ) {
return Notification_Id ;
}
public void setNotification_Id ( String notificationId ) {
Notification_Id = notificationId ;
}
public String getNotifications_Type ( ) {
return Notifications_Type ;
}
public void setNotifications_Type ( String notificationsType ) {
Notifications_Type = notificationsType ;
}
public String getNotifications_Title ( ) {
return Notifications_Title ;
}
public void setNotifications_Title ( String notificationsTitle ) {
Notifications_Title = notificationsTitle ;
}
public String getNotifications_DueTime ( ) {
return Notifications_DueTime ;
}
public void setNotifications_DueTime ( String notificationsDueTime ) {
Notifications_DueTime = notificationsDueTime ;
}
public String getNotifications_Details ( ) {
return Notifications_Details ;
}
public void setNotifications_Details ( String notificationsDetails ) {
Notifications_Details = notificationsDetails ;
}
public String getNotifications_Comments ( ) {
return Notifications_Comments ;
}
public void setNotifications_Comments ( String notificationsComments ) {
Notifications_Comments = notificationsComments ;
}
@Override
public String toString ( ) {
return Notifications_Title ;
}
public Projects ( )
{
}
@Override
public void writeToParcel ( Parcel dest , int flags ) {
List < String > ll = new ArrayList < String > ( ) ;
ll . add ( this . Course_Code ) ;
ll . add ( this . Course_Grade ) ;
ll . add ( this . Course_Name ) ;
ll . add ( this . Notification_Id ) ;
ll . add ( this . Notifications_Comments ) ;
ll . add ( this . Notifications_Details ) ;
ll . add ( this . Notifications_DueTime ) ;
ll . add ( this . Notifications_Title ) ;
ll . add ( this . Notifications_Type ) ;
ll . add ( this . Semister_Name ) ;
dest . writeStringList ( ll ) ;
}
public Projects ( Parcel parcel ) {
List < String > list1 = new ArrayList < String > ( ) ;
parcel . <unk> ( list1 ) ;
this . Course_Code = list1 . get ( <num> ) ;
this . Course_Grade = list1 . get ( <num> ) ;
this . Course_Name = list1 . get ( <num> ) ;
this . Notification_Id = list1 . get ( <num> ) ;
this . Notifications_Comments = list1 . get ( <num> ) ;
this . Notifications_Details = list1 . get ( <num> ) ;
this . Notifications_DueTime = list1 . get ( <num> ) ;
this . Notifications_Title = list1 . get ( <num> ) ;
this . Notifications_Type = list1 . get ( <num> ) ;
this . Semister_Name = list1 . get ( <num> ) ;
}
public static final Creator < Projects > CREATOR = new Creator < Projects > ( ) {
public Projects createFromParcel ( Parcel source ) {
return new Projects ( source ) ;
}
public Projects [ ] newArray ( int size ) {
return new Projects [ size ] ;
}
} ;
public static Creator < Projects > <unk> ( ) {
return CREATOR ;
}
public int describeContents ( ) {
return <num> ;
}
}
package com . mms . mcm . activities ;
import android . app . Activity ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . net . Uri ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . ImageView ;
import android . widget . TextView ;
import com . mms . mcm . R ;
import com . mms . mcm . custom . Utils ;
import com . mms . mcm . model . AuthenticateResponse ;
public class HomeActivity extends Activity implements OnClickListener {
private static final String TAG = " ;
private TextView campusName ;
private ImageView logo ;
private Button singout ;
private MihirApp app ;
private AuthenticateResponse curUser ;
private TextView studentName ;
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . layout_home ) ;
app = ( MihirApp ) getApplication ( ) ;
curUser = app . getCurUserInfo ( ) ;
initViews ( ) ;
Utils . setActionBar ( campusName , null , curUser , logo ) ;
try {
Log . v ( TAG , curUser . getStudent_ID ( ) ) ;
}
catch ( Exception e ) {
Log . v ( TAG , " ) ;
}
}
private void initViews ( ) {
findViewById ( R . id . home_tv_grades ) . setOnClickListener (
HomeActivity . this ) ;
findViewById ( R . id . home_tv_homework_projects ) . setOnClickListener (
HomeActivity . this ) ;
findViewById ( R . id . home_tv_library ) . setOnClickListener (
HomeActivity . this ) ;
findViewById ( R . id . home_tv_notifications ) . setOnClickListener (
HomeActivity . this ) ;
findViewById ( R . id . home_tv_myaccount ) . setOnClickListener (
HomeActivity . this ) ;
findViewById ( R . id . home_tv_complaint_cell ) . setOnClickListener (
HomeActivity . this ) ;
findViewById ( R . id . mms_ad_image ) . setOnClickListener ( this ) ;
singout = ( Button ) findViewById ( R . id . action_bar_signout ) ;
singout . setVisibility ( View . VISIBLE ) ;
singout . setText ( " ) ;
singout . setOnClickListener ( HomeActivity . this ) ;
studentName = ( TextView ) findViewById ( R . id . action_bar_tv_patient_name ) ;
campusName = ( TextView ) findViewById ( R . id . action_tv_hospital_name ) ;
logo = ( ImageView ) findViewById ( R . id . school_logo ) ;
}
public void onClick ( View v ) {
switch ( v . getId ( ) ) {
case R . id . home_tv_grades :
startActivity ( new Intent ( HomeActivity . this ,
GradesActivity . class ) ) ;
break ;
case R . id . home_tv_homework_projects :
startActivity ( new Intent ( HomeActivity . this , HomeWorkProjectsActivity . class ) ) ;
break ;
case R . id . home_tv_notifications :
startActivity ( new Intent ( HomeActivity . this ,
NotificationsActivity . class ) ) ;
break ;
case R . id . home_tv_library :
startActivity ( new Intent ( HomeActivity . this , LibraryActivity . class ) ) ;
break ;
case R . id . home_tv_myaccount :
startActivity ( new Intent ( HomeActivity . this , MyAccountActivity . class ) ) ;
break ;
case R . id . home_tv_complaint_cell :
startActivity ( new Intent ( HomeActivity . this , ComplaintCellActivity . class ) ) ;
break ;
case R . id . action_bar_signout :
clearPreferences ( ) ;
app . setCurUserInfo ( null ) ;
app . setIsloggedin ( false ) ;
Intent intent = new Intent ( HomeActivity . this , LoginActivity . class ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
startActivity ( intent ) ;
finish ( ) ;
break ;
case R . id . mms_ad_image :
startActivity ( new Intent ( Intent . ACTION_VIEW , Uri
. parse ( " ) ) ) ;
break ;
default :
break ;
}
}
private void clearPreferences ( ) {
LoginActivity . mMyPrefs = this . getSharedPreferences ( " ,
MODE_WORLD_WRITEABLE ) ;
SharedPreferences . Editor prefsEditor = LoginActivity . mMyPrefs . edit ( ) ;
prefsEditor . putLong ( LoginActivity . LOGOUTTIME , <num> ) ;
prefsEditor . putString ( " , " ) ;
prefsEditor . remove ( " ) ;
prefsEditor . commit ( ) ;
}
protected void onRestart ( ) {
Log . v ( TAG , " ) ;
super . onRestart ( ) ;
}
@Override
protected void onResume ( ) {
Log . v ( TAG , " ) ;
super . onResume ( ) ;
}
protected void onStart ( ) {
Log . v ( TAG , " ) ;
super . onStart ( ) ;
}
@Override
protected void onPause ( ) {
Log . v ( TAG , " ) ;
super . onPause ( ) ;
}
package com . mms . mcm . custom ;
import java . util . List ;
import android . content . Context ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . ArrayAdapter ;
import android . widget . TextView ;
import com . mms . mcm . R ;
import com . mms . mcm . model . Projects ;
public class HomeWorksAdapter extends ArrayAdapter < Projects > {
private static final String TAG = " ;
private List < Projects > items ;
private LayoutInflater inflater ;
public HomeWorksAdapter ( Context context , int textViewResourceId ,
List < Projects > items ) {
super ( context , textViewResourceId , items ) ;
this . items = items ;
inflater = LayoutInflater . from ( context ) ;
}
public int getCount ( ) {
return items . size ( ) ;
}
public long getItemId ( int position ) {
return position ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
ViewHolder holder ;
if ( convertView == null ) {
convertView = inflater . inflate ( R . layout . home_work_projects_list_layout ,
null ) ;
holder = new ViewHolder ( ) ;
holder . course_code = ( TextView ) convertView
. findViewById ( R . id . projects_course_code ) ;
holder . date = ( TextView ) convertView . findViewById ( R . id . projects_due_date ) ;
convertView . setTag ( holder ) ;
} else {
holder = ( ViewHolder ) convertView . getTag ( ) ;
}
Projects projects = getItem ( position ) ;
holder . course_code . setText ( projects . getCourse_Code ( ) ) ;
holder . date . setText ( " + projects . getNotifications_DueTime ( ) ) ;
return convertView ;
}
@Override
public Projects getItem ( int position ) {
return items . get ( position ) ;
}
private static class ViewHolder {
private TextView date ;
private TextView course_code ;
}
}
package com . mms . mcm . model ;
import org . ksoap2 . serialization . SoapObject ;
public class Course {
private String courseCode ;
private String courseName ;
private String courseGrade ;
public Course ( SoapObject object ) {
if ( object != null ) {
courseCode = object . hasProperty ( " ) ? object . getPropertyAsString ( " ) : " ;
courseName = object . hasProperty ( " ) ? object . getPropertyAsString ( " ) : " ;
courseGrade = object . hasProperty ( " ) ? object . getPropertyAsString ( " ) : " ;
}
}
public String getCourseCode ( ) {
return courseCode ;
}
public void <unk> ( String courseCode ) {
this . courseCode = courseCode ;
}
public String getCourseName ( ) {
return courseName ;
}
public void <unk> ( String courseName ) {
this . courseName = courseName ;
}
public String getCourseGrade ( ) {
return courseGrade ;
}
public void <unk> ( String courseGrade ) {
this . courseGrade = courseGrade ;
}
}
package org . kakavip ;
import java . io . File ;
public class Utils {
public final static String jpeg = " ;
public final static String jpg = " ;
public final static String <unk> = " ;
public final static String tiff = " ;
public final static String tif = " ;
public final static String png = " ;
public static String getExtension ( File f ) {
String ext = null ;
String s = f . getName ( ) ;
int i = s . lastIndexOf ( .' ) ;
if ( i > <num> && i < s . length ( )  <num> ) {
ext = s . substring ( i + <num> ) . toLowerCase ( ) ;
}
return ext ;
}
public static boolean isWindows ( ) {
String os = System . getProperty ( " ) . toLowerCase ( ) ;
return ( os . indexOf ( " ) >= <num> ) ;
}
public static boolean isMac ( ) {
String os = System . getProperty ( " ) . toLowerCase ( ) ;
return ( os . indexOf ( " ) >= <num> ) ;
}
public static boolean isUnix ( ) {
String os = System . getProperty ( " ) . toLowerCase ( ) ;
return ( os . indexOf ( " ) >= <num> || os . indexOf ( " ) >= <num> ) ;
}
}
package org . kakavip ;
import java . io . File ;
import javax . swing . filechooser . FileFilter ;
public class ImageFilter extends FileFilter {
public boolean accept ( File f ) {
if ( f . isDirectory ( ) ) {
return true ;
}
String extension = Utils . getExtension ( f ) ;
if ( extension != null ) {
if ( extension . equals ( Utils . tiff ) ||
extension . equals ( Utils . tif ) ||
extension . equals ( Utils . jpeg ) ||
extension . equals ( Utils . jpg ) ||
extension . equals ( Utils . png ) ) {
return true ;
} else {
return false ;
}
}
return false ;
}
public String getDescription ( ) {
return " ;
}
package org . kakavip ;
import java . awt . Color ;
import java . awt . EventQueue ;
import java . awt . Font ;
import java . awt . List ;
import java . awt . Toolkit ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import java . awt . event . MouseAdapter ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseListener ;
import java . awt . image . BufferedImage ;
import java . io . File ;
import java . io . IOException ;
import javax . imageio . ImageIO ;
import javax . swing . JButton ;
import javax . swing . JCheckBox ;
import javax . swing . JFileChooser ;
import javax . swing . JFrame ;
import javax . swing . JLabel ;
import javax . swing . JProgressBar ;
import javax . swing . JTextField ;
import javax . swing . SwingConstants ;
import javax . swing . SwingWorker ;
public class Main {
private JFrame frmSpriteSheetMaker ;
private int rows ;
private int cols ;
private int padding ;
private int chunks ;
private int chunkWidth , chunkHeight ;
private int type ;
private List list ;
private JFileChooser jFile ;
private Task task ;
private String baseDir = " , saveDir = " ;
private JButton btn_make ;
private JProgressBar progressBar ;
private JTextField txt_filesave ;
private JTextField txt_cols ;
private JTextField txt_rows ;
private JTextField txt_padding ;
private JCheckBox cb_automatrix ;
private BufferedImage finalImg ;
private JTextField txt_width ;
private JTextField txt_height ;
public static void main ( String [ ] args ) {
EventQueue . invokeLater ( new Runnable ( ) {
public void run ( ) {
try {
Main window = new Main ( ) ;
window . frmSpriteSheetMaker . setVisible ( true ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
} ) ;
}
public Main ( ) {
initialize ( ) ;
}
protected void setStatus ( String mStatus ) {
frmSpriteSheetMaker . setTitle ( " + mStatus ) ;
}
class Task extends SwingWorker < Void , Void > {
@Override
protected Void doInBackground ( ) throws Exception {
btn_make . setEnabled ( false ) ;
progressBar . setForeground ( Color . decode ( " ) ) ;
getInfo ( ) ;
return null ;
}
@Override
protected void done ( ) {
btn_make . setEnabled ( true ) ;
setStatus ( " ) ;
}
}
private void getInfo ( ) {
chunks = list . getItemCount ( ) ;
String OS = " ;
if ( Utils . isWindows ( ) ) {
System . out . println ( " ) ;
OS = " ;
} else if ( Utils . isUnix ( ) ) {
System . out . println ( " ) ;
OS = " ;
}
File [ ] imgFiles = new File [ chunks ] ;
for ( int i = <num> ; i < chunks ; i ++ ) {
imgFiles [ i ] = new File ( baseDir + OS + list . getItem ( i ) . toString ( ) ) ;
System . out . println ( baseDir + OS + list . getItem ( i ) . toString ( ) ) ;
}
BufferedImage [ ] buffImages = new BufferedImage [ chunks ] ;
for ( int i = <num> ; i < chunks ; i ++ ) {
try {
buffImages [ i ] = ImageIO . read ( imgFiles [ i ] ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
type = buffImages [ <num> ] . getType ( ) ;
chunkWidth = buffImages [ <num> ] . getWidth ( ) ;
chunkHeight = buffImages [ <num> ] . getHeight ( ) ;
cols = Integer . parseInt ( txt_cols . getText ( ) . toString ( ) ) ;
rows = Integer . parseInt ( txt_rows . getText ( ) . toString ( ) ) ;
padding = Integer . parseInt ( txt_padding . getText ( ) . toString ( ) ) ;
int fixX = <num> ;
int fixY = <num> ;
if ( cols == <num> ) {
fixX = <num> ;
} else {
fixX = padding * ( cols  <num> ) ;
}
if ( rows == <num> ) {
fixY = <num> ;
} else {
fixY = padding * ( rows  <num> ) ;
}
int maxWidth = chunkWidth * cols + ( padding * <num> * ( cols ) )  fixX ;
int maxHeight = chunkHeight * rows + ( padding * <num> * ( rows ) )  fixY ;
System . out . println ( " + maxWidth + " + maxHeight ) ;
txt_width . setText ( " + getWidthHeight ( maxWidth ) ) ;
txt_height . setText ( " + getWidthHeight ( maxHeight ) ) ;
finalImg = new BufferedImage ( maxWidth , maxHeight , type ) ;
progressBar . setMaximum ( chunks ) ;
System . out . println ( " + chunks ) ;
int num = <num> ;
int <unk> = <num> ;
int <unk> = <num> ;
for ( int i = <num> ; i < rows ; i ++ ) {
for ( int j = <num> ; j < cols ; j ++ ) {
if ( num < list . getItemCount ( ) ) {
finalImg . createGraphics ( ) . drawImage ( buffImages [ num ] , chunkWidth * j + padding * ( j + <num> ) , padding * ( i + <num> ) + chunkHeight * i , null ) ;
System . out . println ( " + num ) ;
num ++ ;
progressBar . setValue ( num ) ;
} else {
break ;
}
}
}
try {
ImageIO . write ( finalImg , " , new File ( txt_filesave . getText ( ) . toString ( ) ) ) ;
} catch ( IOException e ) {
progressBar . setForeground ( Color . decode ( " ) ) ;
}
}
private void autoMatrix ( ) {
if ( cb_automatrix . isSelected ( ) ) {
int r = <num> ;
int c = <num> ;
double s = Math . sqrt ( list . getItemCount ( ) ) ;
r = ( int ) Math . round ( s ) ;
c = ( int ) Math . ceil ( s ) ;
txt_rows . setText ( " + r ) ;
txt_cols . setText ( " + c ) ;
}
}
private void initialize ( ) {
frmSpriteSheetMaker = new JFrame ( ) ;
frmSpriteSheetMaker . setResizable ( false ) ;
frmSpriteSheetMaker . setIconImage ( Toolkit . getDefaultToolkit ( ) . getImage ( " ) ) ;
frmSpriteSheetMaker . setTitle ( " ) ;
frmSpriteSheetMaker . getContentPane ( ) . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
frmSpriteSheetMaker . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
frmSpriteSheetMaker . getContentPane ( ) . setLayout ( null ) ;
txt_filesave = new JTextField ( ) ;
txt_filesave . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
txt_filesave . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
txt_filesave . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( txt_filesave ) ;
txt_filesave . setColumns ( <num> ) ;
JButton btn_Browser = new JButton ( " ) ;
btn_Browser . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
btn_Browser . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
btn_Browser . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( btn_Browser ) ;
btn_Browser . addActionListener ( new ActionListener ( ) {
@Override
public void actionPerformed ( ActionEvent arg0 ) {
saveFiles ( ) ;
}
} ) ;
JLabel lblCollum = new JLabel ( " ) ;
lblCollum . setFont ( new Font ( " , Font . BOLD , <num> ) ) ;
lblCollum . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
lblCollum . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( lblCollum ) ;
txt_cols = new JTextField ( ) ;
txt_cols . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
txt_cols . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
txt_cols . setText ( " ) ;
txt_cols . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( txt_cols ) ;
txt_cols . setColumns ( <num> ) ;
JLabel lblRows = new JLabel ( " ) ;
lblRows . setFont ( new Font ( " , Font . BOLD , <num> ) ) ;
lblRows . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
lblRows . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( lblRows ) ;
txt_rows = new JTextField ( ) ;
txt_rows . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
txt_rows . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
txt_rows . setText ( " ) ;
txt_rows . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( txt_rows ) ;
txt_rows . setColumns ( <num> ) ;
JLabel lblPadding = new JLabel ( " ) ;
lblPadding . setFont ( new Font ( " , Font . BOLD , <num> ) ) ;
lblPadding . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
lblPadding . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( lblPadding ) ;
txt_padding = new JTextField ( ) ;
txt_padding . setText ( " ) ;
txt_padding . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
txt_padding . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
txt_padding . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( txt_padding ) ;
txt_padding . setColumns ( <num> ) ;
JButton btn_Open = new JButton ( " ) ;
btn_Open . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
btn_Open . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
btn_Open . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( btn_Open ) ;
btn_Open . addActionListener ( new ActionListener ( ) {
@Override
public void actionPerformed ( ActionEvent arg0 ) {
openFiles ( ) ;
}
} ) ;
list = new List ( ) ;
list . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
list . <unk> ( false ) ;
list . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
list . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( list ) ;
list . addMouseListener ( new MouseListener ( ) {
@Override
public void mouseReleased ( MouseEvent arg0 ) {
if ( arg0 . isPopupTrigger ( ) ) {
openFiles ( ) ;
}
}
@Override
public void mousePressed ( MouseEvent arg0 ) { }
@Override
public void mouseExited ( MouseEvent arg0 ) { }
@Override
public void mouseEntered ( MouseEvent arg0 ) { }
@Override
public void mouseClicked ( MouseEvent arg0 ) { }
} ) ;
JButton btn_removeOne = new JButton ( " ) ;
btn_removeOne . setToolTipText ( " ) ;
btn_removeOne . setFont ( new Font ( " , Font . PLAIN , <num> ) ) ;
btn_removeOne . addActionListener ( new ActionListener ( ) {
public void actionPerformed ( ActionEvent arg0 ) {
if ( list . getSelectedIndex ( ) >= <num> ) {
System . out . println ( " + list . getSelectedIndex ( ) ) ;
list . remove ( list . getSelectedIndex ( ) ) ;
setStatus ( " + list . getItemCount ( ) + " ) ;
autoMatrix ( ) ;
}
}
} ) ;
btn_removeOne . setHorizontalAlignment ( SwingConstants . LEFT ) ;
btn_removeOne . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
btn_removeOne . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
btn_removeOne . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( btn_removeOne ) ;
JButton btn_removeAll = new JButton ( " ) ;
btn_removeAll . setFont ( new Font ( " , Font . PLAIN , <num> ) ) ;
btn_removeAll . addActionListener ( new ActionListener ( ) {
public void actionPerformed ( ActionEvent e ) {
list . removeAll ( ) ;
setStatus ( " ) ;
autoMatrix ( ) ;
}
} ) ;
btn_removeAll . setHorizontalAlignment ( SwingConstants . LEFT ) ;
btn_removeAll . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
btn_removeAll . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
btn_removeAll . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( btn_removeAll ) ;
progressBar = new JProgressBar ( ) ;
progressBar . setBounds ( <num> , <num> , <num> , <num> ) ;
progressBar . setBackground ( Color . BLACK ) ;
progressBar . setForeground ( Color . decode ( " ) ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( progressBar ) ;
btn_make = new JButton ( " ) ;
btn_make . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
btn_make . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
btn_make . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( btn_make ) ;
txt_width = new JTextField ( ) ;
txt_width . setEditable ( false ) ;
txt_width . setBackground ( Color . BLACK ) ;
txt_width . setForeground ( Color . WHITE ) ;
txt_width . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( txt_width ) ;
txt_width . setColumns ( <num> ) ;
JLabel lblWidth = new JLabel ( " ) ;
lblWidth . setFont ( new Font ( " , Font . BOLD , <num> ) ) ;
lblWidth . setForeground ( Color . WHITE ) ;
lblWidth . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( lblWidth ) ;
txt_height = new JTextField ( ) ;
txt_height . setEditable ( false ) ;
txt_height . setForeground ( Color . WHITE ) ;
txt_height . setBackground ( Color . BLACK ) ;
txt_height . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( txt_height ) ;
txt_height . setColumns ( <num> ) ;
JLabel lblHeight = new JLabel ( " ) ;
lblHeight . setFont ( new Font ( " , Font . BOLD , <num> ) ) ;
lblHeight . setForeground ( Color . WHITE ) ;
lblHeight . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( lblHeight ) ;
cb_automatrix = new JCheckBox ( " ) ;
cb_automatrix . setSelected ( true ) ;
cb_automatrix . addMouseListener ( new MouseAdapter ( ) {
@Override
public void mouseClicked ( MouseEvent event ) {
if ( event . getID ( ) == MouseEvent . <unk> ) {
if ( cb_automatrix . isSelected ( ) ) {
cb_automatrix . setSelected ( false ) ;
txt_rows . setEditable ( true ) ;
txt_cols . setEditable ( true ) ;
} else {
cb_automatrix . setSelected ( true ) ;
txt_rows . setEditable ( false ) ;
txt_cols . setEditable ( false ) ;
}
}
}
} ) ;
cb_automatrix . setForeground ( Color . WHITE ) ;
cb_automatrix . setBackground ( Color . BLACK ) ;
cb_automatrix . setBounds ( <num> , <num> , <num> , <num> ) ;
frmSpriteSheetMaker . getContentPane ( ) . add ( cb_automatrix ) ;
btn_make . addActionListener ( new ActionListener ( ) {
@Override
public void actionPerformed ( ActionEvent arg0 ) {
if ( txt_filesave . getText ( ) . equals ( " ) ) {
setStatus ( " ) ;
btn_make . setForeground ( Color . decode ( " ) ) ;
} else if (
Integer . parseInt ( txt_cols . getText ( ) . toString ( ) ) >= <num> && Integer . parseInt ( txt_rows . getText ( ) . toString ( ) ) >= <num>
&& Integer . parseInt ( txt_cols . getText ( ) . toString ( ) ) <= <num> && Integer . parseInt ( txt_rows . getText ( ) . toString ( ) ) <= <num> ) {
setStatus ( " ) ;
btn_make . setForeground ( Color . decode ( " ) ) ;
} else if ( list . getItemCount ( ) <= <num> ) {
setStatus ( " ) ;
btn_make . setForeground ( Color . decode ( " ) ) ;
} else {
btn_make . setForeground ( Color . decode ( " ) ) ;
task = new Task ( ) ;
task . execute ( ) ;
}
}
} ) ;
}
private void openFiles ( ) {
jFile = new JFileChooser ( ) ;
jFile . setFileFilter ( new ImageFilter ( ) ) ;
jFile . setAcceptAllFileFilterUsed ( false ) ;
jFile . setMultiSelectionEnabled ( true ) ;
ImagePreviewPanel preview = new ImagePreviewPanel ( ) ;
jFile . <unk> ( preview ) ;
jFile . addPropertyChangeListener ( preview ) ;
try {
jFile . setCurrentDirectory ( new File ( baseDir ) ) ;
} catch ( Exception e2 ) {
}
int returnVal = jFile . showOpenDialog ( null ) ;
if ( returnVal == JFileChooser . APPROVE_OPTION ) {
File files [ ] = jFile . <unk> ( ) ;
baseDir = jFile . getCurrentDirectory ( ) . toString ( ) ;
System . out . println ( " + baseDir ) ;
for ( int i = <num> ; i < files . length ; i ++ ) {
list . add ( files [ i ] . getName ( ) , list . getItemCount ( ) + i ) ;
}
setStatus ( " + list . getItemCount ( ) + " ) ;
autoMatrix ( ) ;
}
System . out . println ( " ) ;
}
private void saveFiles ( ) {
JFileChooser jFilesave = new JFileChooser ( ) ;
jFilesave . setFileFilter ( new ImageFilter ( ) ) ;
jFilesave . setAcceptAllFileFilterUsed ( false ) ;
jFilesave . setMultiSelectionEnabled ( true ) ;
if ( saveDir . equals ( " ) ) {
saveDir = baseDir ;
}
try {
jFilesave . setCurrentDirectory ( new File ( saveDir ) ) ;
} catch ( Exception e2 ) { }
int returnVal = jFilesave . showSaveDialog ( null ) ;
if ( returnVal == JFileChooser . APPROVE_OPTION ) {
saveDir = jFilesave . getCurrentDirectory ( ) . toString ( ) ;
txt_filesave . setText ( jFilesave . getSelectedFile ( ) . toString ( ) + " ) ;
}
System . out . println ( " ) ;
}
private int getWidthHeight ( int nV ) {
int nReturn = <num> ;
int nValue = <num> ;
while ( true ) {
if ( nValue >= nV ) {
nReturn = nValue ;
break ;
}
nValue *= <num> ;
}
return nReturn ;
}
}
package org . kakavip ;
import java . awt . Color ;
import java . awt . Dimension ;
import java . awt . Graphics ;
import java . awt . Image ;
import java . beans . PropertyChangeEvent ;
import java . beans . PropertyChangeListener ;
import java . io . File ;
import javax . swing . ImageIcon ;
import javax . swing . JFileChooser ;
import javax . swing . JPanel ;
public class ImagePreviewPanel extends JPanel
implements PropertyChangeListener {
private int width , height ;
private ImageIcon icon ;
private Image image ;
private static final int ACCSIZE = <num> ;
private Color bg ;
public ImagePreviewPanel ( ) {
setPreferredSize ( new Dimension ( ACCSIZE ,  <num> ) ) ;
bg = getBackground ( ) ;
}
public void propertyChange ( PropertyChangeEvent e ) {
String propertyName = e . getPropertyName ( ) ;
if ( propertyName . equals ( JFileChooser . <unk> ) ) {
File selection = ( File ) e . getNewValue ( ) ;
String name ;
if ( selection == null )
return ;
else
name = selection . getAbsolutePath ( ) ;
if ( ( name != null ) &&
name . toLowerCase ( ) . endsWith ( " ) ||
name . toLowerCase ( ) . endsWith ( " ) ||
name . toLowerCase ( ) . endsWith ( " ) ||
name . toLowerCase ( ) . endsWith ( " ) ) {
icon = new ImageIcon ( name ) ;
image = icon . getImage ( ) ;
scaleImage ( ) ;
repaint ( ) ;
}
}
}
private void scaleImage ( ) {
width = image . getWidth ( this ) ;
height = image . getHeight ( this ) ;
double ratio = <num> ;
if ( width >= height ) {
ratio = ( double ) ( ACCSIZE  <num> ) / width ;
width = ACCSIZE  <num> ;
height = ( int ) ( height * ratio ) ;
}
else {
if ( getHeight ( ) > <num> ) {
ratio = ( double ) ( ACCSIZE  <num> ) / height ;
height = ACCSIZE  <num> ;
width = ( int ) ( width * ratio ) ;
}
else {
ratio = ( double ) getHeight ( ) / height ;
height = getHeight ( ) ;
width = ( int ) ( width * ratio ) ;
}
}
image = image . getScaledInstance ( width , height , Image . <unk> ) ;
}
public void paintComponent ( Graphics g ) {
g . setColor ( bg ) ;
g . fillRect ( <num> , <num> , ACCSIZE , getHeight ( ) ) ;
g . drawImage ( image , getWidth ( ) / <num>  width / <num> + <num> ,
getHeight ( ) / <num>  height / <num> , this ) ;
}
}
package com . ibm . library . beans ;
import java . io . Serializable ;
import java . util . Collection ;
import com . ibm . ils . library . model . LoanedCopy ;
public class LoanedCopyListBean implements Serializable {
private static final long serialVersionUID = <num> ;
private Collection < LoanedCopy > loanedCopyList ;
public LoanedCopyListBean ( ) { }
public Collection < LoanedCopy > getLoanedCopyList ( ) {
return loanedCopyList ;
}
public void setLoanedCopyList ( Collection < LoanedCopy > loanedCopyList ) {
this . loanedCopyList = loanedCopyList ;
}
}
package com . ibm . library . servlets ;
import java . io . IOException ;
import java . text . DateFormat ;
import java . text . ParseException ;
import java . text . SimpleDateFormat ;
import java . util . Date ;
import javax . servlet . ServletContext ;
import javax . servlet . ServletException ;
import javax . servlet . annotation . WebServlet ;
import javax . servlet . http . HttpServlet ;
import javax . servlet . http . HttpServletRequest ;
import javax . servlet . http . HttpServletResponse ;
import javax . servlet . http . HttpSession ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Item ;
import com . ibm . ils . library . model . exceptions . ItemExists ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
<unk>
public class AddItem extends HttpServlet {
private static final long serialVersionUID = <num> ;
public AddItem ( ) {
super ( ) ;
}
protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
ServletContext context = getServletContext ( ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
HttpSession session = request . getSession ( false ) ;
String title = request . getParameter ( " ) ;
if ( title . equals ( " ) || title == null ) {
showErrorMessage ( " , request , response ) ;
return ;
}
String author = request . getParameter ( " ) ;
if ( author . equals ( " ) || author == null ) {
showErrorMessage ( " , request , response ) ;
return ;
}
String dateString = request . getParameter ( " ) ;
DateFormat formatter = new SimpleDateFormat ( " ) ;
Date date = null ;
try {
date = ( Date ) formatter . parse ( dateString ) ;
} catch ( ParseException e ) {
showErrorMessage ( " , request , response ) ;
return ;
}
char type = request . getParameter ( " ) . charAt ( <num> ) ;
String oversize = request . getParameter ( " ) ;
int number = <num> ;
if ( ! request . getParameter ( " ) . equals ( " ) ) {
try {
number = Integer . parseInt ( request . getParameter ( " ) ) ;
} catch ( NumberFormatException e ) {
showErrorMessage ( " , request , response ) ;
return ;
}
}
String isbn = request . getParameter ( " ) ;
if ( isbn . equals ( " ) || isbn == null ) {
showErrorMessage ( " , request , response ) ;
return ;
}
Item item = new Item ( ) ;
item . setTitle ( title ) ;
item . setAuthor ( author ) ;
item . setPublished ( date ) ;
item . setVolume ( number ) ;
item . setMedium ( type ) ;
if ( oversize == null ) {
item . setOversize ( false ) ;
} else {
item . setOversize ( true ) ;
}
item . setIsbnEquivalent ( isbn ) ;
try {
item . add ( ) ;
session . setAttribute ( " , " ) ;
response . sendRedirect ( " ) ;
} catch ( SystemUnavailableException e ) {
showErrorMessage ( " , request , response ) ;
} catch ( OperationFailed e ) {
showErrorMessage ( " , request , response ) ;
} catch ( ItemExists e ) {
showErrorMessage ( " , request , response ) ;
}
}
private void showErrorMessage ( String message , HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
ServletContext context = getServletContext ( ) ;
request . setAttribute ( " , message ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
}
package com . ibm . ils . library . model . exceptions ;
public class PatronNotFound extends Exception {
private static final long serialVersionUID =  <num> ;
public PatronNotFound ( int id ) {
super ( " + id + " ) ;
}
public PatronNotFound ( String email ) {
super ( " + email + " ) ;
}
}
package com . ibm . ils . library . datastore . util ;
import java . sql . Connection ;
import java . sql . ResultSet ;
import java . sql . SQLException ;
import java . sql . Statement ;
public class DAOUtil {
public static void close ( ResultSet rs , Statement ps , Connection conn ) {
if ( rs != null ) {
try {
rs . close ( ) ;
} catch ( SQLException e ) {
}
}
if ( ps != null ) {
try {
ps . close ( ) ;
} catch ( SQLException e ) {
}
}
if ( conn != null ) {
try {
conn . close ( ) ;
} catch ( SQLException e ) {
}
}
}
}
package com . ibm . ils . library . model . exceptions ;
public class CopyNotFound extends Exception {
private static final long serialVersionUID =  <num> ;
public CopyNotFound ( int itemId , int copyNumber ) {
super ( " + itemId + " + copyNumber
+ " ) ;
}
}
package com . ibm . library . servlets ;
import java . io . IOException ;
import java . util . Collection ;
import java . util . Iterator ;
import javax . servlet . ServletContext ;
import javax . servlet . ServletException ;
import javax . servlet . annotation . WebServlet ;
import javax . servlet . http . HttpServlet ;
import javax . servlet . http . HttpServletRequest ;
import javax . servlet . http . HttpServletResponse ;
import javax . servlet . http . HttpSession ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Copy ;
import com . ibm . ils . library . model . LoanedCopy ;
import com . ibm . ils . library . model . Patron ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . PatronNotFound ;
import com . ibm . library . beans . LoanedCopyListBean ;
@WebServlet("/ProcessListItems")
public class ProcessListItems extends HttpServlet {
private static final long serialVersionUID = <num> ;
public ProcessListItems ( ) {
super ( ) ;
}
protected void doGet ( HttpServletRequest request ,
HttpServletResponse response ) throws ServletException , IOException {
HttpSession session = request . getSession ( false ) ;
int patronId = getPatronId ( request , response , session ) ;
if ( patronId ==  <num> ) {
return ;
}
ServletContext context = getServletContext ( ) ;
Collection < LoanedCopy > loanedCopyList = null ;
try {
loanedCopyList = Copy . findLoanedCopiesForPatronId ( patronId ) ;
session . setAttribute ( " , loanedCopyList ) ;
if ( loanedCopyList != null && loanedCopyList . size ( ) != <num> ) {
LoanedCopyListBean bean = new LoanedCopyListBean ( ) ;
bean . setLoanedCopyList ( loanedCopyList ) ;
session . setAttribute ( " , bean ) ;
context . getRequestDispatcher ( " )
. forward ( request , response ) ;
} else {
showErrorMessage ( " , request , response ) ;
}
} catch ( SystemUnavailableException e ) {
showErrorMessage ( " , request , response ) ;
} catch ( OperationFailed e ) {
showErrorMessage ( " , request , response ) ;
}
}
protected int getPatronId ( HttpServletRequest request , HttpServletResponse response , HttpSession session ) throws ServletException , IOException {
try {
return Integer . parseInt ( session . getAttribute ( " ) . toString ( ) ) ;
} catch ( NumberFormatException e ) {
showErrorMessage ( " , request , response ) ;
} catch ( NullPointerException e ) {
showErrorMessage ( " , request , response ) ;
}
return  <num> ;
}
protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
HttpSession session = request . getSession ( false ) ;
String [ ] checkBoxes = request . getParameterValues ( " ) ;
int patronId = getPatronId ( request , response , session ) ;
ServletContext context = getServletContext ( ) ;
Patron patron = null ;
try {
patron = Patron . findById ( patronId ) ;
} catch ( PatronNotFound e ) {
showErrorMessage ( e . getMessage ( ) , request , response ) ;
return ;
} catch ( SystemUnavailableException e ) {
showErrorMessage ( e . getMessage ( ) , request , response ) ;
return ;
} catch ( OperationFailed e ) {
showErrorMessage ( e . getMessage ( ) , request , response ) ;
return ;
}
@SuppressWarnings("unchecked")
Collection < LoanedCopy > loanedCopyList = ( Collection < LoanedCopy > ) session . getAttribute ( " ) ;
if ( checkBoxes != null ) {
for ( String s : checkBoxes ) {
Iterator < LoanedCopy > i = loanedCopyList . iterator ( ) ;
for ( int a = <num> ; a < Integer . parseInt ( s ) ; a ++ ) {
i . next ( ) ;
}
i . next ( ) . setRenewRequest ( true ) ;
}
try {
patron . renew ( loanedCopyList ) ;
session . setAttribute ( " , loanedCopyList ) ;
if ( loanedCopyList != null && loanedCopyList . size ( ) != <num> ) {
LoanedCopyListBean bean = new LoanedCopyListBean ( ) ;
bean . setLoanedCopyList ( loanedCopyList ) ;
session . setAttribute ( " , bean ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
} catch ( OperationFailed e ) {
showErrorMessage ( e . getMessage ( ) , request , response ) ;
} catch ( SystemUnavailableException e ) {
showErrorMessage ( e . getMessage ( ) , request , response ) ;
}
}
}
private void showErrorMessage ( String message , HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
ServletContext context = getServletContext ( ) ;
request . setAttribute ( " , message ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
}
package com . ibm . ils . library . model ;
import java . io . Serializable ;
import java . util . Calendar ;
import java . util . Collection ;
import java . util . Date ;
import com . ibm . ils . library . datastore . CopyDataStore ;
import com . ibm . ils . library . datastore . DataStoreFactory ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . exceptions . CopyExists ;
import com . ibm . ils . library . model . exceptions . CopyNotFound ;
import com . ibm . ils . library . model . exceptions . ItemNotFound ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . PatronNotFound ;
import com . ibm . ils . library . model . exceptions . RenewFailed ;
public class Copy implements Serializable {
private static final long serialVersionUID =  <num> ;
private static final int MAX_TIMES_RENEW = <num> ;
private static final long DAYS_TO_RENEW = <num> ;
private static final long ONE_DAY_MS = <num> * <num> * <num> * <num> ;
private boolean loanable ;
private Date due ;
private int itemId ;
private int patronId ;
private int timesRenewed ;
private int copyNumber ;
private static CopyDataStore datastore ;
static {
datastore = DataStoreFactory . getCopyDataStore ( ) ;
}
public Copy ( ) {
}
public Copy ( boolean loanable , Date due , int itemId , int patronId ,
int timesRenewed , int copyNumber ) {
super ( ) ;
this . loanable = loanable ;
this . due = due ;
this . itemId = itemId ;
this . patronId = patronId ;
this . timesRenewed = timesRenewed ;
this . copyNumber = copyNumber ;
}
public void add ( ) throws SystemUnavailableException , OperationFailed ,
CopyExists {
datastore . add ( this ) ;
}
public static Collection < Copy > findCopiesForItemId ( int id )
throws OperationFailed , SystemUnavailableException {
return datastore . findCopiesForItemId ( id ) ;
}
public static Collection < Copy > findCopiesForPatronId ( int id )
throws SystemUnavailableException , OperationFailed {
return datastore . findCopiesForPatronId ( id ) ;
}
public static Collection < LoanedCopy > findLoanedCopiesForPatronId ( int id )
throws SystemUnavailableException , OperationFailed {
return datastore . findLoanedCopiesForPatronId ( id ) ;
}
public Item getItem ( ) throws SystemUnavailableException , OperationFailed ,
ItemNotFound {
return datastore . getItem ( this ) ;
}
public Patron getPatron ( ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed {
return datastore . getPatron ( this ) ;
}
public void remove ( ) throws OperationFailed , SystemUnavailableException ,
CopyNotFound {
datastore . remove ( this ) ;
}
public void update ( ) throws CopyNotFound , OperationFailed ,
SystemUnavailableException {
datastore . update ( this ) ;
}
public boolean renew ( ) throws CopyNotFound , OperationFailed ,
SystemUnavailableException , RenewFailed {
Date due = getDue ( ) ;
if ( due == null ) {
return false ;
}
Calendar todayCalendar = Calendar . getInstance ( ) ;
Calendar dueCalendar = Calendar . getInstance ( ) ;
dueCalendar . setTime ( due ) ;
int todayYear = todayCalendar . get ( Calendar . YEAR ) ;
int todayDayOfYear = todayCalendar . get ( Calendar . DAY_OF_YEAR ) ;
int dueYear = dueCalendar . get ( Calendar . YEAR ) ;
int dueDayOfYear = dueCalendar . get ( Calendar . DAY_OF_YEAR ) ;
if ( todayYear < dueYear
|| ( todayYear == dueYear && todayDayOfYear <= dueDayOfYear ) ) {
if ( getTimesRenewed ( ) < MAX_TIMES_RENEW ) {
int newTimesRenewed = getTimesRenewed ( ) + <num> ;
java . sql . Date newDueDate = new java . sql . Date ( due . getTime ( )
+ DAYS_TO_RENEW * ONE_DAY_MS ) ;
datastore . renewCopy ( this , newDueDate , newTimesRenewed ) ;
setDue ( new Date ( newDueDate . getTime ( ) ) ) ;
setTimesRenewed ( newTimesRenewed ) ;
} else {
throw new RenewFailed ( " ) ;
}
} else {
throw new RenewFailed ( " ) ;
}
return true ;
}
public boolean isLoanable ( ) {
return loanable ;
}
public void <unk> ( boolean loanable ) {
this . loanable = loanable ;
}
public Date getDue ( ) {
return due ;
}
public void setDue ( Date due ) {
this . due = due ;
}
public int getItemId ( ) {
return itemId ;
}
public void setItemId ( int itemId ) {
this . itemId = itemId ;
}
public int getPatronId ( ) {
return patronId ;
}
public void <unk> ( int patronId ) {
this . patronId = patronId ;
}
public int getTimesRenewed ( ) {
return timesRenewed ;
}
public void setTimesRenewed ( int timesRenewed ) {
this . timesRenewed = timesRenewed ;
}
public int getCopyNumber ( ) {
return copyNumber ;
}
public void setCopyNumber ( int copyNumber ) {
this . copyNumber = copyNumber ;
}
@Override
public String toString ( ) {
return String
. format ( " ,
loanable , due , itemId , patronId , timesRenewed ,
copyNumber ) ;
}
}
package com . ibm . library . servlets ;
import java . io . IOException ;
import javax . servlet . ServletContext ;
import javax . servlet . ServletException ;
import javax . servlet . annotation . WebServlet ;
import javax . servlet . http . HttpServlet ;
import javax . servlet . http . HttpServletRequest ;
import javax . servlet . http . HttpServletResponse ;
import javax . servlet . http . HttpSession ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Patron ;
import com . ibm . ils . library . model . exceptions . InvalidPassword ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . PatronExists ;
@WebServlet("/Register")
public class Register extends HttpServlet {
private static final long serialVersionUID = <num> ;
public Register ( ) {
super ( ) ;
}
protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
ServletContext context = getServletContext ( ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
HttpSession session = request . getSession ( false ) ;
String firstName = request . getParameter ( " ) ;
String lastName = request . getParameter ( " ) ;
String email = request . getParameter ( " ) ;
String password = request . getParameter ( " ) ;
if ( email != " && ( email . indexOf ( " ) ==  <num> || email . indexOf ( " ) ==  <num> ) ) {
showErrorMessage ( " , request , response ) ;
return ;
}
if ( checkValues ( firstName , lastName , email , password ) ) {
Patron p = new Patron ( ) ;
p . setFirstName ( firstName ) ;
p . setLastName ( lastName ) ;
p . setEmail ( email ) ;
p . setPassword ( password ) ;
try {
p . add ( ) ;
session . setAttribute ( " , " ) ;
response . sendRedirect ( " ) ;
} catch ( PatronExists e ) {
showErrorMessage ( " , request , response ) ;
} catch ( SystemUnavailableException e ) {
showErrorMessage ( " , request , response ) ;
} catch ( OperationFailed e ) {
showErrorMessage ( " , request , response ) ;
} catch ( InvalidPassword e ) {
showErrorMessage ( e . getMessage ( ) , request , response ) ;
}
} else {
showErrorMessage ( " , request , response ) ;
}
}
private boolean checkValues ( String firstName , String lastName , String email , String password ) {
if ( firstName == null || firstName . equals ( " ) ) {
return false ;
}
else if ( lastName == null || lastName . equals ( " ) ) {
return false ;
}
else if ( email == null || email . equals ( " ) ) {
return false ;
}
else if ( password == null || password . equals ( " ) ) {
return false ;
}
return true ;
}
private void showErrorMessage ( String message , HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
ServletContext context = getServletContext ( ) ;
request . setAttribute ( " , message ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
}
package com . ibm . ils . library . model . exceptions ;
public class DAOException extends Exception {
private static final long serialVersionUID = <num> ;
public DAOException ( ) {
}
public DAOException ( String message ) {
super ( message ) ;
}
}
package com . ibm . ils . library . datastore ;
import java . sql . Connection ;
import java . sql . Driver ;
import java . sql . DriverManager ;
import java . sql . SQLException ;
import java . util . Properties ;
public class DriverManagerConnection implements BuildConnection {
private String databaseURL ;
private Properties info ;
public DriverManagerConnection ( Driver driver , String databaseURL ,
Properties info ) throws SQLException {
this . databaseURL = databaseURL ;
this . info = info ;
DriverManager . registerDriver ( driver ) ;
}
@Override
public Connection getConnection ( ) throws SQLException {
return DriverManager . getConnection ( databaseURL , info ) ;
}
}
package com . ibm . ils . library . datastore ;
import java . sql . Connection ;
import java . sql . SQLException ;
public interface BuildConnection {
public Connection getConnection ( ) throws SQLException ;
}
package com . ibm . ils . library . datastore . util ;
import java . util . Random ;
public class LibraryIdGenerator {
private static Random r = new Random ( ) ;
public static int generateId ( ) {
return r . nextInt ( Integer . MAX_VALUE  <num> ) + <num> ;
}
}
package com . ibm . ils . library . datastore ;
import java . sql . Connection ;
import java . sql . Driver ;
import java . sql . SQLException ;
import java . util . Properties ;
public class ConnectionFactory {
private BuildConnection connection ;
public ConnectionFactory ( Driver driver , String databaseURL ,
Properties info ) throws SQLException {
this . connection = new DriverManagerConnection ( driver , databaseURL ,
info ) ;
}
public ConnectionFactory ( String ctxFactory , String dataSource , Properties info ) {
this . connection = new DataSourceConnection ( ctxFactory , dataSource , info ) ;
}
public Connection getConnection ( ) throws SQLException {
return connection . getConnection ( ) ;
}
}
package com . ibm . ils . library . model . exceptions ;
public class InvalidPassword extends Exception {
private static final long serialVersionUID =  <num> ;
public InvalidPassword ( String message ) {
super ( message ) ;
}
}
package com . ibm . ils . library . datastore . jdbc ;
import java . sql . Connection ;
import java . sql . PreparedStatement ;
import java . sql . ResultSet ;
import java . sql . SQLException ;
import java . util . Collection ;
import com . ibm . ils . library . datastore . ConnectionFactory ;
import com . ibm . ils . library . datastore . CopyDataStore ;
import com . ibm . ils . library . datastore . DataStoreFactory ;
import com . ibm . ils . library . datastore . PatronDataStore ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Copy ;
import com . ibm . ils . library . model . LoanedCopy ;
import com . ibm . ils . library . model . Patron ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . PatronExists ;
import com . ibm . ils . library . model . exceptions . PatronNotFound ;
import static com . ibm . ils . library . datastore . util . DAOUtil . close ;
public class PatronDataStoreJDBC implements PatronDataStore {
private ConnectionFactory factory ;
private static final String SQL_ADD = " ;
private static final String SQL_FIND_BY_EMAIL = " ;
private static final String SQL_FIND_BY_ID = " ;
private static final String SQL_REMOVE = " ;
private static final String SQL_UPDATE = " ;
private static final String SQLSTATE_ALREADY_EXISTS = " ;
public PatronDataStoreJDBC ( ConnectionFactory factory ) {
this . factory = factory ;
}
@Override
public void add ( Patron patron ) throws PatronExists ,
SystemUnavailableException , OperationFailed {
Connection connection = null ;
PreparedStatement statementInsert = null ;
try {
connection = factory . getConnection ( ) ;
statementInsert = connection . prepareStatement ( SQL_ADD ) ;
try {
populateStatementForAdd ( statementInsert , patron ) ;
statementInsert . executeUpdate ( ) ;
} catch ( SQLException e ) {
if ( e . getSQLState ( ) . equals ( SQLSTATE_ALREADY_EXISTS ) ) {
throw new PatronExists ( patron . getId ( ) , patron . getEmail ( ) ) ;
} else {
throw new OperationFailed ( e ) ;
}
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( null , statementInsert , connection ) ;
}
}
@Override
public Patron findByEmail ( String email ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed {
Connection connection = null ;
PreparedStatement statementFind = null ;
ResultSet resultSet = null ;
Patron patron = null ;
try {
connection = factory . getConnection ( ) ;
statementFind = connection . prepareStatement ( SQL_FIND_BY_EMAIL ) ;
try {
statementFind . setString ( <num> , email ) ;
resultSet = statementFind . executeQuery ( ) ;
if ( resultSet . next ( ) ) {
patron = mapPatron ( resultSet ) ;
} else {
throw new PatronNotFound ( email ) ;
}
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( resultSet , statementFind , connection ) ;
}
return patron ;
}
@Override
public Patron findById ( int id ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed {
Connection connection = null ;
PreparedStatement statementFind = null ;
ResultSet resultSet = null ;
Patron patron = null ;
try {
connection = factory . getConnection ( ) ;
statementFind = connection . prepareStatement ( SQL_FIND_BY_ID ) ;
try {
statementFind . setInt ( <num> , id ) ;
resultSet = statementFind . executeQuery ( ) ;
if ( resultSet . next ( ) ) {
patron = mapPatron ( resultSet ) ;
} else {
throw new PatronNotFound ( id ) ;
}
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( resultSet , statementFind , connection ) ;
}
return patron ;
}
@Override
public Collection < Copy > getCopies ( Patron patron )
throws SystemUnavailableException , OperationFailed {
CopyDataStore copyDataStore = DataStoreFactory . getCopyDataStore ( ) ;
return copyDataStore . findCopiesForPatronId ( patron . getId ( ) ) ;
}
@Override
public void remove ( Patron patron ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed {
Connection connection = null ;
PreparedStatement statementRemove = null ;
try {
connection = factory . getConnection ( ) ;
statementRemove = connection . prepareStatement ( SQL_REMOVE ) ;
try {
statementRemove . setInt ( <num> , patron . getId ( ) ) ;
int affectedRows = statementRemove . executeUpdate ( ) ;
if ( affectedRows == <num> ) {
throw new PatronNotFound ( patron . getId ( ) ) ;
}
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( null , statementRemove , connection ) ;
}
}
@Override
public Collection < LoanedCopy > retriveLoanedCopies ( Patron patron )
throws SystemUnavailableException , OperationFailed {
CopyDataStore copyDataStore = DataStoreFactory . getCopyDataStore ( ) ;
return copyDataStore . findLoanedCopiesForPatronId ( patron . getId ( ) ) ;
}
@Override
public void update ( Patron patron ) throws SystemUnavailableException ,
OperationFailed , PatronNotFound , PatronExists {
Connection connection = null ;
PreparedStatement statementUpdate = null ;
try {
connection = factory . getConnection ( ) ;
statementUpdate = connection . prepareStatement ( SQL_UPDATE ) ;
try {
populateStatementForUpdate ( statementUpdate , patron ) ;
int affectedRows = statementUpdate . executeUpdate ( ) ;
System . out . println ( " + affectedRows ) ;
if ( affectedRows == <num> ) {
throw new PatronNotFound ( patron . getId ( ) ) ;
}
} catch ( SQLException e ) {
if ( e . getSQLState ( ) . equals ( SQLSTATE_ALREADY_EXISTS ) ) {
throw new PatronExists ( patron . getEmail ( ) ) ;
} else {
throw new OperationFailed ( e ) ;
}
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( null , statementUpdate , connection ) ;
}
}
private static Patron mapPatron ( ResultSet rs ) throws SQLException {
return new Patron ( rs . getInt ( <num> ) , rs . getString ( <num> ) , rs . getString ( <num> ) ,
rs . getString ( <num> ) , rs . getString ( <num> ) ) ;
}
private static void populateStatementForAdd (
PreparedStatement statement , Patron patron ) throws SQLException {
statement . setInt ( <num> , patron . getId ( ) ) ;
statement . setString ( <num> , patron . getFirstName ( ) ) ;
statement . setString ( <num> , patron . getLastName ( ) ) ;
statement . setString ( <num> , patron . getPassword ( ) ) ;
statement . setString ( <num> , patron . getEmail ( ) ) ;
}
private static void populateStatementForUpdate (
PreparedStatement statement , Patron patron ) throws SQLException {
statement . setString ( <num> , patron . getFirstName ( ) ) ;
statement . setString ( <num> , patron . getLastName ( ) ) ;
statement . setString ( <num> , patron . getPassword ( ) ) ;
statement . setString ( <num> , patron . getEmail ( ) ) ;
statement . setInt ( <num> , patron . getId ( ) ) ;
}
}
package com . ibm . ils . library . model . exceptions ;
public class ItemNotFound extends Exception {
private static final long serialVersionUID =  <num> ;
public ItemNotFound ( int id ) {
super ( " + id + " ) ;
}
}
package com . ibm . library . beans ;
import java . io . Serializable ;
import java . util . Collection ;
import com . ibm . ils . library . model . LoanedCopy ;
public class LoanedCopyListBean implements Serializable {
private static final long serialVersionUID = <num> ;
private Collection < LoanedCopy > loanedCopyList ;
public LoanedCopyListBean ( ) { }
public Collection < LoanedCopy > getLoanedCopyList ( ) {
return loanedCopyList ;
}
public void setLoanedCopyList ( Collection < LoanedCopy > loanedCopyList ) {
this . loanedCopyList = loanedCopyList ;
}
}
package com . ibm . ils . library . datastore . jdbc ;
import static com . ibm . ils . library . datastore . util . DAOUtil . close ;
import java . sql . Connection ;
import java . sql . PreparedStatement ;
import java . sql . ResultSet ;
import java . sql . SQLException ;
import java . util . Collection ;
import java . util . Date ;
import com . ibm . ils . library . datastore . ConnectionFactory ;
import com . ibm . ils . library . datastore . CopyDataStore ;
import com . ibm . ils . library . datastore . DataStoreFactory ;
import com . ibm . ils . library . datastore . ItemDataStore ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Copy ;
import com . ibm . ils . library . model . Item ;
import com . ibm . ils . library . model . exceptions . ItemExists ;
import com . ibm . ils . library . model . exceptions . ItemNotFound ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
public class ItemDataStoreJDBC implements ItemDataStore {
private ConnectionFactory factory ;
private static final String SQL_ADD = " ;
private static final String SQL_FIND_BY_ID = " ;
private static final String SQL_REMOVE = " ;
private static final String SQL_UPDATE = " ;
private static final String SIZE_OVERSIZED = " ;
private static final String SIZE_STANDARD = " ;
private static final String SQLSTATE_ALREADY_EXISTS = " ;
public ItemDataStoreJDBC ( ConnectionFactory factory ) {
this . factory = factory ;
}
@Override
public void add ( Item item ) throws SystemUnavailableException ,
OperationFailed , ItemExists {
Connection connection = null ;
PreparedStatement statementInsert = null ;
try {
connection = factory . getConnection ( ) ;
statementInsert = connection . prepareStatement ( SQL_ADD ) ;
try {
populateStatementForAdd ( statementInsert , item ) ;
statementInsert . executeUpdate ( ) ;
} catch ( SQLException e ) {
if ( e . getSQLState ( ) . equals ( SQLSTATE_ALREADY_EXISTS ) ) {
throw new ItemExists ( item . getId ( ) ) ;
} else {
throw new OperationFailed ( e ) ;
}
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( null , statementInsert , connection ) ;
}
}
@Override
public Item findById ( int id ) throws SystemUnavailableException ,
OperationFailed , ItemNotFound {
Connection connection = null ;
PreparedStatement statementFind = null ;
ResultSet resultSet = null ;
Item item = null ;
try {
connection = factory . getConnection ( ) ;
statementFind = connection . prepareStatement ( SQL_FIND_BY_ID ) ;
try {
statementFind . setInt ( <num> , id ) ;
resultSet = statementFind . executeQuery ( ) ;
if ( resultSet . next ( ) ) {
item = mapItem ( resultSet ) ;
} else {
throw new ItemNotFound ( id ) ;
}
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( resultSet , statementFind , connection ) ;
}
return item ;
}
@Override
public Collection < Copy > getCopies ( Item item ) throws OperationFailed ,
SystemUnavailableException {
CopyDataStore copyDataStore = DataStoreFactory . getCopyDataStore ( ) ;
return copyDataStore . findCopiesForItemId ( item . getId ( ) ) ;
}
@Override
public void remove ( Item item ) throws SystemUnavailableException ,
OperationFailed , ItemNotFound {
Connection connection = null ;
PreparedStatement statementRemove = null ;
try {
connection = factory . getConnection ( ) ;
statementRemove = connection . prepareStatement ( SQL_REMOVE ) ;
try {
statementRemove . setInt ( <num> , item . getId ( ) ) ;
int affectedRows = statementRemove . executeUpdate ( ) ;
if ( affectedRows == <num> ) {
throw new ItemNotFound ( item . getId ( ) ) ;
}
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( null , statementRemove , connection ) ;
}
}
@Override
public void update ( Item item ) throws SystemUnavailableException ,
ItemNotFound , OperationFailed {
Connection connection = null ;
PreparedStatement statementUpdate = null ;
try {
connection = factory . getConnection ( ) ;
statementUpdate = connection . prepareStatement ( SQL_UPDATE ) ;
try {
populateStatementForUpdate ( statementUpdate , item ) ;
int affectedRows = statementUpdate . executeUpdate ( ) ;
if ( affectedRows == <num> ) {
throw new ItemNotFound ( item . getId ( ) ) ;
}
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( null , statementUpdate , connection ) ;
}
}
private static Item mapItem ( ResultSet rs ) throws SQLException {
int id = rs . getInt ( <num> ) ;
char medium = rs . getString ( <num> ) . charAt ( <num> ) ;
String isbnEquivalent = rs . getString ( <num> ) ;
String title = rs . getString ( <num> ) ;
String author = rs . getString ( <num> ) ;
String overString = rs . getString ( <num> ) ;
boolean oversize ;
if ( overString . toUpperCase ( ) . equals ( SIZE_OVERSIZED ) ) {
oversize = true ;
} else {
oversize = false ;
}
Integer volumes = ( Integer ) rs . getObject ( <num> ) ;
java . sql . Date publishedSql = rs . getDate ( <num> ) ;
java . util . Date published ;
published = ( publishedSql == null ) ? null : new Date (
publishedSql . getTime ( ) ) ;
return new Item ( id , medium , isbnEquivalent , title , author , oversize ,
volumes , published ) ;
}
private static PreparedStatement populateStatementForAdd (
PreparedStatement statement , Item item ) throws SQLException {
statement . setInt ( <num> , item . getId ( ) ) ;
statement . setString ( <num> , String . valueOf ( item . getMedium ( ) ) ) ;
statement . setString ( <num> , item . getIsbnEquivalent ( ) ) ;
statement . setString ( <num> , item . getTitle ( ) ) ;
statement . setString ( <num> , item . getAuthor ( ) ) ;
String size ;
if ( item . isOversize ( ) ) {
size = SIZE_OVERSIZED ;
} else {
size = SIZE_STANDARD ;
}
statement . setString ( <num> , size ) ;
statement . setObject ( <num> , item . getVolume ( ) ) ;
java . sql . Date published = ( item . getPublished ( ) == null ) ? null
: new java . sql . Date ( item . getPublished ( ) . getTime ( ) ) ;
statement . setDate ( <num> , published ) ;
return statement ;
}
private static PreparedStatement populateStatementForUpdate (
PreparedStatement statement , Item item ) throws SQLException {
statement . setString ( <num> , String . valueOf ( item . getMedium ( ) ) ) ;
statement . setString ( <num> , item . getIsbnEquivalent ( ) ) ;
statement . setString ( <num> , item . getTitle ( ) ) ;
statement . setString ( <num> , item . getAuthor ( ) ) ;
String size ;
if ( item . isOversize ( ) ) {
size = SIZE_OVERSIZED ;
} else {
size = SIZE_STANDARD ;
}
statement . setString ( <num> , size ) ;
statement . setObject ( <num> , item . getVolume ( ) ) ;
java . sql . Date published = ( item . getPublished ( ) == null ) ? null
: new java . sql . Date ( item . getPublished ( ) . getTime ( ) ) ;
statement . setDate ( <num> , published ) ;
statement . setInt ( <num> , item . getId ( ) ) ;
return statement ;
}
}
package com . ibm . library . servlets ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . Collection ;
import javax . servlet . ServletContext ;
import javax . servlet . ServletException ;
import javax . servlet . annotation . WebServlet ;
import javax . servlet . http . HttpServlet ;
import javax . servlet . http . HttpServletRequest ;
import javax . servlet . http . HttpServletResponse ;
import javax . servlet . http . HttpSession ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Copy ;
import com . ibm . ils . library . model . LoanedCopy ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . library . beans . LoanedCopyListBean ;
@WebServlet("/ProcessListItems")
public class ProcessListItems extends HttpServlet {
private static final long serialVersionUID = <num> ;
public ProcessListItems ( ) {
super ( ) ;
}
protected void doGet ( HttpServletRequest request ,
HttpServletResponse response ) throws ServletException , IOException {
HttpSession session = request . getSession ( true ) ;
ServletContext context = getServletContext ( ) ;
Copy copyX = new Copy ( ) ;
Collection < LoanedCopy > loanedCopyList = null ;
try {
loanedCopyList = copyX . findLoanedCopiesForPatronId ( <num> ) ;
} catch ( SystemUnavailableException e ) {
e . printStackTrace ( ) ;
} catch ( OperationFailed e ) {
e . printStackTrace ( ) ;
}
if ( loanedCopyList != null && loanedCopyList . size ( ) != <num> ) {
LoanedCopyListBean bean = new LoanedCopyListBean ( ) ;
bean . setLoanedCopyList ( loanedCopyList ) ;
session . setAttribute ( " , bean ) ;
context . getRequestDispatcher ( " )
. forward ( request , response ) ;
} else {
System . out . println ( " ) ;
}
}
protected void doPost ( HttpServletRequest request ,
HttpServletResponse response ) throws ServletException , IOException {
}
}
package com . ibm . ils . library . model ;
import java . io . Serializable ;
import java . util . Collection ;
import java . util . Date ;
import com . ibm . ils . library . datastore . DataStoreFactory ;
import com . ibm . ils . library . datastore . ItemDataStore ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . datastore . util . LibraryIdGenerator ;
import com . ibm . ils . library . model . exceptions . ItemExists ;
import com . ibm . ils . library . model . exceptions . ItemNotFound ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
public class Item implements Serializable {
private static final long serialVersionUID = <num> ;
private int id ;
private char medium ;
private String isbnEquivalent ;
private String title ;
private String author ;
private boolean oversize ;
private Integer volumes ;
private Date published ;
private static ItemDataStore dataStore ;
static {
dataStore = DataStoreFactory . getItemDataStore ( ) ;
}
public Item ( ) {
this ( ?' , " , " , " , false , <num> , null ) ;
}
public Item ( char medium , String isbnEquivalent , String title ,
String author , boolean oversize , int volumes , Date published ) {
this ( <num> , medium , isbnEquivalent , title , author , oversize , volumes ,
published ) ;
}
public Item ( int id , char medium , String isbnEquivalent , String title ,
String author , boolean oversize , Integer volumes , Date published ) {
super ( ) ;
this . id = id ;
this . medium = medium ;
this . isbnEquivalent = isbnEquivalent ;
this . title = title ;
this . author = author ;
this . oversize = oversize ;
this . volumes = volumes ;
this . published = published ;
}
public void add ( ) throws SystemUnavailableException , OperationFailed ,
ItemExists {
if ( getId ( ) == <num> ) {
setId ( LibraryIdGenerator . generateId ( ) ) ;
}
dataStore . add ( this ) ;
}
public static Item findById ( int id ) throws SystemUnavailableException ,
OperationFailed , ItemNotFound {
return dataStore . findById ( id ) ;
}
public Collection < Copy > getCopies ( ) throws OperationFailed ,
SystemUnavailableException {
return dataStore . getCopies ( this ) ;
}
public void remove ( ) throws SystemUnavailableException ,
OperationFailed , ItemNotFound {
dataStore . remove ( this ) ;
}
public void update ( ) throws SystemUnavailableException ,
ItemNotFound , OperationFailed {
dataStore . update ( this ) ;
}
public int getId ( ) {
return id ;
}
public void setId ( int id ) {
this . id = id ;
}
public char getMedium ( ) {
return medium ;
}
public void setMedium ( char medium ) {
this . medium = medium ;
}
public String getIsbnEquivalent ( ) {
return isbnEquivalent ;
}
public void setIsbnEquivalent ( String isbnEquivalent ) {
this . isbnEquivalent = isbnEquivalent ;
}
public String getTitle ( ) {
return title ;
}
public void setTitle ( String title ) {
this . title = title ;
}
public String getAuthor ( ) {
return author ;
}
public void setAuthor ( String author ) {
this . author = author ;
}
public boolean isOversize ( ) {
return oversize ;
}
public void setOversize ( boolean oversize ) {
this . oversize = oversize ;
}
public Integer getVolume ( ) {
return volumes ;
}
public void setVolume ( Integer volume ) {
this . volumes = volume ;
}
public Date getPublished ( ) {
return published ;
}
public void setPublished ( Date published ) {
this . published = published ;
}
@Override
public String toString ( ) {
return " + id + " + medium + "
+ isbnEquivalent + " + title + " + author
+ " + oversize + " + volumes
+ " + published + " ;
}
}
package com . ibm . ils . library . model . exceptions ;
public class OperationFailed extends Exception {
private static final long serialVersionUID = <num> ;
private Exception exception ;
public OperationFailed ( ) {
}
public OperationFailed ( String message ) {
super ( message ) ;
}
public OperationFailed ( Exception exception ) {
super ( " ) ;
this . exception = exception ;
}
public Exception getException ( ) {
return exception ;
}
}
package com . ibm . ils . library . datastore . exceptions ;
public class PatronExistsException extends Exception {
private static final long serialVersionUID = <num> ;
public PatronExistsException ( String message ) {
super ( message ) ;
}
}
package com . ibm . ils . library . model ;
import java . util . Date ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . exceptions . CopyNotFound ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . RenewFailed ;
public class LoanedCopy {
private String author ;
private String title ;
private int copyNumber ;
private Date due ;
private int itemId ;
private boolean renewAccomplished ;
private String renewMessage ;
private boolean renewRequest ;
private int timesRenewed ;
public LoanedCopy ( ) {
this ( " , " , <num> , null , <num> , false , " , false , <num> ) ;
}
public LoanedCopy ( String author , String title , int copyNumber , Date due ,
int itemId , int timesRenewed ) {
this ( author , title , copyNumber , due , itemId , false , " , false ,
timesRenewed ) ;
}
public LoanedCopy ( String author , String title , int copyNumber , Date due ,
int itemId , boolean renewAccomplished , String renewMessage ,
boolean renewRequest , int timesRenewed ) {
super ( ) ;
this . author = author ;
this . title = title ;
this . copyNumber = copyNumber ;
this . due = due ;
this . itemId = itemId ;
this . renewAccomplished = renewAccomplished ;
this . renewMessage = renewMessage ;
this . renewRequest = renewRequest ;
this . timesRenewed = timesRenewed ;
}
public void renew ( int patron_id ) throws OperationFailed , SystemUnavailableException {
Copy copy = new Copy ( false , getDue ( ) , getItemId ( ) , patron_id ,
getTimesRenewed ( ) , getCopyNumber ( ) ) ;
try {
boolean renewable = copy . renew ( ) ;
if ( renewable ) {
setRenewAccomplished ( true ) ;
setRenewMessage ( " ) ;
setDue ( copy . getDue ( ) ) ;
setTimesRenewed ( copy . getTimesRenewed ( ) ) ;
}
} catch ( CopyNotFound e ) {
setRenewAccomplished ( false ) ;
setRenewMessage ( " ) ;
} catch ( RenewFailed e ) {
setRenewAccomplished ( false ) ;
setRenewMessage ( " + e . getMessage ( ) ) ;
}
}
public String getAuthor ( ) {
return author ;
}
public void setAuthor ( String author ) {
this . author = author ;
}
public String getTitle ( ) {
return title ;
}
public void setTitle ( String title ) {
this . title = title ;
}
public int getCopyNumber ( ) {
return copyNumber ;
}
public void setCopyNumber ( int copyNumber ) {
this . copyNumber = copyNumber ;
}
public Date getDue ( ) {
return due ;
}
public void setDue ( Date due ) {
this . due = due ;
}
public int getItemId ( ) {
return itemId ;
}
public void setItemId ( int itemId ) {
this . itemId = itemId ;
}
public boolean <unk> ( ) {
return renewAccomplished ;
}
public void setRenewAccomplished ( boolean renewAccomplished ) {
this . renewAccomplished = renewAccomplished ;
}
public String <unk> ( ) {
return renewMessage ;
}
public void setRenewMessage ( String renewMessage ) {
this . renewMessage = renewMessage ;
}
public boolean isRenewRequest ( ) {
return renewRequest ;
}
public void setRenewRequest ( boolean renewRequest ) {
this . renewRequest = renewRequest ;
}
public int getTimesRenewed ( ) {
return timesRenewed ;
}
public void setTimesRenewed ( int timesRenewed ) {
this . timesRenewed = timesRenewed ;
}
@Override
public String toString ( ) {
return String
. format ( " ,
author , title , copyNumber , due , itemId ,
renewAccomplished , renewMessage , renewRequest ,
timesRenewed ) ;
}
}
package com . ibm . ils . library . model . exceptions ;
public class PatronExists extends Exception {
private static final long serialVersionUID = <num> ;
public PatronExists ( int id , String email ) {
super ( " + id + " + email + " ) ;
}
public PatronExists ( String email ) {
super ( " + email + " ) ;
}
}
package com . ibm . ils . library . datastore ;
import java . sql . Connection ;
import java . sql . SQLException ;
import java . util . Properties ;
import javax . sql . DataSource ;
public class DataSourceConnection implements BuildConnection {
@SuppressWarnings("unused")
private DataSource source ;
@SuppressWarnings("unused")
private Properties info ;
public DataSourceConnection ( String ctxFactory , String dataSource ,
Properties info ) {
}
@Override
public Connection getConnection ( ) throws SQLException {
return null ;
}
}
package com . ibm . ils . library . datastore ;
import java . io . IOException ;
import java . io . InputStream ;
import java . sql . Driver ;
import java . sql . SQLException ;
import java . util . Properties ;
import com . ibm . ils . library . datastore . jdbc . CopyDataStoreJDBC ;
import com . ibm . ils . library . datastore . jdbc . ItemDataStoreJDBC ;
import com . ibm . ils . library . datastore . jdbc . PatronDataStoreJDBC ;
public class DataStoreFactory {
private static ConnectionFactory factory ;
private static CopyDataStore copyDataStore ;
private static ItemDataStore itemDataStore ;
private static PatronDataStore patronDataStore ;
private static final String PROPERTIES_FILE = " ;
private static final String TYPE = " ;
private static final String TYPE_DRIVER_MANAGER = " ;
private static final String TYPE_DATA_SOURCE = " ;
private static final String USERID = " ;
private static final String PASSWORD = " ;
private static final String DRIVER = " ;
private static final String URL = " ;
static {
loadProperties ( PROPERTIES_FILE ) ;
copyDataStore = new CopyDataStoreJDBC ( factory ) ;
itemDataStore = new ItemDataStoreJDBC ( factory ) ;
patronDataStore = new PatronDataStoreJDBC ( factory ) ;
}
public static CopyDataStore getCopyDataStore ( ) {
return copyDataStore ;
}
public static ItemDataStore getItemDataStore ( ) {
return itemDataStore ;
}
public static PatronDataStore getPatronDataStore ( ) {
return patronDataStore ;
}
private static void loadProperties ( String filename ) {
InputStream inputStream = DataStoreFactory . class . getClassLoader ( )
. getResourceAsStream ( PROPERTIES_FILE ) ;
System . out . println ( "
+ DataStoreFactory . class . getClassLoader ( ) . getResource ( " )
. getFile ( ) ) ;
if ( inputStream == null ) {
processMissingFileError ( filename ) ;
} else {
System . out . println ( " ) ;
}
Properties properties = new Properties ( ) ;
try {
properties . load ( inputStream ) ;
String type = properties . getProperty ( TYPE ) ;
if ( type == null ) {
processMissingProperty ( TYPE ) ;
}
if ( type . equalsIgnoreCase ( TYPE_DRIVER_MANAGER ) ) {
String userid = properties . getProperty ( USERID ) ;
String password = properties . getProperty ( PASSWORD ) ;
String url = properties . getProperty ( URL ) ;
String driver = properties . getProperty ( DRIVER ) ;
instantiateFactory ( driver , url , userid , password ) ;
} else if ( type . equalsIgnoreCase ( TYPE_DATA_SOURCE ) ) {
processDataSourceError ( ) ;
} else {
processIncorectFormatError ( ) ;
}
} catch ( IOException e ) {
processReadError ( ) ;
}
}
private static void processMissingFileError ( String filename ) {
System . err . println ( " + filename + " ) ;
System . exit (  <num> ) ;
}
private static void processDataSourceError ( ) {
System . err . println ( " ) ;
System . exit (  <num> ) ;
}
private static void processIncorectFormatError ( ) {
System . err . println ( " ) ;
System . exit (  <num> ) ;
}
private static void processMissingProperty ( String property ) {
System . err . println ( " + property
+ " ) ;
System . exit (  <num> ) ;
}
private static void processReadError ( ) {
System . err . println ( " ) ;
System . exit (  <num> ) ;
}
private static void instantiateFactory ( String driverName , String url ,
String userid , String password ) {
Properties info = new Properties ( ) ;
info . put ( " , " ) ;
info . put ( " , " ) ;
try {
Driver driver = ( Driver ) Class . forName ( driverName ) . newInstance ( ) ;
factory = new ConnectionFactory ( driver , url , info ) ;
} catch ( IllegalAccessException e ) {
e . printStackTrace ( ) ;
} catch ( InstantiationException e ) {
e . printStackTrace ( ) ;
} catch ( ClassNotFoundException e ) {
e . printStackTrace ( ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
}
}
package com . ibm . library . servlets ;
import java . io . IOException ;
import javax . persistence . EntityExistsException ;
import javax . persistence . RollbackException ;
import javax . servlet . ServletContext ;
import javax . servlet . ServletException ;
import javax . servlet . annotation . WebServlet ;
import javax . servlet . http . HttpServlet ;
import javax . servlet . http . HttpServletRequest ;
import javax . servlet . http . HttpServletResponse ;
import javax . servlet . http . HttpSession ;
import org . apache . <unk> . lib . jdbc . <unk> ;
import com . ibm . library . Patron ;
import com . ibm . library . ejb . PatronEJB ;
import com . ibm . library . ejb . PatronEJBLocal ;
@WebServlet("/Register")
public class Register extends HttpServlet {
private static final long serialVersionUID = <num> ;
public Register ( ) {
super ( ) ;
}
protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
ServletContext context = getServletContext ( ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
HttpSession session = request . getSession ( true ) ;
String firstName = request . getParameter ( " ) ;
String lastName = request . getParameter ( " ) ;
String email = request . getParameter ( " ) ;
String password = request . getParameter ( " ) ;
if ( email != " && ( email . indexOf ( " ) ==  <num> || email . indexOf ( " ) ==  <num> ) ) {
showErrorMessage ( " , request , response ) ;
}
if ( checkValues ( firstName , lastName , email , password ) ) {
Patron p = new Patron ( ) ;
p . setFirstName ( firstName ) ;
p . setLastName ( lastName ) ;
p . setEmail ( email ) ;
p . setPassword ( password ) ;
try {
PatronEJBLocal patronEJB = new PatronEJB ( ) ;
patronEJB . add ( p ) ;
System . out . println ( " ) ;
session . setAttribute ( " , " ) ;
response . sendRedirect ( " ) ;
} catch ( EntityExistsException e ) {
showErrorMessage ( " , request , response ) ;
} catch ( RollbackException e ) {
showErrorMessage ( " , request , response ) ;
} catch ( IllegalStateException e ) {
showErrorMessage ( " , request , response ) ;
}
} else {
showErrorMessage ( " , request , response ) ;
}
}
private boolean checkValues ( String firstName , String lastName , String email , String password ) {
if ( firstName == null || firstName . equals ( " ) ) {
return false ;
}
else if ( lastName == null || lastName . equals ( " ) ) {
return false ;
}
else if ( email == null || email . equals ( " ) ) {
return false ;
}
else if ( password == null || password . equals ( " ) ) {
return false ;
}
return true ;
}
private void showErrorMessage ( String message , HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
ServletContext context = getServletContext ( ) ;
request . setAttribute ( " , message ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
}
package com . ibm . ils . library . model . exceptions ;
public class CopyExists extends Exception {
private static final long serialVersionUID =  <num> ;
public CopyExists ( int itemId , int copyNumber ) {
super ( " + itemId + " + copyNumber
+ " ) ;
}
package com . ibm . ils . library . datastore . exceptions ;
@SuppressWarnings("serial")
public class SystemUnavailableException extends Exception {
@SuppressWarnings("unused")
private Exception exception ;
public SystemUnavailableException ( String message ) {
super ( message ) ;
}
public SystemUnavailableException ( Exception exception ) {
super ( " ) ;
this . exception = exception ;
}
}
package com . ibm . ils . library . datastore ;
import java . util . Collection ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Copy ;
import com . ibm . ils . library . model . Item ;
import com . ibm . ils . library . model . LoanedCopy ;
import com . ibm . ils . library . model . Patron ;
import com . ibm . ils . library . model . exceptions . CopyExists ;
import com . ibm . ils . library . model . exceptions . CopyNotFound ;
import com . ibm . ils . library . model . exceptions . ItemNotFound ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . PatronNotFound ;
public interface CopyDataStore {
public void add ( Copy copy ) throws SystemUnavailableException ,
OperationFailed , CopyExists ;
public Collection < Copy > findCopiesForItemId ( int id ) throws OperationFailed ,
SystemUnavailableException ;
public Collection < Copy > findCopiesForPatronId ( int id )
throws SystemUnavailableException , OperationFailed ;
public Collection < LoanedCopy > findLoanedCopiesForPatronId ( int id )
throws SystemUnavailableException , OperationFailed ;
public Item getItem ( Copy copy ) throws SystemUnavailableException ,
OperationFailed , ItemNotFound ;
public Patron getPatron ( Copy copy ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed ;
public void remove ( Copy copy ) throws OperationFailed ,
SystemUnavailableException , CopyNotFound ;
public void renewCopy ( Copy copy , java . sql . Date dueDate , int timesRenewed )
throws CopyNotFound , OperationFailed , SystemUnavailableException ;
public void update ( Copy copy ) throws CopyNotFound , OperationFailed ,
SystemUnavailableException ;
}
package com . ibm . ils . library . model . exceptions ;
public class RenewFailed extends Exception {
private static final long serialVersionUID = <num> ;
public RenewFailed ( String message ) {
super ( message ) ;
}
}
package com . ibm . library . beans ;
import java . io . Serializable ;
import com . ibm . ils . library . model . Patron ;
public class PatronBean implements Serializable {
private static final long serialVersionUID =  <num> ;
private Patron patron ;
public PatronBean ( ) { }
public Patron getPatron ( ) {
return patron ;
}
public void <unk> ( Patron p ) {
this . patron = p ;
}
}
package com . ibm . ils . library . model . exceptions ;
public class ItemExists extends Exception {
private static final long serialVersionUID = <num> ;
public ItemExists ( int id ) {
super ( " + id + " ) ;
}
}
package com . ibm . library . servlets ;
import java . io . IOException ;
import javax . servlet . ServletContext ;
import javax . servlet . ServletException ;
import javax . servlet . annotation . WebServlet ;
import javax . servlet . http . HttpServlet ;
import javax . servlet . http . HttpServletRequest ;
import javax . servlet . http . HttpServletResponse ;
<unk>
public class Default extends HttpServlet {
private static final long serialVersionUID = <num> ;
public Default ( ) {
super ( ) ;
}
protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
ServletContext context = getServletContext ( ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
}
}
package com . ibm . ils . library . datastore ;
import java . util . Collection ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Copy ;
import com . ibm . ils . library . model . LoanedCopy ;
import com . ibm . ils . library . model . Patron ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . PatronExists ;
import com . ibm . ils . library . model . exceptions . PatronNotFound ;
public interface PatronDataStore {
public void add ( Patron patron ) throws PatronExists ,
SystemUnavailableException , OperationFailed ;
public Patron findByEmail ( String email ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed ;
public Patron findById ( int id ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed ;
public Collection < Copy > getCopies ( Patron patron )
throws SystemUnavailableException , OperationFailed ;
public void remove ( Patron patron ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed ;
public Collection < LoanedCopy > retriveLoanedCopies ( Patron patron )
throws SystemUnavailableException , OperationFailed ;
public void update ( Patron patron ) throws SystemUnavailableException ,
OperationFailed , PatronNotFound , PatronExists ;
}
package com . ibm . library . servlets ;
import java . io . IOException ;
import javax . servlet . ServletContext ;
import javax . servlet . ServletException ;
import javax . servlet . annotation . WebServlet ;
import javax . servlet . http . HttpServlet ;
import javax . servlet . http . HttpServletRequest ;
import javax . servlet . http . HttpServletResponse ;
import javax . servlet . http . HttpSession ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Patron ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . PatronNotFound ;
<unk>
public class Login extends HttpServlet {
private static final long serialVersionUID =  <num> ;
public Login ( ) {
super ( ) ;
}
protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
HttpSession session = request . getSession ( true ) ;
ServletContext context = getServletContext ( ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
HttpSession session = request . getSession ( false ) ;
try {
String patronEmail = request . getParameter ( " ) ;
String patronPassword = request . getParameter ( " ) ;
Patron p = Patron . findByEmail ( patronEmail ) ;
if ( p . getPassword ( ) . equals ( patronPassword ) ) {
session . setAttribute ( " , p . getId ( ) ) ;
session . setAttribute ( " , " ) ;
response . sendRedirect ( " ) ;
} else {
ServletContext context = getServletContext ( ) ;
request . setAttribute ( " , " ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
} catch ( NumberFormatException e ) {
ServletContext context = getServletContext ( ) ;
request . setAttribute ( " , " ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
} catch ( PatronNotFound e ) {
ServletContext context = getServletContext ( ) ;
request . setAttribute ( " , " ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
} catch ( SystemUnavailableException e ) {
ServletContext context = getServletContext ( ) ;
request . setAttribute ( " , " ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
} catch ( OperationFailed e ) {
ServletContext context = getServletContext ( ) ;
request . setAttribute ( " , " ) ;
context . getRequestDispatcher ( " ) . forward ( request , response ) ;
}
}
}
package test ;
import java . util . ArrayList ;
import java . util . Collection ;
import java . util . Date ;
import java . util . List ;
import javax . naming . NamingException ;
import com . ibm . ils . library . datastore . DataStoreFactory ;
import com . ibm . ils . library . datastore . PatronDataStore ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Copy ;
import com . ibm . ils . library . model . Item ;
import com . ibm . ils . library . model . LoanedCopy ;
import com . ibm . ils . library . model . Patron ;
import com . ibm . ils . library . model . exceptions . CopyExists ;
import com . ibm . ils . library . model . exceptions . CopyNotFound ;
import com . ibm . ils . library . model . exceptions . InvalidPassword ;
import com . ibm . ils . library . model . exceptions . ItemExists ;
import com . ibm . ils . library . model . exceptions . ItemNotFound ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . PatronExists ;
import com . ibm . ils . library . model . exceptions . PatronNotFound ;
import com . ibm . <unk> . naming . <unk> ;
public class <unk> {
public static void main ( String [ ] args ) {
Item item = new Item ( F' , " , " , " , true , <num> , null ) ;
item . setId ( <num> ) ;
try {
item . remove ( ) ;
} catch ( SystemUnavailableException e ) {
e . printStackTrace ( ) ;
} catch ( ItemNotFound e ) {
e . printStackTrace ( ) ;
} catch ( OperationFailed e ) {
e . printStackTrace ( ) ;
}
}
}
package com . ibm . ils . library . model ;
import java . io . Serializable ;
import java . util . Collection ;
import com . ibm . ils . library . datastore . DataStoreFactory ;
import com . ibm . ils . library . datastore . PatronDataStore ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . datastore . util . LibraryIdGenerator ;
import com . ibm . ils . library . model . exceptions . InvalidPassword ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . PatronExists ;
import com . ibm . ils . library . model . exceptions . PatronNotFound ;
public class Patron implements Serializable {
private static final long serialVersionUID =  <num> ;
private static final int MIN_PASSWORD_LENGTH = <num> ;
private int id ;
private String firstName ;
private String lastName ;
private String email ;
private String password ;
private static PatronDataStore dataStore ;
static {
dataStore = DataStoreFactory . getPatronDataStore ( ) ;
}
public Patron ( ) {
this ( <num> , null , null , null , null ) ;
}
public Patron ( String firstName , String lastName , String password ,
String email ) {
this ( <num> , firstName , lastName , password , email ) ;
}
public Patron ( int id , String firstName , String lastName , String password ,
String email ) {
super ( ) ;
this . id = id ;
this . firstName = firstName ;
this . lastName = lastName ;
this . email = email ;
this . password = password ;
}
public void add ( ) throws PatronExists , SystemUnavailableException ,
OperationFailed , InvalidPassword {
if ( getId ( ) == <num> ) {
setId ( LibraryIdGenerator . generateId ( ) ) ;
}
verifyPassword ( ) ;
dataStore . add ( this ) ;
}
public static Patron findByEmail ( String email ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed {
return dataStore . findByEmail ( email ) ;
}
public static Patron findById ( int id ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed {
return dataStore . findById ( id ) ;
}
public Collection < Copy > getCopies ( ) throws SystemUnavailableException ,
OperationFailed {
return dataStore . getCopies ( this ) ;
}
public void remove ( ) throws PatronNotFound , SystemUnavailableException ,
OperationFailed {
dataStore . remove ( this ) ;
}
public Collection < LoanedCopy > retriveLoanedCopies ( )
throws SystemUnavailableException , OperationFailed {
return dataStore . retriveLoanedCopies ( this ) ;
}
public void update ( ) throws SystemUnavailableException , OperationFailed ,
PatronNotFound , PatronExists {
dataStore . update ( this ) ;
}
public void renew ( Collection < LoanedCopy > list ) throws OperationFailed ,
SystemUnavailableException {
for ( LoanedCopy loanedCopy : list ) {
if ( loanedCopy . isRenewRequest ( ) ) {
loanedCopy . renew ( getId ( ) ) ;
}
}
}
private void verifyPassword ( ) throws InvalidPassword {
String password = getPassword ( ) ;
if ( password == null || password . length ( ) == <num> ) {
throw new InvalidPassword ( " ) ;
}
for ( int i = <num> ; i < password . length ( ) ; i ++ ) {
if ( Character . isWhitespace ( password . charAt ( i ) ) ) {
throw new InvalidPassword (
" ) ;
}
}
if ( password . length ( ) < MIN_PASSWORD_LENGTH ) {
throw new InvalidPassword ( "
+ MIN_PASSWORD_LENGTH + " ) ;
}
}
public int getId ( ) {
return id ;
}
public void setId ( int id ) {
this . id = id ;
}
public String getFirstName ( ) {
return firstName ;
}
public void setFirstName ( String firstName ) {
this . firstName = firstName ;
}
public String getLastName ( ) {
return lastName ;
}
public void setLastName ( String lastName ) {
this . lastName = lastName ;
}
public String getEmail ( ) {
return email ;
}
public void setEmail ( String email ) {
this . email = email ;
}
public String getPassword ( ) {
return password ;
}
public void setPassword ( String password ) {
this . password = password ;
}
@Override
public String toString ( ) {
return String . format (
" ,
id , firstName , lastName , password , email ) ;
}
}
package com . ibm . ils . library . datastore . jdbc ;
import static com . ibm . ils . library . datastore . util . DAOUtil . close ;
import java . sql . Connection ;
import java . sql . PreparedStatement ;
import java . sql . ResultSet ;
import java . sql . SQLException ;
import java . util . ArrayList ;
import java . util . Collection ;
import java . util . Date ;
import com . ibm . ils . library . datastore . ConnectionFactory ;
import com . ibm . ils . library . datastore . CopyDataStore ;
import com . ibm . ils . library . datastore . DataStoreFactory ;
import com . ibm . ils . library . datastore . ItemDataStore ;
import com . ibm . ils . library . datastore . PatronDataStore ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Copy ;
import com . ibm . ils . library . model . Item ;
import com . ibm . ils . library . model . LoanedCopy ;
import com . ibm . ils . library . model . Patron ;
import com . ibm . ils . library . model . exceptions . CopyExists ;
import com . ibm . ils . library . model . exceptions . CopyNotFound ;
import com . ibm . ils . library . model . exceptions . ItemNotFound ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
import com . ibm . ils . library . model . exceptions . PatronNotFound ;
public class CopyDataStoreJDBC implements CopyDataStore {
private ConnectionFactory factory ;
private static final String SQLSTATE_ALREADY_EXISTS = " ;
private static final String SQLSTATE_INVALID_FOREIGN_KEY = " ;
private static final String SQL_ADD = "
+ " ;
private static final String SQL_FIND_COPIES_FOR_ITEM_ID = " +
" +
" ;
private static final String SQL_FIND_COPIES_FOR_PATRON_ID = "
+ "
+ "
+ "
+ "
+ "
+ " ;
private static final String SQL_FIND_LOANED_COPIES_FOR_PATRON_ID = "
+ "
+ "
+ "
+ "
+ "
+ "
+ "
+ " ;
private static final String SQL_FIND_MAX_COPY_NUMBER = "
+ " ;
private static final String SQL_REMOVE_COPY = "
+ " ;
private static final String SQL_REMOVE_ONLOAN = "
+ " ;
private static final String SQL_RENEW = "
+ "
+ " ;
private static final String SQL_UPDATE_COPY = "
+ " ;
private static final String SQL_UPDATE_ONLOAN = "
+ "
+ " ;
public CopyDataStoreJDBC ( ConnectionFactory factory ) {
this . factory = factory ;
}
@Override
public void add ( Copy copy ) throws SystemUnavailableException ,
OperationFailed , CopyExists {
Connection connection = null ;
PreparedStatement statementInsert = null ;
int nextId = <num> ;
try {
connection = factory . getConnection ( ) ;
try {
nextId = findMaxCopyNumber ( copy . getItemId ( ) , connection ) + <num> ;
statementInsert = connection . prepareStatement ( SQL_ADD ) ;
statementInsert . setInt ( <num> , copy . getItemId ( ) ) ;
statementInsert . setInt ( <num> , nextId ) ;
statementInsert . setString ( <num> , " ) ;
statementInsert . executeUpdate ( ) ;
copy . setCopyNumber ( nextId ) ;
} catch ( SQLException e ) {
if ( e . getSQLState ( ) . equals ( SQLSTATE_ALREADY_EXISTS ) ) {
throw new CopyExists ( copy . getItemId ( ) , nextId ) ;
} else if ( e . getSQLState ( ) . equals ( SQLSTATE_INVALID_FOREIGN_KEY ) ) {
throw new OperationFailed ( "
+ copy . getItemId ( ) + " ) ;
} else {
throw new OperationFailed ( e ) ;
}
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( null , statementInsert , connection ) ;
}
}
private int findMaxCopyNumber ( int itemKey , Connection connection )
throws OperationFailed , SystemUnavailableException {
PreparedStatement statementFindMax = null ;
ResultSet resultSet = null ;
int max = <num> ;
try {
statementFindMax = connection
. prepareStatement ( SQL_FIND_MAX_COPY_NUMBER ) ;
try {
statementFindMax . setInt ( <num> , itemKey ) ;
resultSet = statementFindMax . executeQuery ( ) ;
if ( resultSet . next ( ) ) {
max = resultSet . getInt ( <num> ) ;
}
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
}
return max ;
}
@Override
public Collection < Copy > findCopiesForItemId ( int id ) throws OperationFailed ,
SystemUnavailableException {
Connection connection = null ;
PreparedStatement statementFind = null ;
ResultSet resultSet = null ;
Collection < Copy > copies = new ArrayList < Copy > ( ) ;
try {
connection = factory . getConnection ( ) ;
statementFind = connection
. prepareStatement ( SQL_FIND_COPIES_FOR_ITEM_ID ) ;
try {
statementFind . setInt ( <num> , id ) ;
resultSet = statementFind . executeQuery ( ) ;
mapCopies ( resultSet , copies ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( resultSet , statementFind , connection ) ;
}
return copies ;
}
@Override
public Collection < Copy > findCopiesForPatronId ( int id )
throws SystemUnavailableException , OperationFailed {
Connection connection = null ;
PreparedStatement statementFind = null ;
ResultSet resultSet = null ;
Collection < Copy > copies = new ArrayList < Copy > ( ) ;
try {
connection = factory . getConnection ( ) ;
statementFind = connection
. prepareStatement ( SQL_FIND_COPIES_FOR_PATRON_ID ) ;
try {
statementFind . setInt ( <num> , id ) ;
resultSet = statementFind . executeQuery ( ) ;
mapCopies ( resultSet , copies ) ;
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( resultSet , statementFind , connection ) ;
}
return copies ;
}
@Override
public Collection < LoanedCopy > findLoanedCopiesForPatronId ( int id )
throws SystemUnavailableException , OperationFailed {
Connection connection = null ;
PreparedStatement statementFind = null ;
ResultSet resultSet = null ;
Collection < LoanedCopy > copies = new ArrayList < LoanedCopy > ( ) ;
try {
connection = factory . getConnection ( ) ;
statementFind = connection
. prepareStatement ( SQL_FIND_LOANED_COPIES_FOR_PATRON_ID ) ;
try {
statementFind . setInt ( <num> , id ) ;
resultSet = statementFind . executeQuery ( ) ;
mapLoanedCopies ( resultSet , copies ) ;
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( resultSet , statementFind , connection ) ;
}
return copies ;
}
@Override
public Item getItem ( Copy copy ) throws SystemUnavailableException ,
OperationFailed , ItemNotFound {
ItemDataStore itemDataStore = DataStoreFactory . getItemDataStore ( ) ;
return itemDataStore . findById ( copy . getItemId ( ) ) ;
}
@Override
public Patron getPatron ( Copy copy ) throws PatronNotFound ,
SystemUnavailableException , OperationFailed {
PatronDataStore patronDataStore = DataStoreFactory . getPatronDataStore ( ) ;
return patronDataStore . findById ( copy . getPatronId ( ) ) ;
}
@Override
public void remove ( Copy copy ) throws OperationFailed ,
SystemUnavailableException , CopyNotFound {
Connection connection = null ;
PreparedStatement stRemoveOnloan = null ;
PreparedStatement stRemoveCopy = null ;
try {
connection = factory . getConnection ( ) ;
stRemoveOnloan = connection . prepareStatement ( SQL_REMOVE_ONLOAN ) ;
stRemoveCopy = connection . prepareStatement ( SQL_REMOVE_COPY ) ;
try {
if ( copy . getPatronId ( ) > <num> ) {
stRemoveOnloan . setInt ( <num> , copy . getPatronId ( ) ) ;
stRemoveOnloan . setInt ( <num> , copy . getItemId ( ) ) ;
stRemoveOnloan . setInt ( <num> , copy . getCopyNumber ( ) ) ;
stRemoveOnloan . executeUpdate ( ) ;
}
stRemoveCopy . setInt ( <num> , copy . getItemId ( ) ) ;
stRemoveCopy . setInt ( <num> , copy . getCopyNumber ( ) ) ;
int affectedRows = stRemoveCopy . executeUpdate ( ) ;
if ( affectedRows == <num> ) {
throw new CopyNotFound ( copy . getItemId ( ) ,
copy . getCopyNumber ( ) ) ;
}
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( null , stRemoveOnloan , connection ) ;
close ( null , stRemoveCopy , connection ) ;
}
}
@Override
public void renewCopy ( Copy copy , java . sql . Date dueDate , int timesRenewed )
throws CopyNotFound , OperationFailed , SystemUnavailableException {
Connection connection = null ;
PreparedStatement statementUpdate = null ;
try {
connection = factory . getConnection ( ) ;
statementUpdate = connection . prepareStatement ( SQL_RENEW ) ;
try {
statementUpdate . setDate ( <num> , dueDate ) ;
statementUpdate . setInt ( <num> , timesRenewed ) ;
statementUpdate . setInt ( <num> , copy . getPatronId ( ) ) ;
statementUpdate . setInt ( <num> , copy . getItemId ( ) ) ;
statementUpdate . setInt ( <num> , copy . getCopyNumber ( ) ) ;
int affectedRows = statementUpdate . executeUpdate ( ) ;
if ( affectedRows == <num> ) {
throw new CopyNotFound ( copy . getItemId ( ) ,
copy . getCopyNumber ( ) ) ;
}
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( null , statementUpdate , connection ) ;
}
}
@Override
public void update ( Copy copy ) throws CopyNotFound , OperationFailed ,
SystemUnavailableException {
Connection connection = null ;
PreparedStatement stUpdateOnloan = null ;
PreparedStatement stUpdateCopy = null ;
try {
connection = factory . getConnection ( ) ;
stUpdateOnloan = connection . prepareStatement ( SQL_UPDATE_ONLOAN ) ;
stUpdateCopy = connection . prepareStatement ( SQL_UPDATE_COPY ) ;
try {
if ( copy . getPatronId ( ) > <num> ) {
populateStatementForUpdateOnloan ( stUpdateOnloan , copy ) ;
stUpdateOnloan . executeUpdate ( ) ;
}
populateStatementForUpdateCopy ( stUpdateCopy , copy ) ;
int affectedRows = stUpdateCopy . executeUpdate ( ) ;
if ( affectedRows == <num> ) {
throw new CopyNotFound ( copy . getItemId ( ) ,
copy . getCopyNumber ( ) ) ;
}
} catch ( SQLException e ) {
throw new OperationFailed ( e ) ;
}
} catch ( SQLException e ) {
throw new SystemUnavailableException ( e ) ;
} finally {
close ( null , stUpdateOnloan , connection ) ;
close ( null , stUpdateCopy , connection ) ;
}
}
private static void populateStatementForUpdateOnloan (
PreparedStatement statement , Copy copy ) throws SQLException {
statement . setInt ( <num> , copy . getTimesRenewed ( ) ) ;
java . sql . Date date = ( copy . getDue ( ) != null ) ? new java . sql . Date ( copy
. getDue ( ) . getTime ( ) ) : null ;
statement . setDate ( <num> , date ) ;
statement . setInt ( <num> , copy . getPatronId ( ) ) ;
statement . setInt ( <num> , copy . getItemId ( ) ) ;
statement . setInt ( <num> , copy . getCopyNumber ( ) ) ;
}
private static void populateStatementForUpdateCopy (
PreparedStatement statement , Copy copy ) throws SQLException {
String value = copy . isLoanable ( ) ? " : " ;
statement . setString ( <num> , value ) ;
statement . setInt ( <num> , copy . getItemId ( ) ) ;
statement . setInt ( <num> , copy . getCopyNumber ( ) ) ;
}
private static void mapCopies ( ResultSet rs , Collection < Copy > copies )
throws SQLException {
boolean isLoanable ;
java . util . Date dueUtil ;
java . sql . Date dueSql ;
int itemId ;
int patronId ;
int timesRenewed ;
int copyNumber ;
Copy copy = null ;
while ( rs . next ( ) ) {
isLoanable = rs . getString ( <num> ) . equalsIgnoreCase ( " ) ;
dueSql = rs . getDate ( <num> ) ;
dueUtil = ( dueSql == null ) ? null : new Date ( dueSql . getTime ( ) ) ;
itemId = rs . getInt ( <num> ) ;
patronId = rs . getInt ( <num> ) ;
timesRenewed = rs . getInt ( <num> ) ;
copyNumber = rs . getInt ( <num> ) ;
copy = new Copy ( isLoanable , dueUtil , itemId , patronId ,
timesRenewed , copyNumber ) ;
copies . add ( copy ) ;
}
}
private static void mapLoanedCopies ( ResultSet rs ,
Collection < LoanedCopy > copies ) throws SQLException {
int itemId ;
int copyNumber ;
String author ;
String title ;
java . util . Date dueUtil ;
java . sql . Date dueSql ;
int timesRenewed ;
LoanedCopy loanCopy = null ;
while ( rs . next ( ) ) {
itemId = rs . getInt ( <num> ) ;
copyNumber = rs . getInt ( <num> ) ;
author = rs . getString ( <num> ) ;
title = rs . getString ( <num> ) ;
dueSql = rs . getDate ( <num> ) ;
dueUtil = ( dueSql == null ) ? null : new Date ( dueSql . getTime ( ) ) ;
timesRenewed = rs . getInt ( <num> ) ;
loanCopy = new LoanedCopy ( author , title , copyNumber , dueUtil ,
itemId , timesRenewed ) ;
copies . add ( loanCopy ) ;
}
}
}
package com . ibm . ils . library . datastore ;
import java . util . Collection ;
import com . ibm . ils . library . datastore . exceptions . SystemUnavailableException ;
import com . ibm . ils . library . model . Copy ;
import com . ibm . ils . library . model . Item ;
import com . ibm . ils . library . model . exceptions . ItemExists ;
import com . ibm . ils . library . model . exceptions . ItemNotFound ;
import com . ibm . ils . library . model . exceptions . OperationFailed ;
public interface ItemDataStore {
public void add ( Item item ) throws SystemUnavailableException ,
OperationFailed , ItemExists ;
public Item findById ( int id ) throws SystemUnavailableException ,
OperationFailed , ItemNotFound ;
public Collection < Copy > getCopies ( Item item ) throws OperationFailed ,
SystemUnavailableException ;
public void remove ( Item item ) throws SystemUnavailableException ,
OperationFailed , ItemNotFound ;
public void update ( Item item ) throws SystemUnavailableException ,
ItemNotFound , OperationFailed ;
}
package com . cent285 . project3 . client ;
import com . google . gwt . core . client . JavaScriptObject ;
class Ticket extends JavaScriptObject
{
protected Ticket ( )
{ }
public final native int getID ( )
;
public final native String getCreatedAt ( )
;
public final native String <unk> ( )
;
public final native String <unk> ( )
;
public final native String <unk> ( )
;
public final native String getSubject ( )
;
public final native String getDescription ( )
;
public final native String <unk> ( )
;
}
package com . cent285 . project3 . client ;
import com . google . gwt . core . client . EntryPoint ;
import com . google . gwt . http . client . Request ;
import com . google . gwt . http . client . RequestBuilder ;
import com . google . gwt . http . client . RequestCallback ;
import com . google . gwt . http . client . Response ;
import com . google . gwt . user . client . Window ;
import com . google . gwt . user . client . ui . RootPanel ;
import com . google . gwt . core . client . JsonUtils ;
import java . util . ArrayList ;
import com . google . gwt . core . client . JsArray ;
import com . google . gwt . user . cellview . client . CellTable ;
import com . google . gwt . user . cellview . client . TextColumn ;
import com . google . gwt . user . client . ui . HorizontalPanel ;
import com . google . gwt . user . client . ui . PasswordTextBox ;
import com . google . gwt . user . client . ui . TextBox ;
import com . google . gwt . user . client . ui . Button ;
import com . google . gwt . user . client . ui . Label ;
import com . google . gwt . event . dom . client . ClickHandler ;
import com . google . gwt . event . dom . client . ClickEvent ;
import com . google . gwt . view . client . SelectionChangeEvent ;
import com . google . gwt . view . client . SingleSelectionModel ;
import com . google . gwt . http . client . URL ;
import com . google . gwt . user . client . ui . VerticalPanel ;
public class <unk> implements EntryPoint , ClickHandler
{
VerticalPanel mainPanel = new VerticalPanel ( ) ;
String hostname = Window . Location . getHostName ( ) ;
String baseURL = " + hostname + " ;
ArrayList < MyTicket > tickets ;
JsArray < Ticket > jsonData ;
Button addButton = new Button ( " ) ;
Button deleteButton = new Button ( " ) ;
Button editButton = new Button ( " ) ;
MyTicket selectedTicket = null ;
Button addTicketButton = new Button ( " ) ;
Button editTicketButton = new Button ( " ) ;
TextBox createdBox = new TextBox ( ) ;
TextBox subjBox = new TextBox ( ) ;
TextBox descriptBox = new TextBox ( ) ;
TextBox userBox = new TextBox ( ) ;
PasswordTextBox passBox = new PasswordTextBox ( ) ;
Button loginButton = new Button ( " ) ;
private static class MyTicket
{
private int id ;
private String created_at ;
private String subject ;
private String description ;
public MyTicket ( int id , String created , String subj , String descript )
{
this . id = id ;
this . created_at = created ;
this . subject = subj ;
this . description = descript ;
}
}
public void onModuleLoad ( )
{
String url = baseURL + " ;
getRequest ( url , " ) ;
addButton . addClickHandler ( this ) ;
deleteButton . addClickHandler ( this ) ;
editButton . addClickHandler ( this ) ;
addTicketButton . addClickHandler ( this ) ;
editTicketButton . addClickHandler ( this ) ;
RootPanel . get ( ) . add ( mainPanel ) ;
login ( ) ;
}
public void onClick ( ClickEvent e )
{
Object source = e . getSource ( ) ;
if ( source == addTicketButton ) {
String url = baseURL + " ;
String postData = URL . encode ( " ) + " +
URL . encode ( createdBox . getText ( ) . trim ( ) ) + " +
URL . encode ( " ) + " +
URL . encode ( subjBox . getText ( ) . trim ( ) ) + " +
URL . encode ( " ) + " +
URL . encode ( descriptBox . getText ( ) . trim ( ) ) ;
createdBox . setText ( " ) ;
subjBox . setText ( " ) ;
descriptBox . setText ( " ) ;
postRequest ( url , postData , " ) ;
}
else if ( source == addButton ) {
setupAddTicket ( ) ;
}
else if ( source == deleteButton ) {
String url = baseURL + " ;
String postData = URL . encode ( " ) + " +
URL . encode ( " + selectedTicket . id ) ;
postRequest ( url , postData , " ) ;
}
else if ( source == editTicketButton ) {
String url = baseURL + " ;
String postData = URL . encode ( " ) + " +
URL . encode ( " + selectedTicket . id ) + " +
URL . encode ( " ) + " +
URL . encode ( createdBox . getText ( ) . trim ( ) ) + " +
URL . encode ( " ) + " +
URL . encode ( subjBox . getText ( ) . trim ( ) ) + " +
URL . encode ( " ) + " +
URL . encode ( descriptBox . getText ( ) . trim ( ) ) ;
createdBox . setText ( " ) ;
subjBox . setText ( " ) ;
descriptBox . setText ( " ) ;
postRequest ( url , postData , " ) ;
}
else if ( source == editButton ) {
setupEditTicket ( ) ;
}
}
public void getRequest ( String url , final String getType ) {
final RequestBuilder rb = new
RequestBuilder ( RequestBuilder . GET , url ) ;
try {
rb . sendRequest ( null , new RequestCallback ( )
{
public void onError ( final Request request ,
final Throwable exception )
{
Window . alert ( exception . getMessage ( ) ) ;
}
public void onResponseReceived ( final Request request ,
final Response response )
{
if ( getType . equals ( " ) ) {
showTickets ( response . getText ( ) ) ;
}
}
} ) ;
}
catch ( final Exception e ) {
Window . alert ( e . getMessage ( ) ) ;
}
}
public void postRequest ( String url , String data ,
final String postType )
{
final RequestBuilder rb = new
RequestBuilder ( RequestBuilder . POST , url ) ;
rb . setHeader ( " , " ) ;
try {
rb . sendRequest ( data , new RequestCallback ( )
{
public void onError ( final Request request ,
final Throwable exception )
{
Window . alert ( exception . getMessage ( ) ) ;
}
public void onResponseReceived ( final Request request ,
final Response response )
{
if ( postType . equals ( " ) ||
postType . equals ( " ) ||
postType . equals ( " ) ) {
mainPanel . clear ( ) ;
String url = baseURL + " ;
getRequest ( url , " ) ;
}
else if ( postType . equals ( " ) ) {
mainPanel . clear ( ) ;
if ( Integer . parseInt ( response . getText ( ) ) > <num> ) {
String url = baseURL + " ;
getRequest ( url , " ) ;
}
else {
Label failLabel = new Label ( " ) ;
mainPanel . add ( failLabel ) ;
login ( ) ;
}
}
}
} ) ;
}
catch ( Exception e ) {
Window . alert ( e . getMessage ( ) ) ;
}
}
private void showTickets ( String responseText )
{
jsonData = getData ( responseText ) ;
tickets = new ArrayList < MyTicket > ( ) ;
Ticket ticket = null ;
for ( int i = <num> ; i < jsonData . length ( ) ; i ++ ) {
ticket = jsonData . get ( i ) ;
tickets . add ( new MyTicket ( ticket . getID ( ) ,
ticket . getCreatedAt ( ) , ticket . getSubject ( ) ,
ticket . getDescription ( ) ) ) ;
}
CellTable < MyTicket > table = new CellTable < MyTicket > ( ) ;
TextColumn < MyTicket > createdameCol =
new TextColumn < MyTicket > ( )
{
@Override
public String getValue ( MyTicket ticket )
{
return ticket . created_at ;
}
} ;
TextColumn < MyTicket > subjameCol =
new TextColumn < MyTicket > ( )
{
@Override
public String getValue ( MyTicket ticket )
{
return ticket . subject ;
}
} ;
final SingleSelectionModel < MyTicket > selectionModel =
new SingleSelectionModel < MyTicket > ( ) ;
table . setSelectionModel ( selectionModel ) ;
selectionModel . <unk> (
new SelectionChangeEvent . Handler ( )
{
public void <unk> ( SelectionChangeEvent e )
{
MyTicket selected = selectionModel . <unk> ( ) ;
if ( selected != null ) {
selectedTicket = selected ;
}
}
} ) ;
table . addColumn ( createdameCol , " ) ;
table . addColumn ( subjameCol , " ) ;
table . setRowCount ( tickets . size ( ) , true ) ;
table . <unk> ( <num> , tickets ) ;
HorizontalPanel buttonRow = new HorizontalPanel ( ) ;
buttonRow . add ( addButton ) ;
buttonRow . add ( deleteButton ) ;
buttonRow . add ( editButton ) ;
mainPanel . add ( buttonRow ) ;
mainPanel . add ( table ) ;
}
private void setupAddTicket ( )
{
mainPanel . clear ( ) ;
VerticalPanel addTicketPanel = new VerticalPanel ( ) ;
Label createdLabel = new Label ( " ) ;
HorizontalPanel createdRow = new HorizontalPanel ( ) ;
createdRow . add ( createdLabel ) ;
createdRow . add ( createdBox ) ;
addTicketPanel . add ( createdRow ) ;
Label subjLabel = new Label ( " ) ;
HorizontalPanel subjRow = new HorizontalPanel ( ) ;
subjRow . add ( subjLabel ) ;
subjRow . add ( subjBox ) ;
addTicketPanel . add ( subjRow ) ;
Label descriptLabel = new Label ( " ) ;
HorizontalPanel descriptRow = new HorizontalPanel ( ) ;
descriptRow . add ( descriptLabel ) ;
descriptRow . add ( descriptBox ) ;
addTicketPanel . add ( descriptRow ) ;
addTicketPanel . add ( addTicketButton ) ;
mainPanel . add ( addTicketPanel ) ;
}
private void setupEditTicket ( )
{
mainPanel . clear ( ) ;
VerticalPanel editTicketPanel = new VerticalPanel ( ) ;
Label createdLabel = new Label ( " ) ;
HorizontalPanel createdRow = new HorizontalPanel ( ) ;
createdRow . add ( createdLabel ) ;
createdRow . add ( createdBox ) ;
editTicketPanel . add ( createdRow ) ;
Label subjLabel = new Label ( " ) ;
HorizontalPanel subjRow = new HorizontalPanel ( ) ;
subjRow . add ( subjLabel ) ;
subjRow . add ( subjBox ) ;
editTicketPanel . add ( subjRow ) ;
Label descriptLabel = new Label ( " ) ;
HorizontalPanel descriptRow = new HorizontalPanel ( ) ;
descriptRow . add ( descriptLabel ) ;
descriptRow . add ( descriptBox ) ;
editTicketPanel . add ( descriptRow ) ;
editTicketPanel . add ( editTicketButton ) ;
mainPanel . add ( editTicketPanel ) ;
}
public void login ( )
{
VerticalPanel loginPanel = new VerticalPanel ( ) ;
HorizontalPanel userRow = new HorizontalPanel ( ) ;
Label userLabel = new Label ( " ) ;
userRow . add ( userLabel ) ;
userRow . add ( userBox ) ;
loginPanel . add ( userRow ) ;
HorizontalPanel passRow = new HorizontalPanel ( ) ;
Label passLabel = new Label ( " ) ;
passRow . add ( passLabel ) ;
passRow . add ( passBox ) ;
loginPanel . add ( passRow ) ;
loginPanel . add ( loginButton ) ;
mainPanel . add ( loginPanel ) ;
}
private JsArray < Ticket > getData ( String json )
{
return JsonUtils . <unk> ( json ) ;
}
}
package com . MAS . Lighthouse ;
import com . MAS . helpers . Values ;
import android . app . Activity ;
import android . app . TabActivity ;
import android . content . Context ;
import android . content . Intent ;
import android . location . LocationManager ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . ImageView ;
import android . widget . TabHost ;
import android . widget . TabHost . TabSpec ;
public class MainActivity extends Activity {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
ImageView post = ( ImageView ) findViewById ( R . id . Post ) ;
post . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
postActivity ( v ) ;
}
} ) ;
ImageView scan = ( ImageView ) findViewById ( R . id . Scan ) ;
scan . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
scanActivity ( v ) ;
}
} ) ;
ImageView settings = ( ImageView ) findViewById ( R . id . Settings ) ;
settings . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
scanActivity ( v ) ;
}
} ) ;
}
public void scanActivity ( View view ) {
Log . d ( " , " ) ;
Intent i = new Intent ( this , DisplayMessageActivity . class ) ;
startActivity ( i ) ;
}
public void postActivity ( View view ) {
Intent i = new Intent ( this , PostMessageActivity . class ) ;
i . putExtra ( Values . COMING_FROM , Values . COMING_FROM_MAIN ) ;
startActivity ( i ) ;
}
package com . MAS . utils ;
import java . io . BufferedReader ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . InputStreamReader ;
import java . io . UnsupportedEncodingException ;
import java . util . List ;
import org . apache . http . HttpEntity ;
import org . apache . http . HttpResponse ;
import org . apache . http . NameValuePair ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . client . entity . UrlEncodedFormEntity ;
import org . apache . http . client . methods . HttpPost ;
import org . apache . http . impl . client . DefaultHttpClient ;
import org . json . JSONObject ;
import android . util . Log ;
public class HTTPPutUtil {
static InputStream is = null ;
static JSONObject jObj = null ;
static String json = " ;
public void Execute ( List < NameValuePair > params , String url ) throws ClientProtocolException , IOException
{
try {
DefaultHttpClient httpClient = new DefaultHttpClient ( ) ;
HttpPost httpPost = new HttpPost ( url ) ;
httpPost . setEntity ( ( HttpEntity ) new UrlEncodedFormEntity ( params ) ) ;
HttpResponse httpResponse = httpClient . execute ( httpPost ) ;
HttpEntity httpEntity = httpResponse . getEntity ( ) ;
is = httpEntity . getContent ( ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
} catch ( ClientProtocolException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
package com . MAS . Lighthouse ;
import java . io . File ;
import java . io . IOException ;
import java . text . SimpleDateFormat ;
import java . util . ArrayList ;
import java . util . Date ;
import java . util . List ;
import org . apache . http . HttpResponse ;
import org . apache . http . NameValuePair ;
import org . apache . http . client . ClientProtocolException ;
import org . json . JSONException ;
import org . json . JSONObject ;
import android . app . Activity ;
import android . net . Uri ;
import android . os . Bundle ;
import android . os . Environment ;
import android . provider . MediaStore ;
import android . content . Context ;
import android . content . Intent ;
import android . graphics . Typeface ;
import android . util . Log ;
import android . view . MotionEvent ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . view . View . OnTouchListener ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . TextView ;
import com . MAS . helpers . MessageHelper ;
import com . MAS . helpers . Values ;
import com . MAS . utils . HTTPUtil ;
public class PostMessageActivity extends Activity implements OnClickListener , OnTouchListener {
public final int ACTION_TAKE_VIDEO = <num> ;
public final int <unk> = <num> ;
File f = null ;
String filename = null ;
TextView txt ;
EditText tagtext ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . postlayout ) ;
Intent sender = getIntent ( ) ;
String extraData = sender . getExtras ( ) . getString ( Values . COMING_FROM ) ;
Typeface font = Typeface . createFromAsset ( getAssets ( ) , " ) ;
Typeface editfont = Typeface . createFromAsset ( getAssets ( ) , " ) ;
TextView txt_img_capture = ( TextView ) findViewById ( R . id . image_capture ) ;
TextView txt_video_capture = ( TextView ) findViewById ( R . id . video_capture ) ;
txt = ( TextView ) findViewById ( R . id . message_text ) ;
txt . setTypeface ( editfont ) ;
txt_img_capture . setTypeface ( font ) ;
txt_video_capture . setTypeface ( font ) ;
txt . setOnTouchListener ( this ) ;
if ( extraData . equals ( Values . COMING_FROM_YOUTUBE ) )
{
String editText = sender . getExtras ( ) . getString ( " ) ;
EditText textbox = ( EditText ) findViewById ( R . id . message_text ) ;
textbox . setText ( editText , TextView . BufferType . NORMAL ) ;
}
View submitButton = findViewById ( R . id . submit_button ) ;
tagtext = ( EditText ) findViewById ( R . id . tag_text ) ;
submitButton . setOnClickListener ( this ) ;
}
public void onClick ( View v )
{
EditText editText = ( EditText ) findViewById ( R . id . message_text ) ;
String editTextStr = editText . getText ( ) . toString ( ) ;
String tag = tagtext . getText ( ) . toString ( ) ;
tagtext . setText ( " ) ;
TextView t = new TextView ( this ) ;
t = ( TextView ) findViewById ( R . id . posted_message ) ;
t . setVisibility ( View . VISIBLE ) ;
t . setText ( editTextStr ) ;
TextView p = new TextView ( this ) ;
p = ( TextView ) findViewById ( R . id . message_text ) ;
p . setText ( " ) ;
MessageHelper message = new MessageHelper ( ) ;
List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ;
params = message . createMessage ( this . getApplicationContext ( ) , editTextStr , tag ) ;
HTTPUtil http = new HTTPUtil ( ) ;
JSONObject response = new JSONObject ( ) ;
try {
response = http . Execute ( params , Values . POSTMESSAGE_URL ) ;
} catch ( ClientProtocolException e ) {
System . out . println ( " ) ;
} catch ( IOException e ) {
System . out . println ( " ) ;
}
String messageText = " ;
String timestamp = " ;
try {
messageText = response . getString ( Values . MESSAGE ) ;
timestamp = response . getString ( Values . TIMESTAMP ) ;
} catch ( JSONException e ) {
messageText = " ;
timestamp = " ;
e . printStackTrace ( ) ;
}
Log . d ( null , response . toString ( ) ) ;
}
public void startVideo ( View view )
{
Intent i = new Intent ( ) ;
i . setAction ( MediaStore . <unk> ) ;
try {
f = createVideoFile ( ) ;
} catch ( IOException e ) {
Log . e ( " , " ) ;
e . printStackTrace ( ) ;
}
i . putExtra ( MediaStore . EXTRA_OUTPUT , Uri . fromFile ( f ) ) ;
startActivityForResult ( i , ACTION_TAKE_VIDEO ) ;
}
protected void onActivityResult ( int requestCode , int resultCode , Intent data )
{
if ( requestCode == ACTION_TAKE_VIDEO )
{
Log . d ( " , " ) ;
}
Intent i = new Intent ( this , YouTubeLoginActivity . class ) ;
i . putExtra ( " , f ) ;
i . putExtra ( " , filename ) ;
startActivity ( i ) ;
}
public File createVideoFile ( ) throws IOException {
String timeStamp =
new SimpleDateFormat ( " ) . format ( new Date ( ) ) ;
String videoFileName = Values . MP4_FILE_PREFIX + timeStamp + " ;
File image = File . createTempFile (
videoFileName ,
Values . MP4_FILE_SUFFIX ,
Environment . getExternalStoragePublicDirectory (
Environment . <unk>
)
) ;
String mCurrentVideoPath = image . getAbsolutePath ( ) ;
Log . d ( " , mCurrentVideoPath ) ;
filename = image . getName ( ) ;
return image ;
}
public boolean onTouch ( View v , MotionEvent event ) {
EditText focusEditText = ( EditText ) v ;
String contents = focusEditText . getText ( ) . toString ( ) ;
if ( contents . equals ( " ) )
{
focusEditText . setText ( " ) ;
return false ;
}
return false ;
}
package com . MAS . Lighthouse ;
import java . io . IOException ;
import java . util . List ;
import org . apache . http . NameValuePair ;
import org . apache . http . client . ClientProtocolException ;
import org . json . JSONException ;
import org . json . JSONObject ;
import com . MAS . utils . * ;
import com . MAS . helpers . * ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . app . Dialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . os . Bundle ;
import android . text . InputType ;
import android . util . Log ;
import android . view . MotionEvent ;
import android . view . View ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . TextView ;
import android . widget . Toast ;
public class LoginActivity extends Activity implements View . OnTouchListener
{
private Button loginpageloginbutton ;
private TextView loginpagesignupbutton ;
private EditText username ;
private EditText password ;
private static final int <unk> = <num> ;
@Override
public void onCreate ( Bundle savedInstanceState )
{
if ( PreferencesUtil . checkLoggedIn ( this ) ) {
finish ( ) ;
Intent myIntent = new Intent ( this , MainActivity . class ) ;
startActivity ( myIntent ) ;
}
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . loginlayout ) ;
loginpageloginbutton = ( Button ) findViewById ( R . id . loginpageloginbutton ) ;
loginpagesignupbutton = ( TextView ) findViewById ( R . id . link_to_register ) ;
loginpagesignupbutton . setOnClickListener ( new View . OnClickListener ( ) {
public void onClick ( View v ) {
Intent i = new Intent ( getApplicationContext ( ) , SignUpActivity . class ) ;
startActivity ( i ) ;
}
} ) ;
username = ( EditText ) findViewById ( R . id . loginpageusername ) ;
password = ( EditText ) findViewById ( R . id . loginpagepassword ) ;
username . setOnTouchListener ( this ) ;
password . setOnTouchListener ( this ) ;
}
@Override
protected void onResume ( )
{
super . onResume ( ) ;
Log . d ( " , " ) ;
username . setText ( R . string . username ) ;
password . setText ( R . string . password ) ;
}
public void login ( View view )
{
String userNameText = username . getText ( ) . toString ( ) . replace (  ' , _' ) ;
if ( userNameText . equals ( " ) )
{
userNameText = " ;
}
String passwordText = password . getText ( ) . toString ( ) . replace (  ' , _' ) ;
if ( passwordText . equals ( " ) )
{
passwordText = " ;
}
LoginHelper login = new LoginHelper ( ) ;
List < NameValuePair > params = login . createMessage ( this . getApplicationContext ( ) , userNameText , passwordText ) ;
JSONObject response = new JSONObject ( ) ;
HTTPUtil http = new HTTPUtil ( ) ;
try {
response = http . Execute ( params , Values . LOGIN_URL ) ;
} catch ( ClientProtocolException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
String success = " ;
try {
success = response . getString ( Values . SUCCESS ) ;
} catch ( JSONException e ) {
success = " ;
}
String error ;
try {
error = response . getString ( Values . ERROR_CODE ) ;
} catch ( JSONException e ) {
error = " ;
}
if ( success . equals ( " ) )
{
PreferencesUtil . loggedin ( this ) ;
Intent i = new Intent ( this , MainActivity . class ) ;
startActivity ( i ) ;
}
else
{
int ERROR_CODE = Integer . parseInt ( error ) ;
showDialog ( ERROR_CODE ) ;
}
}
public void signup ( View view )
{
Intent i = new Intent ( this , SignUpActivity . class ) ;
startActivity ( i ) ;
}
public boolean onTouch ( View v , MotionEvent event )
{
EditText focusEditText = ( EditText ) v ;
String contents = focusEditText . getText ( ) . toString ( ) ;
if ( contents . equals ( " ) )
{
focusEditText . setText ( " ) ;
return false ;
}
if ( contents . equals ( " ) )
{
focusEditText . setText ( " ) ;
focusEditText . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_PASSWORD ) ;
return false ;
}
return false ;
}
@Override
protected Dialog onCreateDialog ( int id )
{
if ( id == <num> )
{
AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ;
builder . setTitle ( " ) ;
builder . setMessage ( " ) ;
builder . setIcon ( R . drawable . ic_launcher ) ;
builder . setPositiveButton ( R . string . retry , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int which )
{
return ;
}
} ) ;
return builder . create ( ) ;
}
else if ( id == <num> )
{
AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ;
builder . setTitle ( " ) ;
builder . setMessage ( " ) ;
builder . setIcon ( R . drawable . ic_launcher ) ;
builder . setPositiveButton ( R . string . retry , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int which )
{
return ;
}
} ) ;
return builder . create ( ) ;
}
return null ;
}
package com . MAS . Lighthouse ;
import java . io . IOException ;
import java . util . List ;
import org . apache . http . NameValuePair ;
import org . apache . http . client . ClientProtocolException ;
import org . json . JSONException ;
import org . json . JSONObject ;
import com . MAS . helpers . SignUpHelper ;
import com . MAS . helpers . Values ;
import com . MAS . utils . HTTPUtil ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . app . Dialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . os . Bundle ;
import android . text . InputType ;
import android . view . MotionEvent ;
import android . view . View ;
import android . widget . Button ;
import android . widget . EditText ;
public class SignUpActivity extends Activity implements View . OnTouchListener {
private EditText signupname ;
private EditText signupusername ;
private EditText signuppassword ;
private EditText <unk> ;
private Button signuppagebutton ;
String details ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . signuplayout ) ;
signupname = ( EditText ) findViewById ( R . id . signupname ) ;
signupusername = ( EditText ) findViewById ( R . id . signupusername ) ;
signuppassword = ( EditText ) findViewById ( R . id . signuppassword ) ;
signuppagebutton = ( Button ) findViewById ( R . id . signuppagebutton ) ;
signupname . setOnTouchListener ( this ) ;
signupusername . setOnTouchListener ( this ) ;
signuppassword . setOnTouchListener ( this ) ;
}
@Override
protected void onResume ( ) {
super . onRestart ( ) ;
setContentView ( R . layout . signuplayout ) ;
signupname = ( EditText ) findViewById ( R . id . signupname ) ;
signupusername = ( EditText ) findViewById ( R . id . signupusername ) ;
signuppassword = ( EditText ) findViewById ( R . id . signuppassword ) ;
signuppagebutton = ( Button ) findViewById ( R . id . signuppagebutton ) ;
signupname . setOnTouchListener ( this ) ;
signupusername . setOnTouchListener ( this ) ;
signuppassword . setOnTouchListener ( this ) ;
}
public void createaccount ( View v ) {
SignUpHelper signup = new SignUpHelper ( ) ;
List < NameValuePair > params = signup . createMessage ( this . getApplicationContext ( ) , signupusername . getText ( ) . toString ( ) , signuppassword . getText ( ) . toString ( ) , signupname . getText ( ) . toString ( ) ) ;
HTTPUtil http = new HTTPUtil ( ) ;
JSONObject response = null ;
try {
response = http . Execute ( params , Values . SIGNUP_URL ) ;
} catch ( ClientProtocolException e1 ) {
e1 . printStackTrace ( ) ;
} catch ( IOException e1 ) {
e1 . printStackTrace ( ) ;
}
String success = " ;
try {
success = response . getString ( Values . SUCCESS ) ;
} catch ( JSONException e ) {
success = " ;
}
try {
this . details = response . getString ( Values . DETAILS ) ;
} catch ( JSONException e ) {
this . details = " ;
}
if ( success . equals ( " ) )
{
Intent i = new Intent ( this , MainActivity . class ) ;
startActivity ( i ) ;
}
else
{
int ERROR_CODE = <num> ;
showDialog ( ERROR_CODE ) ;
}
}
public boolean onTouch ( View v , MotionEvent event ) {
EditText focusEditText = ( EditText ) v ;
String contents = focusEditText . getText ( ) . toString ( ) ;
if ( contents . equals ( " ) ) {
focusEditText . setText ( " ) ;
return false ;
}
if ( contents . equals ( " ) ) {
focusEditText . setText ( " ) ;
focusEditText . setInputType ( InputType . TYPE_CLASS_TEXT
| InputType . TYPE_TEXT_VARIATION_PASSWORD ) ;
return false ;
}
if ( contents . equals ( " ) ) {
focusEditText . setText ( " ) ;
return false ;
}
return false ;
}
@Override
protected Dialog onCreateDialog ( int id ) {
if ( id == <num> ) {
AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ;
builder . setTitle ( " ) ;
builder . setMessage ( this . details ) ;
builder . setIcon ( R . drawable . ic_launcher ) ;
builder . setPositiveButton ( R . string . retry ,
new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int which ) {
return ;
}
} ) ;
return builder . create ( ) ;
}
return null ;
}
package com . MAS . Lighthouse ;
import java . io . File ;
import java . io . IOException ;
import java . io . UnsupportedEncodingException ;
import java . net . MalformedURLException ;
import java . net . URL ;
import java . util . ArrayList ;
import java . util . List ;
import org . apache . http . HttpEntity ;
import org . apache . http . HttpResponse ;
import org . apache . http . NameValuePair ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . client . entity . UrlEncodedFormEntity ;
import org . apache . http . client . methods . HttpPost ;
import org . apache . http . client . methods . HttpPut ;
import org . apache . http . impl . client . DefaultHttpClient ;
import org . apache . http . message . BasicNameValuePair ;
import org . apache . http . params . HttpParams ;
import org . json . JSONException ;
import org . json . JSONObject ;
import com . MAS . helpers . GoogleLibraryHelper ;
import com . MAS . helpers . Values ;
import com . MAS . helpers . YouTubeAuthHelper ;
import com . MAS . helpers . YouTubeHelper ;
import com . MAS . utils . HTTPUtil ;
import com . MAS . utils . HTTPPutUtil ;
import com . google . gdata . client . youtube . YouTubeService ;
import com . google . gdata . data . media . MediaFileSource ;
import com . google . gdata . data . media . mediarss . MediaCategory ;
import com . google . gdata . data . media . mediarss . MediaDescription ;
import com . google . gdata . data . media . mediarss . MediaKeywords ;
import com . google . gdata . data . media . mediarss . MediaTitle ;
import com . google . gdata . data . youtube . VideoEntry ;
import com . google . gdata . data . youtube . YouTubeMediaGroup ;
import com . google . gdata . data . youtube . YouTubeNamespace ;
import com . google . gdata . util . AuthenticationException ;
import com . google . gdata . util . ServiceException ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . app . Dialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . os . Bundle ;
import android . text . InputType ;
import android . util . Log ;
import android . view . MotionEvent ;
import android . view . View ;
import android . view . View . OnTouchListener ;
import android . widget . EditText ;
public class YouTubeLoginActivity extends Activity implements OnTouchListener {
File videofile = null ;
String videofilename = null ;
EditText usernameedt ;
EditText passwordedt ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . youtubeloginlayout ) ;
Bundle extras = getIntent ( ) . getExtras ( ) ;
if ( extras != null )
{
videofile = ( File ) extras . get ( " ) ;
videofilename = ( String ) extras . getString ( " ) ;
}
usernameedt = ( EditText ) findViewById ( R . id . youtubeusername ) ;
passwordedt = ( EditText ) findViewById ( R . id . youtubepassword ) ;
usernameedt . setOnTouchListener ( this ) ;
passwordedt . setOnTouchListener ( this ) ;
}
public void getAuthToken ( View view ) throws MalformedURLException , IOException , ServiceException
{
String username = usernameedt . getText ( ) . toString ( ) ;
String password = passwordedt . getText ( ) . toString ( ) ;
if ( username == null || password == null )
{
showDialog ( <num> ) ;
}
YouTubeService service = new YouTubeService ( " , Values . YOUTUBE_DEVELOPER_CODE ) ;
service . <unk> ( username , password ) ;
VideoEntry newEntry = new VideoEntry ( ) ;
YouTubeMediaGroup mg = newEntry . <unk> ( ) ;
mg . setTitle ( new MediaTitle ( ) ) ;
mg . getTitle ( ) . setPlainTextContent ( " ) ;
mg . addCategory ( new MediaCategory ( YouTubeNamespace . <unk> , " ) ) ;
mg . setKeywords ( new MediaKeywords ( ) ) ;
mg . getKeywords ( ) . addKeyword ( " ) ;
mg . getKeywords ( ) . addKeyword ( " ) ;
mg . setDescription ( new MediaDescription ( ) ) ;
mg . getDescription ( ) . setPlainTextContent ( " ) ;
mg . <unk> ( false ) ;
mg . addCategory ( new MediaCategory ( YouTubeNamespace . DEVELOPER_TAG_SCHEME , " ) ) ;
mg . addCategory ( new MediaCategory ( YouTubeNamespace . DEVELOPER_TAG_SCHEME , " ) ) ;
newEntry . setLocation ( " ) ;
MediaFileSource ms = new MediaFileSource ( videofile , " ) ;
newEntry . <unk> ( ms ) ;
String uploadUrl =
" ;
VideoEntry createdEntry = service . insert ( new URL ( uploadUrl ) , newEntry ) ;
String videoURL = createdEntry . <unk> ( ) . toString ( ) ;
Log . d ( " , videoURL ) ;
Intent j = new Intent ( ) ;
j . putExtra ( Values . COMING_FROM , Values . COMING_FROM_YOUTUBE ) ;
j . putExtra ( " , videoURL ) ;
startActivity ( j ) ;
finish ( ) ;
}
protected Dialog onCreateDialog ( int id )
{
AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ;
builder . setTitle ( " ) ;
builder . setMessage ( " ) ;
builder . setIcon ( R . drawable . youtubeimage ) ;
builder . setPositiveButton ( R . string . retry , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int which )
{
return ;
}
} ) ;
return builder . create ( ) ;
}
private String <unk> ( String AuthToken )
{
GoogleLibraryHelper googlelib = new GoogleLibraryHelper ( ) ;
String uploadurl = " ;
try {
uploadurl = googlelib . getUploadUrl ( AuthToken , videofilename ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
String messageText = sendVideo ( uploadurl ) ;
return messageText ;
}
public String sendVideo ( String uploadurl )
{
Long FILE_LENGTH = videofile . length ( ) ;
String VIDEO_FILE_LENGTH = FILE_LENGTH . toString ( ) ;
List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ;
params . add ( new BasicNameValuePair ( " , Values . YOUTUBE_UPLOAD_HOST ) ) ;
params . add ( new BasicNameValuePair ( " , Values . YOUTUBE_CONTENT_TYPE ) ) ;
params . add ( new BasicNameValuePair ( " , VIDEO_FILE_LENGTH ) ) ;
params . add ( new BasicNameValuePair ( " , videofile . toString ( ) ) ) ;
HTTPPutUtil http = new HTTPPutUtil ( ) ;
try {
http . Execute ( params , uploadurl ) ;
} catch ( ClientProtocolException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
String messageText = getActualUrl ( uploadurl ) ;
return messageText ;
}
public String getActualUrl ( String uploadurl )
{
String actualurl = " ;
String code = uploadurl . substring ( uploadurl . lastIndexOf ( /' ) + <num> ) ;
actualurl = actualurl + code ;
return actualurl ;
}
public boolean onTouch ( View v , MotionEvent event )
{
EditText focusEditText = ( EditText ) v ;
Log . d ( " , " ) ;
String contents = focusEditText . getText ( ) . toString ( ) ;
if ( contents . equals ( " ) )
{
focusEditText . setText ( " ) ;
return false ;
}
if ( contents . equals ( " ) )
{
focusEditText . setText ( " ) ;
focusEditText . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_VARIATION_PASSWORD ) ;
return false ;
}
return false ;
}
package com . MAS . utils ;
import com . MAS . helpers . Values ;
import android . content . Intent ;
public class <unk> {
public String VIDEO_FILE_NAME = " ;
public void <unk> ( Intent intent )
{
}
public String <unk> ( String AUTH_TOKEN )
{
String request = " + " ;
request = request + " + " ;
request = request + " + AUTH_TOKEN + " ;
request = request + " + " ;
request = request + " + Values . YOUTUBE_DEVELOPER_CODE + " ;
request = request + " + " ;
request = request + " + VIDEO_FILE_NAME ;
return request ;
}
package com . MAS . Lighthouse ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . List ;
import org . apache . http . NameValuePair ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . message . BasicNameValuePair ;
import org . json . JSONObject ;
import com . MAS . helpers . Values ;
import com . MAS . utils . HTTPUtil ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . widget . Button ;
import android . widget . TextView ;
public class SingleListItemActivity extends Activity {
Button like ;
TextView txtProduct ;
String messageText ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . setContentView ( R . layout . single_list_item ) ;
txtProduct = ( TextView ) findViewById ( R . id . posted_message ) ;
like = ( Button ) findViewById ( R . id . submit_button ) ;
Intent i = getIntent ( ) ;
messageText = i . getStringExtra ( " ) ;
String nick = i . getStringExtra ( " ) ;
txtProduct . setText ( nick + " + " + messageText ) ;
}
public void <unk> ( View v ) {
List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ;
params . add ( new BasicNameValuePair ( Values . MESSAGE , messageText ) ) ;
HTTPUtil http = new HTTPUtil ( ) ;
Log . d ( " , messageText ) ;
JSONObject response = new JSONObject ( ) ;
try {
response = http . Execute ( params , Values . LIKE_URL ) ;
} catch ( ClientProtocolException e ) {
System . out . println ( " ) ;
} catch ( IOException e ) {
System . out . println ( " ) ;
}
}
package com . MAS . utils ;
import java . io . BufferedReader ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . InputStreamReader ;
import java . io . UnsupportedEncodingException ;
import java . util . List ;
import org . apache . http . HttpEntity ;
import org . apache . http . HttpResponse ;
import org . apache . http . NameValuePair ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . client . entity . UrlEncodedFormEntity ;
import org . apache . http . client . methods . HttpPost ;
import org . apache . http . impl . client . DefaultHttpClient ;
import org . apache . http . params . HttpParams ;
import org . json . JSONException ;
import org . json . JSONObject ;
import com . MAS . helpers . Values ;
import android . util . Log ;
public class HTTPUtil {
static InputStream is = null ;
static JSONObject jObj = null ;
static String json = " ;
public JSONObject Execute ( List < NameValuePair > params , String method ) throws ClientProtocolException , IOException
{
String url = " ;
if ( method . equals ( Values . LOGIN_URL ) )
{
url = url + Values . LOGIN_URL ;
}
else if ( method . equals ( Values . SIGNUP_URL ) )
{
url = url + Values . SIGNUP_URL ;
}
else if ( method . equals ( Values . POSTMESSAGE_URL ) )
{
url = url + Values . POSTMESSAGE_URL ;
}
else if ( method . equals ( Values . GETMESSAGES_URL ) )
{
url = url + Values . GETMESSAGES_URL ;
}
else if ( method . equals ( Values . YOUTUBE_AUTH ) )
{
url = Values . YOUTUBE_AUTH_URL ;
}
else if ( method . equals ( Values . YOUTUBE_URL ) )
{
url = Values . YOUTUBE_URL ;
}
else if ( method . equals ( Values . LIKE_URL ) )
{
url = url + Values . LIKE_URL ;
}
else if ( method . equals ( Values . GETMESSAGESBYTAG_URL ) )
{
url = url + Values . GETMESSAGESBYTAG_URL ;
}
else
{
url = url + " ;
}
try {
DefaultHttpClient httpClient = new DefaultHttpClient ( ) ;
HttpPost httpPost = new HttpPost ( url ) ;
httpPost . setEntity ( ( HttpEntity ) new UrlEncodedFormEntity ( params ) ) ;
HttpResponse httpResponse = httpClient . execute ( httpPost ) ;
HttpEntity httpEntity = httpResponse . getEntity ( ) ;
is = httpEntity . getContent ( ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
} catch ( ClientProtocolException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
try {
BufferedReader reader = new BufferedReader ( new InputStreamReader ( is , " ) , <num> ) ;
StringBuilder sb = new StringBuilder ( ) ;
String line = null ;
while ( ( line = reader . readLine ( ) ) != null ) {
sb . append ( line + " ) ;
}
is . close ( ) ;
json = sb . toString ( ) ;
Log . e ( " , json ) ;
} catch ( Exception e ) {
Log . e ( " , " + e . toString ( ) ) ;
}
try {
if ( method . equals ( Values . YOUTUBE_AUTH ) )
{
jObj = parseString ( json ) ;
}
else
{
jObj = new JSONObject ( json ) ;
}
} catch ( JSONException e ) {
Log . e ( " , " + e . toString ( ) ) ;
}
return jObj ;
}
public JSONObject parseString ( String json )
{
JSONObject myjson = new JSONObject ( ) ;
int index = json . indexOf ( " ) ;
StringBuilder sb = new StringBuilder ( ) ;
for ( int i = index + <num> ; i < json . length ( ) && json . charAt ( i ) != \n' ; i ++ )
{
sb . append ( json . charAt ( i ) ) ;
}
try {
myjson . put ( " , sb . toString ( ) ) ;
} catch ( JSONException e ) {
e . printStackTrace ( ) ;
}
return myjson ;
}
public JSONObject Execute ( HttpParams params , String method ) throws ClientProtocolException , IOException
{
String url = Values . YOUTUBE_URL ;
String Location = " ;
try {
DefaultHttpClient httpClient = new DefaultHttpClient ( ) ;
HttpPost httpPost = new HttpPost ( url ) ;
httpPost . setParams ( params ) ;
HttpResponse httpResponse = httpClient . execute ( httpPost ) ;
HttpEntity httpEntity = httpResponse . getEntity ( ) ;
is = httpEntity . getContent ( ) ;
} catch ( UnsupportedEncodingException e ) {
e . printStackTrace ( ) ;
} catch ( ClientProtocolException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
try {
BufferedReader reader = new BufferedReader ( new InputStreamReader ( is , " ) , <num> ) ;
StringBuilder sb = new StringBuilder ( ) ;
String line = null ;
while ( ( line = reader . readLine ( ) ) != null ) {
sb . append ( line + " ) ;
}
is . close ( ) ;
json = sb . toString ( ) ;
Log . e ( " , json ) ;
} catch ( Exception e ) {
Log . e ( " , " + e . toString ( ) ) ;
}
try {
jObj = new JSONObject ( json ) ;
} catch ( JSONException e ) {
Log . e ( " , " + e . toString ( ) ) ;
}
return jObj ;
}
package com . MAS . utils ;
import android . content . Context ;
import android . telephony . TelephonyManager ;
public class DeviceUtil {
public String getDeviceId ( Context context )
{
TelephonyManager telephonyManager = ( TelephonyManager ) context . getSystemService ( Context . TELEPHONY_SERVICE ) ;
String deviceId = telephonyManager . getDeviceId ( ) ;
return deviceId ;
}
package com . MAS . helpers ;
import java . util . ArrayList ;
import java . util . List ;
import org . apache . http . NameValuePair ;
import org . apache . http . message . BasicNameValuePair ;
import com . MAS . utils . GPSUtil ;
import android . content . Context ;
import android . location . Location ;
public class ReceiveHelper {
Context context ;
public List < NameValuePair > createMessage ( Context context )
{
this . context = context ;
List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ;
GPSUtil gps = new GPSUtil ( ) ;
Location myLocation = gps . getGPSLocation ( this . context ) ;
double dbl = myLocation . getLatitude ( ) ;
int x = ( int ) ( dbl * <num> ) ;
Double latitude = ( double ) x / <num> ;
String lat = latitude . toString ( ) ;
dbl = myLocation . getLongitude ( ) ;
x = ( int ) ( dbl * <num> ) ;
Double longitude = ( double ) x / <num> ;
String longi = longitude . toString ( ) ;
params . add ( new BasicNameValuePair ( " , lat ) ) ;
params . add ( new BasicNameValuePair ( " , longi ) ) ;
return params ;
}
package com . MAS . helpers ;
import java . sql . Timestamp ;
import java . util . ArrayList ;
import java . util . List ;
import org . apache . http . NameValuePair ;
import org . apache . http . message . BasicNameValuePair ;
import com . MAS . utils . * ;
import android . content . Context ;
import android . location . Location ;
public class MessageHelper {
private String message_text ;
private String deviceId ;
private Location myLocation ;
private Timestamp timestamp ;
Context context ;
public List < NameValuePair > createMessage ( Context context , String message , String tag )
{
this . context = context ;
List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ;
this . message_text = message ;
params . add ( new BasicNameValuePair ( " , this . message_text ) ) ;
GPSUtil gps = new GPSUtil ( ) ;
this . myLocation = gps . getGPSLocation ( this . context ) ;
double dbl = myLocation . getLatitude ( ) ;
int x = ( int ) ( dbl * <num> ) ;
Double latitude = ( double ) x / <num> ;
String lat = latitude . toString ( ) ;
params . add ( new BasicNameValuePair ( " , lat ) ) ;
dbl = myLocation . getLongitude ( ) ;
x = ( int ) ( dbl * <num> ) ;
Double longitude = ( double ) x / <num> ;
String longi = longitude . toString ( ) ;
params . add ( new BasicNameValuePair ( " , longi ) ) ;
DeviceUtil device = new DeviceUtil ( ) ;
this . deviceId = device . getDeviceId ( this . context ) ;
params . add ( new BasicNameValuePair ( " , this . deviceId ) ) ;
TimestampUtil timestamp = new TimestampUtil ( ) ;
this . timestamp = timestamp . getTimeStamp ( ) ;
params . add ( new BasicNameValuePair ( " , this . timestamp . toString ( ) ) ) ;
params . add ( new BasicNameValuePair ( " , tag ) ) ;
return params ;
}
package com . MAS . helpers ;
public class Values
{
public static final String SUCCESS = " ;
public static final String NICKNAME = " ;
public static final String ERROR_CODE = " ;
public static final String TIMESTAMP = " ;
public static final String MESSAGE = " ;
public static final String MESSAGELIST = " ;
public static final String DETAILS = " ;
public static final String LOGIN_URL = " ;
public static final String SIGNUP_URL = " ;
public static final String POSTMESSAGE_URL = " ;
public static final String GETMESSAGES_URL = " ;
public static final String YOUTUBE_URL = " ;
public static final String YOUTUBE_AUTH_URL = " ;
public static final String <unk> = " ;
public static final String YOUTUBE_DEVELOPER_CODE = " ;
public static final String YOUTUBE_AUTH = " ;
public static final String YOUTUBE_SOURCE = " ;
public static final String YOUTUBE_AUTH_HEADER = " ;
public static final String MP4_FILE_PREFIX = " ;
public static final String MP4_FILE_SUFFIX = " ;
public static final String YOUTUBE_CONTENT_TYPE = " ;
public static final String YOUTUBE_UPLOAD_HOST = " ;
public static final String COMING_FROM = " ;
public static final String COMING_FROM_YOUTUBE = " ;
public static final String COMING_FROM_MAIN = " ;
public static final String LIKES = " ;
public static final String LIKE_URL = " ;
public static final String GETMESSAGESBYTAG_URL = " ;
package com . MAS . utils ;
import android . app . Activity ;
import android . content . Context ;
import android . content . SharedPreferences ;
import android . content . SharedPreferences . Editor ;
public class PreferencesUtil
{
public static final String SETTINGS_FILE_NAME = " ;
public static void loggedin ( Activity activity )
{
Editor editor = getPreferences ( activity ) . edit ( ) ;
editor . putBoolean ( " , true ) ;
editor . commit ( ) ;
}
public static SharedPreferences getPreferences ( Context context ) {
return context . getSharedPreferences ( SETTINGS_FILE_NAME , context . MODE_PRIVATE ) ;
}
public static boolean checkLoggedIn ( Activity activity )
{
return getPreferences ( activity ) . contains ( " ) ;
}
package com . MAS . helpers ;
import java . util . ArrayList ;
import java . util . List ;
import org . apache . http . NameValuePair ;
import org . apache . http . message . BasicNameValuePair ;
import com . MAS . utils . DeviceUtil ;
import android . content . Context ;
public class LoginHelper {
private static String username ;
private static String password ;
private static String userid ;
Context context ;
public List < NameValuePair > createMessage ( Context context , String user , String pass )
{
this . context = context ;
List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ;
DeviceUtil device = new DeviceUtil ( ) ;
userid = device . getDeviceId ( this . context ) ;
username = user ;
password = pass ;
params . add ( new BasicNameValuePair ( " , userid ) ) ;
params . add ( new BasicNameValuePair ( " , username ) ) ;
params . add ( new BasicNameValuePair ( " , password ) ) ;
return params ;
}
package com . MAS . Lighthouse ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import org . apache . http . NameValuePair ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . message . BasicNameValuePair ;
import org . json . JSONArray ;
import org . json . JSONException ;
import org . json . JSONObject ;
import com . MAS . helpers . ReceiveHelper ;
import com . MAS . helpers . Values ;
import com . MAS . utils . HTTPUtil ;
import android . app . Activity ;
import android . app . ListActivity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . ListAdapter ;
import android . widget . ListView ;
import android . widget . SimpleAdapter ;
import android . widget . TextView ;
public class DisplayMessageActivity extends ListActivity
{
Button search ;
EditText search_item ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . displaymessagelayout ) ;
Log . e ( " , " ) ;
search = ( Button ) findViewById ( R . id . search ) ;
search_item = ( EditText ) findViewById ( R . id . search_item ) ;
ArrayList < HashMap < String , String >> messageList = new ArrayList < HashMap < String , String >> ( ) ;
ReceiveHelper receive = new ReceiveHelper ( ) ;
List < NameValuePair > params = receive . createMessage ( this . getApplicationContext ( ) ) ;
HTTPUtil http = new HTTPUtil ( ) ;
JSONObject json ;
try {
json = http . Execute ( params , Values . GETMESSAGES_URL ) ;
} catch ( ClientProtocolException e1 ) {
json = null ;
e1 . printStackTrace ( ) ;
} catch ( IOException e1 ) {
json = null ;
e1 . printStackTrace ( ) ;
}
JSONArray message = new JSONArray ( ) ;
try {
message = json . getJSONArray ( Values . MESSAGELIST ) ;
for ( int i = <num> ; i < message . length ( ) ; i ++ ) {
JSONObject c = message . getJSONObject ( i ) ;
String text = c . getString ( Values . MESSAGE ) ;
String nickname = c . getString ( Values . NICKNAME ) + " ;
String timestamp = " + c . getString ( Values . TIMESTAMP ) ;
String nooflikes = c . getString ( Values . LIKES ) ;
Log . d ( " , timestamp ) ;
HashMap < String , String > map = new HashMap < String , String > ( ) ;
map . put ( Values . MESSAGE , text ) ;
map . put ( Values . NICKNAME , nickname ) ;
map . put ( Values . TIMESTAMP , timestamp ) ;
map . put ( Values . LIKES , nooflikes ) ;
messageList . add ( map ) ;
}
} catch ( JSONException e ) {
e . printStackTrace ( ) ;
}
ListAdapter adapter = new SimpleAdapter ( this , messageList ,
R . layout . displaylist_item ,
new String [ ] { Values . MESSAGE , Values . NICKNAME , Values . TIMESTAMP , Values . LIKES } , new int [ ] {
R . id . messageText_label , R . id . nickname_label , R . id . timestamp_label , R . id . nooflikes } ) ;
setListAdapter ( adapter ) ;
ListView lv = getListView ( ) ;
lv . setOnItemClickListener ( new OnItemClickListener ( ) {
public void onItemClick ( AdapterView < ? > parent , View view ,
int position , long id ) {
String messageText = ( ( TextView ) view . findViewById ( R . id . messageText_label ) ) . getText ( ) . toString ( ) ;
String nickname = ( ( TextView ) view . findViewById ( R . id . nickname_label ) ) . getText ( ) . toString ( ) ;
Intent in = new Intent ( getApplicationContext ( ) , SingleListItemActivity . class ) ;
in . putExtra ( " , messageText ) ;
in . putExtra ( " , nickname ) ;
startActivity ( in ) ;
}
} ) ;
}
@Override
protected void onResume ( ) {
super . onRestart ( ) ;
setContentView ( R . layout . displaymessagelayout ) ;
Log . e ( " , " ) ;
search = ( Button ) findViewById ( R . id . search ) ;
search_item = ( EditText ) findViewById ( R . id . search_item ) ;
ArrayList < HashMap < String , String >> messageList = new ArrayList < HashMap < String , String >> ( ) ;
ReceiveHelper receive = new ReceiveHelper ( ) ;
List < NameValuePair > params = receive . createMessage ( this . getApplicationContext ( ) ) ;
HTTPUtil http = new HTTPUtil ( ) ;
JSONObject json ;
try {
json = http . Execute ( params , Values . GETMESSAGES_URL ) ;
} catch ( ClientProtocolException e1 ) {
json = null ;
e1 . printStackTrace ( ) ;
} catch ( IOException e1 ) {
json = null ;
e1 . printStackTrace ( ) ;
}
JSONArray message = new JSONArray ( ) ;
try {
message = json . getJSONArray ( Values . MESSAGELIST ) ;
for ( int i = <num> ; i < message . length ( ) ; i ++ ) {
JSONObject c = message . getJSONObject ( i ) ;
String text = c . getString ( Values . MESSAGE ) ;
String nickname = c . getString ( Values . NICKNAME ) + " ;
String timestamp = " + c . getString ( Values . TIMESTAMP ) ;
String nooflikes = c . getString ( Values . LIKES ) ;
Log . d ( " , timestamp ) ;
HashMap < String , String > map = new HashMap < String , String > ( ) ;
map . put ( Values . MESSAGE , text ) ;
map . put ( Values . NICKNAME , nickname ) ;
map . put ( Values . TIMESTAMP , timestamp ) ;
map . put ( Values . LIKES , nooflikes ) ;
messageList . add ( map ) ;
}
} catch ( JSONException e ) {
e . printStackTrace ( ) ;
}
ListAdapter adapter = new SimpleAdapter ( this , messageList ,
R . layout . displaylist_item ,
new String [ ] { Values . MESSAGE , Values . NICKNAME , Values . TIMESTAMP , Values . LIKES } , new int [ ] {
R . id . messageText_label , R . id . nickname_label , R . id . timestamp_label , R . id . nooflikes } ) ;
setListAdapter ( adapter ) ;
ListView lv = getListView ( ) ;
lv . setOnItemClickListener ( new OnItemClickListener ( ) {
public void onItemClick ( AdapterView < ? > parent , View view ,
int position , long id ) {
String messageText = ( ( TextView ) view . findViewById ( R . id . messageText_label ) ) . getText ( ) . toString ( ) ;
String nickname = ( ( TextView ) view . findViewById ( R . id . nickname_label ) ) . getText ( ) . toString ( ) ;
Intent in = new Intent ( getApplicationContext ( ) , SingleListItemActivity . class ) ;
in . putExtra ( " , messageText ) ;
in . putExtra ( " , nickname ) ;
startActivity ( in ) ;
}
} ) ;
}
public void search ( View v )
{
String tag = search_item . getText ( ) . toString ( ) ;
search_item . setText ( " ) ;
ArrayList < HashMap < String , String >> messageList = new ArrayList < HashMap < String , String >> ( ) ;
ReceiveHelper receive = new ReceiveHelper ( ) ;
List < NameValuePair > params = receive . createMessage ( this . getApplicationContext ( ) ) ;
params . add ( new BasicNameValuePair ( " , tag ) ) ;
HTTPUtil http = new HTTPUtil ( ) ;
JSONObject json ;
try {
json = http . Execute ( params , Values . GETMESSAGESBYTAG_URL ) ;
} catch ( ClientProtocolException e1 ) {
json = null ;
e1 . printStackTrace ( ) ;
} catch ( IOException e1 ) {
json = null ;
e1 . printStackTrace ( ) ;
}
JSONArray message = new JSONArray ( ) ;
try {
message = json . getJSONArray ( Values . MESSAGELIST ) ;
for ( int i = <num> ; i < message . length ( ) ; i ++ ) {
JSONObject c = message . getJSONObject ( i ) ;
String text = c . getString ( Values . MESSAGE ) ;
String nickname = c . getString ( Values . NICKNAME ) + " ;
String timestamp = " + c . getString ( Values . TIMESTAMP ) ;
String nooflikes = c . getString ( Values . LIKES ) ;
Log . d ( " , timestamp ) ;
HashMap < String , String > map = new HashMap < String , String > ( ) ;
map . put ( Values . MESSAGE , text ) ;
map . put ( Values . NICKNAME , nickname ) ;
map . put ( Values . TIMESTAMP , timestamp ) ;
map . put ( Values . LIKES , nooflikes ) ;
messageList . add ( map ) ;
}
} catch ( JSONException e ) {
e . printStackTrace ( ) ;
}
ListAdapter adapter = new SimpleAdapter ( this , messageList ,
R . layout . displaylist_item ,
new String [ ] { Values . MESSAGE , Values . NICKNAME , Values . TIMESTAMP , Values . LIKES } , new int [ ] {
R . id . messageText_label , R . id . nickname_label , R . id . timestamp_label , R . id . nooflikes } ) ;
setListAdapter ( adapter ) ;
ListView lv = getListView ( ) ;
lv . setOnItemClickListener ( new OnItemClickListener ( ) {
public void onItemClick ( AdapterView < ? > parent , View view ,
int position , long id ) {
String messageText = ( ( TextView ) view . findViewById ( R . id . messageText_label ) ) . getText ( ) . toString ( ) ;
String nickname = ( ( TextView ) view . findViewById ( R . id . nickname_label ) ) . getText ( ) . toString ( ) ;
Intent in = new Intent ( getApplicationContext ( ) , SingleListItemActivity . class ) ;
in . putExtra ( " , messageText ) ;
in . putExtra ( " , nickname ) ;
startActivity ( in ) ;
}
} ) ;
}
package com . MAS . utils ;
import java . sql . Timestamp ;
import java . util . Date ;
public class TimestampUtil {
public Timestamp getTimeStamp ( )
{
long current_time ;
Date date = new Date ( ) ;
current_time = date . getTime ( ) ;
Timestamp currenttime = new Timestamp ( current_time ) ;
return currenttime ;
}
}
package com . MAS . helpers ;
import java . util . ArrayList ;
import java . util . List ;
import org . apache . http . NameValuePair ;
import org . apache . http . message . BasicNameValuePair ;
import android . content . Context ;
public class YouTubeAuthHelper {
public List < NameValuePair > createMessage ( Context context , String username , String password ) {
List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ;
params . add ( new BasicNameValuePair ( " , Values . YOUTUBE_AUTH_HEADER ) ) ;
params . add ( new BasicNameValuePair ( " , username ) ) ;
params . add ( new BasicNameValuePair ( " , password ) ) ;
params . add ( new BasicNameValuePair ( " , " ) ) ;
params . add ( new BasicNameValuePair ( " , Values . YOUTUBE_SOURCE ) ) ;
return params ;
}
package com . MAS . Lighthouse ;
public final class R {
public static final class attr {
}
public static final class color {
public static final int black = <num> ;
}
public static final class drawable {
public static final int arrow = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int camera = <num> ;
public static final int edge = <num> ;
public static final int find = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int heart = <num> ;
public static final int ic_launcher = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int icon = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int like = <num> ;
public static final int <unk> = <num> ;
public static final int logo = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int play = <num> ;
public static final int post = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int scan = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int settings = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int tick = <num> ;
public static final int <unk> = <num> ;
public static final int youtube = <num> ;
public static final int youtubeimage = <num> ;
}
public static final class id {
public static final int Post = <num> ;
public static final int PostText = <num> ;
public static final int Scan = <num> ;
public static final int <unk> = <num> ;
public static final int Settings = <num> ;
public static final int header = <num> ;
public static final int image_capture = <num> ;
public static final int like = <num> ;
public static final int link_to_register = <num> ;
public static final int <unk> = <num> ;
public static final int loginpageloginbutton = <num> ;
public static final int loginpagepassword = <num> ;
public static final int loginpageusername = <num> ;
public static final int messageText_label = <num> ;
public static final int message_text = <num> ;
public static final int nickname_label = <num> ;
public static final int nooflikes = <num> ;
public static final int posted_message = <num> ;
public static final int radius = <num> ;
public static final int search = <num> ;
public static final int search_item = <num> ;
public static final int signupname = <num> ;
public static final int signuppagebutton = <num> ;
public static final int signuppassword = <num> ;
public static final int signupusername = <num> ;
public static final int submit_button = <num> ;
public static final int tag_text = <num> ;
public static final int thumbnail = <num> ;
public static final int timestamp_label = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int video_capture = <num> ;
public static final int youtubeimage = <num> ;
public static final int youtubepassword = <num> ;
public static final int <unk> = <num> ;
public static final int youtubeusername = <num> ;
}
public static final class layout {
public static final int displaylist_item = <num> ;
public static final int <unk> = <num> ;
public static final int displaymessagelayout = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int loginlayout = <num> ;
public static final int main = <num> ;
public static final int postlayout = <num> ;
public static final int <unk> = <num> ;
public static final int signuplayout = <num> ;
public static final int single_list_item = <num> ;
public static final int youtubeloginlayout = <num> ;
}
public static final class string {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int app_name = <num> ;
public static final int <unk> = <num> ;
public static final int createaccount = <num> ;
public static final int <unk> = <num> ;
public static final int hello = <num> ;
public static final int login = <num> ;
public static final int nickname = <num> ;
public static final int password = <num> ;
public static final int retry = <num> ;
public static final int signup = <num> ;
public static final int username = <num> ;
public static final int youtubepassword = <num> ;
public static final int <unk> = <num> ;
public static final int youtubeusername = <num> ;
}
}
package com . MAS . utils ;
import android . content . Context ;
import android . location . * ;
public class GPSUtil {
private LocationManager mgr ;
private String best ;
public Location getGPSLocation ( Context context )
{
this . mgr = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ;
Criteria criteria = new Criteria ( ) ;
this . best = this . mgr . getBestProvider ( criteria , true ) ;
Location location = null ;
while ( location == null )
location = this . mgr . getLastKnownLocation ( this . best ) ;
return location ;
}
package com . MAS . helpers ;
import java . util . ArrayList ;
import java . util . List ;
import org . apache . http . NameValuePair ;
import org . apache . http . message . BasicNameValuePair ;
import org . apache . http . params . BasicHttpParams ;
import org . apache . http . params . HttpParams ;
import android . content . Context ;
public class YouTubeHelper {
<unk>
public HttpParams createMessage ( Context context , String AUTH_TOKEN , String VIDEO_FILE_NAME ) {
HttpParams params = new BasicHttpParams ( ) ;
params . setParameter ( " , " ) ;
params . setParameter ( " , new BasicNameValuePair ( " , AUTH_TOKEN ) ) ;
params . setParameter ( " , " ) ;
params . setParameter ( " , new BasicNameValuePair ( " , Values . YOUTUBE_DEVELOPER_CODE ) ) ;
params . setParameter ( " , <num> ) ;
params . setParameter ( " , VIDEO_FILE_NAME ) ;
return params ;
}
package com . MAS . helpers ;
import java . util . ArrayList ;
import java . util . List ;
import org . apache . http . NameValuePair ;
import org . apache . http . message . BasicNameValuePair ;
import com . MAS . utils . DeviceUtil ;
import android . content . Context ;
public class SignUpHelper {
private static String userid ;
private static String username ;
private static String password ;
private static String nickname ;
Context context ;
public List < NameValuePair > createMessage ( Context context , String user , String pass , String nick )
{
this . context = context ;
username = user ;
password = pass ;
nickname = nick ;
List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ;
DeviceUtil device = new DeviceUtil ( ) ;
userid = device . getDeviceId ( this . context ) ;
params . add ( new BasicNameValuePair ( " , userid ) ) ;
params . add ( new BasicNameValuePair ( " , username ) ) ;
params . add ( new BasicNameValuePair ( " , password ) ) ;
params . add ( new BasicNameValuePair ( " , nickname ) ) ;
return params ;
}
}
package com . MAS . helpers ;
import java . io . IOException ;
import android . util . Log ;
import com . google . api . client . googleapis . GoogleHeaders ;
import com . google . api . client . http . GenericUrl ;
import com . google . api . client . http . HttpRequest ;
import com . google . api . client . http . HttpRequestFactory ;
import com . google . api . client . http . HttpResponse ;
import com . google . api . client . http . <unk> ;
import com . google . api . client . http . <unk> . NetHttpTransport ;
public class GoogleLibraryHelper {
public String getUploadUrl ( String authToken , String videofilename ) throws IOException {
Log . d ( " , " ) ;
HttpRequestFactory requestFactory = new NetHttpTransport ( ) . <unk> ( ) ;
HttpRequest request = requestFactory . <unk> ( new GenericUrl ( Values . YOUTUBE_URL ) , null ) ;
GoogleHeaders headers = new GoogleHeaders ( ) ;
headers . setContentLength ( " ) ;
headers . <unk> ( " + Values . YOUTUBE_DEVELOPER_CODE ) ;
headers . <unk> ( " ) ;
headers . setAuthorization ( " + authToken ) ;
headers . <unk> ( videofilename ) ;
HttpResponse initialResponse = null ;
request . setHeaders ( headers ) ;
try {
initialResponse = request . execute ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
String uploadurl = initialResponse . getHeaders ( ) . getLocation ( ) ;
Log . d ( " , uploadurl ) ;
return uploadurl ;
}
package jmgr2007 . bukkit . RealTalk ;
import java . util . HashSet ;
import org . bukkit . command . Command ;
import org . bukkit . command . CommandExecutor ;
import org . bukkit . command . CommandSender ;
import org . bukkit . entity . Player ;
public class Commands implements CommandExecutor {
private RealTalk plugin ;
public Commands ( RealTalk instance ) {
plugin = instance ;
}
public static HashSet < String > fake = new HashSet < String > ( ) ;
@Override
public boolean onCommand ( CommandSender sender , Command cmd , String commandLabel , String [ ] args )
{
String logArgs = " ;
for ( int i = <num> ; i < args . length ; i ++ ) {
logArgs += " + args [ i ] ;
}
if ( sender instanceof Player ) {
System . out . println ( " + sender . getName ( ) + " + cmd . getName ( ) + logArgs ) ;
} else {
System . out . println ( " + cmd . getName ( ) + logArgs ) ;
}
if ( plugin . getConfig ( ) . getBoolean ( " ) == true ) {
if ( plugin . getServer ( ) . getPlayer ( " ) != null ) {
Player targetPlayer = plugin . getServer ( ) . getPlayer ( " ) ;
if ( sender instanceof Player ) {
Player player = ( Player ) sender ;
targetPlayer . sendMessage ( " + player . getName ( ) + " + cmd . getName ( ) + logArgs ) ;
} else {
targetPlayer . sendMessage ( " + sender . getName ( ) + " + cmd . getName ( ) + logArgs ) ;
}
}
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " )
&& sender . hasPermission ( " ) ) {
if ( args . length == <num> ) {
sender . sendMessage ( " ) ;
sender . sendMessage ( " ) ;
sender . sendMessage ( " ) ;
sender . sendMessage ( " ) ;
sender . sendMessage ( " ) ;
if ( fake . contains ( sender . getName ( ) ) )
sender . sendMessage ( " ) ;
} else if ( args . length >= <num> ) {
if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
plugin . reloadConfig ( ) ;
sender . sendMessage ( " ) ;
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( args . length >= <num> ) {
String allArgs = " ;
allArgs = allArgs + args [ <num> ] ;
for ( int i = <num> ; i < args . length ; i ++ ) {
allArgs += " + args [ i ] ;
}
allArgs . trim ( ) ;
allArgs = allArgs . replaceAll ( " , " ) ;
sender . sendMessage ( " + args [ <num> ] + " + allArgs + " ) ;
plugin . getConfig ( ) . set ( args [ <num> ] , allArgs ) ;
plugin . saveConfig ( ) ;
} else {
sender . sendMessage ( " ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( args . length == <num> ) {
String that = plugin . getConfig ( ) . getString ( args [ <num> ] ) ;
that = that . replaceAll ( " , " ) ;
sender . sendMessage ( " + args [ <num> ] + " + that + " ) ;
} else { sender . sendMessage ( " ) ;
}
} else if ( args [ <num> ] . equals ( " ) ) {
sender . sendMessage ( " ) ;
} else if ( args [ <num> ] . equals ( " ) ) {
if ( fake . contains ( sender . getName ( ) ) ) {
if ( plugin . getServer ( ) . getPlayer ( args [ <num> ] ) != null ) {
Player targetPlayer = plugin . getServer ( ) . getPlayer ( args [ <num> ] ) ;
String prefix = " ;
String suffix = " ;
if ( targetPlayer . isOp ( ) ) {
prefix = plugin . getConfig ( ) . getString ( " ) ;
suffix = plugin . getConfig ( ) . getString ( " ) ;
} else {
prefix = plugin . getConfig ( ) . getString ( " ) ;
suffix = plugin . getConfig ( ) . getString ( " ) ;
}
for ( int i = plugin . getConfig ( ) . getInt ( " ) ; i >= <num> ; i  ) {
if ( targetPlayer . hasPermission ( " + i ) ) {
prefix = plugin . getConfig ( ) . getString ( " + i + " ) ;
suffix = plugin . getConfig ( ) . getString ( " + i + " ) ;
}
}
String allArgs = " ;
allArgs = allArgs + args [ <num> ] ;
for ( int i = <num> ; i < args . length ; i ++ ) {
allArgs += " + args [ i ] ;
}
allArgs . trim ( ) ;
if ( targetPlayer . hasPermission ( " ) ) {
allArgs = allArgs . replaceAll ( " , " ) ;
}
prefix = prefix . replaceAll ( " , " ) ;
suffix = suffix . replaceAll ( " , " ) ;
String format = plugin . getConfig ( ) . getString ( " ) ;
format = format . replace ( " , prefix ) ;
format = format . replace ( " , suffix ) ;
format = format . replace ( " , targetPlayer . getDisplayName ( ) ) ;
format = format . replace ( " , allArgs ) ;
plugin . getServer ( ) . broadcastMessage ( format ) ;
} else {
sender . sendMessage ( " ) ;
}
} else {
sender . sendMessage ( " ) ;
}
}
}
return true ;
}
return false ;
}
}
package jmgr2007 . bukkit . RealTalk ;
import java . util . Set ;
import org . bukkit . Effect ;
import org . bukkit . Location ;
import org . bukkit . configuration . Configuration ;
import org . bukkit . entity . Player ;
import org . bukkit . event . EventHandler ;
import org . bukkit . event . Listener ;
import org . bukkit . event . player . PlayerChatEvent ;
import org . bukkit . event . player . PlayerJoinEvent ;
import org . bukkit . event . player . PlayerQuitEvent ;
public class Events implements Listener {
public static RealTalk plugin ;
public Configuration config ;
public Events ( RealTalk instance )
{
plugin = instance ;
}
@EventHandler
public void onPlayerChat ( PlayerChatEvent event ) {
String Message = event . getMessage ( ) ;
String prefix = " ;
String suffix = " ;
if ( event . getPlayer ( ) . hasPermission ( " ) ) {
Message = Message . replaceAll ( " , " ) ;
}
if ( plugin . getConfig ( ) . getBoolean ( " ) == true ) {
Set < Player > players = event . getRecipients ( ) ;
for ( Player player : players ) {
Location playerloc = player . getLocation ( ) ;
playerloc . getWorld ( ) . playEffect ( playerloc , Effect . CLICK1 , <num> ) ;
}
}
if ( event . getPlayer ( ) . isOp ( ) ) {
prefix = plugin . getConfig ( ) . getString ( " ) ;
suffix = plugin . getConfig ( ) . getString ( " ) ;
} else {
prefix = plugin . getConfig ( ) . getString ( " ) ;
suffix = plugin . getConfig ( ) . getString ( " ) ;
}
for ( int i = <num> ; i >= plugin . getConfig ( ) . getInt ( " ) ; i ++ ) {
if ( event . getPlayer ( ) . hasPermission ( " + i ) ) {
prefix = plugin . getConfig ( ) . getString ( " + i + " ) ;
suffix = plugin . getConfig ( ) . getString ( " + i + " ) ;
}
}
prefix = prefix . replaceAll ( " , " ) ;
suffix = suffix . replaceAll ( " , " ) ;
String format = plugin . getConfig ( ) . getString ( " ) ;
format = format . replace ( " , prefix ) ;
format = format . replace ( " , suffix ) ;
format = format . replace ( " , event . getPlayer ( ) . getDisplayName ( ) ) ;
format = format . replace ( " , Message ) ;
event . setFormat ( format ) ;
}
@EventHandler
public void onPlayerJoin ( PlayerJoinEvent event ) {
String Message = " ;
Player player = event . getPlayer ( ) ;
Message = plugin . getConfig ( ) . getString ( " ) ;
Message = Message . replaceAll ( " , " ) ;
Message = Message . replaceAll ( " , player . getDisplayName ( ) ) ;
event . setJoinMessage ( Message ) ;
}
@EventHandler
public void onPlayerQuit ( PlayerQuitEvent event ) {
String Message = " ;
Player player = event . getPlayer ( ) ;
Message = plugin . getConfig ( ) . getString ( " ) ;
Message = Message . replaceAll ( " , " ) ;
Message = Message . replaceAll ( " , player . getDisplayName ( ) ) ;
event . setQuitMessage ( Message ) ;
}
package jmgr2007 . bukkit . RealTalk ;
import java . io . File ;
import org . bukkit . Effect ;
import org . bukkit . Location ;
import org . bukkit . command . Command ;
import org . bukkit . command . CommandSender ;
import org . bukkit . entity . Player ;
import org . bukkit . plugin . PluginDescriptionFile ;
import org . bukkit . plugin . PluginManager ;
import org . bukkit . plugin . java . JavaPlugin ;
public class RealTalk extends JavaPlugin {
private final Events listener = new Events ( this ) ;
private final Commands commands = new Commands ( this ) ;
public void onEnable ( ) {
PluginDescriptionFile pdffile = this . getDescription ( ) ;
initialConfigCheck ( ) ;
this . getLogger ( ) . info ( " + pdffile . getVersion ( ) + " ) ;
PluginManager pm = getServer ( ) . getPluginManager ( ) ;
pm . registerEvents ( listener , this ) ;
getCommand ( " ) . setExecutor ( commands ) ;
}
private void initialConfigCheck ( ) {
getConfig ( ) . options ( ) . copyDefaults ( true ) ;
if ( ! ( new File ( this . getDataFolder ( ) , " ) . exists ( ) ) ) {
this . getLogger ( ) . info ( " ) ;
this . saveDefaultConfig ( ) ;
}
}
public void onDisable ( ) {
PluginDescriptionFile pdffile = this . getDescription ( ) ;
this . getLogger ( ) . info ( " + pdffile . getVersion ( ) + " ) ;
}
public boolean onCommand ( CommandSender sender , Command cmd , String commandLabel , String [ ] args )
{
String logArgs = " ;
for ( int i = <num> ; i < args . length ; i ++ ) {
logArgs += " + args [ i ] ;
}
if ( sender instanceof Player ) {
System . out . println ( " + sender . getName ( ) + " + cmd . getName ( ) + logArgs ) ;
} else {
System . out . println ( " + cmd . getName ( ) + logArgs ) ;
}
if ( this . getConfig ( ) . getBoolean ( " ) == true ) {
if ( this . getServer ( ) . getPlayer ( " ) != null ) {
Player targetPlayer = this . getServer ( ) . getPlayer ( " ) ;
if ( sender instanceof Player ) {
Player player = ( Player ) sender ;
targetPlayer . sendMessage ( " + player . getName ( ) + " + cmd . getName ( ) + logArgs ) ;
} else {
targetPlayer . sendMessage ( " + sender . getName ( ) + " + cmd . getName ( ) + logArgs ) ;
}
}
}
if ( commandLabel . equalsIgnoreCase ( " )
|| commandLabel . equalsIgnoreCase ( " )
|| commandLabel . equalsIgnoreCase ( " )
|| commandLabel . equalsIgnoreCase ( " )
|| commandLabel . equalsIgnoreCase ( " ) ) {
if ( sender . hasPermission ( " ) ) {
if ( getServer ( ) . getPlayer ( args [ <num> ] ) != null ) {
Player targetPlayer = getServer ( ) . getPlayer ( args [ <num> ] ) ;
String allArgs = " ;
allArgs = allArgs + args [ <num> ] ;
for ( int i = <num> ; i < args . length ; i ++ ) {
allArgs += " + args [ i ] ;
}
allArgs . trim ( ) ;
if ( sender . hasPermission ( " ) ) {
allArgs = allArgs . replaceAll ( " , " ) ;
}
if ( sender instanceof Player ) {
Player player = ( Player ) sender ;
targetPlayer . sendMessage ( " + player . getDisplayName ( ) + " + " + allArgs ) ;
} else {
targetPlayer . sendMessage ( " + allArgs ) ;
}
sender . sendMessage ( " + targetPlayer . getDisplayName ( ) + " + allArgs ) ;
Location playerloc = targetPlayer . getLocation ( ) ;
playerloc . getWorld ( ) . playEffect ( playerloc , Effect . <unk> , <num> ) ;
} else {
sender . sendMessage ( " ) ;
}
}
return true ;
}
if ( commandLabel . equalsIgnoreCase ( " ) ) {
if ( sender . hasPermission ( " ) ) {
if ( sender instanceof Player ) {
Player player = ( Player ) sender ;
String allArgs = " ;
for ( int i = <num> ; i < args . length ; i ++ ) {
allArgs += " + args [ i ] ;
}
allArgs = allArgs . trim ( ) ;
this . getServer ( ) . broadcastMessage ( " + player . getDisplayName ( ) + " + allArgs ) ;
}
}
return true ;
}
if ( commandLabel . equalsIgnoreCase ( " ) ) {
int x = <num> ;
if ( sender . hasPermission ( " ) ) {
if ( sender instanceof Player ) {
Player p = ( Player ) sender ;
if ( args . length == <num> ) {
while ( x <= <num> ) {
p . sendMessage ( " ) ;
x ++ ;
}
}
}
}
return true ;
}
return false ;
}
}
package placeholderDatabeans ;
import java . text . NumberFormat ;
public class StatBean {
private Integer kills ;
private Integer deaths ;
private Integer wins ;
private Integer losses ;
private Integer time ;
private Integer shots ;
private Integer hits ;
public StatBean ( ) {
setKills ( <num> ) ;
setDeaths ( <num> ) ;
setWins ( <num> ) ;
setLosses ( <num> ) ;
setTime ( <num> ) ;
setShots ( <num> ) ;
setHits ( <num> ) ;
}
public Integer getKills ( ) {
return kills ;
}
public void setKills ( Integer kills ) {
this . kills = kills ;
}
public Integer getDeaths ( ) {
return deaths ;
}
public void setDeaths ( Integer deaths ) {
this . deaths = deaths ;
}
public Integer getWins ( ) {
return wins ;
}
public void setWins ( Integer wins ) {
this . wins = wins ;
}
public Integer getLosses ( ) {
return losses ;
}
public void setLosses ( Integer losses ) {
this . losses = losses ;
}
public Integer getTime ( ) {
return time ;
}
public void setTime ( Integer time ) {
this . time = time ;
}
public Integer getShots ( ) {
return shots ;
}
public void setShots ( Integer shots ) {
this . shots = shots ;
}
public Integer getHits ( ) {
return hits ;
}
public void setHits ( Integer hits ) {
this . hits = hits ;
}
public void onGameFinish ( StatBean finishedGameStats ) {
setKills ( getKills ( ) + finishedGameStats . getKills ( ) ) ;
setDeaths ( getDeaths ( ) + finishedGameStats . getDeaths ( ) ) ;
setWins ( getWins ( ) + finishedGameStats . getWins ( ) ) ;
setLosses ( getLosses ( ) + finishedGameStats . getLosses ( ) ) ;
setTime ( getTime ( ) + finishedGameStats . getTime ( ) ) ;
setShots ( getShots ( ) + finishedGameStats . getShots ( ) ) ;
setHits ( getHits ( ) + finishedGameStats . getHits ( ) ) ;
}
public String getAccuracy ( ) {
if ( getHits ( ) == <num> )
return " ;
Float floatShots = Float . valueOf ( getShots ( ) ) ;
Float floatHits = Float . valueOf ( getHits ( ) ) ;
Float ratio = floatHits / floatShots ;
ratio = ratio * <num> ;
NumberFormat nf = NumberFormat . getInstance ( ) ;
nf . setMaximumFractionDigits ( <num> ) ;
nf . setMinimumFractionDigits ( <num> ) ;
return nf . format ( ratio ) + " ;
}
}
package placeholderDatabeans ;
public class UserBean {
private String name ;
private String password ;
private StatBean lastGameStats = new StatBean ( ) ;
private StatBean totalStats = new StatBean ( ) ;
public UserBean ( ) { }
public UserBean ( String name ) {
setName ( name ) ;
setLastGameStats ( new StatBean ( ) ) ;
setTotalStats ( new StatBean ( ) ) ;
}
public static UserBean <unk> = new UserBean ( " ) ;
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
public String getPassword ( ) {
return password ;
}
public void setPassword ( String password ) {
this . password = password ;
}
public StatBean getLastGameStats ( ) {
return lastGameStats ;
}
public void setLastGameStats ( StatBean lastGameStats ) {
this . lastGameStats = lastGameStats ;
}
public StatBean getTotalStats ( ) {
return totalStats ;
}
public void setTotalStats ( StatBean totalStats ) {
this . totalStats = totalStats ;
}
public void onGameFinish ( ) {
setLastGameStats ( fromLastGamePlaceholder ( ) ) ;
getTotalStats ( ) . onGameFinish ( getLastGameStats ( ) ) ;
}
private StatBean fromLastGamePlaceholder ( ) {
StatBean stat = new StatBean ( ) ;
stat . setKills ( <num> ) ;
stat . setDeaths ( <num> ) ;
stat . setHits ( <num> ) ;
stat . setShots ( <num> ) ;
stat . setWins ( <num> ) ;
stat . setLosses ( <num> ) ;
return stat ;
}
}
package <unk> ;
import java . util . HashMap ;
import java . util . Map ;
import placeholderDatabeans . UserBean ;
import com . opensymphony . xwork2 . ActionContext ;
import com . opensymphony . xwork2 . util . <unk> ;
public class <unk> {
private String name ;
private String target ;
private static final String SUMMARY = " ;
private static final String SUCCESS = " ;
public String login ( ) throws Exception {
Map < String , Object > session = ActionContext . getContext ( ) . getSession ( ) ;
if ( session . get ( " ) == null ) {
UserBean user = new UserBean ( ) ;
user . setName ( name ) ;
user . getTotalStats ( ) . setShots ( <num> ) ;
user . getTotalStats ( ) . setHits ( <num> ) ;
user . onGameFinish ( ) ;
session . put ( " , user ) ;
}
return SUMMARY ;
}
public String nav ( ) throws Exception {
return getTarget ( ) ;
}
public String logout ( ) throws Exception {
Map < String , Object > session = ActionContext . getContext ( ) . getSession ( ) ;
session . remove ( " ) ;
return SUCCESS ;
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
public String getTarget ( ) {
return target ;
}
public void setTarget ( String target ) {
this . target = target ;
}
}
package com . <unk> . <unk> . servlet ;
import java . io . FileInputStream ;
import java . io . IOException ;
import java . io . PrintWriter ;
import javax . servlet . ServletException ;
import javax . servlet . annotation . WebServlet ;
import javax . servlet . http . HttpServlet ;
import javax . servlet . http . HttpServletRequest ;
import javax . servlet . http . HttpServletResponse ;
<unk>
public class EnviarPDFServlet extends HttpServlet {
private static final long serialVersionUID = <num> ;
public EnviarPDFServlet ( ) {
super ( ) ;
}
protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException {
String caminho = request . getParameter ( " ) ;
PrintWriter saida = response . getWriter ( ) ;
response . setContentType ( " ) ;
FileInputStream fis = new FileInputStream ( caminho ) ;
try {
int c ;
while ( ( c = fis . read ( ) ) !=  <num> ) {
saida . write ( c ) ;
}
} finally {
if ( fis != null ) {
fis . close ( ) ;
}
}
saida . close ( ) ;
}
}
package net . minecraft . src ;
import java . util . Random ;
public class KonungBlockAlchemyWhiteRoot extends BlockFlower
{
public KonungBlockAlchemyWhiteRoot ( int i , int j )
{
super ( i , j ) ;
float f = <num> F ;
setBlockBounds ( <num> F  f , <num> F , <num> F  f , <num> F + f , f * <num> F , <num> F + f ) ;
setTickRandomly ( true ) ;
}
public int idDropped ( int i , Random random )
{
if ( blockID == mod_konungAlchemy . KonungNut . blockID )
{
return mod_konungAlchemy . KonungNut . blockID ;
}
else
{
return blockID ;
}
}
public int quantityDropped ( Random random )
{
return <num> ;
}
public void updateTick ( World world , int i , int j , int k , Random random )
{
if ( random . nextInt ( <num> ) == <num> )
{
int l = ( i + random . nextInt ( <num> ) )  <num> ;
int i1 = ( j + random . nextInt ( <num> ) )  random . nextInt ( <num> ) ;
int j1 = ( k + random . nextInt ( <num> ) )  <num> ;
if ( world . isAirBlock ( l , i1 , j1 ) && canBlockStay ( world , l , i1 , j1 ) )
{
world . setBlockWithNotify ( l , i1 , j1 , blockID ) ;
}
}
}
protected boolean canThisPlantGrowOnThisBlockID ( int i )
{
return i == Block . grass . blockID || i == Block . dirt . blockID || i == Block . tilledField . blockID ;
}
public boolean canBlockStay ( World world , int i , int j , int k )
{
if ( j < <num> || j >= <num> )
{
return false ;
} else
{
return ( world . getFullBlockLightValue ( i , j , k ) >= <num> || world . canBlockSeeTheSky ( i , j , k ) ) && canThisPlantGrowOnThisBlockID ( world . getBlockId ( i , j  <num> , k ) ) ;
}
}
}
package net . minecraft . src ;
import java . io . BufferedReader ;
import java . io . File ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . io . FileOutputStream ;
import java . io . FileReader ;
import java . io . IOException ;
import java . io . InputStreamReader ;
import java . io . OutputStream ;
import java . io . PrintStream ;
import java . io . UnsupportedEncodingException ;
import java . util . ArrayList ;
import java . util . ConcurrentModificationException ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
import java . util . Map . Entry ;
public final class KrushProps
{
private String fileName ;
private List < String > lines = new ArrayList ( ) ;
private Map < String , String > props = new HashMap ( ) ;
public KrushProps ( String fName ) {
this . fileName = fName ;
File file = new File ( this . fileName ) ;
if ( file . exists ( ) )
try {
load ( ) ;
} catch ( IOException ex ) {
System . out . println ( " + this . fileName + " ) ;
}
else save ( ) ;
}
public void load ( )
throws IOException
{
BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( this . fileName ) , " ) ) ;
this . lines . clear ( ) ;
this . props . clear ( ) ;
String line ;
while ( ( line = reader . readLine ( ) ) != null ) {
line = new String ( line . getBytes ( ) , " ) ;
char c = \000' ;
int pos = <num> ;
while ( ( pos < line . length ( ) ) && ( Character . isWhitespace ( c = line . charAt ( pos ) ) ) ) pos ++ ;
if ( ( line . length ( )  pos == <num> ) || ( line . charAt ( pos ) == #' ) || ( line . charAt ( pos ) == !' ) ) {
this . lines . add ( line ) ;
}
else
{
int start = pos ;
boolean needsEscape = line . indexOf ( \\' , pos ) !=  <num> ;
StringBuffer key = needsEscape ? new StringBuffer ( ) : null ;
if ( key != null ) while ( true ) {
if ( ( pos >= line . length ( ) ) || ( Character . isWhitespace ( c = line . charAt ( pos ++ ) ) ) || ( c == =' ) || ( c == :' ) ) break ; if ( ( needsEscape ) && ( c == \\' ) ) {
if ( pos == line . length ( ) ) {
line = reader . readLine ( ) ;
if ( line == null ) line = " ;
pos = <num> ;
pos ++ ; if ( pos < line . length ( ) ) {
if ( Character . isWhitespace ( c = line . charAt ( pos ) ) ) break ; continue ;
}
}
c = line . charAt ( pos ++ ) ; continue ;
}
switch ( c ) {
case n' :
key . append ( \n' ) ;
break ;
case t' :
key . append ( \t' ) ;
break ;
case r' :
key . append ( \r' ) ;
break ;
case u' :
if ( pos + <num> > line . length ( ) ) continue ;
char uni = ( char ) Integer . parseInt ( line . substring ( pos , pos + <num> ) , <num> ) ;
key . append ( uni ) ;
pos += <num> ;
break ;
case o' :
case p' :
case q' :
case s' :
default :
key . append ( \000' ) ;
}
}
boolean isDelim = ( c == :' ) || ( c == =' ) ;
String keyString ;
if ( needsEscape ) { keyString = key . toString ( ) ;
}
else
{
if ( ( isDelim ) || ( Character . isWhitespace ( c ) ) )
keyString = line . substring ( start , pos  <num> ) ;
else {
keyString = line . substring ( start , pos ) ;
}
}
while ( ( pos < line . length ( ) ) && ( Character . isWhitespace ( c = line . charAt ( pos ) ) ) ) pos ++ ;
if ( ( ! isDelim ) && ( ( c == :' ) || ( c == =' ) ) ) {
pos ++ ;
while ( ( pos < line . length ( ) ) && ( Character . isWhitespace ( c = line . charAt ( pos ) ) ) ) pos ++ ;
}
if ( ! needsEscape ) {
this . lines . add ( line ) ;
}
else
{
StringBuilder element = new StringBuilder ( line . length ( )  pos ) ;
while ( pos < line . length ( ) ) {
c = line . charAt ( pos ++ ) ;
if ( c == \\' ) {
if ( pos == line . length ( ) ) {
line = reader . readLine ( ) ;
if ( line == null ) break ;
pos = <num> ;
while ( ( pos < line . length ( ) ) && ( Character . isWhitespace ( c = line . charAt ( pos ) ) ) ) pos ++ ;
element . ensureCapacity ( line . length ( )  pos + element . length ( ) ) ;
continue ;
}
c = line . charAt ( pos ++ ) ;
switch ( c ) {
case n' :
element . append ( \n' ) ;
break ;
case t' :
element . append ( \t' ) ;
break ;
case r' :
element . append ( \r' ) ;
break ;
case u' :
if ( pos + <num> > line . length ( ) ) continue ;
char uni = ( char ) Integer . parseInt ( line . substring ( pos , pos + <num> ) , <num> ) ;
element . append ( uni ) ;
pos += <num> ;
break ;
case o' :
case p' :
case q' :
case s' :
default :
element . append ( \000' ) ;
}
}
element . append ( \000' ) ;
}
this . lines . add ( keyString + " + element . toString ( ) ) ;
}
}
}
reader . close ( ) ;
}
public void save ( )
{
OutputStream os = null ;
try {
os = new FileOutputStream ( this . fileName ) ;
} catch ( FileNotFoundException ex ) {
System . out . println ( " + this . fileName + " ) ;
}
PrintStream ps = null ;
try {
ps = new PrintStream ( os , true , " ) ;
} catch ( UnsupportedEncodingException ex ) {
System . out . println ( " + this . fileName + " ) ;
}
List usedProps = new ArrayList ( ) ;
for ( String line : this . lines ) {
if ( line . trim ( ) . length ( ) == <num> ) {
ps . println ( line ) ;
}
else if ( line . charAt ( <num> ) == #' ) {
ps . println ( line ) ;
}
else if ( line . contains ( " ) ) {
int delimPosition = line . indexOf ( =' ) ;
String key = line . substring ( <num> , delimPosition ) . trim ( ) ;
if ( this . props . containsKey ( key ) ) {
String value = ( String ) this . props . get ( key ) ;
ps . println ( key + " + value ) ;
usedProps . add ( key ) ; } else {
ps . println ( line ) ;
}
} else {
ps . println ( line ) ;
}
}
for ( Map . Entry entry : this . props . entrySet ( ) ) {
if ( ! usedProps . contains ( entry . getKey ( ) ) ) {
ps . println ( ( String ) entry . getKey ( ) + " + ( String ) entry . getValue ( ) ) ;
}
}
ps . close ( ) ;
try {
this . props . clear ( ) ;
this . lines . clear ( ) ;
load ( ) ;
} catch ( IOException ex ) {
System . out . println ( " + this . fileName + " ) ;
}
}
public Map < String , String > <unk> ( ) throws Exception
{
Map map = new HashMap ( ) ;
BufferedReader reader = new BufferedReader ( new FileReader ( this . fileName ) ) ;
String line ;
while ( ( line = reader . readLine ( ) ) != null )
{
if ( ( line . trim ( ) . length ( ) != <num> ) && ( line . charAt ( <num> ) != #' ) && ( line . contains ( " ) ) ) {
int delimPosition = line . indexOf ( =' ) ;
String key = line . substring ( <num> , delimPosition ) . trim ( ) ;
String value = line . substring ( delimPosition + <num> ) . trim ( ) ;
map . put ( key , value ) ;
}
}
reader . close ( ) ;
return map ;
}
public boolean containsKey ( String var ) {
for ( String line : this . lines )
if ( ( line . trim ( ) . length ( ) != <num> ) && ( line . charAt ( <num> ) != #' ) && ( line . contains ( " ) ) ) {
int delimPosition = line . indexOf ( =' ) ;
String key = line . substring ( <num> , delimPosition ) ;
if ( key . equals ( var ) ) return true ;
}
return false ;
}
public String getProperty ( String var ) {
for ( String line : this . lines )
if ( ( line . trim ( ) . length ( ) != <num> ) && ( line . charAt ( <num> ) != #' ) && ( line . contains ( " ) ) ) {
int delimPosition = line . indexOf ( =' ) ;
String key = line . substring ( <num> , delimPosition ) . trim ( ) ;
String value = line . substring ( delimPosition + <num> ) ;
if ( key . equals ( var ) ) return value ;
}
return " ;
}
public void removeKey ( String var ) {
Boolean changed = Boolean . valueOf ( false ) ;
if ( this . props . containsKey ( var ) ) {
this . props . remove ( var ) ;
changed = Boolean . valueOf ( true ) ;
}
try {
for ( int i = <num> ; i < this . lines . size ( ) ; i ++ ) {
String line = ( String ) this . lines . get ( i ) ;
if ( ( line . trim ( ) . length ( ) == <num> ) || ( line . charAt ( <num> ) == #' ) || ( ! line . contains ( " ) ) ) {
continue ;
}
int delimPosition = line . indexOf ( =' ) ;
String key = line . substring ( <num> , delimPosition ) . trim ( ) ;
if ( key . equals ( var ) ) {
this . lines . remove ( i ) ;
changed = Boolean . valueOf ( true ) ;
}
}
}
catch ( ConcurrentModificationException <unk> )
{
removeKey ( var ) ;
return ;
}
if ( changed . booleanValue ( ) ) save ( ) ;
}
public boolean keyExists ( String key )
{
try
{
return containsKey ( key ) ; } catch ( Exception localException ) {
}
return false ;
}
public String getString ( String key ) {
if ( containsKey ( key ) ) return getProperty ( key ) ;
return " ;
}
public String getString ( String key , String value ) {
if ( containsKey ( key ) ) return getProperty ( key ) ;
setString ( key , value ) ;
return value ;
}
public void setString ( String key , String value ) {
this . props . put ( key , value ) ;
save ( ) ;
}
public int getInt ( String key ) {
if ( containsKey ( key ) ) return Integer . parseInt ( getProperty ( key ) ) ;
return <num> ;
}
public int getInt ( String key , int value ) {
if ( containsKey ( key ) ) return Integer . parseInt ( getProperty ( key ) ) ;
setInt ( key , value ) ;
return value ;
}
public void setInt ( String key , int value ) {
this . props . put ( key , String . valueOf ( value ) ) ;
save ( ) ;
}
public double getDouble ( String key ) {
if ( containsKey ( key ) ) return Double . parseDouble ( getProperty ( key ) ) ;
return <num> D ;
}
public double getDouble ( String key , double value ) {
if ( containsKey ( key ) ) return Double . parseDouble ( getProperty ( key ) ) ;
setDouble ( key , value ) ;
return value ;
}
public void setDouble ( String key , double value ) {
this . props . put ( key , String . valueOf ( value ) ) ;
save ( ) ;
}
public long getLong ( String key ) {
if ( containsKey ( key ) ) return Long . parseLong ( getProperty ( key ) ) ;
return <num> ;
}
public long getLong ( String key , long value ) {
if ( containsKey ( key ) ) return Long . parseLong ( getProperty ( key ) ) ;
setLong ( key , value ) ;
return value ;
}
public void setLong ( String key , long value ) {
this . props . put ( key , String . valueOf ( value ) ) ;
save ( ) ;
}
public boolean getBoolean ( String key ) {
if ( containsKey ( key ) ) return Boolean . parseBoolean ( getProperty ( key ) ) ;
return false ;
}
public boolean getBoolean ( String key , boolean value ) {
if ( containsKey ( key ) ) return Boolean . parseBoolean ( getProperty ( key ) ) ;
setBoolean ( key , value ) ;
return value ;
}
public void setBoolean ( String key , boolean value ) {
this . props . put ( key , String . valueOf ( value ) ) ;
save ( ) ;
}
package net . minecraft . src ;
import org . lwjgl . opengl . GL11 ;
public class KonungRenderIdolIcon extends TileEntitySpecialRenderer
{
private KonungModelIdolIcon model ;
public KonungRenderIdolIcon ( )
{
model = new KonungModelIdolIcon ( ) ;
}
public void renderAModelAt ( KonungTileEntityIdolIcon tile , double d , double d1 , double d2 , float f )
{
int i = <num> ;
if ( tile . worldObj != null )
{
i = ( tile . worldObj . getBlockMetadata ( tile . xCoord , tile . yCoord , tile . zCoord ) ) ;
}
int j = <num> ;
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
bindTextureByName ( " ) ;
GL11 . glPushMatrix ( ) ;
GL11 . glTranslatef ( ( float ) d + <num> F , ( float ) d1 + <num> F , ( float ) d2 + <num> F ) ;
GL11 . glRotatef ( j , <num> F , <num> F , <num> F ) ;
GL11 . glScalef ( <num> F ,  1F ,  1F ) ;
model . renderModel ( <num> F ) ;
GL11 . glPopMatrix ( ) ;
}
public void renderTileEntityAt ( TileEntity tileentity , double d , double d1 , double d2 , float f )
{
renderAModelAt ( ( KonungTileEntityIdolIcon ) tileentity , d , d1 , d2 , f ) ;
}
}
package net . minecraft . src ;
import org . lwjgl . opengl . GL11 ;
public class KonungRenderIdol extends TileEntitySpecialRenderer
{
private KonungModelIdol model ;
public KonungRenderIdol ( )
{
model = new KonungModelIdol ( ) ;
}
public void renderAModelAt ( KonungTileEntityIdol tile , double d , double d1 , double d2 , float f )
{
int i = <num> ;
if ( tile . worldObj != null )
{
i = ( tile . worldObj . getBlockMetadata ( tile . xCoord , tile . yCoord , tile . zCoord ) ) ;
}
int j = <num> ;
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
bindTextureByName ( " ) ;
GL11 . glPushMatrix ( ) ;
GL11 . glTranslatef ( ( float ) d + <num> F , ( float ) d1 + <num> F , ( float ) d2 + <num> F ) ;
GL11 . glRotatef ( j , <num> F , <num> F , <num> F ) ;
GL11 . glScalef ( <num> F ,  1F ,  1F ) ;
model . renderModel ( <num> F ) ;
GL11 . glPopMatrix ( ) ;
}
public void renderTileEntityAt ( TileEntity tileentity , double d , double d1 , double d2 , float f )
{
renderAModelAt ( ( KonungTileEntityIdol ) tileentity , d , d1 , d2 , f ) ;
}
}
package net . minecraft . src ;
import java . util . Random ;
public class mod_konungAlchemy extends BaseMod
{
public static final Block KonungNut = new KonungBlockAlchemyNut ( <num> , ModLoader . addOverride ( " , " ) ) . setStepSound ( Block . soundGrassFootstep ) . setBlockName ( " ) ;
public static final Block KonungWhiteRoot = new KonungBlockAlchemyWhiteRoot ( <num> , ModLoader . addOverride ( " , " ) ) . setStepSound ( Block . soundGrassFootstep ) . setBlockName ( " ) ;
public static final Item KonungHealingPotion02 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . heal . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungHealingPotion04 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . heal . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungHealingPotion06 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . heal . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungHealingPotion08 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . heal . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungHealingPotion10 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . heal . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungOilPotion02 = new ItemFood ( <num> ,  <num> , 1F , false ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungOilPotion04 = new ItemFood ( <num> ,  <num> , 1F , false ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungOilPotion06 = new ItemFood ( <num> ,  <num> , 1F , false ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungOilPotion08 = new ItemFood ( <num> ,  <num> , 1F , false ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungOilPotion10 = new ItemFood ( <num> ,  <num> , 1F , false ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungBragaPotion02 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . damageBoost . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungBragaPotion04 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . damageBoost . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungBragaPotion06 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . damageBoost . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungBragaPotion08 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . damageBoost . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungBragaPotion10 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . damageBoost . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPoisonPotion02 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . harm . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPoisonPotion04 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . harm . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPoisonPotion06 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . harm . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPoisonPotion08 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . harm . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPoisonPotion10 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . harm . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPotionPotion02 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . jump . id , <num> , <num> , <num> F ) . setPotionEffect ( Potion . moveSpeed . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPotionPotion04 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . jump . id , <num> , <num> , <num> F ) . setPotionEffect ( Potion . moveSpeed . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPotionPotion06 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . jump . id , <num> , <num> , <num> F ) . setPotionEffect ( Potion . moveSpeed . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPotionPotion08 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . jump . id , <num> , <num> , <num> F ) . setPotionEffect ( Potion . moveSpeed . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPotionPotion10 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . jump . id , <num> , <num> , <num> F ) . setPotionEffect ( Potion . moveSpeed . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungAntidotePotion02 = new KonungItemAntidotePotion ( <num> ) . setItemName ( " ) ;
public static final Item KonungAntidotePotion04 = new KonungItemAntidotePotion ( <num> ) . setItemName ( " ) ;
public static final Item KonungAntidotePotion06 = new KonungItemAntidotePotion ( <num> ) . setItemName ( " ) ;
public static final Item KonungAntidotePotion08 = new KonungItemAntidotePotion ( <num> ) . setItemName ( " ) ;
public static final Item KonungAntidotePotion10 = new KonungItemAntidotePotion ( <num> ) . setItemName ( " ) ;
public static final Item KonungPureTearPotion02 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . digSpeed . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPureTearPotion04 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . digSpeed . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPureTearPotion06 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . digSpeed . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPureTearPotion08 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . digSpeed . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungPureTearPotion10 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . digSpeed . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungElixirOfWisdomPotion02 = new KonungItemElixirOfWisdom ( <num> ) . setItemName ( " ) ;
public static final Item KonungElixirOfWisdomPotion04 = new KonungItemElixirOfWisdom ( <num> ) . setItemName ( " ) ;
public static final Item KonungElixirOfWisdomPotion06 = new KonungItemElixirOfWisdom ( <num> ) . setItemName ( " ) ;
public static final Item KonungElixirOfWisdomPotion08 = new KonungItemElixirOfWisdom ( <num> ) . setItemName ( " ) ;
public static final Item KonungElixirOfWisdomPotion10 = new KonungItemElixirOfWisdom ( <num> ) . setItemName ( " ) ;
public static final Item KonungLiveWaterPotion02 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . fireResistance . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungLiveWaterPotion04 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . fireResistance . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungLiveWaterPotion06 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . fireResistance . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungLiveWaterPotion08 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . fireResistance . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public static final Item KonungLiveWaterPotion10 = new ItemFood ( <num> , <num> , 1F , false ) . setPotionEffect ( Potion . fireResistance . id , <num> , <num> , <num> F ) . setAlwaysEdible ( ) . setItemName ( " ) ;
public mod_konungAlchemy ( )
{
ModLoader . registerBlock ( KonungNut ) ;
ModLoader . registerBlock ( KonungWhiteRoot ) ;
ModLoader . addName ( KonungNut , " ) ;
ModLoader . addName ( KonungWhiteRoot , " ) ;
KonungNut . blockIndexInTexture = ModLoader . addOverride ( " , " ) ;
KonungWhiteRoot . blockIndexInTexture = ModLoader . addOverride ( " , " ) ;
ModLoader . addName ( KonungHealingPotion02 , " ) ;
ModLoader . addName ( KonungHealingPotion04 , " ) ;
ModLoader . addName ( KonungHealingPotion06 , " ) ;
ModLoader . addName ( KonungHealingPotion08 , " ) ;
ModLoader . addName ( KonungHealingPotion10 , " ) ;
ModLoader . addName ( KonungOilPotion02 , " ) ;
ModLoader . addName ( KonungOilPotion04 , " ) ;
ModLoader . addName ( KonungOilPotion06 , " ) ;
ModLoader . addName ( KonungOilPotion08 , " ) ;
ModLoader . addName ( KonungOilPotion10 , " ) ;
ModLoader . addName ( KonungPoisonPotion02 , " ) ;
ModLoader . addName ( KonungPoisonPotion04 , " ) ;
ModLoader . addName ( KonungPoisonPotion06 , " ) ;
ModLoader . addName ( KonungPoisonPotion08 , " ) ;
ModLoader . addName ( KonungPoisonPotion10 , " ) ;
ModLoader . addName ( KonungBragaPotion02 , " ) ;
ModLoader . addName ( KonungBragaPotion04 , " ) ;
ModLoader . addName ( KonungBragaPotion06 , " ) ;
ModLoader . addName ( KonungBragaPotion08 , " ) ;
ModLoader . addName ( KonungBragaPotion10 , " ) ;
ModLoader . addName ( KonungPotionPotion02 , " ) ;
ModLoader . addName ( KonungPotionPotion04 , " ) ;
ModLoader . addName ( KonungPotionPotion06 , " ) ;
ModLoader . addName ( KonungPotionPotion08 , " ) ;
ModLoader . addName ( KonungPotionPotion10 , " ) ;
ModLoader . addName ( KonungAntidotePotion02 , " ) ;
ModLoader . addName ( KonungAntidotePotion04 , " ) ;
ModLoader . addName ( KonungAntidotePotion06 , " ) ;
ModLoader . addName ( KonungAntidotePotion08 , " ) ;
ModLoader . addName ( KonungAntidotePotion10 , " ) ;
ModLoader . addName ( KonungPureTearPotion02 , " ) ;
ModLoader . addName ( KonungPureTearPotion04 , " ) ;
ModLoader . addName ( KonungPureTearPotion06 , " ) ;
ModLoader . addName ( KonungPureTearPotion08 , " ) ;
ModLoader . addName ( KonungPureTearPotion10 , " ) ;
ModLoader . addName ( KonungElixirOfWisdomPotion02 , " ) ;
ModLoader . addName ( KonungElixirOfWisdomPotion04 , " ) ;
ModLoader . addName ( KonungElixirOfWisdomPotion06 , " ) ;
ModLoader . addName ( KonungElixirOfWisdomPotion08 , " ) ;
ModLoader . addName ( KonungElixirOfWisdomPotion10 , " ) ;
ModLoader . addName ( KonungLiveWaterPotion02 , " ) ;
ModLoader . addName ( KonungLiveWaterPotion04 , " ) ;
ModLoader . addName ( KonungLiveWaterPotion06 , " ) ;
ModLoader . addName ( KonungLiveWaterPotion08 , " ) ;
ModLoader . addName ( KonungLiveWaterPotion10 , " ) ;
KonungHealingPotion02 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungHealingPotion04 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungHealingPotion06 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungHealingPotion08 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungHealingPotion10 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungOilPotion02 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungOilPotion04 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungOilPotion06 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungOilPotion08 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungOilPotion10 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPoisonPotion02 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPoisonPotion04 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPoisonPotion06 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPoisonPotion08 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPoisonPotion10 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungBragaPotion02 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungBragaPotion04 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungBragaPotion06 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungBragaPotion08 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungBragaPotion10 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPotionPotion02 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPotionPotion04 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPotionPotion06 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPotionPotion08 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPotionPotion10 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungAntidotePotion02 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungAntidotePotion04 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungAntidotePotion06 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungAntidotePotion08 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungAntidotePotion10 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPureTearPotion02 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPureTearPotion04 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPureTearPotion06 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPureTearPotion08 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungPureTearPotion10 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungElixirOfWisdomPotion02 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungElixirOfWisdomPotion04 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungElixirOfWisdomPotion06 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungElixirOfWisdomPotion08 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungElixirOfWisdomPotion10 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungLiveWaterPotion02 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungLiveWaterPotion04 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungLiveWaterPotion06 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungLiveWaterPotion08 . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungLiveWaterPotion10 . iconIndex = ModLoader . addOverride ( " , " ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungWhiteRoot , Character . valueOf ( #' ) , Item . potion } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , Item . potion , Character . valueOf ( #' ) , mod_konungAlchemy . KonungWhiteRoot } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungWhiteRoot } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungWhiteRoot , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungWhiteRoot } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungWhiteRoot , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungWhiteRoot } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungWhiteRoot , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungWhiteRoot } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungHealingPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungWhiteRoot , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungNut , Character . valueOf ( #' ) , Item . potion } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , Item . potion , Character . valueOf ( #' ) , mod_konungAlchemy . KonungNut } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungNut } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungNut , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungNut } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungNut , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungNut } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungNut , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungNut } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungOilPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungNut , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungMobs . KonungPoisonSting , Character . valueOf ( #' ) , Item . potion } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , Item . potion , Character . valueOf ( #' ) , mod_konungMobs . KonungPoisonSting } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungMobs . KonungPoisonSting } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungMobs . KonungPoisonSting , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungMobs . KonungPoisonSting } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungMobs . KonungPoisonSting , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungMobs . KonungPoisonSting } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungMobs . KonungPoisonSting , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungMobs . KonungPoisonSting } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPoisonPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungMobs . KonungPoisonSting , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungBragaPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPotionPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPotionPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPotionPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPotionPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPotionPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPotionPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPotionPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPotionPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPotionPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPotionPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPotionPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPotionPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPotionPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPotionPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPotionPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPotionPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPotionPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPotionPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPotionPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungHealingPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungHealingPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungAntidotePotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPureTearPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPureTearPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPureTearPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPureTearPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPureTearPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPureTearPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPureTearPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPureTearPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPureTearPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPureTearPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPureTearPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPureTearPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPureTearPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPureTearPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPureTearPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPureTearPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungPureTearPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPureTearPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPureTearPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungBragaPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungPoisonPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungPoisonPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungBragaPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungElixirOfWisdomPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungElixirOfWisdomPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion02 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion04 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungLiveWaterPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungLiveWaterPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungLiveWaterPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion06 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungLiveWaterPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungLiveWaterPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungLiveWaterPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungLiveWaterPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungLiveWaterPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungLiveWaterPotion02 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion08 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungLiveWaterPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungOilPotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungAntidotePotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungAntidotePotion10 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungOilPotion10 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungLiveWaterPotion02 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungLiveWaterPotion08 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungLiveWaterPotion04 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungLiveWaterPotion06 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungLiveWaterPotion06 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungLiveWaterPotion04 } ) ;
ModLoader . addRecipe ( new ItemStack ( KonungLiveWaterPotion10 , <num> ) , new Object [ ] { " , " , Character . valueOf ( X' ) , mod_konungAlchemy . KonungLiveWaterPotion08 , Character . valueOf ( #' ) , mod_konungAlchemy . KonungLiveWaterPotion02 } ) ;
}
public void <unk> ( World world , Random random , int chunkX , int chunkZ )
{
for ( int a = <num> ; a < <num> ; a ++ )
{
int Xcoord = chunkX + random . nextInt ( <num> ) + <num> ;
int Ycoord = random . nextInt ( <num> + <num> ) ;
int Zcoord = chunkZ + random . nextInt ( <num> ) + <num> ;
( new KonungWorldGenAlchemy ( KonungNut . blockID ) ) . generate ( world , random , Xcoord , Ycoord , Zcoord ) ;
( new KonungWorldGenAlchemy ( KonungWhiteRoot . blockID ) ) . generate ( world , random , Xcoord , Ycoord , Zcoord ) ;
}
}
public void load ( ) { } ;
public String getVersion ( ) { return " ; }
}
package net . minecraft . src ;
public class KonungItemBarrel extends ItemBlock
{
public KonungItemBarrel ( int par1 , Block block )
{
super ( par1 ) ;
setHasSubtypes ( true ) ;
}
public int getMetadata ( int par1 )
{
return par1 ;
}
}
package net . minecraft . src ;
public class KonungModelTable extends ModelBase
{
ModelRenderer top ;
ModelRenderer leg1 ;
ModelRenderer leg2 ;
ModelRenderer leg3 ;
ModelRenderer leg4 ;
ModelRenderer pole ;
public KonungModelTable ( )
{
textureWidth = <num> ;
textureHeight = <num> ;
top = new ModelRenderer ( this , <num> , <num> ) ;
top . addBox (  8F , 0F ,  8F , <num> , <num> , <num> ) ;
top . setRotationPoint ( 0F , 8F , 0F ) ;
top . setTextureSize ( <num> , <num> ) ;
top . mirror = true ;
setRotation ( top , 0F , 0F , 0F ) ;
leg1 = new ModelRenderer ( this , <num> , <num> ) ;
leg1 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
leg1 . setRotationPoint (  6F , <num> F ,  5F ) ;
leg1 . setTextureSize ( <num> , <num> ) ;
leg1 . mirror = true ;
setRotation ( leg1 , 0F , 0F , 0F ) ;
leg2 = new ModelRenderer ( this , <num> , <num> ) ;
leg2 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
leg2 . setRotationPoint ( 4F , <num> F , 1F ) ;
leg2 . setTextureSize ( <num> , <num> ) ;
leg2 . mirror = true ;
setRotation ( leg2 , 0F , 0F , 0F ) ;
leg3 = new ModelRenderer ( this , <num> , <num> ) ;
leg3 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
leg3 . setRotationPoint ( 4F , <num> F ,  5F ) ;
leg3 . setTextureSize ( <num> , <num> ) ;
leg3 . mirror = true ;
setRotation ( leg3 , 0F , 0F , 0F ) ;
leg4 = new ModelRenderer ( this , <num> , <num> ) ;
leg4 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
leg4 . setRotationPoint (  6F , <num> F , 1F ) ;
leg4 . setTextureSize ( <num> , <num> ) ;
leg4 . mirror = true ;
setRotation ( leg4 , 0F , 0F , 0F ) ;
pole = new ModelRenderer ( this , <num> , <num> ) ;
pole . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
pole . setRotationPoint (  8F , <num> F ,  1F ) ;
pole . setTextureSize ( <num> , <num> ) ;
pole . mirror = true ;
setRotation ( pole , 0F , 0F , 0F ) ;
}
public void render ( Entity entity , float f , float f1 , float f2 , float f3 , float f4 , float f5 )
{
super . render ( entity , f , f1 , f2 , f3 , f4 , f5 ) ;
setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , entity ) ;
top . render ( f5 ) ;
leg1 . render ( f5 ) ;
leg2 . render ( f5 ) ;
leg3 . render ( f5 ) ;
leg4 . render ( f5 ) ;
pole . render ( f5 ) ;
}
private void setRotation ( ModelRenderer model , float x , float y , float z )
{
model . rotateAngleX = x ;
model . rotateAngleY = y ;
model . rotateAngleZ = z ;
}
public void setRotationAngles ( float f , float f1 , float f2 , float f3 , float f4 , float f5 , Entity par7Entity )
{
super . setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , par7Entity ) ;
}
public void renderModel ( float f )
{
top . render ( f ) ;
leg1 . render ( f ) ;
leg2 . render ( f ) ;
leg3 . render ( f ) ;
leg4 . render ( f ) ;
pole . render ( f ) ;
}
package net . minecraft . src ;
import java . util . List ;
public class KonungBlockRefinedPlanks extends Block
{
public static final String [ ] woodType = new String [ ] { " , " , " , " } ;
public KonungBlockRefinedPlanks ( int par1 )
{
super ( par1 , <num> , Material . wood ) ;
this . setCreativeTab ( CreativeTabs . tabBlock ) ;
}
public int getBlockTextureFromSideAndMetadata ( int par1 , int par2 )
{
int oak = mod_konungRefinedPlanks . oakRefinedPlanksTexture ;
int spruce = mod_konungRefinedPlanks . spruceRefinedPlanksTexture ;
int birch = mod_konungRefinedPlanks . birchRefinedPlanksTexture ;
int jungle = mod_konungRefinedPlanks . jungleRefinedPlanksTexture ;
switch ( par2 )
{
case <num> :
return spruce ;
case <num> :
return birch ;
case <num> :
return jungle ;
default :
return oak ;
}
}
public int damageDropped ( int par1 )
{
return par1 ;
}
public void getSubBlocks ( int par1 , CreativeTabs par2CreativeTabs , List par3List )
{
par3List . add ( new ItemStack ( par1 , <num> , <num> ) ) ;
par3List . add ( new ItemStack ( par1 , <num> , <num> ) ) ;
par3List . add ( new ItemStack ( par1 , <num> , <num> ) ) ;
par3List . add ( new ItemStack ( par1 , <num> , <num> ) ) ;
}
}
package net . minecraft . src ;
public class mod_konungRefinedWood extends BaseMod
{
public static final Block refinedWood = ( new KonungBlockRefinedWood ( <num> ) ) . setHardness ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) ;
public static int topRefinedWoodTexture ;
public static int oakRefinedWoodTexture ;
public static int spruceRefinedWoodTexture ;
public static int birchRefinedWoodTexture ;
public static int jungleRefinedWoodTexture ;
public mod_konungRefinedWood ( )
{
ModLoader . registerBlock ( refinedWood ) ;
topRefinedWoodTexture = ModLoader . addOverride ( " , " ) ;
oakRefinedWoodTexture = ModLoader . addOverride ( " , " ) ;
spruceRefinedWoodTexture = ModLoader . addOverride ( " , " ) ;
birchRefinedWoodTexture = ModLoader . addOverride ( " , " ) ;
jungleRefinedWoodTexture = ModLoader . addOverride ( " , " ) ;
ModLoader . addRecipe ( new ItemStack ( refinedWood , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( Block . wood , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( refinedWood , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( Block . wood , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( refinedWood , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( Block . wood , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( refinedWood , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( Block . wood , <num> , <num> ) } ) ;
}
public void load ( ) { } ;
public String getVersion ( ) { return " ; }
}
package net . minecraft . src ;
public class KonungItemWindow extends ItemBlock
{
public KonungItemWindow ( int par1 , Block block )
{
super ( par1 ) ;
setHasSubtypes ( true ) ;
}
public int getMetadata ( int par1 )
{
return par1 ;
}
}
package net . minecraft . src ;
import java . util . Random ;
public class KonungTileEntityBarrel extends TileEntity implements IInventory
{
private ItemStack barrelContents [ ] ;
public boolean adjacentChestChecked ;
public KonungTileEntityBarrel adjacentChestZNeg ;
public KonungTileEntityBarrel adjacentChestXPos ;
public KonungTileEntityBarrel adjacentChestXNeg ;
public KonungTileEntityBarrel adjacentChestZPos ;
public float lidAngle ;
public float prevLidAngle ;
public int numUsingPlayers ;
private int ticksSinceSync ;
public KonungTileEntityBarrel ( )
{
barrelContents = new ItemStack [ <num> ] ;
adjacentChestChecked = false ;
}
public int getSizeInventory ( )
{
return <num> ;
}
public ItemStack getStackInSlot ( int par1 )
{
return barrelContents [ par1 ] ;
}
public ItemStack <unk> ( int par1 , int par2 )
{
if ( barrelContents [ par1 ] != null )
{
if ( barrelContents [ par1 ] . stackSize <= par2 )
{
ItemStack itemstack = barrelContents [ par1 ] ;
barrelContents [ par1 ] = null ;
onInventoryChanged ( ) ;
return itemstack ;
}
ItemStack itemstack1 = barrelContents [ par1 ] . <unk> ( par2 ) ;
if ( barrelContents [ par1 ] . stackSize == <num> )
{
barrelContents [ par1 ] = null ;
}
onInventoryChanged ( ) ;
return itemstack1 ;
}
else
{
return null ;
}
}
public ItemStack <unk> ( int par1 )
{
if ( barrelContents [ par1 ] != null )
{
ItemStack itemstack = barrelContents [ par1 ] ;
barrelContents [ par1 ] = null ;
return itemstack ;
}
else
{
return null ;
}
}
public void <unk> ( int par1 , ItemStack par2ItemStack )
{
barrelContents [ par1 ] = par2ItemStack ;
if ( par2ItemStack != null && par2ItemStack . stackSize > getInventoryStackLimit ( ) )
{
par2ItemStack . stackSize = getInventoryStackLimit ( ) ;
}
onInventoryChanged ( ) ;
}
public String <unk> ( )
{
return " ;
}
public void readFromNBT ( NBTTagCompound par1NBTTagCompound )
{
super . readFromNBT ( par1NBTTagCompound ) ;
NBTTagList nbttaglist = par1NBTTagCompound . <unk> ( " ) ;
barrelContents = new ItemStack [ getSizeInventory ( ) ] ;
for ( int i = <num> ; i < nbttaglist . <unk> ( ) ; i ++ )
{
NBTTagCompound nbttagcompound = ( NBTTagCompound ) nbttaglist . <unk> ( i ) ;
int j = nbttagcompound . getByte ( " ) & <num> ;
if ( j >= <num> && j < barrelContents . length )
{
barrelContents [ j ] = ItemStack . <unk> ( nbttagcompound ) ;
}
}
}
public void writeToNBT ( NBTTagCompound par1NBTTagCompound )
{
super . writeToNBT ( par1NBTTagCompound ) ;
NBTTagList nbttaglist = new NBTTagList ( ) ;
for ( int i = <num> ; i < barrelContents . length ; i ++ )
{
if ( barrelContents [ i ] != null )
{
NBTTagCompound nbttagcompound = new NBTTagCompound ( ) ;
nbttagcompound . setByte ( " , ( byte ) i ) ;
barrelContents [ i ] . writeToNBT ( nbttagcompound ) ;
nbttaglist . <unk> ( nbttagcompound ) ;
}
}
par1NBTTagCompound . setTag ( " , nbttaglist ) ;
}
public int getInventoryStackLimit ( )
{
return <num> ;
}
public boolean <unk> ( EntityPlayer par1EntityPlayer )
{
if ( worldObj . getBlockTileEntity ( xCoord , yCoord , zCoord ) != this )
{
return false ;
}
return par1EntityPlayer . <unk> ( ( double ) xCoord + <num> D , ( double ) yCoord + <num> D , ( double ) zCoord + <num> D ) <= <num> D ;
}
public void updateContainingBlockInfo ( )
{
super . updateContainingBlockInfo ( ) ;
adjacentChestChecked = false ;
}
public void updateEntity ( )
{
super . updateEntity ( ) ;
if ( ( ++ ticksSinceSync % <num> ) * <num> == <num> )
{
;
}
prevLidAngle = lidAngle ;
float f = <num> F ;
if ( numUsingPlayers > <num> && lidAngle == <num> F && adjacentChestZNeg == null && adjacentChestXNeg == null )
{
double d = ( double ) xCoord + <num> D ;
double d1 = ( double ) zCoord + <num> D ;
if ( adjacentChestZPos != null )
{
d1 += <num> D ;
}
if ( adjacentChestXPos != null )
{
d += <num> D ;
}
worldObj . playSoundEffect ( d , ( double ) yCoord + <num> D , d1 , " , <num> F , worldObj . rand . nextFloat ( ) * <num> F + <num> F ) ;
}
if ( numUsingPlayers == <num> && lidAngle > <num> F || numUsingPlayers > <num> && lidAngle < <num> F )
{
float f1 = lidAngle ;
if ( numUsingPlayers > <num> )
{
lidAngle += f ;
}
else
{
lidAngle -= f ;
}
if ( lidAngle > <num> F )
{
lidAngle = <num> F ;
}
float f2 = <num> F ;
if ( lidAngle < f2 && f1 >= f2 && adjacentChestZNeg == null && adjacentChestXNeg == null )
{
double d2 = ( double ) xCoord + <num> D ;
double d3 = ( double ) zCoord + <num> D ;
if ( adjacentChestZPos != null )
{
d3 += <num> D ;
}
if ( adjacentChestXPos != null )
{
d2 += <num> D ;
}
worldObj . playSoundEffect ( d2 , ( double ) yCoord + <num> D , d3 , " , <num> F , worldObj . rand . nextFloat ( ) * <num> F + <num> F ) ;
}
if ( lidAngle < <num> F )
{
lidAngle = <num> F ;
}
}
}
public void <unk> ( int par1 , int par2 )
{
if ( par1 == <num> )
{
numUsingPlayers = par2 ;
}
}
public void <unk> ( )
{
++ this . numUsingPlayers ;
this . worldObj . addBlockEvent ( this . xCoord , this . yCoord , this . zCoord , Block . chest . blockID , <num> , this . numUsingPlayers ) ;
}
public void <unk> ( )
{
this . numUsingPlayers ;
this . worldObj . addBlockEvent ( this . xCoord , this . yCoord , this . zCoord , Block . chest . blockID , <num> , this . numUsingPlayers ) ;
}
public void invalidate ( )
{
updateContainingBlockInfo ( ) ;
super . invalidate ( ) ;
}
}
package net . minecraft . src ;
import java . util . ArrayList ;
import java . util . List ;
public class KonungBlockStockade extends Block
{
public KonungBlockStockade ( int i , int j , Material material )
{
super ( i , j , material ) ;
setLightOpacity ( mod_konungStockade . SlopesOpacity ) ;
}
public int getRenderType ( )
{
return mod_konungStockade . CornersRenderID ;
}
public boolean isOpaqueCube ( )
{
return false ;
}
public boolean renderAsNormalBlock ( )
{
return false ;
}
public boolean shouldSideBeRendered ( IBlockAccess iblockaccess , int i , int j , int k , int l )
{
return true ;
}
public void setBlockBoundsBasedOnState ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 )
{
{
boolean var5 = ( par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4 ) & <num> ) != <num> ;
if ( var5 )
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
else
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
}
}
public static int <unk> ( int i )
{
return i ;
}
public static int func_21035_d ( int i )
{
return i ;
}
public void <unk> ( World par1World , int par2 , int par3 , int par4 , Entity par5Entity )
{
par5Entity . <unk> ( <unk> . cactus , <num> ) ;
}
}
package net . minecraft . src ;
public class KonungTileEntityLeatherBanner extends TileEntity
{
public KonungTileEntityLeatherBanner ( )
{
}
}
package net . minecraft . src ;
public class KonungModelWindow extends ModelBase
{
ModelRenderer plank1 ;
ModelRenderer plank2 ;
ModelRenderer plank3 ;
ModelRenderer plank4 ;
ModelRenderer glass ;
public KonungModelWindow ( )
{
textureWidth = <num> ;
textureHeight = <num> ;
plank1 = new ModelRenderer ( this , <num> , <num> ) ;
plank1 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
plank1 . setRotationPoint ( 8F , 9F ,  8F ) ;
plank1 . setTextureSize ( <num> , <num> ) ;
plank1 . mirror = true ;
setRotation ( plank1 , 0F , 0F , <num> F ) ;
plank2 = new ModelRenderer ( this , <num> , <num> ) ;
plank2 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
plank2 . setRotationPoint (  8F , <num> F ,  8F ) ;
plank2 . setTextureSize ( <num> , <num> ) ;
plank2 . mirror = true ;
setRotation ( plank2 , 0F , 0F , 0F ) ;
plank3 = new ModelRenderer ( this , <num> , <num> ) ;
plank3 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
plank3 . setRotationPoint (  8F , 8F ,  8F ) ;
plank3 . setTextureSize ( <num> , <num> ) ;
plank3 . mirror = true ;
setRotation ( plank3 , 0F , 0F , 0F ) ;
plank4 = new ModelRenderer ( this , <num> , <num> ) ;
plank4 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
plank4 . setRotationPoint (  7F , 9F ,  8F ) ;
plank4 . setTextureSize ( <num> , <num> ) ;
plank4 . mirror = true ;
setRotation ( plank4 , 0F , 0F , <num> F ) ;
glass = new ModelRenderer ( this , <num> , <num> ) ;
glass . addBox ( 0F , 0F ,  <num> F , <num> , <num> , <num> ) ;
glass . setRotationPoint (  7F , 9F , 0F ) ;
glass . setTextureSize ( <num> , <num> ) ;
glass . mirror = true ;
setRotation ( glass , 0F , 0F , 0F ) ;
}
public void render ( Entity entity , float f , float f1 , float f2 , float f3 , float f4 , float f5 )
{
super . render ( entity , f , f1 , f2 , f3 , f4 , f5 ) ;
setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , entity ) ;
plank1 . render ( f5 ) ;
plank2 . render ( f5 ) ;
plank3 . render ( f5 ) ;
plank4 . render ( f5 ) ;
glass . render ( f5 ) ;
}
private void setRotation ( ModelRenderer model , float x , float y , float z )
{
model . rotateAngleX = x ;
model . rotateAngleY = y ;
model . rotateAngleZ = z ;
}
public void setRotationAngles ( float f , float f1 , float f2 , float f3 , float f4 , float f5 , Entity par7Entity )
{
super . setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , par7Entity ) ;
}
public void renderModel ( float f )
{
plank1 . render ( f ) ;
plank2 . render ( f ) ;
plank3 . render ( f ) ;
plank4 . render ( f ) ;
glass . render ( f ) ;
}
package net . minecraft . src ;
public class KonungTileEntityLeather extends TileEntity
{
public KonungTileEntityLeather ( )
{
}
}
package net . minecraft . src ;
public class KonungTileEntityIdol extends TileEntity
{
public KonungTileEntityIdol ( )
{
}
}
package net . minecraft . src ;
public class mod_konungDecorations extends BaseMod
{
public static int blockWindowID = <num> ;
public static int blockTableID = <num> ;
public static int blockBenchID = <num> ;
public static int blockBarrelID = <num> ;
public static int blockLeatherID = <num> ;
public static int blockIdolID = <num> ;
public static int modelWindowID ;
public static int modelTableID ;
public static int modelBenchID ;
public static int modelBarrelID ;
public static int modelLeatherID ;
public static int modelIdolID ;
public static final Block blockWindow = ( new KonungBlockWindow ( blockWindowID , <num> , KonungTileEntityWindow . class ) ) . setHardness ( <num> F ) . setResistance ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) . setCreativeTab ( CreativeTabs . tabBlock ) ;
public static final Block blockTable = ( new KonungBlockTable ( blockTableID , <num> , KonungTileEntityTable . class , true ) ) . setHardness ( <num> F ) . setResistance ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) . setCreativeTab ( CreativeTabs . tabBlock ) ;
public static final Block blockBench = ( new KonungBlockBench ( blockBenchID , <num> , KonungTileEntityBench . class ) ) . setHardness ( <num> F ) . setResistance ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) . setCreativeTab ( CreativeTabs . tabBlock ) ;
public static final Block blockBarrel = ( new KonungBlockBarrel ( blockBarrelID , <num> , KonungTileEntityBarrel . class ) ) . setHardness ( <num> F ) . setResistance ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) . setCreativeTab ( CreativeTabs . tabBlock ) ;
public static final Block blockLeather = ( new KonungBlockLeather ( blockLeatherID , <num> , KonungTileEntityLeather . class ) ) . setHardness ( <num> F ) . setResistance ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) . setCreativeTab ( CreativeTabs . tabBlock ) ;
public static final Block blockIdol = ( new KonungBlockIdol ( blockIdolID , <num> , KonungTileEntityIdol . class ) ) . setHardness ( <num> F ) . setResistance ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) . setCreativeTab ( CreativeTabs . tabBlock ) ;
public static final Item itemWindow = ( new KonungItemWindow ( blockWindowID  <num> , blockWindow ) . setItemName ( " ) ) ;
public static final Item itemTable = ( new KonungItemTable ( blockTableID  <num> , blockTable ) . setItemName ( " ) ) ;
public static final Item itemBench = ( new KonungItemBench ( blockBenchID  <num> , blockBench ) . setItemName ( " ) ) ;
public static final Item itemBarrel = ( new KonungItemBarrel ( blockBarrelID  <num> , blockBarrel ) . setItemName ( " ) ) ;
public static final Item itemLeather = ( new KonungItemLeather ( blockLeatherID  <num> , blockLeather ) . setItemName ( " ) ) ;
public static final Item itemIdol = ( new KonungItemIdol ( blockIdolID  <num> , blockIdol ) . setItemName ( " ) ) ;
public mod_konungDecorations ( )
{
ModLoader . addName ( new ItemStack ( blockWindow , <num> , <num> ) , " ) ;
ModLoader . addName ( new ItemStack ( blockWindow , <num> , <num> ) , " , " ) ;
ModLoader . addName ( new ItemStack ( blockTable , <num> , <num> ) , " ) ;
ModLoader . addName ( new ItemStack ( blockTable , <num> , <num> ) , " , " ) ;
ModLoader . addName ( new ItemStack ( blockBench , <num> , <num> ) , " ) ;
ModLoader . addName ( new ItemStack ( blockBench , <num> , <num> ) , " , " ) ;
ModLoader . addName ( new ItemStack ( blockBarrel , <num> , <num> ) , " ) ;
ModLoader . addName ( new ItemStack ( blockBarrel , <num> , <num> ) , " , " ) ;
ModLoader . addName ( new ItemStack ( blockLeather , <num> , <num> ) , " ) ;
ModLoader . addName ( new ItemStack ( blockLeather , <num> , <num> ) , " , " ) ;
ModLoader . addName ( new ItemStack ( blockIdol , <num> , <num> ) , " ) ;
ModLoader . addName ( new ItemStack ( blockIdol , <num> , <num> ) , " , " ) ;
ModLoader . registerTileEntity ( KonungTileEntityWindow . class , " , new KonungRenderWindow ( ) ) ;
ModLoader . registerTileEntity ( KonungTileEntityTable . class , " , new KonungRenderTable ( ) ) ;
ModLoader . registerTileEntity ( KonungTileEntityBench . class , " , new KonungRenderBench ( ) ) ;
ModLoader . registerTileEntity ( KonungTileEntityBarrel . class , " , new KonungRenderBarrel ( ) ) ;
ModLoader . registerTileEntity ( KonungTileEntityLeather . class , " , new KonungRenderLeather ( ) ) ;
ModLoader . registerTileEntity ( KonungTileEntityIdol . class , " , new KonungRenderIdol ( ) ) ;
ModLoader . registerTileEntity ( KonungTileEntityIdolIcon . class , " , new KonungRenderIdolIcon ( ) ) ;
ModLoader . addRecipe ( new ItemStack ( blockWindow , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedPlanks . refinedPlanks , <num> , <num> ) , Character . valueOf ( Y' ) , Block . <unk> } ) ;
ModLoader . addRecipe ( new ItemStack ( blockTable , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedPlanks . refinedPlanks , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( blockBench , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedPlanks . refinedPlanks , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( blockBarrel , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedPlanks . refinedPlanks , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( blockLeather , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( Item . stick , <num> ) , Character . valueOf ( Y' ) , new ItemStack ( Item . <unk> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( blockIdol , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedWood . refinedWood , <num> , <num> ) } ) ;
modelWindowID = ModLoader . getUniqueBlockModelID ( this , true ) ;
modelTableID = ModLoader . getUniqueBlockModelID ( this , true ) ;
modelBenchID = ModLoader . getUniqueBlockModelID ( this , true ) ;
modelBarrelID = ModLoader . getUniqueBlockModelID ( this , true ) ;
modelLeatherID = ModLoader . getUniqueBlockModelID ( this , true ) ;
modelIdolID = ModLoader . getUniqueBlockModelID ( this , true ) ;
}
public void renderInvBlock ( RenderBlocks var1 , Block var2 , int var3 , int var4 )
{
super . renderInvBlock ( var1 , var2 , var3 , var4 ) ;
if ( var2 == blockWindow )
{
TileEntityRenderer . instance . renderTileEntityAt ( new KonungTileEntityWindow ( ) , <num> D ,  <num> D , <num> D , <num> F ) ;
}
if ( var2 == blockTable )
{
TileEntityRenderer . instance . renderTileEntityAt ( new KonungTileEntityTable ( ) , <num> D ,  <num> D , <num> D , <num> F ) ;
}
if ( var2 == blockBench )
{
TileEntityRenderer . instance . renderTileEntityAt ( new KonungTileEntityBench ( ) , <num> D , <num> D , <num> D , <num> F ) ;
}
if ( var2 == blockBarrel )
{
TileEntityRenderer . instance . renderTileEntityAt ( new KonungTileEntityBarrel ( ) , <num> D ,  <num> D , <num> D , <num> F ) ;
}
if ( var2 == blockLeather )
{
TileEntityRenderer . instance . renderTileEntityAt ( new KonungTileEntityLeather ( ) , <num> D , <num> D , <num> D , <num> F ) ;
}
if ( var2 == blockIdol )
{
TileEntityRenderer . instance . renderTileEntityAt ( new KonungTileEntityIdolIcon ( ) , <num> D , <num> D , <num> D , <num> F ) ;
}
}
public void load ( ) { } ;
public String getVersion ( ) { return " ; }
}
package net . minecraft . src ;
public class KonungItemLeather extends ItemBlock
{
public KonungItemLeather ( int par1 , Block block )
{
super ( par1 ) ;
setHasSubtypes ( true ) ;
}
public int getMetadata ( int par1 )
{
return par1 ;
}
}
package net . minecraft . src ;
public class KonungTileEntityBench extends TileEntity
{
public KonungTileEntityBench ( )
{
}
}
package net . minecraft . src ;
import java . util . List ;
import java . util . Random ;
public class KonungBlockRefinedStairs extends Block
{
private static final int [ ] [ ] field_72159_a = new int [ ] [ ] { { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> } , { <num> , <num> } } ;
private static final int [ ] <unk> = new int [ ] { <num> ,  <num> , <num> , <num> } ;
private static final int [ ] <unk> = new int [ ] { <num> , <num> , <num> ,  <num> } ;
private final Block modelBlock ;
private final int field_72158_c ;
private boolean field_72156_cr = false ;
private int field_72160_cs = <num> ;
protected KonungBlockRefinedStairs ( int par1 , Block par2Block , int par3 )
{
super ( par1 , par2Block . blockIndexInTexture , par2Block . blockMaterial ) ;
this . modelBlock = par2Block ;
this . field_72158_c = par3 ;
this . setHardness ( par2Block . <unk> ) ;
this . setResistance ( par2Block . <unk> / <num> F ) ;
this . setStepSound ( par2Block . <unk> ) ;
this . setLightOpacity ( <num> ) ;
this . setCreativeTab ( CreativeTabs . tabBlock ) ;
}
public void setBlockBoundsBasedOnState ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 )
{
if ( this . field_72156_cr )
{
this . setBlockBounds ( <num> F * ( float ) ( this . field_72160_cs % <num> ) , <num> F * ( float ) ( this . field_72160_cs / <num> % <num> ) , <num> F * ( float ) ( this . field_72160_cs / <num> % <num> ) , <num> F + <num> F * ( float ) ( this . field_72160_cs % <num> ) , <num> F + <num> F * ( float ) ( this . field_72160_cs / <num> % <num> ) , <num> F + <num> F * ( float ) ( this . field_72160_cs / <num> % <num> ) ) ;
}
else
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
}
public boolean isOpaqueCube ( )
{
return false ;
}
public boolean renderAsNormalBlock ( )
{
return false ;
}
public int getRenderType ( )
{
return <num> ;
}
public void func_82541_d ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 )
{
int var5 = par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4 ) ;
if ( ( var5 & <num> ) != <num> )
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
else
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
}
public static boolean func_82543_e ( int par0 )
{
return par0 > <num> && Block . blocksList [ par0 ] instanceof <unk> ;
}
private boolean func_82540_f ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 , int par5 )
{
int var6 = par1IBlockAccess . getBlockId ( par2 , par3 , par4 ) ;
return func_82543_e ( var6 ) && par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4 ) == par5 ;
}
public boolean func_82542_g ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 )
{
int var5 = par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4 ) ;
int var6 = var5 & <num> ;
float var7 = <num> F ;
float var8 = <num> F ;
if ( ( var5 & <num> ) != <num> )
{
var7 = <num> F ;
var8 = <num> F ;
}
float var9 = <num> F ;
float var10 = <num> F ;
float var11 = <num> F ;
float var12 = <num> F ;
boolean var13 = true ;
int var14 ;
int var15 ;
int var16 ;
if ( var6 == <num> )
{
var9 = <num> F ;
var12 = <num> F ;
var14 = par1IBlockAccess . getBlockId ( par2 + <num> , par3 , par4 ) ;
var15 = par1IBlockAccess . getBlockMetadata ( par2 + <num> , par3 , par4 ) ;
if ( func_82543_e ( var14 ) && ( var5 & <num> ) == ( var15 & <num> ) )
{
var16 = var15 & <num> ;
if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 , par3 , par4 + <num> , var5 ) )
{
var12 = <num> F ;
var13 = false ;
}
else if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 , par3 , par4  <num> , var5 ) )
{
var11 = <num> F ;
var13 = false ;
}
}
}
else if ( var6 == <num> )
{
var10 = <num> F ;
var12 = <num> F ;
var14 = par1IBlockAccess . getBlockId ( par2  <num> , par3 , par4 ) ;
var15 = par1IBlockAccess . getBlockMetadata ( par2  <num> , par3 , par4 ) ;
if ( func_82543_e ( var14 ) && ( var5 & <num> ) == ( var15 & <num> ) )
{
var16 = var15 & <num> ;
if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 , par3 , par4 + <num> , var5 ) )
{
var12 = <num> F ;
var13 = false ;
}
else if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 , par3 , par4  <num> , var5 ) )
{
var11 = <num> F ;
var13 = false ;
}
}
}
else if ( var6 == <num> )
{
var11 = <num> F ;
var12 = <num> F ;
var14 = par1IBlockAccess . getBlockId ( par2 , par3 , par4 + <num> ) ;
var15 = par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4 + <num> ) ;
if ( func_82543_e ( var14 ) && ( var5 & <num> ) == ( var15 & <num> ) )
{
var16 = var15 & <num> ;
if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 + <num> , par3 , par4 , var5 ) )
{
var10 = <num> F ;
var13 = false ;
}
else if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2  <num> , par3 , par4 , var5 ) )
{
var9 = <num> F ;
var13 = false ;
}
}
}
else if ( var6 == <num> )
{
var14 = par1IBlockAccess . getBlockId ( par2 , par3 , par4  <num> ) ;
var15 = par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4  <num> ) ;
if ( func_82543_e ( var14 ) && ( var5 & <num> ) == ( var15 & <num> ) )
{
var16 = var15 & <num> ;
if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 + <num> , par3 , par4 , var5 ) )
{
var10 = <num> F ;
var13 = false ;
}
else if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2  <num> , par3 , par4 , var5 ) )
{
var9 = <num> F ;
var13 = false ;
}
}
}
this . setBlockBounds ( var9 , var7 , var11 , var10 , var8 , var12 ) ;
return var13 ;
}
public boolean func_82544_h ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 )
{
int var5 = par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4 ) ;
int var6 = var5 & <num> ;
float var7 = <num> F ;
float var8 = <num> F ;
if ( ( var5 & <num> ) != <num> )
{
var7 = <num> F ;
var8 = <num> F ;
}
float var9 = <num> F ;
float var10 = <num> F ;
float var11 = <num> F ;
float var12 = <num> F ;
boolean var13 = false ;
int var14 ;
int var15 ;
int var16 ;
if ( var6 == <num> )
{
var14 = par1IBlockAccess . getBlockId ( par2  <num> , par3 , par4 ) ;
var15 = par1IBlockAccess . getBlockMetadata ( par2  <num> , par3 , par4 ) ;
if ( func_82543_e ( var14 ) && ( var5 & <num> ) == ( var15 & <num> ) )
{
var16 = var15 & <num> ;
if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 , par3 , par4  <num> , var5 ) )
{
var11 = <num> F ;
var12 = <num> F ;
var13 = true ;
}
else if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 , par3 , par4 + <num> , var5 ) )
{
var11 = <num> F ;
var12 = <num> F ;
var13 = true ;
}
}
}
else if ( var6 == <num> )
{
var14 = par1IBlockAccess . getBlockId ( par2 + <num> , par3 , par4 ) ;
var15 = par1IBlockAccess . getBlockMetadata ( par2 + <num> , par3 , par4 ) ;
if ( func_82543_e ( var14 ) && ( var5 & <num> ) == ( var15 & <num> ) )
{
var9 = <num> F ;
var10 = <num> F ;
var16 = var15 & <num> ;
if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 , par3 , par4  <num> , var5 ) )
{
var11 = <num> F ;
var12 = <num> F ;
var13 = true ;
}
else if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 , par3 , par4 + <num> , var5 ) )
{
var11 = <num> F ;
var12 = <num> F ;
var13 = true ;
}
}
}
else if ( var6 == <num> )
{
var14 = par1IBlockAccess . getBlockId ( par2 , par3 , par4  <num> ) ;
var15 = par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4  <num> ) ;
if ( func_82543_e ( var14 ) && ( var5 & <num> ) == ( var15 & <num> ) )
{
var11 = <num> F ;
var12 = <num> F ;
var16 = var15 & <num> ;
if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2  <num> , par3 , par4 , var5 ) )
{
var13 = true ;
}
else if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 + <num> , par3 , par4 , var5 ) )
{
var9 = <num> F ;
var10 = <num> F ;
var13 = true ;
}
}
}
else if ( var6 == <num> )
{
var14 = par1IBlockAccess . getBlockId ( par2 , par3 , par4 + <num> ) ;
var15 = par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4 + <num> ) ;
if ( func_82543_e ( var14 ) && ( var5 & <num> ) == ( var15 & <num> ) )
{
var16 = var15 & <num> ;
if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2  <num> , par3 , par4 , var5 ) )
{
var13 = true ;
}
else if ( var16 == <num> && ! this . func_82540_f ( par1IBlockAccess , par2 + <num> , par3 , par4 , var5 ) )
{
var9 = <num> F ;
var10 = <num> F ;
var13 = true ;
}
}
}
if ( var13 )
{
this . setBlockBounds ( var9 , var7 , var11 , var10 , var8 , var12 ) ;
}
return var13 ;
}
public void addCollidingBlockToList ( World par1World , int par2 , int par3 , int par4 , AxisAlignedBB par5AxisAlignedBB , List par6List , Entity par7Entity )
{
this . func_82541_d ( par1World , par2 , par3 , par4 ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
boolean var8 = this . func_82542_g ( par1World , par2 , par3 , par4 ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
if ( var8 && this . func_82544_h ( par1World , par2 , par3 , par4 ) )
{
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
public void randomDisplayTick ( World par1World , int par2 , int par3 , int par4 , Random par5Random )
{
this . modelBlock . randomDisplayTick ( par1World , par2 , par3 , par4 , par5Random ) ;
}
public void onBlockClicked ( World par1World , int par2 , int par3 , int par4 , EntityPlayer par5EntityPlayer )
{
this . modelBlock . onBlockClicked ( par1World , par2 , par3 , par4 , par5EntityPlayer ) ;
}
public void onBlockDestroyedByPlayer ( World par1World , int par2 , int par3 , int par4 , int par5 )
{
this . modelBlock . onBlockDestroyedByPlayer ( par1World , par2 , par3 , par4 , par5 ) ;
}
public int getMixedBrightnessForBlock ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 )
{
return this . modelBlock . getMixedBrightnessForBlock ( par1IBlockAccess , par2 , par3 , par4 ) ;
}
public float getBlockBrightness ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 )
{
return this . modelBlock . getBlockBrightness ( par1IBlockAccess , par2 , par3 , par4 ) ;
}
public float getExplosionResistance ( Entity par1Entity )
{
return this . modelBlock . getExplosionResistance ( par1Entity ) ;
}
public int getRenderBlockPass ( )
{
return this . modelBlock . getRenderBlockPass ( ) ;
}
public int getBlockTextureFromSideAndMetadata ( int par1 , int par2 )
{
return this . modelBlock . getBlockTextureFromSideAndMetadata ( par1 , this . field_72158_c ) ;
}
public int <unk> ( int par1 )
{
return this . modelBlock . getBlockTextureFromSideAndMetadata ( par1 , this . field_72158_c ) ;
}
public int tickRate ( )
{
return this . modelBlock . tickRate ( ) ;
}
public AxisAlignedBB getSelectedBoundingBoxFromPool ( World par1World , int par2 , int par3 , int par4 )
{
return this . modelBlock . getSelectedBoundingBoxFromPool ( par1World , par2 , par3 , par4 ) ;
}
public void velocityToAddToEntity ( World par1World , int par2 , int par3 , int par4 , Entity par5Entity , Vec3 par6Vec3 )
{
this . modelBlock . velocityToAddToEntity ( par1World , par2 , par3 , par4 , par5Entity , par6Vec3 ) ;
}
public boolean isCollidable ( )
{
return this . modelBlock . isCollidable ( ) ;
}
public boolean canCollideCheck ( int par1 , boolean par2 )
{
return this . modelBlock . canCollideCheck ( par1 , par2 ) ;
}
public boolean canPlaceBlockAt ( World par1World , int par2 , int par3 , int par4 )
{
return this . modelBlock . canPlaceBlockAt ( par1World , par2 , par3 , par4 ) ;
}
public void onBlockAdded ( World par1World , int par2 , int par3 , int par4 )
{
this . <unk> ( par1World , par2 , par3 , par4 , <num> ) ;
this . modelBlock . onBlockAdded ( par1World , par2 , par3 , par4 ) ;
}
public void breakBlock ( World par1World , int par2 , int par3 , int par4 , int par5 , int par6 )
{
this . modelBlock . breakBlock ( par1World , par2 , par3 , par4 , par5 , par6 ) ;
}
public void onEntityWalking ( World par1World , int par2 , int par3 , int par4 , Entity par5Entity )
{
this . modelBlock . onEntityWalking ( par1World , par2 , par3 , par4 , par5Entity ) ;
}
public void updateTick ( World par1World , int par2 , int par3 , int par4 , Random par5Random )
{
this . modelBlock . updateTick ( par1World , par2 , par3 , par4 , par5Random ) ;
}
public boolean onBlockActivated ( World par1World , int par2 , int par3 , int par4 , EntityPlayer par5EntityPlayer , int par6 , float par7 , float par8 , float par9 )
{
return this . modelBlock . onBlockActivated ( par1World , par2 , par3 , par4 , par5EntityPlayer , <num> , <num> F , <num> F , <num> F ) ;
}
public void onBlockDestroyedByExplosion ( World par1World , int par2 , int par3 , int par4 )
{
this . modelBlock . onBlockDestroyedByExplosion ( par1World , par2 , par3 , par4 ) ;
}
public void onBlockPlacedBy ( World par1World , int par2 , int par3 , int par4 , EntityLiving par5EntityLiving )
{
int var6 = MathHelper . floor_double ( ( double ) ( par5EntityLiving . rotationYaw * <num> F / <num> F ) + <num> D ) & <num> ;
int var7 = par1World . getBlockMetadata ( par2 , par3 , par4 ) & <num> ;
if ( var6 == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | var7 ) ;
}
if ( var6 == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | var7 ) ;
}
if ( var6 == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | var7 ) ;
}
if ( var6 == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | var7 ) ;
}
}
public void <unk> ( World par1World , int par2 , int par3 , int par4 , int par5 , float par6 , float par7 , float par8 )
{
if ( par5 == <num> || par5 != <num> && ( double ) par7 > <num> D )
{
int var9 = par1World . getBlockMetadata ( par2 , par3 , par4 ) ;
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , var9 | <num> ) ;
}
}
public MovingObjectPosition collisionRayTrace ( World par1World , int par2 , int par3 , int par4 , Vec3 par5Vec3 , Vec3 par6Vec3 )
{
MovingObjectPosition [ ] var7 = new MovingObjectPosition [ <num> ] ;
int var8 = par1World . getBlockMetadata ( par2 , par3 , par4 ) ;
int var9 = var8 & <num> ;
boolean var10 = ( var8 & <num> ) == <num> ;
int [ ] var11 = field_72159_a [ var9 + ( var10 ? <num> : <num> ) ] ;
this . field_72156_cr = true ;
int var14 ;
int var15 ;
int var16 ;
for ( int var12 = <num> ; var12 < <num> ; ++ var12 )
{
this . field_72160_cs = var12 ;
int [ ] var13 = var11 ;
var14 = var11 . length ;
for ( var15 = <num> ; var15 < var14 ; ++ var15 )
{
var16 = var13 [ var15 ] ;
if ( var16 == var12 )
{
;
}
}
var7 [ var12 ] = super . collisionRayTrace ( par1World , par2 , par3 , par4 , par5Vec3 , par6Vec3 ) ;
}
int [ ] var21 = var11 ;
int var24 = var11 . length ;
for ( var14 = <num> ; var14 < var24 ; ++ var14 )
{
var15 = var21 [ var14 ] ;
var7 [ var15 ] = null ;
}
MovingObjectPosition var23 = null ;
double var22 = <num> D ;
MovingObjectPosition [ ] var25 = var7 ;
var16 = var7 . length ;
for ( int var17 = <num> ; var17 < var16 ; ++ var17 )
{
MovingObjectPosition var18 = var25 [ var17 ] ;
if ( var18 != null )
{
double var19 = var18 . <unk> . <unk> ( par6Vec3 ) ;
if ( var19 > var22 )
{
var23 = var18 ;
var22 = var19 ;
}
}
}
return var23 ;
}
}
package net . minecraft . src ;
import java . util . Random ;
public class KonungBlockAlchemyNut extends BlockFlower
{
public KonungBlockAlchemyNut ( int i , int j )
{
super ( i , j ) ;
float f = <num> F ;
setBlockBounds ( <num> F  f , <num> F , <num> F  f , <num> F + f , f * <num> F , <num> F + f ) ;
setTickRandomly ( true ) ;
}
public int idDropped ( int i , Random random )
{
if ( blockID == mod_konungAlchemy . KonungNut . blockID )
{
return mod_konungAlchemy . KonungNut . blockID ;
}
else
{
return blockID ;
}
}
public int quantityDropped ( Random random )
{
return <num> ;
}
public void updateTick ( World world , int i , int j , int k , Random random )
{
if ( random . nextInt ( <num> ) == <num> )
{
int l = ( i + random . nextInt ( <num> ) )  <num> ;
int i1 = ( j + random . nextInt ( <num> ) )  random . nextInt ( <num> ) ;
int j1 = ( k + random . nextInt ( <num> ) )  <num> ;
if ( world . isAirBlock ( l , i1 , j1 ) && canBlockStay ( world , l , i1 , j1 ) )
{
world . setBlockWithNotify ( l , i1 , j1 , blockID ) ;
}
}
}
protected boolean canThisPlantGrowOnThisBlockID ( int i )
{
return i == Block . grass . blockID || i == Block . dirt . blockID || i == Block . tilledField . blockID ;
}
public boolean canBlockStay ( World world , int i , int j , int k )
{
if ( j < <num> || j >= <num> )
{
return false ;
} else
{
return ( world . getFullBlockLightValue ( i , j , k ) >= <num> || world . canBlockSeeTheSky ( i , j , k ) ) && canThisPlantGrowOnThisBlockID ( world . getBlockId ( i , j  <num> , k ) ) ;
}
}
}
package net . minecraft . src ;
public class KonungItemAntidotePotion extends Item
{
public KonungItemAntidotePotion ( int par1 )
{
super ( par1 ) ;
setMaxStackSize ( <num> ) ;
}
public ItemStack onFoodEaten ( ItemStack par1ItemStack , World par2World , EntityPlayer par3EntityPlayer )
{
par1ItemStack . stackSize  ;
if ( ! par2World . isRemote )
{
par3EntityPlayer . <unk> ( ) ;
}
return par1ItemStack ;
}
public int getMaxItemUseDuration ( ItemStack par1ItemStack )
{
return <num> ;
}
public EnumAction getItemUseAction ( ItemStack par1ItemStack )
{
return EnumAction . drink ;
}
public ItemStack onItemRightClick ( ItemStack par1ItemStack , World par2World , EntityPlayer par3EntityPlayer )
{
par3EntityPlayer . setItemInUse ( par1ItemStack , getMaxItemUseDuration ( par1ItemStack ) ) ;
return par1ItemStack ;
}
}
package net . minecraft . src ;
public class KonungItemPoisonSting extends Item
{
public KonungItemPoisonSting ( int i )
{
super ( i ) ;
setMaxStackSize ( <num> ) ;
}
}
package net . minecraft . src ;
public class mod_konungRefinedStairs extends BaseMod
{
public static final Block refinedStairs = ( new KonungBlockRefinedStairs ( <num> , mod_konungRefinedPlanks . refinedPlanks , <num> ) ) . setHardness ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) ;
public static final Block spruceRefinedStairs = ( new KonungBlockRefinedStairs ( <num> , mod_konungRefinedPlanks . refinedPlanks , <num> ) ) . setHardness ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) ;
public static final Block birchRefinedStairs = ( new KonungBlockRefinedStairs ( <num> , mod_konungRefinedPlanks . refinedPlanks , <num> ) ) . setHardness ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) ;
public static final Block jungleRefinedStairs = ( new KonungBlockRefinedStairs ( <num> , mod_konungRefinedPlanks . refinedPlanks , <num> ) ) . setHardness ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) ;
public mod_konungRefinedStairs ( )
{
ModLoader . registerBlock ( refinedStairs ) ;
ModLoader . registerBlock ( spruceRefinedStairs ) ;
ModLoader . registerBlock ( birchRefinedStairs ) ;
ModLoader . registerBlock ( jungleRefinedStairs ) ;
refinedStairs . blockIndexInTexture = ModLoader . addOverride ( " , " ) ;
spruceRefinedStairs . blockIndexInTexture = ModLoader . addOverride ( " , " ) ;
birchRefinedStairs . blockIndexInTexture = ModLoader . addOverride ( " , " ) ;
jungleRefinedStairs . blockIndexInTexture = ModLoader . addOverride ( " , " ) ;
ModLoader . addRecipe ( new ItemStack ( refinedStairs , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedPlanks . refinedPlanks , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( spruceRefinedStairs , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedPlanks . refinedPlanks , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( birchRefinedStairs , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedPlanks . refinedPlanks , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( jungleRefinedStairs , <num> , <num> ) , new Object [ ] { " , " , " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedPlanks . refinedPlanks , <num> , <num> ) } ) ;
}
public void load ( ) { } ;
public String getVersion ( ) { return " ; }
}
package net . minecraft . src ;
import java . util . Random ;
public class KonungEntitySpider extends <unk>
{
public KonungEntitySpider ( World par1World )
{
super ( par1World ) ;
texture = " ;
setSize ( <num> F , <num> F ) ;
moveSpeed = <num> F ;
}
public int getMaxHealth ( )
{
return <num> ;
}
public void onLivingUpdate ( )
{
super . onLivingUpdate ( ) ;
}
protected int <unk> ( )
{
return mod_konungMobs . KonungPoisonSting . itemID ;
}
protected void dropFewItems ( boolean par1 , int par2 )
{
super . dropFewItems ( par1 , par2 ) ;
if ( par1 && ( rand . nextInt ( <num> ) == <num> || rand . nextInt ( <num> + par2 ) > <num> ) )
{
dropItem ( mod_konungMobs . KonungPoisonSting . itemID , <num> ) ;
}
}
protected String <unk> ( )
{
return " ;
}
protected String <unk> ( )
{
return " ;
}
protected String <unk> ( )
{
return " ;
}
public float <unk> ( )
{
return <num> F ;
}
protected boolean isValidLightLevel ( )
{
return true ;
}
public boolean <unk> ( )
{
return isValidLightLevel ( ) ;
}
protected Entity <unk> ( )
{
return worldObj . <unk> ( this , 2D ) ;
}
protected void <unk> ( Entity par1Entity , float par2 )
{
if ( <unk> )
{
( ( EntityLiving ) par1Entity ) . addPotionEffect ( new PotionEffect ( Potion . <unk> . id , <num> * <num> , <num> ) ) ;
double d = par1Entity . posX  posX ;
double d1 = par1Entity . posZ  posZ ;
float f1 = MathHelper . <unk> ( d * d + d1 * d1 ) ;
motionX = ( d / ( double ) f1 ) * <num> D * <num> D + motionX * <num> D ;
motionZ = ( d1 / ( double ) f1 ) * <num> D * <num> D + motionZ * <num> D ;
motionY = <num> D ;
}
}
}
package net . minecraft . src ;
public class KonungItemBench extends ItemBlock
{
public KonungItemBench ( int par1 , Block block )
{
super ( par1 ) ;
setHasSubtypes ( true ) ;
}
public int getMetadata ( int par1 )
{
return par1 ;
}
}
package net . minecraft . src ;
import java . util . ArrayList ;
import java . util . List ;
public class KonungBlockCornerStairs extends Block
{
public KonungBlockCornerStairs ( int i , int j )
{
super ( i , j , Material . grass ) ;
}
public void <unk> ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 )
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
public void addCollidingBlockToList ( World par1World , int par2 , int par3 , int par4 , AxisAlignedBB par5AxisAlignedBB , List par6List , Entity par7Entity )
{
int i = par1World . getBlockMetadata ( par2 , par3 , par4 ) ;
int j = i & <num> ;
float f = <num> F ;
float f1 = <num> F ;
float f2 = <num> F ;
float f3 = <num> F ;
if ( ( i & <num> ) != <num> )
{
f = <num> F ;
f1 = <num> F ;
f2 = <num> F ;
f3 = <num> F ;
}
this . setBlockBounds ( <num> F , f , <num> F , <num> F , f1 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
else if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
else if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
else if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
public void onBlockPlacedBy ( World par1World , int par2 , int par3 , int par4 , EntityLiving par5EntityLiving )
{
int i = MathHelper . floor_double ( ( double ) ( ( par5EntityLiving . rotationYaw * 4F ) / <num> F ) + <num> D ) & <num> ;
int j = par1World . getBlockMetadata ( par2 , par3 , par4 ) & <num> ;
if ( i == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | j ) ;
}
if ( i == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | j ) ;
}
if ( i == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | j ) ;
}
if ( i == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | j ) ;
}
}
public void onBlockPlaced ( World par1World , int par2 , int par3 , int par4 , int par5 )
{
if ( par5 == <num> )
{
int i = par1World . getBlockMetadata ( par2 , par3 , par4 ) ;
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , i | <num> ) ;
}
}
public void setBlockBoundsBasedOnState ( IBlockAccess iblockaccess , int i , int j , int k )
{
setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
public boolean isOpaqueCube ( )
{
return false ;
}
public boolean renderAsNormalBlock ( )
{
return false ;
}
package net . minecraft . src ;
public class mod_konungRefinedPlanks extends BaseMod
{
public static final Block refinedPlanks = ( new KonungBlockRefinedPlanks ( <num> ) ) . setHardness ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setBlockName ( " ) ;
public static int oakRefinedPlanksTexture ;
public static int spruceRefinedPlanksTexture ;
public static int birchRefinedPlanksTexture ;
public static int jungleRefinedPlanksTexture ;
public mod_konungRefinedPlanks ( )
{
ModLoader . registerBlock ( refinedPlanks ) ;
oakRefinedPlanksTexture = ModLoader . addOverride ( " , " ) ;
spruceRefinedPlanksTexture = ModLoader . addOverride ( " , " ) ;
birchRefinedPlanksTexture = ModLoader . addOverride ( " , " ) ;
jungleRefinedPlanksTexture = ModLoader . addOverride ( " , " ) ;
ModLoader . addRecipe ( new ItemStack ( refinedPlanks , <num> , <num> ) , new Object [ ] { " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedWood . refinedWood , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( refinedPlanks , <num> , <num> ) , new Object [ ] { " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedWood . refinedWood , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( refinedPlanks , <num> , <num> ) , new Object [ ] { " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedWood . refinedWood , <num> , <num> ) } ) ;
ModLoader . addRecipe ( new ItemStack ( refinedPlanks , <num> , <num> ) , new Object [ ] { " , Character . valueOf ( X' ) , new ItemStack ( mod_konungRefinedWood . refinedWood , <num> , <num> ) } ) ;
}
public void load ( ) { } ;
public String getVersion ( ) { return " ; }
}
package net . minecraft . src ;
import java . util . Random ;
public class KonungWorldGenAlchemy extends <unk>
{
private int plantBlockId ;
public KonungWorldGenAlchemy ( int par1 )
{
plantBlockId = par1 ;
}
public boolean generate ( World par1World , Random par2Random , int par3 , int par4 , int par5 )
{
for ( int i = <num> ; i < <num> ; i ++ )
{
int j = ( par3 + par2Random . nextInt ( <num> ) )  par2Random . nextInt ( <num> ) ;
int k = ( par4 + par2Random . nextInt ( <num> ) )  par2Random . nextInt ( <num> ) ;
int l = ( par5 + par2Random . nextInt ( <num> ) )  par2Random . nextInt ( <num> ) ;
if ( par1World . isAirBlock ( j , k , l ) && ( ( BlockFlower ) Block . blocksList [ plantBlockId ] ) . canBlockStay ( par1World , j , k , l ) )
{
par1World . setBlock ( j , k , l , plantBlockId ) ;
}
}
return true ;
}
}
package net . minecraft . src ;
import java . util . Random ;
public class mod_konungWeapons extends BaseMod
{
public static final Item KonungKnife = new ItemSword ( <num> , EnumToolMaterial . WOOD ) . setItemName ( " ) ;
public static final Item KonunGladius = new ItemSword ( <num> , EnumToolMaterial . STONE ) . setItemName ( " ) ;
public static final Item KonungSpata = new ItemSword ( <num> , EnumToolMaterial . IRON ) . setItemName ( " ) ;
public static final Item KonungLongSword = new ItemSword ( <num> , EnumToolMaterial . <unk> ) . setItemName ( " ) ;
public mod_konungWeapons ( )
{
ModLoader . addName ( KonungKnife , " ) ;
ModLoader . addName ( KonunGladius , " ) ;
ModLoader . addName ( KonungSpata , " ) ;
ModLoader . addName ( KonungLongSword , " ) ;
KonungKnife . iconIndex = ModLoader . addOverride ( " , " ) ;
KonunGladius . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungSpata . iconIndex = ModLoader . addOverride ( " , " ) ;
KonungLongSword . iconIndex = ModLoader . addOverride ( " , " ) ;
ModLoader . addRecipe ( new ItemStack ( KonungKnife , <num> ) , new Object [ ]
{
" , " , Character . valueOf ( #' ) , Item . ingotIron , Character . valueOf ( X' ) , Item . stick
} ) ;
ModLoader . addRecipe ( new ItemStack ( KonunGladius , <num> ) , new Object [ ]
{
" , " , " , Character . valueOf ( #' ) , Item . ingotIron , Character . valueOf ( X' ) , Item . stick
} ) ;
ModLoader . addRecipe ( new ItemStack ( KonungSpata , <num> ) , new Object [ ]
{
" , " , " , Character . valueOf ( #' ) , Item . ingotIron , Character . valueOf ( X' ) , Item . stick
} ) ;
ModLoader . addRecipe ( new ItemStack ( KonunGladius , <num> ) , new Object [ ]
{
" , " , " , Character . valueOf ( #' ) , Item . ingotIron , Character . valueOf ( X' ) , Item . stick
} ) ;
}
public void load ( ) { } ;
public String getVersion ( ) { return " ; }
}
package net . minecraft . src ;
public class KonungTileEntityWoodIdol extends TileEntity
{
public KonungTileEntityWoodIdol ( )
{
}
}
package net . minecraft . src ;
public class KonungModelBench extends ModelBase
{
ModelRenderer top ;
ModelRenderer leg1 ;
ModelRenderer leg2 ;
ModelRenderer leg3 ;
ModelRenderer leg4 ;
ModelRenderer pole ;
public KonungModelBench ( )
{
textureWidth = <num> ;
textureHeight = <num> ;
top = new ModelRenderer ( this , <num> , <num> ) ;
top . addBox (  8F , 0F ,  3F , <num> , <num> , <num> ) ;
top . setRotationPoint ( 0F , <num> F , 0F ) ;
top . setTextureSize ( <num> , <num> ) ;
top . mirror = true ;
setRotation ( top , 0F , 0F , 0F ) ;
leg1 = new ModelRenderer ( this , <num> , <num> ) ;
leg1 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
leg1 . setRotationPoint (  6F , <num> F ,  3F ) ;
leg1 . setTextureSize ( <num> , <num> ) ;
leg1 . mirror = true ;
setRotation ( leg1 , 0F , 0F , 0F ) ;
leg2 = new ModelRenderer ( this , <num> , <num> ) ;
leg2 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
leg2 . setRotationPoint ( 4F , <num> F , 1F ) ;
leg2 . setTextureSize ( <num> , <num> ) ;
leg2 . mirror = true ;
setRotation ( leg2 , 0F , 0F , 0F ) ;
leg3 = new ModelRenderer ( this , <num> , <num> ) ;
leg3 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
leg3 . setRotationPoint ( 4F , <num> F ,  3F ) ;
leg3 . setTextureSize ( <num> , <num> ) ;
leg3 . mirror = true ;
setRotation ( leg3 , 0F , 0F , 0F ) ;
leg4 = new ModelRenderer ( this , <num> , <num> ) ;
leg4 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
leg4 . setRotationPoint (  6F , <num> F , 1F ) ;
leg4 . setTextureSize ( <num> , <num> ) ;
leg4 . mirror = true ;
setRotation ( leg4 , 0F , 0F , 0F ) ;
pole = new ModelRenderer ( this , <num> , <num> ) ;
pole . addBox (  8F ,  1F ,  1F , <num> , <num> , <num> ) ;
pole . setRotationPoint ( 1F , <num> F , 0F ) ;
pole . setTextureSize ( <num> , <num> ) ;
pole . mirror = true ;
setRotation ( pole , 0F , 0F , 0F ) ;
}
public void render ( Entity entity , float f , float f1 , float f2 , float f3 , float f4 , float f5 )
{
super . render ( entity , f , f1 , f2 , f3 , f4 , f5 ) ;
setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , entity ) ;
top . render ( f5 ) ;
leg1 . render ( f5 ) ;
leg2 . render ( f5 ) ;
leg3 . render ( f5 ) ;
leg4 . render ( f5 ) ;
pole . render ( f5 ) ;
}
private void setRotation ( ModelRenderer model , float x , float y , float z )
{
model . rotateAngleX = x ;
model . rotateAngleY = y ;
model . rotateAngleZ = z ;
}
public void setRotationAngles ( float f , float f1 , float f2 , float f3 , float f4 , float f5 , Entity par7Entity )
{
super . setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , par7Entity ) ;
}
public void renderModel ( float f )
{
top . render ( f ) ;
leg1 . render ( f ) ;
leg2 . render ( f ) ;
leg3 . render ( f ) ;
leg4 . render ( f ) ;
pole . render ( f ) ;
}
package net . minecraft . src ;
public class KonungTileEntityIdolIcon extends TileEntity
{
public KonungTileEntityIdolIcon ( )
{
}
}
package net . minecraft . src ;
public class KonungTileEntityTable extends TileEntity
{
public KonungTileEntityTable ( )
{
}
}
package net . minecraft . src ;
import net . minecraft . client . Minecraft ;
import org . lwjgl . opengl . GL11 ;
import java . io . File ;
public class mod_konungStockade extends BaseMod
{
public static void prepareProps ( )
{
props . getInt ( " , <num> ) ;
props . getInt ( " , <num> ) ;
}
public mod_konungStockade ( )
{
CornersRenderID = ModLoader . getUniqueBlockModelID ( this , true ) ;
enableAO = false ;
aoLightValueThis = <num> F ;
aoLightValueXNeg = <num> F ;
aoLightValueYNeg = <num> F ;
aoLightValueZNeg = <num> F ;
aoLightValueXPos = <num> F ;
aoLightValueYPos = <num> F ;
aoLightValueZPos = <num> F ;
aoLightValueXNegYNegZNeg = <num> F ;
aoLightValueXNegYNeg = <num> F ;
aoLightValueXNegYNegZPos = <num> F ;
aoLightValueYNegZNeg = <num> F ;
aoLightValueYNegZPos = <num> F ;
aoLightValueXPosYNegZNeg = <num> F ;
aoLightValueXPosYNeg = <num> F ;
aoLightValueXPosYNegZPos = <num> F ;
aoLightValueXNegYPosZNeg = <num> F ;
aoLightValueXNegYPos = <num> F ;
aoLightValueXNegYPosZPos = <num> F ;
aoLightValueYPosZNeg = <num> F ;
aoLightValueXPosYPosZNeg = <num> F ;
aoLightValueXPosYPos = <num> F ;
aoLightValueYPosZPos = <num> F ;
aoLightValueXPosYPosZPos = <num> F ;
aoLightValueXNegZNeg = <num> F ;
aoLightValueXPosZNeg = <num> F ;
aoLightValueXNegZPos = <num> F ;
aoLightValueXPosZPos = <num> F ;
field_22352_G = <num> ;
isBlockYPosZNeg = false ;
isBlockXPosYPos = false ;
isBlockXNegYPos = false ;
isBlockYPosZPos = false ;
isBlockXNegZNeg = false ;
isBlockXPosZPos = false ;
isBlockXNegZPos = false ;
isBlockXPosZNeg = false ;
isBlockYNegZNeg = false ;
isBlockXPosYNeg = false ;
isBlockXNegYNeg = false ;
isBlockYNegZPos = false ;
factorTop = <num> F ;
factorBottom = <num> F ;
factorEast = <num> F ;
factorWest = <num> F ;
factorNorth = <num> F ;
factorSouth = <num> F ;
colorRedTopLeft_TopFace = <num> F ;
colorRedBottomLeft_TopFace = <num> F ;
colorRedBottomRight_TopFace = <num> F ;
colorRedTopRight_TopFace = <num> F ;
colorGreenTopLeft_TopFace = <num> F ;
colorGreenBottomLeft_TopFace = <num> F ;
colorGreenBottomRight_TopFace = <num> F ;
colorGreenTopRight_TopFace = <num> F ;
colorBlueTopLeft_TopFace = <num> F ;
colorBlueBottomLeft_TopFace = <num> F ;
colorBlueBottomRight_TopFace = <num> F ;
colorBlueTopRight_TopFace = <num> F ;
colorRedTopLeft_BottomFace = <num> F ;
colorRedBottomLeft_BottomFace = <num> F ;
colorRedBottomRight_BottomFace = <num> F ;
colorRedTopRight_BottomFace = <num> F ;
colorGreenTopLeft_BottomFace = <num> F ;
colorGreenBottomLeft_BottomFace = <num> F ;
colorGreenBottomRight_BottomFace = <num> F ;
colorGreenTopRight_BottomFace = <num> F ;
colorBlueTopLeft_BottomFace = <num> F ;
colorBlueBottomLeft_BottomFace = <num> F ;
colorBlueBottomRight_BottomFace = <num> F ;
colorBlueTopRight_BottomFace = <num> F ;
colorRedTopLeft_EastFace = <num> F ;
colorRedBottomLeft_EastFace = <num> F ;
colorRedBottomRight_EastFace = <num> F ;
colorRedTopRight_EastFace = <num> F ;
colorGreenTopLeft_EastFace = <num> F ;
colorGreenBottomLeft_EastFace = <num> F ;
colorGreenBottomRight_EastFace = <num> F ;
colorGreenTopRight_EastFace = <num> F ;
colorBlueTopLeft_EastFace = <num> F ;
colorBlueBottomLeft_EastFace = <num> F ;
colorBlueBottomRight_EastFace = <num> F ;
colorBlueTopRight_EastFace = <num> F ;
colorRedTopLeft_WestFace = <num> F ;
colorRedBottomLeft_WestFace = <num> F ;
colorRedBottomRight_WestFace = <num> F ;
colorRedTopRight_WestFace = <num> F ;
colorGreenTopLeft_WestFace = <num> F ;
colorGreenBottomLeft_WestFace = <num> F ;
colorGreenBottomRight_WestFace = <num> F ;
colorGreenTopRight_WestFace = <num> F ;
colorBlueTopLeft_WestFace = <num> F ;
colorBlueBottomLeft_WestFace = <num> F ;
colorBlueBottomRight_WestFace = <num> F ;
colorBlueTopRight_WestFace = <num> F ;
colorRedTopLeft_NorthFace = <num> F ;
colorRedBottomLeft_NorthFace = <num> F ;
colorRedBottomRight_NorthFace = <num> F ;
colorRedTopRight_NorthFace = <num> F ;
colorGreenTopLeft_NorthFace = <num> F ;
colorGreenBottomLeft_NorthFace = <num> F ;
colorGreenBottomRight_NorthFace = <num> F ;
colorGreenTopRight_NorthFace = <num> F ;
colorBlueTopLeft_NorthFace = <num> F ;
colorBlueBottomLeft_NorthFace = <num> F ;
colorBlueBottomRight_NorthFace = <num> F ;
colorBlueTopRight_NorthFace = <num> F ;
colorRedTopLeft_SouthFace = <num> F ;
colorRedBottomLeft_SouthFace = <num> F ;
colorRedBottomRight_SouthFace = <num> F ;
colorRedTopRight_SouthFace = <num> F ;
colorGreenTopLeft_SouthFace = <num> F ;
colorGreenBottomLeft_SouthFace = <num> F ;
colorGreenBottomRight_SouthFace = <num> F ;
colorGreenTopRight_SouthFace = <num> F ;
colorBlueTopLeft_SouthFace = <num> F ;
colorBlueBottomLeft_SouthFace = <num> F ;
colorBlueBottomRight_SouthFace = <num> F ;
colorBlueTopRight_SouthFace = <num> F ;
colorRedSlopes = <num> F ;
colorGreenSlopes = <num> F ;
colorBlueSlopes = <num> F ;
ModLoader . <unk> ( " , " ) ;
BlockKaevWoodCorners . blockIndexInTexture = ModLoader . addOverride ( " , " ) ;
ModLoader . addRecipe ( new ItemStack ( BlockKaevWoodCorners , <num> , KonungBlockStockade . func_21035_d ( <num> ) ) , new Object [ ] {
" , " , Character . valueOf ( #' ) , Block . wood
} ) ;
}
private static String getAppdata ( )
{
return Minecraft . <unk> ( ) . getPath ( ) ;
}
public static KrushProps props ;
public static int CornersRenderID ;
public static int SlopesOpacity ;
public static final Block BlockKaevWoodCorners ;
public static Item ItemKaevWoodCorners ;
public static boolean <unk> = true ;
public static boolean field_27511_cfgGrassFix = true ;
public boolean enableAO ;
public float aoLightValueThis ;
public float aoLightValueXNeg ;
public float aoLightValueYNeg ;
public float aoLightValueZNeg ;
public float aoLightValueXPos ;
public float aoLightValueYPos ;
public float aoLightValueZPos ;
public float aoLightValueXNegYNegZNeg ;
public float aoLightValueXNegYNeg ;
public float aoLightValueXNegYNegZPos ;
public float aoLightValueYNegZNeg ;
public float aoLightValueYNegZPos ;
public float aoLightValueXPosYNegZNeg ;
public float aoLightValueXPosYNeg ;
public float aoLightValueXPosYNegZPos ;
public float aoLightValueXNegYPosZNeg ;
public float aoLightValueXNegYPos ;
public float aoLightValueXNegYPosZPos ;
public float aoLightValueYPosZNeg ;
public float aoLightValueXPosYPosZNeg ;
public float aoLightValueXPosYPos ;
public float aoLightValueYPosZPos ;
public float aoLightValueXPosYPosZPos ;
public float aoLightValueXNegZNeg ;
public float aoLightValueXPosZNeg ;
public float aoLightValueXNegZPos ;
public float aoLightValueXPosZPos ;
public int field_22352_G ;
public boolean isBlockYPosZNeg ;
public boolean isBlockXPosYPos ;
public boolean isBlockXNegYPos ;
public boolean isBlockYPosZPos ;
public boolean isBlockXNegZNeg ;
public boolean isBlockXPosZPos ;
public boolean isBlockXNegZPos ;
public boolean isBlockXPosZNeg ;
public boolean isBlockYNegZNeg ;
public boolean isBlockXPosYNeg ;
public boolean isBlockXNegYNeg ;
public boolean isBlockYNegZPos ;
public int <unk> ;
public int <unk> ;
public int <unk> ;
public float factorTop ;
public float factorBottom ;
public float factorEast ;
public float factorWest ;
public float factorNorth ;
public float factorSouth ;
public float colorRedTopLeft_TopFace ;
public float colorRedBottomLeft_TopFace ;
public float colorRedBottomRight_TopFace ;
public float colorRedTopRight_TopFace ;
public float colorGreenTopLeft_TopFace ;
public float colorGreenBottomLeft_TopFace ;
public float colorGreenBottomRight_TopFace ;
public float colorGreenTopRight_TopFace ;
public float colorBlueTopLeft_TopFace ;
public float colorBlueBottomLeft_TopFace ;
public float colorBlueBottomRight_TopFace ;
public float colorBlueTopRight_TopFace ;
public float colorRedTopLeft_BottomFace ;
public float colorRedBottomLeft_BottomFace ;
public float colorRedBottomRight_BottomFace ;
public float colorRedTopRight_BottomFace ;
public float colorGreenTopLeft_BottomFace ;
public float colorGreenBottomLeft_BottomFace ;
public float colorGreenBottomRight_BottomFace ;
public float colorGreenTopRight_BottomFace ;
public float colorBlueTopLeft_BottomFace ;
public float colorBlueBottomLeft_BottomFace ;
public float colorBlueBottomRight_BottomFace ;
public float colorBlueTopRight_BottomFace ;
public float colorRedTopLeft_EastFace ;
public float colorRedBottomLeft_EastFace ;
public float colorRedBottomRight_EastFace ;
public float colorRedTopRight_EastFace ;
public float colorGreenTopLeft_EastFace ;
public float colorGreenBottomLeft_EastFace ;
public float colorGreenBottomRight_EastFace ;
public float colorGreenTopRight_EastFace ;
public float colorBlueTopLeft_EastFace ;
public float colorBlueBottomLeft_EastFace ;
public float colorBlueBottomRight_EastFace ;
public float colorBlueTopRight_EastFace ;
public float colorRedTopLeft_WestFace ;
public float colorRedBottomLeft_WestFace ;
public float colorRedBottomRight_WestFace ;
public float colorRedTopRight_WestFace ;
public float colorGreenTopLeft_WestFace ;
public float colorGreenBottomLeft_WestFace ;
public float colorGreenBottomRight_WestFace ;
public float colorGreenTopRight_WestFace ;
public float colorBlueTopLeft_WestFace ;
public float colorBlueBottomLeft_WestFace ;
public float colorBlueBottomRight_WestFace ;
public float colorBlueTopRight_WestFace ;
public float colorRedTopLeft_NorthFace ;
public float colorRedBottomLeft_NorthFace ;
public float colorRedBottomRight_NorthFace ;
public float colorRedTopRight_NorthFace ;
public float colorGreenTopLeft_NorthFace ;
public float colorGreenBottomLeft_NorthFace ;
public float colorGreenBottomRight_NorthFace ;
public float colorGreenTopRight_NorthFace ;
public float colorBlueTopLeft_NorthFace ;
public float colorBlueBottomLeft_NorthFace ;
public float colorBlueBottomRight_NorthFace ;
public float colorBlueTopRight_NorthFace ;
public float colorRedTopLeft_SouthFace ;
public float colorRedBottomLeft_SouthFace ;
public float colorRedBottomRight_SouthFace ;
public float colorRedTopRight_SouthFace ;
public float colorGreenTopLeft_SouthFace ;
public float colorGreenBottomLeft_SouthFace ;
public float colorGreenBottomRight_SouthFace ;
public float colorGreenTopRight_SouthFace ;
public float colorBlueTopLeft_SouthFace ;
public float colorBlueBottomLeft_SouthFace ;
public float colorBlueBottomRight_SouthFace ;
public float colorBlueTopRight_SouthFace ;
public float colorRedSlopes ;
public float colorGreenSlopes ;
public float colorBlueSlopes ;
static
{
props = new KrushProps ( new File ( getAppdata ( ) + " ) . getPath ( ) ) ;
prepareProps ( ) ;
SlopesOpacity = props . getInt ( " ) ;
if ( props . getInt ( " ) != <num> ) {
BlockKaevWoodCorners = new KonungBlockStockade ( props . getInt ( " ) , <num> , Material . wood ) . setHardness ( <num> F ) . setStepSound ( Block . soundWoodFootstep ) . setResistance ( 5F ) . setBlockName ( " ) . setCreativeTab ( CreativeTabs . tabBlock ) ;
ItemKaevWoodCorners = new KonungItemStockade ( BlockKaevWoodCorners . blockID  <num> , " ) . setItemName ( " ) ;
} else {
BlockKaevWoodCorners = Block . stone ;
}
props . save ( ) ;
}
public void renderInvBlock ( RenderBlocks renderblocks , Block block , int i , int j )
{
Tessellator tessellator = Tessellator . instance ;
if ( j == CornersRenderID )
{
block . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
GL11 . glTranslatef (  <num> F ,  <num> F ,  <num> F ) ;
tessellator . startDrawingQuads ( ) ;
tessellator . setNormal ( <num> F ,  1F , <num> F ) ;
renderCornersBottomFace ( block , <num> D , <num> D , <num> D , block . getBlockTextureFromSideAndMetadata ( <num> , i ) , i + <num> , renderblocks , <num> ) ;
tessellator . draw ( ) ;
tessellator . startDrawingQuads ( ) ;
tessellator . setNormal ( <num> F , <num> F , <num> F ) ;
renderCornersTopFace ( block , <num> D , <num> D , <num> D , block . getBlockTextureFromSideAndMetadata ( <num> , i ) , i + <num> , renderblocks , <num> ) ;
tessellator . draw ( ) ;
tessellator . startDrawingQuads ( ) ;
tessellator . setNormal ( <num> F , <num> F ,  1F ) ;
renderCornersEastFace ( block , <num> D , <num> D , <num> D , block . getBlockTextureFromSideAndMetadata ( <num> , i ) , i + <num> , renderblocks , <num> ) ;
tessellator . draw ( ) ;
tessellator . startDrawingQuads ( ) ;
tessellator . setNormal ( <num> F , <num> F , <num> F ) ;
renderCornersWestFace ( block , <num> D , <num> D , <num> D , block . getBlockTextureFromSideAndMetadata ( <num> , i ) , i + <num> , renderblocks , <num> ) ;
tessellator . draw ( ) ;
tessellator . startDrawingQuads ( ) ;
tessellator . setNormal (  1F , <num> F , <num> F ) ;
renderCornersNorthFace ( block , <num> D , <num> D , <num> D , block . getBlockTextureFromSideAndMetadata ( <num> , i ) , i + <num> , renderblocks , <num> ) ;
tessellator . draw ( ) ;
tessellator . startDrawingQuads ( ) ;
tessellator . setNormal ( <num> F , <num> F , <num> F ) ;
renderCornersSouthFace ( block , <num> D , <num> D , <num> D , block . getBlockTextureFromSideAndMetadata ( <num> , i ) , i + <num> , renderblocks , <num> ) ;
tessellator . draw ( ) ;
GL11 . glTranslatef ( <num> F , <num> F , <num> F ) ;
}
block . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
public boolean <unk> ( RenderBlocks renderblocks , IBlockAccess iblockaccess , int i , int j , int k , Block block , int l )
{
if ( l == CornersRenderID )
{
return renderBlockCorners ( block , i , j , k , renderblocks , iblockaccess ) ;
}
return false ;
}
public boolean renderBlockCorners ( Block block , int i , int j , int k , RenderBlocks renderblocks , IBlockAccess iblockaccess )
{
int iDir = iblockaccess . getBlockMetadata ( i , j , k ) ;
int l = block . <unk> ( iblockaccess , i , j , k ) ;
float f = ( float ) ( l >> <num> & <num> ) / <num> F ;
float f1 = ( float ) ( l >> <num> & <num> ) / <num> F ;
float f2 = ( float ) ( l & <num> ) / <num> F ;
if ( Minecraft . <unk> ( ) )
{
return renderCornersBlockWithAmbientOcclusion ( block , i , j , k , f , f1 , f2 , iDir , renderblocks , iblockaccess ) ;
} else
{
return renderCornersBlockWithColorMultiplier ( block , i , j , k , f , f1 , f2 , iDir , renderblocks , iblockaccess ) ;
}
}
public boolean renderCornersBlockWithAmbientOcclusion ( Block block , int i , int j , int k , float f , float f1 , float f2 , int iDir , RenderBlocks renderblocks , IBlockAccess iblockaccess )
{
enableAO = true ;
boolean flag = false ;
boolean flag1 = true ;
boolean flag2 = true ;
boolean flag3 = true ;
boolean flag4 = true ;
boolean flag5 = true ;
boolean flag6 = true ;
aoLightValueThis = block . getAmbientOcclusionLightValue ( iblockaccess , i , j , k ) ;
aoLightValueXNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i  <num> , j , k ) ;
aoLightValueYNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i , j  <num> , k ) ;
aoLightValueZNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i , j , k  <num> ) ;
aoLightValueXPos = block . getAmbientOcclusionLightValue ( iblockaccess , i + <num> , j , k ) ;
aoLightValueYPos = block . getAmbientOcclusionLightValue ( iblockaccess , i , j + <num> , k ) ;
aoLightValueZPos = block . getAmbientOcclusionLightValue ( iblockaccess , i , j , k + <num> ) ;
aoLightValueXPosYPos = block . getAmbientOcclusionLightValue ( iblockaccess , i + <num> , j + <num> , k ) ;
aoLightValueXPosYNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i + <num> , j  <num> , k ) ;
aoLightValueXPosZPos = block . getAmbientOcclusionLightValue ( iblockaccess , i + <num> , j , k + <num> ) ;
aoLightValueXPosZNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i + <num> , j , k  <num> ) ;
aoLightValueXNegYPos = block . getAmbientOcclusionLightValue ( iblockaccess , i  <num> , j + <num> , k ) ;
aoLightValueXNegYNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i  <num> , j  <num> , k ) ;
aoLightValueXNegZNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i  <num> , j , k  <num> ) ;
aoLightValueXNegZPos = block . getAmbientOcclusionLightValue ( iblockaccess , i  <num> , j , k + <num> ) ;
aoLightValueYPosZPos = block . getAmbientOcclusionLightValue ( iblockaccess , i , j + <num> , k + <num> ) ;
aoLightValueYPosZNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i , j + <num> , k  <num> ) ;
aoLightValueYNegZPos = block . getAmbientOcclusionLightValue ( iblockaccess , i , j  <num> , k + <num> ) ;
aoLightValueYNegZNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i , j  <num> , k  <num> ) ;
aoLightValueXPosYPosZPos = block . getAmbientOcclusionLightValue ( iblockaccess , i + <num> , j + <num> , k + <num> ) ;
aoLightValueXPosYNegZPos = block . getAmbientOcclusionLightValue ( iblockaccess , i + <num> , j  <num> , k + <num> ) ;
aoLightValueXPosYPosZNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i + <num> , j + <num> , k  <num> ) ;
aoLightValueXPosYNegZNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i + <num> , j  <num> , k  <num> ) ;
aoLightValueXNegYPosZPos = block . getAmbientOcclusionLightValue ( iblockaccess , i  <num> , j + <num> , k + <num> ) ;
aoLightValueXNegYNegZPos = block . getAmbientOcclusionLightValue ( iblockaccess , i  <num> , j  <num> , k + <num> ) ;
aoLightValueXNegYPosZNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i  <num> , j + <num> , k  <num> ) ;
aoLightValueXNegYNegZNeg = block . getAmbientOcclusionLightValue ( iblockaccess , i  <num> , j  <num> , k  <num> ) ;
if ( block . blockIndexInTexture == <num> )
{
flag1 = flag3 = flag4 = flag5 = flag6 = false ;
}
float f7 ;
float f13 ;
float f19 ;
float f25 ;
if ( field_22352_G > <num> )
{
f7 = ( aoLightValueXNegYNegZPos + aoLightValueXNegYNeg + aoLightValueYNegZPos + aoLightValueYNeg ) / 4F ;
f25 = ( aoLightValueYNegZPos + aoLightValueYNeg + aoLightValueXPosYNegZPos + aoLightValueXPosYNeg ) / 4F ;
f19 = ( aoLightValueYNeg + aoLightValueYNegZNeg + aoLightValueXPosYNeg + aoLightValueXPosYNegZNeg ) / 4F ;
f13 = ( aoLightValueXNegYNeg + aoLightValueXNegYNegZNeg + aoLightValueYNeg + aoLightValueYNegZNeg ) / 4F ;
} else
{
f7 = f13 = f19 = f25 = aoLightValueYNeg ;
}
colorRedTopLeft_BottomFace = colorRedBottomLeft_BottomFace = colorRedBottomRight_BottomFace = colorRedTopRight_BottomFace = ( flag1 ? f : <num> F ) * <num> F ;
colorGreenTopLeft_BottomFace = colorGreenBottomLeft_BottomFace = colorGreenBottomRight_BottomFace = colorGreenTopRight_BottomFace = ( flag1 ? f1 : <num> F ) * <num> F ;
colorBlueTopLeft_BottomFace = colorBlueBottomLeft_BottomFace = colorBlueBottomRight_BottomFace = colorBlueTopRight_BottomFace = ( flag1 ? f2 : <num> F ) * <num> F ;
colorRedTopLeft_BottomFace *= f7 ;
colorGreenTopLeft_BottomFace *= f7 ;
colorBlueTopLeft_BottomFace *= f7 ;
colorRedBottomLeft_BottomFace *= f13 ;
colorGreenBottomLeft_BottomFace *= f13 ;
colorBlueBottomLeft_BottomFace *= f13 ;
colorRedBottomRight_BottomFace *= f19 ;
colorGreenBottomRight_BottomFace *= f19 ;
colorBlueBottomRight_BottomFace *= f19 ;
colorRedTopRight_BottomFace *= f25 ;
colorGreenTopRight_BottomFace *= f25 ;
colorBlueTopRight_BottomFace *= f25 ;
float f8 ;
float f14 ;
float f20 ;
float f26 ;
if ( field_22352_G > <num> )
{
f26 = ( aoLightValueXNegYPosZPos + aoLightValueXNegYPos + aoLightValueYPosZPos + aoLightValueYPos ) / 4F ;
f8 = ( aoLightValueYPosZPos + aoLightValueYPos + aoLightValueXPosYPosZPos + aoLightValueXPosYPos ) / 4F ;
f14 = ( aoLightValueYPos + aoLightValueYPosZNeg + aoLightValueXPosYPos + aoLightValueXPosYPosZNeg ) / 4F ;
f20 = ( aoLightValueXNegYPos + aoLightValueXNegYPosZNeg + aoLightValueYPos + aoLightValueYPosZNeg ) / 4F ;
} else
{
f8 = f14 = f20 = f26 = aoLightValueYPos ;
}
colorRedTopLeft_TopFace = colorRedBottomLeft_TopFace = colorRedBottomRight_TopFace = colorRedTopRight_TopFace = flag2 ? f : <num> F ;
colorGreenTopLeft_TopFace = colorGreenBottomLeft_TopFace = colorGreenBottomRight_TopFace = colorGreenTopRight_TopFace = flag2 ? f1 : <num> F ;
colorBlueTopLeft_TopFace = colorBlueBottomLeft_TopFace = colorBlueBottomRight_TopFace = colorBlueTopRight_TopFace = flag2 ? f2 : <num> F ;
colorRedTopLeft_TopFace *= f8 ;
colorGreenTopLeft_TopFace *= f8 ;
colorBlueTopLeft_TopFace *= f8 ;
colorRedBottomLeft_TopFace *= f14 ;
colorGreenBottomLeft_TopFace *= f14 ;
colorBlueBottomLeft_TopFace *= f14 ;
colorRedBottomRight_TopFace *= f20 ;
colorGreenBottomRight_TopFace *= f20 ;
colorBlueBottomRight_TopFace *= f20 ;
colorRedTopRight_TopFace *= f26 ;
colorGreenTopRight_TopFace *= f26 ;
colorBlueTopRight_TopFace *= f26 ;
float f9 ;
float f15 ;
float f21 ;
float f27 ;
if ( field_22352_G > <num> )
{
f9 = ( aoLightValueXNegZNeg + aoLightValueXNegYPosZNeg + aoLightValueZNeg + aoLightValueYPosZNeg ) / 4F ;
f15 = ( aoLightValueZNeg + aoLightValueYPosZNeg + aoLightValueXPosZNeg + aoLightValueXPosYPosZNeg ) / 4F ;
f21 = ( aoLightValueYNegZNeg + aoLightValueZNeg + aoLightValueXPosYNegZNeg + aoLightValueXPosZNeg ) / 4F ;
f27 = ( aoLightValueXNegYNegZNeg + aoLightValueXNegZNeg + aoLightValueYNegZNeg + aoLightValueZNeg ) / 4F ;
} else
{
f9 = f15 = f21 = f27 = aoLightValueZNeg ;
}
colorRedTopLeft_EastFace = colorRedBottomLeft_EastFace = colorRedBottomRight_EastFace = colorRedTopRight_EastFace = ( flag3 ? f : <num> F ) * <num> F ;
colorGreenTopLeft_EastFace = colorGreenBottomLeft_EastFace = colorGreenBottomRight_EastFace = colorGreenTopRight_EastFace = ( flag3 ? f1 : <num> F ) * <num> F ;
colorBlueTopLeft_EastFace = colorBlueBottomLeft_EastFace = colorBlueBottomRight_EastFace = colorBlueTopRight_EastFace = ( flag3 ? f2 : <num> F ) * <num> F ;
colorRedTopLeft_EastFace *= f9 ;
colorGreenTopLeft_EastFace *= f9 ;
colorBlueTopLeft_EastFace *= f9 ;
colorRedBottomLeft_EastFace *= f15 ;
colorGreenBottomLeft_EastFace *= f15 ;
colorBlueBottomLeft_EastFace *= f15 ;
colorRedBottomRight_EastFace *= f21 ;
colorGreenBottomRight_EastFace *= f21 ;
colorBlueBottomRight_EastFace *= f21 ;
colorRedTopRight_EastFace *= f27 ;
colorGreenTopRight_EastFace *= f27 ;
colorBlueTopRight_EastFace *= f27 ;
int l = block . getBlockTexture ( iblockaccess , i , j , k , <num> ) ;
float f10 ;
float f16 ;
float f22 ;
float f28 ;
if ( field_22352_G > <num> )
{
f10 = ( aoLightValueXNegZPos + aoLightValueXNegYPosZPos + aoLightValueZPos + aoLightValueYPosZPos ) / 4F ;
f28 = ( aoLightValueZPos + aoLightValueYPosZPos + aoLightValueXPosZPos + aoLightValueXPosYPosZPos ) / 4F ;
f22 = ( aoLightValueYNegZPos + aoLightValueZPos + aoLightValueXPosYNegZPos + aoLightValueXPosZPos ) / 4F ;
f16 = ( aoLightValueXNegYNegZPos + aoLightValueXNegZPos + aoLightValueYNegZPos + aoLightValueZPos ) / 4F ;
} else
{
f10 = f16 = f22 = f28 = aoLightValueZPos ;
}
colorRedTopLeft_WestFace = colorRedBottomLeft_WestFace = colorRedBottomRight_WestFace = colorRedTopRight_WestFace = ( flag4 ? f : <num> F ) * <num> F ;
colorGreenTopLeft_WestFace = colorGreenBottomLeft_WestFace = colorGreenBottomRight_WestFace = colorGreenTopRight_WestFace = ( flag4 ? f1 : <num> F ) * <num> F ;
colorBlueTopLeft_WestFace = colorBlueBottomLeft_WestFace = colorBlueBottomRight_WestFace = colorBlueTopRight_WestFace = ( flag4 ? f2 : <num> F ) * <num> F ;
colorRedTopLeft_WestFace *= f10 ;
colorGreenTopLeft_WestFace *= f10 ;
colorBlueTopLeft_WestFace *= f10 ;
colorRedBottomLeft_WestFace *= f16 ;
colorGreenBottomLeft_WestFace *= f16 ;
colorBlueBottomLeft_WestFace *= f16 ;
colorRedBottomRight_WestFace *= f22 ;
colorGreenBottomRight_WestFace *= f22 ;
colorBlueBottomRight_WestFace *= f22 ;
colorRedTopRight_WestFace *= f28 ;
colorGreenTopRight_WestFace *= f28 ;
colorBlueTopRight_WestFace *= f28 ;
int i1 = block . getBlockTexture ( iblockaccess , i , j , k , <num> ) ;
float f11 ;
float f17 ;
float f23 ;
float f29 ;
if ( field_22352_G > <num> )
{
f29 = ( aoLightValueXNegYNeg + aoLightValueXNegYNegZPos + aoLightValueXNeg + aoLightValueXNegZPos ) / 4F ;
f11 = ( aoLightValueXNeg + aoLightValueXNegZPos + aoLightValueXNegYPos + aoLightValueXNegYPosZPos ) / 4F ;
f17 = ( aoLightValueXNegZNeg + aoLightValueXNeg + aoLightValueXNegYPosZNeg + aoLightValueXNegYPos ) / 4F ;
f23 = ( aoLightValueXNegYNegZNeg + aoLightValueXNegYNeg + aoLightValueXNegZNeg + aoLightValueXNeg ) / 4F ;
} else
{
f11 = f17 = f23 = f29 = aoLightValueXNeg ;
}
colorRedTopLeft_NorthFace = colorRedBottomLeft_NorthFace = colorRedBottomRight_NorthFace = colorRedTopRight_NorthFace = ( flag5 ? f : <num> F ) * <num> F ;
colorGreenTopLeft_NorthFace = colorGreenBottomLeft_NorthFace = colorGreenBottomRight_NorthFace = colorGreenTopRight_NorthFace = ( flag5 ? f1 : <num> F ) * <num> F ;
colorBlueTopLeft_NorthFace = colorBlueBottomLeft_NorthFace = colorBlueBottomRight_NorthFace = colorBlueTopRight_NorthFace = ( flag5 ? f2 : <num> F ) * <num> F ;
colorRedTopLeft_NorthFace *= f11 ;
colorGreenTopLeft_NorthFace *= f11 ;
colorBlueTopLeft_NorthFace *= f11 ;
colorRedBottomLeft_NorthFace *= f17 ;
colorGreenBottomLeft_NorthFace *= f17 ;
colorBlueBottomLeft_NorthFace *= f17 ;
colorRedBottomRight_NorthFace *= f23 ;
colorGreenBottomRight_NorthFace *= f23 ;
colorBlueBottomRight_NorthFace *= f23 ;
colorRedTopRight_NorthFace *= f29 ;
colorGreenTopRight_NorthFace *= f29 ;
colorBlueTopRight_NorthFace *= f29 ;
int j1 = block . getBlockTexture ( iblockaccess , i , j , k , <num> ) ;
float f12 ;
float f18 ;
float f24 ;
float f30 ;
if ( field_22352_G > <num> )
{
f12 = ( aoLightValueXPosYNeg + aoLightValueXPosYNegZPos + aoLightValueXPos + aoLightValueXPosZPos ) / 4F ;
f30 = ( aoLightValueXPos + aoLightValueXPosZPos + aoLightValueXPosYPos + aoLightValueXPosYPosZPos ) / 4F ;
f24 = ( aoLightValueXPosZNeg + aoLightValueXPos + aoLightValueXPosYPosZNeg + aoLightValueXPosYPos ) / 4F ;
f18 = ( aoLightValueXPosYNegZNeg + aoLightValueXPosYNeg + aoLightValueXPosZNeg + aoLightValueXPos ) / 4F ;
} else
{
f12 = f18 = f24 = f30 = aoLightValueXPos ;
}
colorRedTopLeft_SouthFace = colorRedBottomLeft_SouthFace = colorRedBottomRight_SouthFace = colorRedTopRight_SouthFace = ( flag6 ? f : <num> F ) * <num> F ;
colorGreenTopLeft_SouthFace = colorGreenBottomLeft_SouthFace = colorGreenBottomRight_SouthFace = colorGreenTopRight_SouthFace = ( flag6 ? f1 : <num> F ) * <num> F ;
colorBlueTopLeft_SouthFace = colorBlueBottomLeft_SouthFace = colorBlueBottomRight_SouthFace = colorBlueTopRight_SouthFace = ( flag6 ? f2 : <num> F ) * <num> F ;
colorRedTopLeft_SouthFace *= f12 ;
colorGreenTopLeft_SouthFace *= f12 ;
colorBlueTopLeft_SouthFace *= f12 ;
colorRedBottomLeft_SouthFace *= f18 ;
colorGreenBottomLeft_SouthFace *= f18 ;
colorBlueBottomLeft_SouthFace *= f18 ;
colorRedBottomRight_SouthFace *= f24 ;
colorGreenBottomRight_SouthFace *= f24 ;
colorBlueBottomRight_SouthFace *= f24 ;
colorRedTopRight_SouthFace *= f30 ;
colorGreenTopRight_SouthFace *= f30 ;
colorBlueTopRight_SouthFace *= f30 ;
int k1 = block . getBlockTexture ( iblockaccess , i , j , k , <num> ) ;
colorRedSlopes = f ;
colorGreenSlopes = f1 ;
colorBlueSlopes = f2 ;
if ( block . shouldSideBeRendered ( iblockaccess , i , j  <num> , k , <num> ) )
{
renderCornersBottomFace ( block , i , j , k , block . getBlockTexture ( iblockaccess , i , j , k , <num> ) , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
flag = true ;
}
if ( block . shouldSideBeRendered ( iblockaccess , i , j + <num> , k , <num> ) )
{
renderCornersTopFace ( block , i , j , k , block . getBlockTexture ( iblockaccess , i , j , k , <num> ) , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
flag = true ;
}
if ( block . shouldSideBeRendered ( iblockaccess , i , j , k  <num> , <num> ) )
{
renderCornersEastFace ( block , i , j , k , l , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
if ( field_27511_cfgGrassFix && l == <num> )
{
colorRedTopLeft_EastFace *= f ;
colorRedBottomLeft_EastFace *= f ;
colorRedBottomRight_EastFace *= f ;
colorRedTopRight_EastFace *= f ;
colorGreenTopLeft_EastFace *= f1 ;
colorGreenBottomLeft_EastFace *= f1 ;
colorGreenBottomRight_EastFace *= f1 ;
colorGreenTopRight_EastFace *= f1 ;
colorBlueTopLeft_EastFace *= f2 ;
colorBlueBottomLeft_EastFace *= f2 ;
colorBlueBottomRight_EastFace *= f2 ;
colorBlueTopRight_EastFace *= f2 ;
renderCornersEastFace ( block , i , j , k , <num> , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
}
flag = true ;
}
if ( block . shouldSideBeRendered ( iblockaccess , i , j , k + <num> , <num> ) )
{
renderCornersWestFace ( block , i , j , k , i1 , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
if ( field_27511_cfgGrassFix && i1 == <num> )
{
colorRedTopLeft_WestFace *= f ;
colorRedBottomLeft_WestFace *= f ;
colorRedBottomRight_WestFace *= f ;
colorRedTopRight_WestFace *= f ;
colorGreenTopLeft_WestFace *= f1 ;
colorGreenBottomLeft_WestFace *= f1 ;
colorGreenBottomRight_WestFace *= f1 ;
colorGreenTopRight_WestFace *= f1 ;
colorBlueTopLeft_WestFace *= f2 ;
colorBlueBottomLeft_WestFace *= f2 ;
colorBlueBottomRight_WestFace *= f2 ;
colorBlueTopRight_WestFace *= f2 ;
renderCornersWestFace ( block , i , j , k , <num> , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
}
flag = true ;
}
if ( block . shouldSideBeRendered ( iblockaccess , i  <num> , j , k , <num> ) )
{
renderCornersNorthFace ( block , i , j , k , j1 , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
if ( field_27511_cfgGrassFix && j1 == <num> )
{
colorRedTopLeft_NorthFace *= f ;
colorRedBottomLeft_NorthFace *= f ;
colorRedBottomRight_NorthFace *= f ;
colorRedTopRight_NorthFace *= f ;
colorGreenTopLeft_NorthFace *= f1 ;
colorGreenBottomLeft_NorthFace *= f1 ;
colorGreenBottomRight_NorthFace *= f1 ;
colorGreenTopRight_NorthFace *= f1 ;
colorBlueTopLeft_NorthFace *= f2 ;
colorBlueBottomLeft_NorthFace *= f2 ;
colorBlueBottomRight_NorthFace *= f2 ;
colorBlueTopRight_NorthFace *= f2 ;
renderCornersNorthFace ( block , i , j , k , <num> , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
}
flag = true ;
}
if ( block . shouldSideBeRendered ( iblockaccess , i + <num> , j , k , <num> ) )
{
renderCornersSouthFace ( block , i , j , k , k1 , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
if ( field_27511_cfgGrassFix && k1 == <num> )
{
colorRedTopLeft_SouthFace *= f ;
colorRedBottomLeft_SouthFace *= f ;
colorRedBottomRight_SouthFace *= f ;
colorRedTopRight_SouthFace *= f ;
colorGreenTopLeft_SouthFace *= f1 ;
colorGreenBottomLeft_SouthFace *= f1 ;
colorGreenBottomRight_SouthFace *= f1 ;
colorGreenTopRight_SouthFace *= f1 ;
colorBlueTopLeft_SouthFace *= f2 ;
colorBlueBottomLeft_SouthFace *= f2 ;
colorBlueBottomRight_SouthFace *= f2 ;
colorBlueTopRight_SouthFace *= f2 ;
renderCornersSouthFace ( block , i , j , k , <num> , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
}
flag = true ;
}
enableAO = false ;
return flag ;
}
public boolean renderCornersBlockWithColorMultiplier ( Block block , int i , int j , int k , float f , float f1 , float f2 , int iDir , RenderBlocks renderblocks , IBlockAccess iblockaccess )
{
Tessellator tessellator = Tessellator . instance ;
boolean flag = false ;
float f3 = <num> F ;
float f4 = 1F ;
float f5 = <num> F ;
float f6 = <num> F ;
float f7 = f4 * f ;
float f8 = f4 * f1 ;
float f9 = f4 * f2 ;
if ( block == Block . grass )
{
f = f1 = f2 = <num> F ;
}
float f10 = f3 * f ;
float f11 = f5 * f ;
float f12 = f6 * f ;
float f13 = f3 * f1 ;
float f14 = f5 * f1 ;
float f15 = f6 * f1 ;
float f16 = f3 * f2 ;
float f17 = f5 * f2 ;
float f18 = f6 * f2 ;
float f19 = block . getAmbientOcclusionLightValue ( iblockaccess , i , j , k ) ;
if ( block . shouldSideBeRendered ( iblockaccess , i , j  <num> , k , <num> ) )
{
if ( iDir / <num> != <num> && iDir / <num> != <num> ) {
float f20 = block . getAmbientOcclusionLightValue ( iblockaccess , i , j  <num> , k ) ;
tessellator . setColorOpaque_F ( f10 * f20 , f13 * f20 , f16 * f20 ) ;
renderCornersBottomFace ( block , i , j , k , block . getBlockTexture ( iblockaccess , i , j , k , <num> ) , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
flag = true ;
}
}
if ( block . shouldSideBeRendered ( iblockaccess , i , j + <num> , k , <num> ) )
{
if ( iDir / <num> != <num> && iDir / <num> != <num> ) {
float f21 = block . getAmbientOcclusionLightValue ( iblockaccess , i , j + <num> , k ) ;
if ( block . maxY != <num> D && ! block . blockMaterial . isLiquid ( ) )
{
f21 = f19 ;
}
tessellator . setColorOpaque_F ( f7 * f21 , f8 * f21 , f9 * f21 ) ;
renderCornersTopFace ( block , i , j , k , block . getBlockTexture ( iblockaccess , i , j , k , <num> ) , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
flag = true ;
}
}
if ( block . shouldSideBeRendered ( iblockaccess , i , j , k  <num> , <num> ) || iDir % <num> == <num> )
{
float f22 = block . getAmbientOcclusionLightValue ( iblockaccess , i , j , k  <num> ) ;
if ( iDir % <num> == <num> ) {
f22 = f19 ;
}
tessellator . setColorOpaque_F ( f11 * f22 , f14 * f22 , f17 * f22 ) ;
renderCornersEastFace ( block , i , j , k , block . getBlockTexture ( iblockaccess , i , j , k , <num> ) , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
flag = true ;
}
if ( block . shouldSideBeRendered ( iblockaccess , i , j , k + <num> , <num> ) || iDir % <num> == <num> )
{
float f23 = block . getAmbientOcclusionLightValue ( iblockaccess , i , j , k + <num> ) ;
if ( iDir % <num> == <num> )
{
f23 = f19 ;
}
tessellator . setColorOpaque_F ( f11 * f23 , f14 * f23 , f17 * f23 ) ;
renderCornersWestFace ( block , i , j , k , block . getBlockTexture ( iblockaccess , i , j , k , <num> ) , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
flag = true ;
}
if ( block . shouldSideBeRendered ( iblockaccess , i  <num> , j , k , <num> ) || iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> )
{
float f24 = block . getAmbientOcclusionLightValue ( iblockaccess , i  <num> , j , k ) ;
if ( iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> )
{
f24 = f19 ;
}
tessellator . setColorOpaque_F ( f12 * f24 , f15 * f24 , f18 * f24 ) ;
renderCornersNorthFace ( block , i , j , k , block . getBlockTexture ( iblockaccess , i , j , k , <num> ) , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
flag = true ;
}
if ( block . shouldSideBeRendered ( iblockaccess , i + <num> , j , k , <num> ) || iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> )
{
float f25 = block . getAmbientOcclusionLightValue ( iblockaccess , i + <num> , j , k ) ;
if ( iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> || iDir == <num> )
{
f25 = f19 ;
}
tessellator . setColorOpaque_F ( f12 * f25 , f15 * f25 , f18 * f25 ) ;
renderCornersSouthFace ( block , i , j , k , block . getBlockTexture ( iblockaccess , i , j , k , <num> ) , iDir , renderblocks , block . getMixedBrightnessForBlock ( iblockaccess , i , j , k ) ) ;
flag = true ;
}
return flag ;
}
public void renderCornersBottomFace ( Block block , double d , double d1 , double d2 , int i , int iDir , RenderBlocks renderblocks , int lBrightness )
{
Tessellator tessellator = Tessellator . instance ;
tessellator . setBrightness ( lBrightness ) ;
int j = ( i & <num> ) << <num> ;
int k = i & <num> ;
double d3 = ( ( double ) j + block . minX * <num> D ) / <num> D ;
double d4 = ( ( ( double ) j + block . maxX * <num> D )  <num> D ) / <num> D ;
double d5 = ( ( double ) k + block . minZ * <num> D ) / <num> D ;
double d6 = ( ( ( double ) k + block . maxZ * <num> D )  <num> D ) / <num> D ;
if ( block . minX < <num> D || block . maxX > <num> D )
{
d3 = ( ( float ) j + <num> F ) / <num> F ;
d4 = ( ( float ) j + <num> F ) / <num> F ;
}
if ( block . minZ < <num> D || block . maxZ > <num> D )
{
d5 = ( ( float ) k + <num> F ) / <num> F ;
d6 = ( ( float ) k + <num> F ) / <num> F ;
}
double d7 = d + block . minX ;
double d8 = d + block . maxX ;
double d9 = d1 + block . minY ;
double d10 = d2 + block . minZ ;
double d11 = d2 + block . maxZ ;
if ( enableAO )
{
if ( iDir / <num> == <num> ) {
tessellator . setColorOpaque_F ( colorRedTopLeft_BottomFace , colorGreenTopLeft_BottomFace , colorBlueTopLeft_BottomFace ) ;
tessellator . addVertexWithUV ( d7 , d9 , d11 , d3 , d6 ) ;
tessellator . setColorOpaque_F ( colorRedBottomLeft_BottomFace , colorGreenBottomLeft_BottomFace , colorBlueBottomLeft_BottomFace ) ;
tessellator . addVertexWithUV ( d7 , d9 , d10 , d3 , d5 ) ;
tessellator . setColorOpaque_F ( colorRedBottomRight_BottomFace , colorGreenBottomRight_BottomFace , colorBlueBottomRight_BottomFace ) ;
tessellator . addVertexWithUV ( d8 , d9 , d10 , d4 , d5 ) ;
tessellator . setColorOpaque_F ( colorRedTopRight_BottomFace , colorGreenTopRight_BottomFace , colorBlueTopRight_BottomFace ) ;
tessellator . addVertexWithUV ( d8 , d9 , d11 , d4 , d6 ) ;
}
} else
{
if ( iDir / <num> == <num> ) {
tessellator . addVertexWithUV ( d7 , d9 , d11 , d3 , d6 ) ;
tessellator . addVertexWithUV ( d7 , d9 , d10 , d3 , d5 ) ;
tessellator . addVertexWithUV ( d8 , d9 , d10 , d4 , d5 ) ;
tessellator . addVertexWithUV ( d8 , d9 , d11 , d4 , d6 ) ;
}
}
}
public void renderCornersTopFace ( Block block , double d , double d1 , double d2 , int i , int iDir , RenderBlocks renderblocks , int lBrightness )
{
Tessellator tessellator = Tessellator . instance ;
tessellator . setBrightness ( lBrightness ) ;
int j = ( i & <num> ) << <num> ;
int k = i & <num> ;
double d3 = ( ( double ) j + block . minX * <num> D ) / <num> D ;
double d4 = ( ( ( double ) j + block . maxX * <num> D )  <num> D ) / <num> D ;
double d5 = ( ( double ) k + block . minZ * <num> D ) / <num> D ;
double d6 = ( ( ( double ) k + block . maxZ * <num> D )  <num> D ) / <num> D ;
if ( block . minX < <num> D || block . maxX > <num> D )
{
d3 = ( ( float ) j + <num> F ) / <num> F ;
d4 = ( ( float ) j + <num> F ) / <num> F ;
}
if ( block . minZ < <num> D || block . maxZ > <num> D )
{
d5 = ( ( float ) k + <num> F ) / <num> F ;
d6 = ( ( float ) k + <num> F ) / <num> F ;
}
double d7 = d + block . minX ;
double d8 = d + block . maxX ;
double d9 = d1 + block . maxY ;
double d10 = d2 + block . minZ ;
double d11 = d2 + block . maxZ ;
if ( enableAO )
{
if ( iDir / <num> == <num> ) {
tessellator . setColorOpaque_F ( colorRedTopLeft_TopFace , colorGreenTopLeft_TopFace , colorBlueTopLeft_TopFace ) ;
tessellator . addVertexWithUV ( d8 , d9 , d11 , d4 , d6 ) ;
tessellator . setColorOpaque_F ( colorRedBottomLeft_TopFace , colorGreenBottomLeft_TopFace , colorBlueBottomLeft_TopFace ) ;
tessellator . addVertexWithUV ( d8 , d9 , d10 , d4 , d5 ) ;
tessellator . setColorOpaque_F ( colorRedBottomRight_TopFace , colorGreenBottomRight_TopFace , colorBlueBottomRight_TopFace ) ;
tessellator . addVertexWithUV ( d7 , d9 , d10 , d3 , d5 ) ;
tessellator . setColorOpaque_F ( colorRedTopRight_TopFace , colorGreenTopRight_TopFace , colorBlueTopRight_TopFace ) ;
tessellator . addVertexWithUV ( d7 , d9 , d11 , d3 , d6 ) ;
}
} else
{
if ( iDir / <num> == <num> ) {
tessellator . addVertexWithUV ( d8 , d9 , d11 , d4 , d6 ) ;
tessellator . addVertexWithUV ( d8 , d9 , d10 , d4 , d5 ) ;
tessellator . addVertexWithUV ( d7 , d9 , d10 , d3 , d5 ) ;
tessellator . addVertexWithUV ( d7 , d9 , d11 , d3 , d6 ) ;
}
}
}
public void renderCornersEastFace ( Block block , double d , double d1 , double d2 , int i , int iDir , RenderBlocks renderblocks , int lBrightness )
{
Tessellator tessellator = Tessellator . instance ;
tessellator . setBrightness ( lBrightness ) ;
int j = ( i & <num> ) << <num> ;
int k = i & <num> ;
double d3 = ( ( double ) j + block . minX * <num> D ) / <num> D ;
double d4 = ( ( ( double ) j + block . maxX * <num> D )  <num> D ) / <num> D ;
double d5 = ( ( double ) k + block . minY * <num> D ) / <num> D ;
double d6 = ( ( ( double ) k + block . maxY * <num> D )  <num> D ) / <num> D ;
if ( block . minX < <num> D || block . maxX > <num> D )
{
d3 = ( ( float ) j + <num> F ) / <num> F ;
d4 = ( ( float ) j + <num> F ) / <num> F ;
}
if ( block . minY < <num> D || block . maxY > <num> D )
{
d5 = ( ( float ) k + <num> F ) / <num> F ;
d6 = ( ( float ) k + <num> F ) / <num> F ;
}
double d8 = d + block . minX ;
double d9 = d + block . maxX ;
double d91 = d + block . maxX / <num> ;
double d10 = d1 + block . minY ;
double d11 = d1 + block . maxY ;
double d12 = d2 + block . minZ ;
double d13 = d2 + block . maxZ / <num> ;
if ( enableAO )
{
if ( iDir == <num> ) {
tessellator . setColorOpaque_F ( colorRedSlopes * ( aoLightValueYPos + aoLightValueXPosYPos ) * ( factorTop + factorEast ) / 4F , colorGreenSlopes * ( aoLightValueYPos + aoLightValueXPosYPos ) * ( factorTop + factorEast ) / 4F , colorBlueSlopes * ( aoLightValueYPos + aoLightValueXPosYPos ) * ( factorTop + factorEast ) / 4F ) ;
tessellator . addVertexWithUV ( d91 , d11 , d13 , d3 , d5 ) ;
tessellator . setColorOpaque_F ( colorRedSlopes * ( aoLightValueYPos + aoLightValueXPosYPos ) * ( factorTop + factorEast ) / 4F , colorGreenSlopes * ( aoLightValueYPos + aoLightValueXPosYPos ) * ( factorTop + factorEast ) / 4F , colorBlueSlopes * ( aoLightValueYPos + aoLightValueXPosYPos ) * ( factorTop + factorEast ) / 4F ) ;
tessellator . addVertexWithUV ( d91 , d11 , d13 , d3 , d5 ) ;
tessellator . setColorOpaque_F ( colorRedSlopes * ( aoLightValueZNeg + aoLightValueXPosZNeg ) * ( factorTop + factorEast ) / 4F , colorGreenSlopes * ( aoLightValueZNeg + aoLightValueXPosZNeg ) * ( factorTop + factorEast ) / 4F , colorBlueSlopes * ( aoLightValueZNeg + aoLightValueXPosZNeg ) * ( factorTop + factorEast ) / 4F ) ;
tessellator . addVertexWithUV ( d9 , d10 , d12 , d3 , d6 ) ;
tessellator . setColorOpaque_F ( colorRedSlopes * ( aoLightValueZNeg + aoLightValueXNegZNeg ) * ( factorTop + factorEast ) / 4F , colorGreenSlopes * ( aoLightValueZNeg + aoLightValueXNegZNeg ) * ( factorTop + factorEast ) / 4F , colorBlueSlopes * ( aoLightValueZNeg + aoLightValueXNegZNeg ) * ( factorTop + factorEast ) / 4F ) ;
tessellator . addVertexWithUV ( d8 , d10 , d12 , d4 , d6 ) ;
}
} else
{
if ( iDir == <num> || iDir == <num> ) {
tessellator . addVertexWithUV ( d91 , d11 , d13 , d4 , d5 ) ;
tessellator . addVertexWithUV ( d91 , d11 , d13 , d4 , d5 ) ;
tessellator . addVertexWithUV ( d9 , d10 , d12 , d3 , d6 ) ;
tessellator . addVertexWithUV ( d8 , d10 , d12 , d4 , d6 ) ;
}
}
}
public void renderCornersWestFace ( Block block , double d , double d1 , double d2 , int i , int iDir , RenderBlocks renderblocks , int lBrightness )
{
Tessellator tessellator = Tessellator . instance ;
tessellator . setBrightness ( lBrightness ) ;
int j = ( i & <num> ) << <num> ;
int k = i & <num> ;
double d3 = ( ( double ) j + block . minX * <num> D ) / <num> D ;
double d4 = ( ( ( double ) j + block . maxX * <num> D )  <num> D ) / <num> D ;
double d5 = ( ( double ) k + block . minY * <num> D ) / <num> D ;
double d6 = ( ( ( double ) k + block . maxY * <num> D )  <num> D ) / <num> D ;
if ( block . minX < <num> D || block . maxX > <num> D )
{
d3 = ( ( float ) j + <num> F ) / <num> F ;
d4 = ( ( float ) j + <num> F ) / <num> F ;
}
if ( block . minY < <num> D || block . maxY > <num> D )
{
d5 = ( ( float ) k + <num> F ) / <num> F ;
d6 = ( ( float ) k + <num> F ) / <num> F ;
}
double d8 = d + block . minX ;
double d9 = d + block . maxX ;
double d91 = d + block . maxX / <num> ;
double d10 = d1 + block . minY ;
double d11 = d1 + block . maxY ;
double d12 = d2 + block . maxZ ;
double d121 = d2 + block . maxZ / <num> ;
double d13 = d2 + block . minZ ;
if ( enableAO )
{
if ( iDir == <num> || iDir == <num> ) {
tessellator . setColorOpaque_F ( colorRedBottomLeft_WestFace , colorGreenBottomLeft_WestFace , colorBlueBottomLeft_WestFace ) ;
tessellator . addVertexWithUV ( d8 , d10 , d12 , d3 , d6 ) ;
tessellator . setColorOpaque_F ( colorRedBottomLeft_WestFace , colorGreenBottomLeft_WestFace , colorBlueBottomLeft_WestFace ) ;
tessellator . addVertexWithUV ( d8 , d10 , d12 , d3 , d6 ) ;
tessellator . setColorOpaque_F ( colorRedBottomRight_WestFace , colorGreenBottomRight_WestFace , colorBlueBottomRight_WestFace ) ;
tessellator . addVertexWithUV ( d9 , d10 , d12 , d4 , d6 ) ;
tessellator . setColorOpaque_F ( colorRedTopRight_WestFace , colorGreenTopRight_WestFace , colorBlueTopRight_WestFace ) ;
tessellator . addVertexWithUV ( d91 , d11 , d121 , d4 , d5 ) ;
}
} else
{
if ( iDir == <num> ) {
tessellator . addVertexWithUV ( d91 , d11 , d121 , d3 , d5 ) ;
tessellator . addVertexWithUV ( d8 , d10 , d12 , d3 , d6 ) ;
tessellator . addVertexWithUV ( d9 , d10 , d12 , d4 , d6 ) ;
tessellator . addVertexWithUV ( d91 , d11 , d121 , d3 , d5 ) ;
}
}
}
public void renderCornersNorthFace ( Block block , double d , double d1 , double d2 , int i , int iDir , RenderBlocks renderblocks , int lBrightness )
{
Tessellator tessellator = Tessellator . instance ;
tessellator . setBrightness ( lBrightness ) ;
int j = ( i & <num> ) << <num> ;
int k = i & <num> ;
double d3 = ( ( double ) j + block . minZ * <num> D ) / <num> D ;
double d4 = ( ( ( double ) j + block . maxZ * <num> D )  <num> D ) / <num> D ;
double d5 = ( ( double ) k + block . minY * <num> D ) / <num> D ;
double d6 = ( ( ( double ) k + block . maxY * <num> D )  <num> D ) / <num> D ;
if ( block . minZ < <num> D || block . maxZ > <num> D )
{
d3 = ( ( float ) j + <num> F ) / <num> F ;
d4 = ( ( float ) j + <num> F ) / <num> F ;
}
if ( block . minY < <num> D || block . maxY > <num> D )
{
d5 = ( ( float ) k + <num> F ) / <num> F ;
d6 = ( ( float ) k + <num> F ) / <num> F ;
}
double d8 = d + block . minX ;
double d9 = d1 + block . minY ;
double d10 = d1 + block . maxY ;
double d11 = d2 + block . minZ ;
double d12 = d2 + block . maxZ ;
double d121 = d2 + block . maxZ / <num> ;
double d13 = d + block . maxX / <num> ;
if ( enableAO )
{
if ( iDir == <num> ) {
tessellator . setColorOpaque_F ( colorRedSlopes * ( aoLightValueYPos + aoLightValueYPosZPos ) * ( factorTop + factorNorth ) / 4F , colorGreenSlopes * ( aoLightValueYPos + aoLightValueYPosZPos ) * ( factorTop + factorNorth ) / 4F , colorBlueSlopes * ( aoLightValueYPos + aoLightValueYPosZPos ) * ( factorTop + factorNorth ) / 4F ) ;
tessellator . addVertexWithUV ( d13 , d10 , d121 , d4 , d5 ) ;
tessellator . setColorOpaque_F ( colorRedSlopes * ( aoLightValueYPos + aoLightValueYPosZPos ) * ( factorTop + factorNorth ) / 4F , colorGreenSlopes * ( aoLightValueYPos + aoLightValueYPosZPos ) * ( factorTop + factorNorth ) / 4F , colorBlueSlopes * ( aoLightValueYPos + aoLightValueYPosZPos ) * ( factorTop + factorNorth ) / 4F ) ;
tessellator . addVertexWithUV ( d13 , d10 , d121 , d4 , d5 ) ;
tessellator . setColorOpaque_F ( colorRedSlopes * ( aoLightValueXNeg + aoLightValueXNegZNeg ) * ( factorTop + factorNorth ) / 4F , colorGreenSlopes * ( aoLightValueXNeg + aoLightValueXNegZNeg ) * ( factorTop + factorNorth ) / 4F , colorBlueSlopes * ( aoLightValueXNeg + aoLightValueXNegZNeg ) * ( factorTop + factorNorth ) / 4F ) ;
tessellator . addVertexWithUV ( d8 , d9 , d11 , d3 , d6 ) ;
tessellator . setColorOpaque_F ( colorRedSlopes * ( aoLightValueXNeg + aoLightValueXNegZPos ) * ( factorTop + factorNorth ) / 4F , colorGreenSlopes * ( aoLightValueXNeg + aoLightValueXNegZPos ) * ( factorTop + factorNorth ) / 4F , colorBlueSlopes * ( aoLightValueXNeg + aoLightValueXNegZPos ) * ( factorTop + factorNorth ) / 4F ) ;
tessellator . addVertexWithUV ( d8 , d9 , d12 , d4 , d6 ) ;
}
} else
{
if ( iDir == <num> || iDir == <num> ) {
tessellator . addVertexWithUV ( d13 , d10 , d121 , d3 , d5 ) ;
tessellator . addVertexWithUV ( d13 , d10 , d121 , d3 , d5 ) ;
tessellator . addVertexWithUV ( d8 , d9 , d11 , d3 , d6 ) ;
tessellator . addVertexWithUV ( d8 , d9 , d12 , d4 , d6 ) ;
}
}
}
public void renderCornersSouthFace ( Block block , double d , double d1 , double d2 , int i , int iDir , RenderBlocks renderblocks , int lBrightness )
{
Tessellator tessellator = Tessellator . instance ;
tessellator . setBrightness ( lBrightness ) ;
int j = ( i & <num> ) << <num> ;
int k = i & <num> ;
double d3 = ( ( double ) j + block . minZ * <num> D ) / <num> D ;
double d4 = ( ( ( double ) j + block . maxZ * <num> D )  <num> D ) / <num> D ;
double d5 = ( ( double ) k + block . minY * <num> D ) / <num> D ;
double d6 = ( ( ( double ) k + block . maxY * <num> D )  <num> D ) / <num> D ;
if ( block . minZ < <num> D || block . maxZ > <num> D )
{
d3 = ( ( float ) j + <num> F ) / <num> F ;
d4 = ( ( float ) j + <num> F ) / <num> F ;
}
if ( block . minY < <num> D || block . maxY > <num> D )
{
d5 = ( ( float ) k + <num> F ) / <num> F ;
d6 = ( ( float ) k + <num> F ) / <num> F ;
}
double d8 = d + block . maxX ;
double d81 = d + block . maxX / <num> ;
double d9 = d1 + block . minY ;
double d10 = d1 + block . maxY ;
double d11 = d2 + block . minZ ;
double d12 = d2 + block . maxZ ;
double d121 = d2 + block . maxZ / <num> ;
double d13 = d + block . minX ;
if ( enableAO )
{
if ( iDir == <num> || iDir == <num> ) {
tessellator . setColorOpaque_F ( colorRedTopLeft_SouthFace , colorGreenTopLeft_SouthFace , colorBlueTopLeft_SouthFace ) ;
tessellator . addVertexWithUV ( d8 , d9 , d12 , d3 , d6 ) ;
tessellator . setColorOpaque_F ( colorRedBottomLeft_SouthFace , colorGreenBottomLeft_SouthFace , colorBlueBottomLeft_SouthFace ) ;
tessellator . addVertexWithUV ( d8 , d9 , d11 , d4 , d6 ) ;
tessellator . setColorOpaque_F ( colorRedBottomLeft_SouthFace , colorGreenBottomLeft_SouthFace , colorBlueBottomLeft_SouthFace ) ;
tessellator . addVertexWithUV ( d8 , d9 , d11 , d4 , d6 ) ;
tessellator . setColorOpaque_F ( colorRedTopRight_SouthFace , colorGreenTopRight_SouthFace , colorBlueTopRight_SouthFace ) ;
tessellator . addVertexWithUV ( d81 , d10 , d121 , d3 , d5 ) ;
}
} else
{
if ( iDir == <num> ) {
tessellator . addVertexWithUV ( d8 , d9 , d12 , d3 , d6 ) ;
tessellator . addVertexWithUV ( d8 , d9 , d11 , d4 , d6 ) ;
tessellator . addVertexWithUV ( d81 , d10 , d121 , d4 , d5 ) ;
tessellator . addVertexWithUV ( d81 , d10 , d121 , d4 , d5 ) ;
}
}
}
public void load ( ) { } ;
public String getVersion ( ) { return " ; }
package net . minecraft . src ;
import org . lwjgl . opengl . GL11 ;
public class KonungRenderWindow extends TileEntitySpecialRenderer
{
private KonungModelWindow model ;
public KonungRenderWindow ( )
{
model = new KonungModelWindow ( ) ;
}
public void renderAModelAt ( KonungTileEntityWindow tile , double d , double d1 , double d2 , float f )
{
int i = <num> ;
if ( tile . worldObj != null )
{
i = ( tile . worldObj . getBlockMetadata ( tile . xCoord , tile . yCoord , tile . zCoord ) ) ;
}
int j = <num> ;
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
bindTextureByName ( " ) ;
GL11 . glPushMatrix ( ) ;
GL11 . glTranslatef ( ( float ) d + <num> F , ( float ) d1 + <num> F , ( float ) d2 + <num> F ) ;
GL11 . glRotatef ( j , <num> F , <num> F , <num> F ) ;
GL11 . glScalef ( <num> F ,  1F ,  1F ) ;
model . renderModel ( <num> F ) ;
GL11 . glPopMatrix ( ) ;
}
public void renderTileEntityAt ( TileEntity tileentity , double d , double d1 , double d2 , float f )
{
renderAModelAt ( ( KonungTileEntityWindow ) tileentity , d , d1 , d2 , f ) ;
}
}
package net . minecraft . src ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Random ;
public class KonungBlockIdol extends BlockContainer
{
public KonungBlockIdol ( int par1 , int par2 , Class class1 )
{
super ( par1 , par2 , Material . wood ) ;
this . setCreativeTab ( CreativeTabs . tabBlock ) ;
this . setRequiresSelfNotify ( ) ;
}
public TileEntity getBlockEntity ( )
{
return new KonungTileEntityIdol ( ) ;
}
public int idDropped ( int i , Random random , int j )
{
return mod_konungDecorations . itemIdol . iconIndex ;
}
public int quantityDropped ( Random random )
{
return <num> ;
}
public int getRenderType ( )
{
return mod_konungDecorations . modelIdolID ;
}
public boolean isOpaqueCube ( )
{
return false ;
}
public boolean renderAsNormalBlock ( )
{
return false ;
}
public int damageDropped ( int par1 )
{
return par1 ;
}
public void onBlockPlacedBy ( World par1World , int par2 , int par3 , int par4 , EntityLiving par5EntityLiving )
{
int p = MathHelper . floor_double ( ( double ) ( ( par5EntityLiving . rotationYaw * 4F ) / <num> F ) + <num> D ) & <num> ;
byte byte0 = <num> ;
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , byte0 ) ;
}
public void addCollidingBlockToList ( World par1World , int par2 , int par3 , int par4 , AxisAlignedBB par5AxisAlignedBB , List par6List , Entity par7Entity )
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
public void setBlockBoundsBasedOnState ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 )
{
{
boolean var5 = ( par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4 ) & <num> ) != <num> ;
if ( var5 )
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
else
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
}
}
public void randomDisplayTick ( World par1World , int par2 , int par3 , int par4 , Random par5Random )
{
if ( par5Random . nextInt ( <num> ) == <num> )
{
par1World . playSound ( ( double ) par2 + <num> D , ( double ) par3 + <num> D , ( double ) par4 + <num> D , " , <num> F , par5Random . nextFloat ( ) * <num> F + <num> F , false ) ;
}
for ( int var6 = <num> ; var6 < <num> ; ++ var6 )
{
double var7 = ( double ) ( ( float ) par2 + par5Random . nextFloat ( ) ) ;
double var9 = ( double ) ( ( float ) par3 + par5Random . nextFloat ( ) ) ;
double var11 = ( double ) ( ( float ) par4 + par5Random . nextFloat ( ) ) ;
double var13 = <num> D ;
double var15 = <num> D ;
double var17 = <num> D ;
int var19 = par5Random . nextInt ( <num> ) * <num>  <num> ;
var13 = ( ( double ) par5Random . nextFloat ( )  <num> D ) * <num> D ;
var15 = ( ( double ) par5Random . nextFloat ( )  <num> D ) * <num> D ;
var17 = ( ( double ) par5Random . nextFloat ( )  <num> D ) * <num> D ;
if ( par1World . getBlockId ( par2  <num> , par3 , par4 ) != this . blockID && par1World . getBlockId ( par2 + <num> , par3 , par4 ) != this . blockID )
{
var7 = ( double ) par2 + <num> D + <num> D * ( double ) var19 ;
var13 = ( double ) ( par5Random . nextFloat ( ) * <num> F * ( float ) var19 ) ;
}
else
{
var11 = ( double ) par4 + <num> D + <num> D * ( double ) var19 ;
var17 = ( double ) ( par5Random . nextFloat ( ) * <num> F * ( float ) var19 ) ;
}
par1World . <unk> ( " , var7 , var9 , var11 , var13 , var15 , var17 ) ;
}
}
public TileEntity createNewTileEntity ( World var1 )
{
return new KonungTileEntityIdol ( ) ;
}
package net . minecraft . src ;
public class KonungModelIdolIcon extends ModelBase
{
ModelRenderer Shape1 ;
ModelRenderer Shape2 ;
ModelRenderer Shape3 ;
ModelRenderer Shape4 ;
public KonungModelIdolIcon ( )
{
textureWidth = <num> ;
textureHeight = <num> ;
Shape1 = new ModelRenderer ( this , <num> , <num> ) ;
Shape1 . addBox (  4F , 0F ,  4F , <num> , <num> , <num> ) ;
Shape1 . setRotationPoint ( 0F , <num> F , 0F ) ;
Shape1 . setTextureSize ( <num> , <num> ) ;
Shape1 . mirror = true ;
setRotation ( Shape1 , 0F , 0F , 0F ) ;
Shape2 = new ModelRenderer ( this , <num> , <num> ) ;
Shape2 . addBox (  3F , 0F ,  3F , <num> , <num> , <num> ) ;
Shape2 . setRotationPoint ( 0F , <num> F , 0F ) ;
Shape2 . setTextureSize ( <num> , <num> ) ;
Shape2 . mirror = true ;
setRotation ( Shape2 , 0F , 0F , 0F ) ;
Shape3 = new ModelRenderer ( this , <num> , <num> ) ;
Shape3 . addBox (  4F , 0F ,  4F , <num> , <num> , <num> ) ;
Shape3 . setRotationPoint ( 0F , 9F , 0F ) ;
Shape3 . setTextureSize ( <num> , <num> ) ;
Shape3 . mirror = true ;
setRotation ( Shape3 , 0F , 0F , 0F ) ;
Shape4 = new ModelRenderer ( this , <num> , <num> ) ;
Shape4 . addBox (  3F , 0F ,  3F , <num> , <num> , <num> ) ;
Shape4 . setRotationPoint ( 0F , 8F , 0F ) ;
Shape4 . setTextureSize ( <num> , <num> ) ;
Shape4 . mirror = true ;
setRotation ( Shape4 , 0F , 0F , 0F ) ;
}
public void render ( Entity entity , float f , float f1 , float f2 , float f3 , float f4 , float f5 )
{
super . render ( entity , f , f1 , f2 , f3 , f4 , f5 ) ;
setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , entity ) ;
Shape1 . render ( f5 ) ;
Shape2 . render ( f5 ) ;
Shape3 . render ( f5 ) ;
Shape4 . render ( f5 ) ;
}
private void setRotation ( ModelRenderer model , float x , float y , float z )
{
model . rotateAngleX = x ;
model . rotateAngleY = y ;
model . rotateAngleZ = z ;
}
public void setRotationAngles ( float f , float f1 , float f2 , float f3 , float f4 , float f5 , Entity par7Entity )
{
super . setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , par7Entity ) ;
}
public void renderModel ( float f )
{
Shape1 . render ( f ) ;
Shape2 . render ( f ) ;
Shape3 . render ( f ) ;
Shape4 . render ( f ) ;
}
}
package net . minecraft . src ;
import java . util . Random ;
import java . util . List ;
public class KonungBlockTable extends BlockContainer
{
private final boolean isActive ;
public KonungBlockTable ( int par1 , int par2 , Class class1 , boolean par3 )
{
super ( par1 , par2 , Material . wood ) ;
this . setCreativeTab ( CreativeTabs . tabBlock ) ;
this . setRequiresSelfNotify ( ) ;
this . isActive = par3 ;
}
public TileEntity getBlockEntity ( )
{
return new KonungTileEntityTable ( ) ;
}
public int idDropped ( int i , Random random , int j )
{
return mod_konungDecorations . itemTable . iconIndex ;
}
public int quantityDropped ( Random random )
{
return <num> ;
}
public int getRenderType ( )
{
return mod_konungDecorations . modelTableID ;
}
public boolean isOpaqueCube ( )
{
return false ;
}
public boolean renderAsNormalBlock ( )
{
return false ;
}
public int damageDropped ( int par1 )
{
return par1 ;
}
public void onBlockPlacedBy ( World par1World , int par2 , int par3 , int par4 , EntityLiving par5EntityLiving )
{
int p = MathHelper . floor_double ( ( double ) ( ( par5EntityLiving . rotationYaw * 4F ) / <num> F ) + <num> D ) & <num> ;
byte byte0 = <num> ;
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , byte0 ) ;
}
public TileEntity createNewTileEntity ( World var1 )
{
return new KonungTileEntityTable ( ) ;
}
package net . minecraft . src ;
import java . util . List ;
import java . util . Random ;
public class KonungBlockRefinedWood extends Block
{
public static final String [ ] woodType = new String [ ] { " , " , " , " } ;
protected KonungBlockRefinedWood ( int par1 )
{
super ( par1 , Material . wood ) ;
this . blockIndexInTexture = <num> ;
this . setCreativeTab ( CreativeTabs . tabBlock ) ;
}
public int getRenderType ( )
{
return <num> ;
}
public int quantityDropped ( Random <unk> )
{
return <num> ;
}
public int idDropped ( int par1 , Random par2Random , int par3 )
{
return Block . wood . blockID ;
}
public void breakBlock ( World par1World , int par2 , int par3 , int par4 , int par5 , int par6 )
{
byte var7 = <num> ;
int var8 = var7 + <num> ;
if ( par1World . <unk> ( par2  var8 , par3  var8 , par4  var8 , par2 + var8 , par3 + var8 , par4 + var8 ) )
{
for ( int var9 =  var7 ; var9 <= var7 ; ++ var9 )
{
for ( int var10 =  var7 ; var10 <= var7 ; ++ var10 )
{
for ( int var11 =  var7 ; var11 <= var7 ; ++ var11 )
{
int var12 = par1World . getBlockId ( par2 + var9 , par3 + var10 , par4 + var11 ) ;
if ( var12 == Block . leaves . blockID )
{
int var13 = par1World . getBlockMetadata ( par2 + var9 , par3 + var10 , par4 + var11 ) ;
if ( ( var13 & <num> ) == <num> )
{
par1World . <unk> ( par2 + var9 , par3 + var10 , par4 + var11 , var13 | <num> ) ;
}
}
}
}
}
}
}
public void onBlockPlacedBy ( World par1World , int par2 , int par3 , int par4 , EntityLiving par5EntityLiving )
{
int var6 = par1World . getBlockMetadata ( par2 , par3 , par4 ) & <num> ;
int var7 = <unk> . <unk> ( par1World , par2 , par3 , par4 , ( EntityPlayer ) par5EntityLiving ) ;
byte var8 = <num> ;
switch ( var7 )
{
case <num> :
case <num> :
var8 = <num> ;
break ;
case <num> :
case <num> :
var8 = <num> ;
break ;
case <num> :
case <num> :
var8 = <num> ;
}
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , var6 | var8 ) ;
}
public int getBlockTextureFromSideAndMetadata ( int par1 , int par2 )
{
int top = mod_konungRefinedWood . topRefinedWoodTexture ;
int oak = mod_konungRefinedWood . oakRefinedWoodTexture ;
int spruce = mod_konungRefinedWood . spruceRefinedWoodTexture ;
int birch = mod_konungRefinedWood . birchRefinedWoodTexture ;
int jungle = mod_konungRefinedWood . jungleRefinedWoodTexture ;
int var3 = par2 & <num> ;
int var4 = par2 & <num> ;
return var3 == <num> && ( par1 == <num> || par1 == <num> ) ? top : ( var3 == <num> && ( par1 == <num> || par1 == <num> ) ? top : ( var3 == <num> && ( par1 == <num> || par1 == <num> ) ? top : ( var4 == <num> ? spruce : ( var4 == <num> ? birch : ( var4 == <num> ? jungle : oak ) ) ) ) ) ;
}
public int damageDropped ( int par1 )
{
return par1 & <num> ;
}
public static int limitToValidMetadata ( int par0 )
{
return par0 & <num> ;
}
public void getSubBlocks ( int par1 , CreativeTabs par2CreativeTabs , List par3List )
{
par3List . add ( new ItemStack ( par1 , <num> , <num> ) ) ;
par3List . add ( new ItemStack ( par1 , <num> , <num> ) ) ;
par3List . add ( new ItemStack ( par1 , <num> , <num> ) ) ;
par3List . add ( new ItemStack ( par1 , <num> , <num> ) ) ;
}
protected ItemStack <unk> ( int par1 )
{
return new ItemStack ( this . blockID , <num> , limitToValidMetadata ( par1 ) ) ;
}
}
package net . minecraft . src ;
public class KonungModelBarrel extends ModelBase
{
ModelRenderer Shape1 ;
ModelRenderer Shape2 ;
ModelRenderer Shape3 ;
ModelRenderer Shape4 ;
ModelRenderer Shape5 ;
ModelRenderer Shape6 ;
ModelRenderer Shape7 ;
ModelRenderer Shape8 ;
ModelRenderer Shape9 ;
ModelRenderer Shape10 ;
ModelRenderer Shape11 ;
public KonungModelBarrel ( )
{
textureWidth = <num> ;
textureHeight = <num> ;
Shape1 = new ModelRenderer ( this , <num> , <num> ) ;
Shape1 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
Shape1 . setRotationPoint (  5F , <num> F ,  5F ) ;
Shape1 . setTextureSize ( <num> , <num> ) ;
Shape1 . mirror = true ;
setRotation ( Shape1 , 0F , 0F , 0F ) ;
Shape2 = new ModelRenderer ( this , <num> , <num> ) ;
Shape2 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
Shape2 . setRotationPoint ( 4F , <num> F ,  5F ) ;
Shape2 . setTextureSize ( <num> , <num> ) ;
Shape2 . mirror = true ;
setRotation ( Shape2 , 0F , 0F , 0F ) ;
Shape3 = new ModelRenderer ( this , <num> , <num> ) ;
Shape3 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
Shape3 . setRotationPoint (  4F , <num> F , 4F ) ;
Shape3 . setTextureSize ( <num> , <num> ) ;
Shape3 . mirror = true ;
setRotation ( Shape3 , 0F , 0F , 0F ) ;
Shape4 = new ModelRenderer ( this , <num> , <num> ) ;
Shape4 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
Shape4 . setRotationPoint (  4F , <num> F ,  5F ) ;
Shape4 . setTextureSize ( <num> , <num> ) ;
Shape4 . mirror = true ;
setRotation ( Shape4 , 0F , 0F , 0F ) ;
Shape5 = new ModelRenderer ( this , <num> , <num> ) ;
Shape5 . addBox (  <num> F , 0F ,  <num> F , <num> , <num> , <num> ) ;
Shape5 . setRotationPoint ( 0F , <num> F , 0F ) ;
Shape5 . setTextureSize ( <num> , <num> ) ;
Shape5 . mirror = true ;
setRotation ( Shape5 , 0F , 0F , 0F ) ;
Shape6 = new ModelRenderer ( this , <num> , <num> ) ;
Shape6 . addBox (  5F , 0F ,  5F , <num> , <num> , <num> ) ;
Shape6 . setRotationPoint ( 0F , <num> F , 0F ) ;
Shape6 . setTextureSize ( <num> , <num> ) ;
Shape6 . mirror = true ;
setRotation ( Shape6 , 0F , 0F , 0F ) ;
Shape7 = new ModelRenderer ( this , <num> , <num> ) ;
Shape7 . addBox (  <num> F , 0F ,  <num> F , <num> , <num> , <num> ) ;
Shape7 . setRotationPoint ( 0F , <num> F , 0F ) ;
Shape7 . setTextureSize ( <num> , <num> ) ;
Shape7 . mirror = true ;
setRotation ( Shape7 , 0F , 0F , 0F ) ;
Shape8 = new ModelRenderer ( this , <num> , <num> ) ;
Shape8 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
Shape8 . setRotationPoint (  5F , 9F ,  5F ) ;
Shape8 . setTextureSize ( <num> , <num> ) ;
Shape8 . mirror = true ;
setRotation ( Shape8 , 0F , 0F , 0F ) ;
Shape9 = new ModelRenderer ( this , <num> , <num> ) ;
Shape9 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
Shape9 . setRotationPoint (  4F , 9F ,  5F ) ;
Shape9 . setTextureSize ( <num> , <num> ) ;
Shape9 . mirror = true ;
setRotation ( Shape9 , 0F , 0F , 0F ) ;
Shape10 = new ModelRenderer ( this , <num> , <num> ) ;
Shape10 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
Shape10 . setRotationPoint ( 4F , 9F ,  5F ) ;
Shape10 . setTextureSize ( <num> , <num> ) ;
Shape10 . mirror = true ;
setRotation ( Shape10 , 0F , 0F , 0F ) ;
Shape11 = new ModelRenderer ( this , <num> , <num> ) ;
Shape11 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
Shape11 . setRotationPoint (  4F , 9F , 4F ) ;
Shape11 . setTextureSize ( <num> , <num> ) ;
Shape11 . mirror = true ;
setRotation ( Shape11 , 0F , 0F , 0F ) ;
}
public void render ( Entity entity , float f , float f1 , float f2 , float f3 , float f4 , float f5 )
{
super . render ( entity , f , f1 , f2 , f3 , f4 , f5 ) ;
setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , entity ) ;
Shape1 . render ( f5 ) ;
Shape2 . render ( f5 ) ;
Shape3 . render ( f5 ) ;
Shape4 . render ( f5 ) ;
Shape5 . render ( f5 ) ;
Shape6 . render ( f5 ) ;
Shape7 . render ( f5 ) ;
Shape8 . render ( f5 ) ;
Shape9 . render ( f5 ) ;
Shape10 . render ( f5 ) ;
Shape11 . render ( f5 ) ;
}
private void setRotation ( ModelRenderer model , float x , float y , float z )
{
model . rotateAngleX = x ;
model . rotateAngleY = y ;
model . rotateAngleZ = z ;
}
public void setRotationAngles ( float f , float f1 , float f2 , float f3 , float f4 , float f5 , Entity par7Entity )
{
super . setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , par7Entity ) ;
}
public void renderModel ( float f )
{
Shape1 . render ( f ) ;
Shape2 . render ( f ) ;
Shape3 . render ( f ) ;
Shape4 . render ( f ) ;
Shape5 . render ( f ) ;
Shape6 . render ( f ) ;
Shape7 . render ( f ) ;
Shape8 . render ( f ) ;
Shape9 . render ( f ) ;
Shape10 . render ( f ) ;
Shape11 . render ( f ) ;
}
package net . minecraft . src ;
public class KonungModelLeather extends ModelBase
{
ModelRenderer stick1 ;
ModelRenderer stick2 ;
ModelRenderer stick3 ;
ModelRenderer stick4 ;
ModelRenderer skin ;
public KonungModelLeather ( )
{
textureWidth = <num> ;
textureHeight = <num> ;
stick1 = new ModelRenderer ( this , <num> , <num> ) ;
stick1 . addBox ( 0F ,  <num> F ,  1F , <num> , <num> , <num> ) ;
stick1 . setRotationPoint ( 6F , <num> F , 7F ) ;
stick1 . setTextureSize ( <num> , <num> ) ;
stick1 . mirror = true ;
setRotation ( stick1 , <num> F , 0F , 0F ) ;
stick2 = new ModelRenderer ( this , <num> , <num> ) ;
stick2 . addBox ( 0F ,  <num> F ,  1F , <num> , <num> , <num> ) ;
stick2 . setRotationPoint (  7F , <num> F , 7F ) ;
stick2 . setTextureSize ( <num> , <num> ) ;
stick2 . mirror = true ;
setRotation ( stick2 , <num> F , 0F , 0F ) ;
stick3 = new ModelRenderer ( this , <num> , <num> ) ;
stick3 . addBox ( 0F , 0F , 0F , <num> , <num> , <num> ) ;
stick3 . setRotationPoint (  6F , <num> F ,  <num> F ) ;
stick3 . setTextureSize ( <num> , <num> ) ;
stick3 . mirror = true ;
setRotation ( stick3 ,  <num> F , 0F , 0F ) ;
stick4 = new ModelRenderer ( this , <num> , <num> ) ;
stick4 . addBox (  <num> F , 0F , 0F , <num> , <num> , <num> ) ;
stick4 . setRotationPoint ( 0F , 9F ,  7F ) ;
stick4 . setTextureSize ( <num> , <num> ) ;
stick4 . mirror = true ;
setRotation ( stick4 , 0F , 0F , 0F ) ;
skin = new ModelRenderer ( this , <num> , <num> ) ;
skin . addBox ( 0F ,  <num> F , 0F , <num> , <num> , <num> ) ;
skin . setRotationPoint (  6F , <num> F , <num> F ) ;
skin . setTextureSize ( <num> , <num> ) ;
skin . mirror = true ;
setRotation ( skin , <num> F , 0F , 0F ) ;
}
public void render ( Entity entity , float f , float f1 , float f2 , float f3 , float f4 , float f5 )
{
super . render ( entity , f , f1 , f2 , f3 , f4 , f5 ) ;
setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , entity ) ;
stick1 . render ( f5 ) ;
stick2 . render ( f5 ) ;
stick3 . render ( f5 ) ;
stick4 . render ( f5 ) ;
skin . render ( f5 ) ;
}
private void setRotation ( ModelRenderer model , float x , float y , float z )
{
model . rotateAngleX = x ;
model . rotateAngleY = y ;
model . rotateAngleZ = z ;
}
public void setRotationAngles ( float f , float f1 , float f2 , float f3 , float f4 , float f5 , Entity par7Entity )
{
super . setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , par7Entity ) ;
}
public void renderModel ( float f )
{
stick1 . render ( f ) ;
stick2 . render ( f ) ;
stick3 . render ( f ) ;
stick4 . render ( f ) ;
skin . render ( f ) ;
}
package net . minecraft . src ;
public class KonungItemStockade extends ItemBlock
{
public KonungItemStockade ( int i , String pItemMatName )
{
super ( i ) ;
itemMatName = pItemMatName ;
<unk> ( <num> ) ;
setHasSubtypes ( true ) ;
}
public int getMetadata ( int i )
{
return i ;
}
public String <unk> ( ItemStack itemstack )
{
return ( new StringBuilder ( ) ) . append ( " ) . append ( itemMatName ) . append ( " ) . append ( Kaevator_Materials [ itemstack . getItemDamage ( ) ] ) . toString ( ) ;
}
public static final String Kaevator_Materials [ ] = {
" , " , " , " ,
" , " , " , " ,
" , " , " , " ,
" , " , " , "
} ;
private String itemMatName ;
}
package net . minecraft . src ;
import java . util . Random ;
import java . util . List ;
public class KonungBlockWindow extends BlockContainer
{
public KonungBlockWindow ( int par1 , int par2 , Class class1 )
{
super ( par1 , par2 , Material . wood ) ;
this . setCreativeTab ( CreativeTabs . tabBlock ) ;
this . setRequiresSelfNotify ( ) ;
}
public TileEntity getBlockEntity ( )
{
return new KonungTileEntityWindow ( ) ;
}
public int idDropped ( int i , Random random , int j )
{
return mod_konungDecorations . itemWindow . iconIndex ;
}
public int quantityDropped ( Random random )
{
return <num> ;
}
public int getRenderType ( )
{
return mod_konungDecorations . modelWindowID ;
}
public boolean isOpaqueCube ( )
{
return false ;
}
public boolean renderAsNormalBlock ( )
{
return false ;
}
public int damageDropped ( int par1 )
{
return par1 ;
}
public void onBlockPlacedBy ( World par1World , int par2 , int par3 , int par4 , EntityLiving par5EntityLiving )
{
int p = MathHelper . floor_double ( ( double ) ( ( par5EntityLiving . rotationYaw * 4F ) / <num> F ) + <num> D ) & <num> ;
byte byte0 = <num> ;
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , byte0 ) ;
}
public TileEntity createNewTileEntity ( World var1 )
{
return new KonungTileEntityWindow ( ) ;
}
package net . minecraft . src ;
import java . util . Map ;
import java . util . Random ;
public class mod_konungMobs extends BaseMod
{
public static final Item KonungPoisonSting = new KonungItemPoisonSting ( <num> ) . setItemName ( " ) ;
public mod_konungMobs ( )
{
KonungPoisonSting . iconIndex = ModLoader . addOverride ( " , " ) ;
ModLoader . addName ( KonungPoisonSting , " , " ) ;
ModLoader . <unk> ( KonungEntitySpider . class , " , ( byte ) ModLoader . <unk> ( ) ) ;
ModLoader . <unk> ( KonungEntitySpider . class , <num> , <num> , <num> , <unk> . <unk> ) ;
}
public void <unk> ( Map map )
{
map . put ( KonungEntitySpider . class , new <unk> ( ) ) ;
}
public void load ( ) { } ;
public String getVersion ( ) { return " ; }
}
package net . minecraft . src ;
public class KonungItemElixirOfWisdom extends Item
{
public KonungItemElixirOfWisdom ( int par1 )
{
super ( par1 ) ;
setMaxStackSize ( <num> ) ;
}
public ItemStack onFoodEaten ( ItemStack par1ItemStack , World par2World , EntityPlayer par3EntityPlayer )
{
par1ItemStack . stackSize  ;
if ( ! par2World . isRemote )
{
par3EntityPlayer . <unk> ( <num> ) ;
}
return par1ItemStack ;
}
public int getMaxItemUseDuration ( ItemStack par1ItemStack )
{
return <num> ;
}
public EnumAction getItemUseAction ( ItemStack par1ItemStack )
{
return EnumAction . drink ;
}
public ItemStack onItemRightClick ( ItemStack par1ItemStack , World par2World , EntityPlayer par3EntityPlayer )
{
par3EntityPlayer . setItemInUse ( par1ItemStack , getMaxItemUseDuration ( par1ItemStack ) ) ;
return par1ItemStack ;
}
}
package net . minecraft . src ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Random ;
public class KonungBlockLeather extends BlockContainer
{
public KonungBlockLeather ( int par1 , int par2 , Class class1 )
{
super ( par1 , par2 , Material . wood ) ;
this . setCreativeTab ( CreativeTabs . tabBlock ) ;
this . setRequiresSelfNotify ( ) ;
}
public TileEntity getBlockEntity ( )
{
return new KonungTileEntityLeather ( ) ;
}
public int idDropped ( int i , Random random , int j )
{
return mod_konungDecorations . itemLeather . iconIndex ;
}
public int quantityDropped ( Random random )
{
return <num> ;
}
public int getRenderType ( )
{
return mod_konungDecorations . modelLeatherID ;
}
public boolean isOpaqueCube ( )
{
return false ;
}
public boolean renderAsNormalBlock ( )
{
return false ;
}
public int damageDropped ( int par1 )
{
return par1 ;
}
public void onBlockPlacedBy ( World par1World , int par2 , int par3 , int par4 , EntityLiving par5EntityLiving )
{
int p = MathHelper . floor_double ( ( double ) ( ( par5EntityLiving . rotationYaw * 4F ) / <num> F ) + <num> D ) & <num> ;
byte byte0 = <num> ;
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , byte0 ) ;
}
public void addCollidingBlockToList ( World par1World , int par2 , int par3 , int par4 , AxisAlignedBB par5AxisAlignedBB , List par6List , Entity par7Entity )
{
int i = par1World . getBlockMetadata ( par2 , par3 , par4 ) ;
int j = i & <num> ;
float f = <num> F ;
float f1 = <num> F ;
float f2 = <num> F ;
float f3 = <num> F ;
this . setBlockBounds ( <num> F , f , <num> F , <num> F , f1 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
else if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
else if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
else if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
public TileEntity createNewTileEntity ( World var1 )
{
return new KonungTileEntityLeather ( ) ;
}
package net . minecraft . src ;
public class KonungItemIdol extends ItemBlock
{
public KonungItemIdol ( int par1 , Block block )
{
super ( par1 ) ;
setHasSubtypes ( true ) ;
}
public int getMetadata ( int par1 )
{
return par1 ;
}
}
package net . minecraft . src ;
import org . lwjgl . opengl . GL11 ;
public class KonungRenderBarrel extends TileEntitySpecialRenderer
{
private KonungModelBarrel model ;
public KonungRenderBarrel ( )
{
model = new KonungModelBarrel ( ) ;
}
public void renderAModelAt ( KonungTileEntityBarrel tile , double d , double d1 , double d2 , float f )
{
int i = <num> ;
if ( tile . worldObj != null )
{
i = ( tile . worldObj . getBlockMetadata ( tile . xCoord , tile . yCoord , tile . zCoord ) ) ;
}
int j = <num> ;
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
bindTextureByName ( " ) ;
GL11 . glPushMatrix ( ) ;
GL11 . glTranslatef ( ( float ) d + <num> F , ( float ) d1 + <num> F , ( float ) d2 + <num> F ) ;
GL11 . glRotatef ( j , <num> F , <num> F , <num> F ) ;
GL11 . glScalef ( <num> F ,  1F ,  1F ) ;
model . renderModel ( <num> F ) ;
GL11 . glPopMatrix ( ) ;
}
public void renderTileEntityAt ( TileEntity tileentity , double d , double d1 , double d2 , float f )
{
renderAModelAt ( ( KonungTileEntityBarrel ) tileentity , d , d1 , d2 , f ) ;
}
}
package net . minecraft . src ;
import java . util . * ;
public class KonungBlockBarrel extends BlockContainer
{
private Random random ;
public KonungBlockBarrel ( int par1 , int par2 , Class class1 )
{
super ( par1 , par2 , Material . wood ) ;
this . setCreativeTab ( CreativeTabs . tabBlock ) ;
this . setRequiresSelfNotify ( ) ;
random = new Random ( ) ;
}
public boolean isOpaqueCube ( )
{
return false ;
}
public boolean renderAsNormalBlock ( )
{
return false ;
}
public int getRenderType ( )
{
return mod_konungDecorations . modelBarrelID ;
}
public int idDropped ( int i , Random random , int j )
{
return mod_konungDecorations . itemBarrel . iconIndex ;
}
public void onBlockPlacedBy ( World par1World , int par2 , int par3 , int par4 , EntityLiving par5EntityLiving )
{
int var6 = par1World . getBlockId ( par2 , par3 , par4  <num> ) ;
int var7 = par1World . getBlockId ( par2 , par3 , par4 + <num> ) ;
int var8 = par1World . getBlockId ( par2  <num> , par3 , par4 ) ;
int var9 = par1World . getBlockId ( par2 + <num> , par3 , par4 ) ;
byte var10 = <num> ;
int var11 = MathHelper . floor_double ( ( double ) ( par5EntityLiving . rotationYaw * <num> F / <num> F ) + <num> D ) & <num> ;
if ( var11 == <num> )
{
var10 = <num> ;
}
if ( var11 == <num> )
{
var10 = <num> ;
}
if ( var11 == <num> )
{
var10 = <num> ;
}
if ( var11 == <num> )
{
var10 = <num> ;
}
if ( var6 != this . blockID && var7 != this . blockID && var8 != this . blockID && var9 != this . blockID )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , var10 ) ;
}
else
{
if ( ( var6 == this . blockID || var7 == this . blockID ) && ( var10 == <num> || var10 == <num> ) )
{
if ( var6 == this . blockID )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4  <num> , var10 ) ;
}
else
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 + <num> , var10 ) ;
}
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , var10 ) ;
}
if ( ( var8 == this . blockID || var9 == this . blockID ) && ( var10 == <num> || var10 == <num> ) )
{
if ( var8 == this . blockID )
{
par1World . setBlockMetadataWithNotify ( par2  <num> , par3 , par4 , var10 ) ;
}
else
{
par1World . setBlockMetadataWithNotify ( par2 + <num> , par3 , par4 , var10 ) ;
}
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , var10 ) ;
}
}
}
public void breakBlock ( World par1World , int par2 , int par3 , int par4 , int par5 , int par6 )
{
KonungTileEntityBarrel var7 = ( KonungTileEntityBarrel ) par1World . getBlockTileEntity ( par2 , par3 , par4 ) ;
if ( var7 != null )
{
for ( int var8 = <num> ; var8 < var7 . getSizeInventory ( ) ; ++ var8 )
{
ItemStack var9 = var7 . getStackInSlot ( var8 ) ;
if ( var9 != null )
{
float var10 = this . random . nextFloat ( ) * <num> F + <num> F ;
float var11 = this . random . nextFloat ( ) * <num> F + <num> F ;
EntityItem var14 ;
for ( float var12 = this . random . nextFloat ( ) * <num> F + <num> F ; var9 . stackSize > <num> ; par1World . <unk> ( var14 ) )
{
int var13 = this . random . nextInt ( <num> ) + <num> ;
if ( var13 > var9 . stackSize )
{
var13 = var9 . stackSize ;
}
var9 . stackSize -= var13 ;
var14 = new EntityItem ( par1World , ( double ) ( ( float ) par2 + var10 ) , ( double ) ( ( float ) par3 + var11 ) , ( double ) ( ( float ) par4 + var12 ) , new ItemStack ( var9 . itemID , var13 , var9 . getItemDamage ( ) ) ) ;
float var15 = <num> F ;
var14 . motionX = ( double ) ( ( float ) this . random . nextGaussian ( ) * var15 ) ;
var14 . motionY = ( double ) ( ( float ) this . random . nextGaussian ( ) * var15 + <num> F ) ;
var14 . motionZ = ( double ) ( ( float ) this . random . nextGaussian ( ) * var15 ) ;
if ( var9 . <unk> ( ) )
{
var14 . <unk> ( ) . <unk> ( ( NBTTagCompound ) var9 . <unk> ( ) . copy ( ) ) ;
}
}
}
}
}
super . breakBlock ( par1World , par2 , par3 , par4 , par5 , par6 ) ;
}
public boolean onBlockActivated ( World par1World , int par2 , int par3 , int par4 , EntityPlayer par5EntityPlayer , int par6 , float par7 , float par8 , float par9 )
{
Object var10 = ( KonungTileEntityBarrel ) par1World . getBlockTileEntity ( par2 , par3 , par4 ) ;
if ( var10 == null )
{
return true ;
}
else if ( par1World . isBlockNormalCube ( par2 , par3 + <num> , par4 ) )
{
return true ;
}
else if ( isOcelotBlockingChest ( par1World , par2 , par3 , par4 ) )
{
return true ;
}
else if ( par1World . getBlockId ( par2  <num> , par3 , par4 ) == this . blockID && ( par1World . isBlockNormalCube ( par2  <num> , par3 + <num> , par4 ) || isOcelotBlockingChest ( par1World , par2  <num> , par3 , par4 ) ) )
{
return true ;
}
else if ( par1World . getBlockId ( par2 + <num> , par3 , par4 ) == this . blockID && ( par1World . isBlockNormalCube ( par2 + <num> , par3 + <num> , par4 ) || isOcelotBlockingChest ( par1World , par2 + <num> , par3 , par4 ) ) )
{
return true ;
}
else if ( par1World . getBlockId ( par2 , par3 , par4  <num> ) == this . blockID && ( par1World . isBlockNormalCube ( par2 , par3 + <num> , par4  <num> ) || isOcelotBlockingChest ( par1World , par2 , par3 , par4  <num> ) ) )
{
return true ;
}
else if ( par1World . getBlockId ( par2 , par3 , par4 + <num> ) == this . blockID && ( par1World . isBlockNormalCube ( par2 , par3 + <num> , par4 + <num> ) || isOcelotBlockingChest ( par1World , par2 , par3 , par4 + <num> ) ) )
{
return true ;
}
else
{
if ( par1World . isRemote )
{
return true ;
}
else
{
par5EntityPlayer . <unk> ( ( IInventory ) var10 ) ;
return true ;
}
}
}
public TileEntity createNewTileEntity ( World par1World )
{
return new KonungTileEntityBarrel ( ) ;
}
private static boolean isOcelotBlockingChest ( World par0World , int par1 , int par2 , int par3 )
{
Iterator var4 = par0World . getEntitiesWithinAABB ( EntityOcelot . class , AxisAlignedBB . <unk> ( ) . <unk> ( ( double ) par1 , ( double ) ( par2 + <num> ) , ( double ) par3 , ( double ) ( par1 + <num> ) , ( double ) ( par2 + <num> ) , ( double ) ( par3 + <num> ) ) ) . iterator ( ) ;
EntityOcelot var6 ;
do
{
if ( ! var4 . hasNext ( ) )
{
return false ;
}
EntityOcelot var5 = ( EntityOcelot ) var4 . next ( ) ;
var6 = ( EntityOcelot ) var5 ;
}
while ( ! var6 . isSitting ( ) ) ;
return true ;
}
public TileEntity getBlockEntity ( )
{
return new KonungTileEntityBarrel ( ) ;
}
private static boolean <unk> ( World par0World , int par1 , int par2 , int par3 )
{
for ( Iterator iterator = par0World . getEntitiesWithinAABB ( net . minecraft . src . EntityOcelot . class , AxisAlignedBB . getBoundingBox ( par1 , par2 + <num> , par3 , par1 + <num> , par2 + <num> , par3 + <num> ) ) . iterator ( ) ; iterator . hasNext ( ) ; )
{
Entity entity = ( Entity ) iterator . next ( ) ;
EntityOcelot entityocelot = ( EntityOcelot ) entity ;
if ( entityocelot . isSitting ( ) )
{
return true ;
}
}
return false ;
}
package net . minecraft . src ;
public class KonungModelIdol extends ModelBase
{
ModelRenderer Shape1 ;
ModelRenderer Shape2 ;
ModelRenderer Shape3 ;
ModelRenderer Shape4 ;
public KonungModelIdol ( )
{
textureWidth = <num> ;
textureHeight = <num> ;
Shape1 = new ModelRenderer ( this , <num> , <num> ) ;
Shape1 . addBox (  8F , 0F ,  8F , <num> , <num> , <num> ) ;
Shape1 . setRotationPoint ( 0F , 9F , 0F ) ;
Shape1 . setTextureSize ( <num> , <num> ) ;
Shape1 . mirror = true ;
setRotation ( Shape1 , 0F , <num> F , 0F ) ;
Shape2 = new ModelRenderer ( this , <num> , <num> ) ;
Shape2 . addBox (  7F , 0F ,  7F , <num> , <num> , <num> ) ;
Shape2 . setRotationPoint ( 0F , 7F , 0F ) ;
Shape2 . setTextureSize ( <num> , <num> ) ;
Shape2 . mirror = true ;
setRotation ( Shape2 , 0F , <num> F , 0F ) ;
Shape3 = new ModelRenderer ( this , <num> , <num> ) ;
Shape3 . addBox (  8F , 0F ,  8F , <num> , <num> , <num> ) ;
Shape3 . setRotationPoint ( 0F ,  <num> F , 0F ) ;
Shape3 . setTextureSize ( <num> , <num> ) ;
Shape3 . mirror = true ;
setRotation ( Shape3 , 0F , <num> F , 0F ) ;
Shape4 = new ModelRenderer ( this , <num> , <num> ) ;
Shape4 . addBox (  7F , 0F ,  7F , <num> , <num> , <num> ) ;
Shape4 . setRotationPoint ( 0F ,  <num> F , 0F ) ;
Shape4 . setTextureSize ( <num> , <num> ) ;
Shape4 . mirror = true ;
setRotation ( Shape4 , 0F , <num> F , 0F ) ;
}
public void render ( Entity entity , float f , float f1 , float f2 , float f3 , float f4 , float f5 )
{
super . render ( entity , f , f1 , f2 , f3 , f4 , f5 ) ;
setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , entity ) ;
Shape1 . render ( f5 ) ;
Shape2 . render ( f5 ) ;
Shape3 . render ( f5 ) ;
Shape4 . render ( f5 ) ;
}
private void setRotation ( ModelRenderer model , float x , float y , float z )
{
model . rotateAngleX = x ;
model . rotateAngleY = y ;
model . rotateAngleZ = z ;
}
public void setRotationAngles ( float f , float f1 , float f2 , float f3 , float f4 , float f5 , Entity par7Entity )
{
super . setRotationAngles ( f , f1 , f2 , f3 , f4 , f5 , par7Entity ) ;
}
public void renderModel ( float f )
{
Shape1 . render ( f ) ;
Shape2 . render ( f ) ;
Shape3 . render ( f ) ;
Shape4 . render ( f ) ;
}
package net . minecraft . src ;
import java . util . Random ;
import java . util . List ;
public class KonungBlockBench extends BlockContainer
{
public KonungBlockBench ( int par1 , int par2 , Class class1 )
{
super ( par1 , par2 , Material . wood ) ;
this . setCreativeTab ( CreativeTabs . tabBlock ) ;
this . setRequiresSelfNotify ( ) ;
}
public void setBlockBoundsBasedOnState ( IBlockAccess par1IBlockAccess , int par2 , int par3 , int par4 )
{
{
boolean var5 = ( par1IBlockAccess . getBlockMetadata ( par2 , par3 , par4 ) & <num> ) != <num> ;
if ( var5 )
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
else
{
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
}
}
public TileEntity getBlockEntity ( )
{
return new KonungTileEntityBench ( ) ;
}
public int idDropped ( int i , Random random , int j )
{
return mod_konungDecorations . itemBench . iconIndex ;
}
public int quantityDropped ( Random random )
{
return <num> ;
}
public int getRenderType ( )
{
return mod_konungDecorations . modelBenchID ;
}
public boolean isOpaqueCube ( )
{
return false ;
}
public boolean renderAsNormalBlock ( )
{
return false ;
}
public int damageDropped ( int par1 )
{
return par1 ;
}
public void onBlockPlacedBy ( World par1World , int par2 , int par3 , int par4 , EntityLiving par5EntityLiving )
{
int p = MathHelper . floor_double ( ( double ) ( ( par5EntityLiving . rotationYaw * 4F ) / <num> F ) + <num> D ) & <num> ;
byte byte0 = <num> ;
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
if ( p == <num> )
{
byte0 = <num> ;
}
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , byte0 ) ;
}
public TileEntity createNewTileEntity ( World var1 )
{
return new KonungTileEntityBench ( ) ;
}
package net . minecraft . src ;
import java . util . ArrayList ;
import java . util . List ;
public class KonungBlockStairs extends Block
{
public KonungBlockStairs ( int i , int j )
{
super ( i , j , Material . grass ) ;
}
public void addCollidingBlockToList ( World par1World , int par2 , int par3 , int par4 , AxisAlignedBB par5AxisAlignedBB , List par6List , Entity par7Entity )
{
int i = par1World . getBlockMetadata ( par2 , par3 , par4 ) ;
int j = i & <num> ;
float f = <num> F ;
float f1 = <num> F ;
float f2 = <num> F ;
float f3 = <num> F ;
if ( ( i & <num> ) != <num> )
{
f = <num> F ;
f1 = <num> F ;
f2 = <num> F ;
f3 = <num> F ;
}
this . setBlockBounds ( <num> F , f , <num> F , <num> F , f1 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
else if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
else if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
else if ( j == <num> )
{
this . setBlockBounds ( <num> F , f2 , <num> F , <num> F , f3 , <num> F ) ;
super . addCollidingBlockToList ( par1World , par2 , par3 , par4 , par5AxisAlignedBB , par6List , par7Entity ) ;
}
this . setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
public void onBlockPlacedBy ( World par1World , int par2 , int par3 , int par4 , EntityLiving par5EntityLiving )
{
int i = MathHelper . floor_double ( ( double ) ( ( par5EntityLiving . rotationYaw * 4F ) / <num> F ) + <num> D ) & <num> ;
int j = par1World . getBlockMetadata ( par2 , par3 , par4 ) & <num> ;
if ( i == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | j ) ;
}
if ( i == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | j ) ;
}
if ( i == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | j ) ;
}
if ( i == <num> )
{
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , <num> | j ) ;
}
}
public void onBlockPlaced ( World par1World , int par2 , int par3 , int par4 , int par5 )
{
if ( par5 == <num> )
{
int i = par1World . getBlockMetadata ( par2 , par3 , par4 ) ;
par1World . setBlockMetadataWithNotify ( par2 , par3 , par4 , i | <num> ) ;
}
}
public void setBlockBoundsBasedOnState ( IBlockAccess iblockaccess , int i , int j , int k )
{
setBlockBounds ( <num> F , <num> F , <num> F , <num> F , <num> F , <num> F ) ;
}
public boolean isOpaqueCube ( )
{
return false ;
}
public boolean renderAsNormalBlock ( )
{
return false ;
}
public int getRenderType ( )
{
return <num> ;
}
package net . minecraft . src ;
import org . lwjgl . opengl . GL11 ;
public class KonungRenderTable extends TileEntitySpecialRenderer
{
private KonungModelTable model ;
public KonungRenderTable ( )
{
model = new KonungModelTable ( ) ;
}
public void renderAModelAt ( KonungTileEntityTable tile , double d , double d1 , double d2 , float f )
{
int i = <num> ;
if ( tile . worldObj != null )
{
i = ( tile . worldObj . getBlockMetadata ( tile . xCoord , tile . yCoord , tile . zCoord ) ) ;
}
int j = <num> ;
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
bindTextureByName ( " ) ;
GL11 . glPushMatrix ( ) ;
GL11 . glTranslatef ( ( float ) d + <num> F , ( float ) d1 + <num> F , ( float ) d2 + <num> F ) ;
GL11 . glRotatef ( j , <num> F , <num> F , <num> F ) ;
GL11 . glScalef ( <num> F ,  1F ,  1F ) ;
model . renderModel ( <num> F ) ;
GL11 . glPopMatrix ( ) ;
}
public void renderTileEntityAt ( TileEntity tileentity , double d , double d1 , double d2 , float f )
{
renderAModelAt ( ( KonungTileEntityTable ) tileentity , d , d1 , d2 , f ) ;
}
}
package net . minecraft . src ;
import org . lwjgl . opengl . GL11 ;
public class KonungRenderLeather extends TileEntitySpecialRenderer
{
private KonungModelLeather model ;
public KonungRenderLeather ( )
{
model = new KonungModelLeather ( ) ;
}
public void renderAModelAt ( KonungTileEntityLeather tile , double d , double d1 , double d2 , float f )
{
int i = <num> ;
if ( tile . worldObj != null )
{
i = ( tile . worldObj . getBlockMetadata ( tile . xCoord , tile . yCoord , tile . zCoord ) ) ;
}
int j = <num> ;
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
bindTextureByName ( " ) ;
GL11 . glPushMatrix ( ) ;
GL11 . glTranslatef ( ( float ) d + <num> F , ( float ) d1 + <num> F , ( float ) d2 + <num> F ) ;
GL11 . glRotatef ( j , <num> F , <num> F , <num> F ) ;
GL11 . glScalef ( <num> F ,  1F ,  1F ) ;
model . renderModel ( <num> F ) ;
GL11 . glPopMatrix ( ) ;
}
public void renderTileEntityAt ( TileEntity tileentity , double d , double d1 , double d2 , float f )
{
renderAModelAt ( ( KonungTileEntityLeather ) tileentity , d , d1 , d2 , f ) ;
}
}
package net . minecraft . src ;
public class KonungItemTable extends ItemBlock
{
public KonungItemTable ( int par1 , Block block )
{
super ( par1 ) ;
setHasSubtypes ( true ) ;
}
public int getMetadata ( int par1 )
{
return par1 ;
}
}
package net . minecraft . src ;
public class KonungTileEntityWindow extends TileEntity
{
public KonungTileEntityWindow ( )
{
}
}
package net . minecraft . src ;
import org . lwjgl . opengl . GL11 ;
public class KonungRenderBench extends TileEntitySpecialRenderer
{
private KonungModelBench model ;
public KonungRenderBench ( )
{
model = new KonungModelBench ( ) ;
}
public void renderAModelAt ( KonungTileEntityBench tile , double d , double d1 , double d2 , float f )
{
int i = <num> ;
if ( tile . worldObj != null )
{
i = ( tile . worldObj . getBlockMetadata ( tile . xCoord , tile . yCoord , tile . zCoord ) ) ;
}
int j = <num> ;
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
if ( i == <num> )
{
j = <num> ;
}
bindTextureByName ( " ) ;
GL11 . glPushMatrix ( ) ;
GL11 . glTranslatef ( ( float ) d + <num> F , ( float ) d1 + <num> F , ( float ) d2 + <num> F ) ;
GL11 . glRotatef ( j , <num> F , <num> F , <num> F ) ;
GL11 . glScalef ( <num> F ,  1F ,  1F ) ;
model . renderModel ( <num> F ) ;
GL11 . glPopMatrix ( ) ;
}
public void renderTileEntityAt ( TileEntity tileentity , double d , double d1 , double d2 , float f )
{
renderAModelAt ( ( KonungTileEntityBench ) tileentity , d , d1 , d2 , f ) ;
}
}
public class <unk> { }
package yagisanyubin ;
public class Setting
{
public final String protocol ;
public final String host ;
public final int port ;
public final String account ;
public final String password ;
public Setting ( String protocol , String host , int port , String account , String password )
{
this . protocol = protocol ;
this . host = host ;
this . port = port ;
this . account = account ;
this . password = password ;
}
public String getProtocol ( )
{
return ( protocol ) ;
}
public String getHost ( )
{
return ( host ) ;
}
public int getProt ( )
{
return ( port ) ;
}
public String getAccount ( )
{
return ( account ) ;
}
public String getPassword ( )
{
return ( password ) ;
}
}
package yagisanyubin ;
import java . io . BufferedInputStream ;
import java . io . FileInputStream ;
import java . io . IOException ;
import java . util . Properties ;
import javax . activation . DataHandler ;
import javax . mail . BodyPart ;
import javax . mail . Message ;
import javax . mail . MessagingException ;
import javax . mail . Multipart ;
import javax . mail . Session ;
import javax . mail . Transport ;
import javax . mail . internet . AddressException ;
import javax . mail . internet . InternetAddress ;
import javax . mail . internet . MimeBodyPart ;
import javax . mail . internet . MimeMessage ;
import javax . mail . internet . MimeMultipart ;
import javax . mail . util . ByteArrayDataSource ;
public class MailSender
{
public static void execute ( Setting setting , String to , ExportedMail exportedMail ) throws AddressException , MessagingException , IOException
{
Properties systemProperties = new Properties ( ) ;
systemProperties . put ( " , setting . getHost ( ) ) ;
systemProperties . put ( " , setting . getProt ( ) ) ;
systemProperties . put ( " , " ) ;
systemProperties . put ( " , " ) ;
Session session = Session . getInstance ( systemProperties ) ;
MimeMessage mimeMessage = createSendMessage ( session , exportedMail . getFrom ( ) , to , exportedMail . getSubject ( ) , exportedMail . getText ( ) , exportedMail . getAttachmentFilePath ( ) ) ;
Transport transport = session . getTransport ( setting . getProtocol ( ) ) ;
transport . connect ( setting . getAccount ( ) , setting . getPassword ( ) ) ;
transport . sendMessage ( mimeMessage , mimeMessage . getAllRecipients ( ) ) ;
}
private static MimeMessage createSendMessage ( Session session , String from , String to , String subject , String text , String attachmentFilePath ) throws IOException , AddressException , MessagingException
{
MimeMessage mimeMessage = new MimeMessage ( session ) ;
mimeMessage . setFrom ( new InternetAddress ( from ) ) ;
mimeMessage . <unk> ( Message . RecipientType . TO , new InternetAddress ( to ) ) ;
mimeMessage . setSubject ( subject ) ;
mimeMessage . setHeader ( " , " ) ;
Multipart multipart = new MimeMultipart ( ) ;
MimeBodyPart textPart = new MimeBodyPart ( ) ;
textPart . setText ( text , " ) ;
multipart . addBodyPart ( textPart ) ;
BodyPart attachmentPart = new MimeBodyPart ( ) ;
attachmentPart . setDataHandler ( new DataHandler ( new ByteArrayDataSource ( new BufferedInputStream ( new FileInputStream ( attachmentFilePath ) ) , " ) ) ) ;
attachmentPart . setFileName ( attachmentFilePath ) ;
multipart . addBodyPart ( attachmentPart ) ;
mimeMessage . setContent ( multipart ) ;
return ( mimeMessage ) ;
}
}
package yagisanyubin ;
import java . io . FileOutputStream ;
import java . io . FileWriter ;
import java . io . IOException ;
import org . json . JSONException ;
import org . json . JSONObject ;
public class MailExporter
{
private static MailExporter instance = new MailExporter ( ) ;
public static MailExporter getInstance ( )
{
return ( instance ) ;
}
private String workDirectoryPath = " ;
private MailExporter ( ) { }
public void initialize ( String workDirectoryPath )
{
this . workDirectoryPath = workDirectoryPath ;
}
public ExportedMail export ( Mail mail ) throws IOException
{
String exportAttachmentFilePath = workDirectoryPath + mail . getAttachmentName ( ) ;
String exportJSONFilePath = workDirectoryPath + System . currentTimeMillis ( ) + " ;
exportAttachmentFile ( exportAttachmentFilePath , mail . getAttachment ( ) ) ;
ExportedMail exportedMail = new ExportedMail ( mail . getFrom ( ) , mail . getSubject ( ) , mail . getText ( ) , exportAttachmentFilePath ) ;
try
{
exportJSON ( exportJSONFilePath , mail , exportAttachmentFilePath ) ;
}
catch ( JSONException e )
{
e . printStackTrace ( ) ;
}
catch ( IOException e )
{
e . printStackTrace ( ) ;
}
return ( exportedMail ) ;
}
private void exportJSON ( String outputJSONPath , Mail mail , String attachmentFilePath ) throws JSONException , IOException
{
JSONObject jsonObject = new JSONObject ( ) ;
jsonObject . put ( " , mail . getFrom ( ) ) ;
jsonObject . put ( " , mail . getSubject ( ) ) ;
jsonObject . put ( " , mail . getText ( ) ) ;
jsonObject . put ( " , attachmentFilePath ) ;
FileWriter fw = null ;
try
{
fw = new FileWriter ( outputJSONPath ) ;
jsonObject . write ( fw ) ;
fw . flush ( ) ;
}
finally
{
if ( fw != null )
{
try
{
fw . close ( ) ;
}
catch ( IOException ignore )
{
ignore . printStackTrace ( ) ;
}
fw = null ;
}
}
}
private void exportAttachmentFile ( String filePath , byte [ ] file ) throws IOException
{
FileOutputStream fout = null ;
try
{
fout = new FileOutputStream ( filePath ) ;
fout . write ( file ) ;
fout . flush ( ) ;
}
finally
{
if ( fout != null )
{
try
{
fout . close ( ) ;
}
catch ( IOException ignore )
{
ignore . printStackTrace ( ) ;
}
fout = null ;
}
}
}
}
package yagisanyubin ;
import java . io . ByteArrayOutputStream ;
import java . io . FileNotFoundException ;
import java . io . IOException ;
import java . io . InputStream ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Properties ;
import javax . mail . Flags . Flag ;
import javax . mail . Folder ;
import javax . mail . Message ;
import javax . mail . MessagingException ;
import javax . mail . Multipart ;
import javax . mail . Part ;
import javax . mail . Session ;
import javax . mail . Store ;
public class MailReceiver
{
public static List < Mail > <unk> ( Setting setting , String attachmentType ) throws MessagingException , FileNotFoundException , IOException
{
List < Mail > result = new ArrayList < Mail > ( ) ;
Properties systemProperties = System . getProperties ( ) ;
Session session = Session . getInstance ( systemProperties , null ) ;
Store store = session . getStore ( setting . getProtocol ( ) ) ;
store . connect ( setting . getHost ( ) , setting . getProt ( ) , setting . getAccount ( ) , setting . getPassword ( ) ) ;
Folder folder = store . getFolder ( " ) ;
if ( folder . exists ( ) )
{
folder . open ( Folder . READ_WRITE ) ;
for ( Message message : folder . getMessages ( ) )
{
if ( ! message . getFlags ( ) . contains ( Flag . <unk> ) )
{
Mail mail = MailReceiver . createMail ( message , attachmentType ) ;
if ( mail != null )
{
result . add ( mail ) ;
}
}
}
folder . close ( false ) ;
}
return ( result ) ;
}
private static Mail createMail ( Message message , String attachmentType ) throws FileNotFoundException , MessagingException , IOException
{
Object messageContent = message . getContent ( ) ;
Mail result = null ;
if ( messageContent instanceof Multipart )
{
Multipart multiPart = ( Multipart ) messageContent ;
String text = " ;
byte [ ] attachment = null ;
String attachmentName = null ;
for ( int i = <num> ; i < multiPart . getCount ( ) ; i ++ )
{
Part part = multiPart . getBodyPart ( i ) ;
String contentType = part . getContentType ( ) ;
if ( contentType . startsWith ( " ) )
{
text = part . getContent ( ) . toString ( ) ;
}
else if ( attachment == null && contentType . startsWith ( attachmentType ) )
{
InputStream in = part . getInputStream ( ) ;
attachment = MailReceiver . readInputStream ( in ) ;
attachmentName = part . getFileName ( ) ;
}
}
if ( attachment != null )
{
String from = message . getFrom ( ) [ <num> ] . toString ( ) ;
String subject = message . getSubject ( ) ;
result = new Mail ( from , subject , text , attachment , attachmentName ) ;
}
}
return ( result ) ;
}
private static byte [ ] readInputStream ( InputStream in ) throws IOException
{
byte [ ] result = new byte [ <num> ] ;
ByteArrayOutputStream bout = null ;
try
{
byte [ ] buffer = new byte [ <num> ] ;
bout = new ByteArrayOutputStream ( ) ;
while ( true )
{
int cursor = in . read ( buffer , <num> , buffer . length ) ;
if ( cursor ==  <num> )
{
break ;
}
bout . write ( buffer , <num> , cursor ) ;
}
bout . flush ( ) ;
result = bout . toByteArray ( ) ;
}
finally
{
if ( bout != null )
{
try
{
bout . close ( ) ;
}
catch ( IOException ignore )
{
ignore . printStackTrace ( ) ;
}
bout = null ;
}
}
return ( result ) ;
}
}
package yagisanyubin ;
public class Mail
{
private final String from ;
private final String subject ;
private final String text ;
private final byte [ ] attachment ;
private final String attachmentName ;
public Mail ( String from , String subject , String text , byte [ ] attachment , String attachmentName )
{
this . from = from ;
this . subject = subject ;
this . text = text ;
this . attachment = ( byte [ ] ) attachment . clone ( ) ;
this . attachmentName = attachmentName ;
}
public String getFrom ( )
{
return ( from ) ;
}
public String getSubject ( )
{
return ( subject ) ;
}
public String getText ( )
{
return ( text ) ;
}
public byte [ ] getAttachment ( )
{
return ( attachment ) ;
}
public String getAttachmentName ( )
{
return ( attachmentName ) ;
}
}
package yagisanyubin ;
import java . io . File ;
import java . io . IOException ;
import java . io . InputStream ;
public class <unk>
{
public static boolean convert ( String srcMovieFilePath , String dstMovieFilePath ) throws IOException
{
boolean result = false ;
InputStream stream = null ;
try
{
ProcessBuilder builder = new ProcessBuilder ( " , " , srcMovieFilePath , " , " , " , " , " , " , " , " , " , " , dstMovieFilePath ) ;
Process process = builder . start ( ) ;
stream = process . getErrorStream ( ) ;
while ( true )
{
int c = stream . read ( ) ;
if ( c ==  <num> )
{
break ;
}
}
File dstFile = new File ( dstMovieFilePath ) ;
result = dstFile . exists ( ) ;
}
finally
{
if ( stream != null )
{
try
{
stream . close ( ) ;
}
catch ( IOException ignore )
{
ignore . printStackTrace ( ) ;
}
stream = null ;
}
}
return ( result ) ;
}
}
package yagisanyubin ;
public class ExportedMail
{
private final String from ;
private final String subject ;
private final String text ;
private final String attachmentFilePath ;
public ExportedMail ( String from , String subject , String text , String attachmentFilePath )
{
this . from = from ;
this . subject = subject ;
this . text = text ;
this . attachmentFilePath = attachmentFilePath ;
}
public String getFrom ( )
{
return ( from ) ;
}
public String getSubject ( )
{
return ( subject ) ;
}
public String getText ( )
{
return ( text ) ;
}
public String getAttachmentFilePath ( )
{
return ( attachmentFilePath ) ;
}
}
package com . amazon . karanb . s3 ;
import com . amazonaws . AmazonClientException ;
import com . amazonaws . auth . PropertiesCredentials ;
import com . amazonaws . services . s3 . <unk> ;
import com . amazonaws . services . s3 . AmazonS3Client ;
import com . amazonaws . services . s3 . model . * ;
import com . amazonaws . services . s3 . transfer . TransferManager ;
import com . amazonaws . services . s3 . transfer . TransferManagerConfiguration ;
import com . amazonaws . services . s3 . transfer . Upload ;
import java . io . File ;
import java . io . IOException ;
import java . io . InputStream ;
import java . net . URI ;
import java . net . URISyntaxException ;
import java . util . ArrayList ;
import java . util . Enumeration ;
import java . util . List ;
import java . util . Properties ;
import java . util . concurrent . Executors ;
import java . util . concurrent . ThreadFactory ;
import java . util . concurrent . ThreadPoolExecutor ;
public class App
{
public static ThreadPoolExecutor createDefaultExecutorService ( int n ) {
ThreadFactory threadFactory = new ThreadFactory ( ) {
private int threadCount = <num> ;
public Thread newThread ( Runnable r ) {
Thread thread = new Thread ( r ) ;
thread . setName ( " + threadCount ++ ) ;
return thread ;
}
} ;
return ( ThreadPoolExecutor ) Executors . newFixedThreadPool ( n , threadFactory ) ;
}
public static void printUsage ( ) {
System . out . println ( " ) ;
}
public static boolean validateS3Url ( String s3url ) {
return s3url . matches ( " ) ;
}
public static String extractS3Bucket ( String s3url ) {
try {
URI u = new URI ( s3url ) ;
if ( u != null && u . getScheme ( ) != null && u . getScheme ( ) . equals ( " ) ) {
return ( u . getAuthority ( ) ) ;
}
} catch ( URISyntaxException e ) {
}
return null ;
}
public static String extractS3KeyName ( String s3url ) {
try {
URI u = new URI ( s3url ) ;
if ( u != null && u . getScheme ( ) != null && u . getScheme ( ) . equals ( " ) ) {
return ( u . getPath ( ) . substring ( <num> ) ) ;
}
} catch ( URISyntaxException e ) {
}
return null ;
}
public static boolean validateFile ( String filePath ) {
return true ;
}
public static void main ( String [ ] args )
{
if ( args . length < <num> ) {
printUsage ( ) ;
System . exit (  <num> ) ;
}
String downloadS3Url = args [ <num> ] ;
String filePath = args [ <num> ] ;
int numThreads = Integer . parseInt ( args [ <num> ] ) ;
long uploadPartSize = Long . parseLong ( args [ <num> ] ) ;
if ( ! validateS3Url ( downloadS3Url ) ) {
printUsage ( ) ;
System . exit (  <num> ) ;
}
String bucketName = extractS3Bucket ( downloadS3Url ) ;
String keyName = extractS3KeyName ( downloadS3Url ) ;
if ( ! validateFile ( filePath ) ) {
printUsage ( ) ;
System . exit (  <num> ) ;
}
TransferManager tm = null ;
TransferManagerConfiguration tmc = new TransferManagerConfiguration ( ) ;
tmc . <unk> ( uploadPartSize ) ;
tmc . <unk> ( <num> ) ;
try {
InputStream i = App . class . getResourceAsStream ( " ) ;
tm = new TransferManager ( new AmazonS3Client ( new PropertiesCredentials ( i ) ) , createDefaultExecutorService ( numThreads ) ) ;
tm . setConfiguration ( tmc ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
PutObjectRequest request = new PutObjectRequest (
bucketName , keyName , new File ( filePath ) ) ;
request . <unk> ( new <unk> ( ) {
long totalbytestransfered = <num> ;
long starttime = System . nanoTime ( ) ;
long numParts = <num> ;
public void <unk> ( ProgressEvent event ) {
long b = addBytes ( event . <unk> ( ) ) ;
if ( event . getEventCode ( ) == ProgressEvent . <unk> ) {
System . out . println ( " +
b ) ;
long now = System . nanoTime ( ) ;
long diff = ( now  starttime ) / <num> ;
System . out . println ( " + diff ) ;
System . out . println ( " + b / diff + " ) ;
} else if ( event . getEventCode ( ) == ProgressEvent . <unk> ) {
long p = addPart ( ) ;
System . out . println ( " + p + " ) ;
} else if ( event . getEventCode ( ) == ProgressEvent . <unk> ) {
System . out . println ( " ) ;
long now = System . nanoTime ( ) ;
long diff = ( now  starttime ) / <num> ;
System . out . println ( " + b / diff + " ) ;
}
}
public synchronized long addBytes ( long b ) {
totalbytestransfered += b ;
return totalbytestransfered ;
}
public synchronized long addPart ( ) {
numParts ++ ;
return numParts ;
}
} ) ;
Upload upload = tm . upload ( request ) ;
try {
try {
upload . waitForCompletion ( ) ;
} catch ( InterruptedException e ) {
e . printStackTrace ( ) ;
}
} catch ( AmazonClientException amazonClientException ) {
System . out . println ( " ) ;
amazonClientException . printStackTrace ( ) ;
}
System . exit ( <num> ) ;
}
}
package com . amazon . karanb . s3 ;
import junit . framework . Test ;
import junit . framework . TestCase ;
import junit . framework . TestSuite ;
public class AppTest
extends TestCase
{
public AppTest ( String testName )
{
super ( testName ) ;
}
public static Test suite ( )
{
return new TestSuite ( AppTest . class ) ;
}
public void testApp ( )
{
assertTrue ( true ) ;
}
}
package com . example . functiongenerator ;
public final class R {
public static final class attr {
}
public static final class drawable {
public static final int ic_launcher = <num> ;
}
public static final class id {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int editTextFrequency = <num> ;
public static final int menu_settings = <num> ;
public static final int textView1 = <num> ;
}
public static final class layout {
public static final int activity_main = <num> ;
public static final int activity_sine_wave = <num> ;
public static final int activity_square_wave = <num> ;
}
public static final class menu {
public static final int activity_main = <num> ;
public static final int activity_sine_wave = <num> ;
public static final int activity_square_wave = <num> ;
}
public static final class string {
public static final int app_name = <num> ;
public static final int hello_world = <num> ;
public static final int menu_settings = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
}
public static final class style {
public static final int AppBaseTheme = <num> ;
public static final int AppTheme = <num> ;
}
}
package com . my . siggen ;
public abstract class Constants {
public static final int DEFAULT_LOWER_FREQ = <num> ;
public static final int DEFAULT_HIGHER_FREQ = <num> ;
public abstract class StartStopToggleButton {
public static final boolean START = false ;
public static final boolean STOP = true ;
public static final String START_STRING = " ;
public static final String STOP_STRING = " ;
public static final String INVALID_STRING = " ;
}
public abstract class VARIABLES_ {
public static final String CURRENT_FREQ = " ;
public static final String WAVE_TYPE = " ;
public static final int SINE_0 = <num> ;
public static final int SQUARE_1 = <num> ;
}
}
package com . example . functiongenerator ;
import android . media . AudioFormat ;
import android . media . AudioManager ;
import android . media . AudioTrack ;
import android . os . Bundle ;
import android . app . Activity ;
import android . content . Intent ;
import android . view . Menu ;
public class SquareWaveActivity extends Activity {
private final int duration = <num> ;
private final int sampleRate = <num> ;
private final int numSamples = sampleRate * duration ;
private final double sample [ ] = new double [ numSamples ] ;
private double freqOfTone = <num> ;
private final byte generatedSnd [ ] = new byte [ <num> * numSamples ] ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . activity_square_wave ) ;
Intent intent = getIntent ( ) ;
freqOfTone = Double . parseDouble ( intent . getStringExtra ( " ) ) ;
long initTime = System . currentTimeMillis ( ) ;
System . out . println ( " ) ;
for ( int i = <num> ; i < numSamples ; i ++ ) {
if ( ( ( int ) Math . floor ( i * freqOfTone / sampleRate ) ) % <num> == <num> ) {
sample [ i ] = <num> ;
} else {
sample [ i ] = <num> ;
}
}
System . out . println ( " ) ;
int idx = <num> ;
for ( double dVal : sample ) {
short val = ( short ) ( dVal * <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( val & <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( ( val & <num> ) >>> <num> ) ;
}
System . out . println ( " + ( System . currentTimeMillis ( )  initTime ) + " ) ;
System . out . println ( " ) ;
AudioTrack audioTrack = new AudioTrack ( AudioManager . STREAM_MUSIC , <num> , AudioFormat . CHANNEL_CONFIGURATION_MONO ,
AudioFormat . ENCODING_PCM_16BIT , numSamples , AudioTrack . MODE_STATIC ) ;
audioTrack . write ( generatedSnd , <num> , numSamples ) ;
audioTrack . play ( ) ;
System . out . println ( " ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
getMenuInflater ( ) . inflate ( R . menu . activity_square_wave , menu ) ;
return true ;
}
}
package com . my . siggen . logic ;
import com . my . siggen . Constants ;
import com . my . siggen . GlobalVar ;
import android . media . AudioFormat ;
import android . media . AudioManager ;
import android . media . AudioTrack ;
public class TriangularWaveLogic implements AudioWaveLogic {
private static final int duration = <num> ;
private static final int sampleRate = <num> ;
private static final int numSamples = sampleRate * duration ;
private static final double sample [ ] = new double [ numSamples ] ;
public static double freqOfTone = <num> ;
private final byte generatedSnd [ ] = new byte [ <num> * numSamples ] ;
public static AudioTrack audioTrack = new AudioTrack ( AudioManager . STREAM_MUSIC , <num> , AudioFormat . CHANNEL_CONFIGURATION_MONO ,
AudioFormat . ENCODING_PCM_16BIT , numSamples , AudioTrack . MODE_STREAM ) ;
public void play ( double freqOfTone ) {
TriangularWaveLogic . freqOfTone = freqOfTone ;
}
@Override
public void play ( ) {
Object freqOfToneValue = GlobalVar . getInstance ( ) . retrieve ( Constants . VARIABLES_ . CURRENT_FREQ ) ;
if ( freqOfToneValue != null ) {
TriangularWaveLogic . freqOfTone = ( ( Integer ) freqOfToneValue ) . doubleValue ( ) ;
}
long initTime = System . currentTimeMillis ( ) ;
System . out . println ( " ) ;
for ( int i = <num> ; i < numSamples ; i ++ ) {
if ( ( ( int ) Math . floor ( i * freqOfTone / sampleRate ) ) % <num> == <num> ) {
sample [ i ] = <num> ;
} else {
sample [ i ] = <num> ;
}
}
System . out . println ( " ) ;
int idx = <num> ;
for ( double dVal : sample ) {
short val = ( short ) ( dVal * <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( val & <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( ( val & <num> ) >>> <num> ) ;
}
System . out . println ( " + ( System . currentTimeMillis ( )  initTime ) + " ) ;
System . out . println ( " ) ;
audioTrack . write ( generatedSnd , <num> , numSamples ) ;
audioTrack . play ( ) ;
System . out . println ( " ) ;
}
public void releaseAudioTrack ( ) {
audioTrack . release ( ) ;
}
}
package com . my . siggen ;
import java . lang . ref . WeakReference ;
import java . util . HashMap ;
import java . util . Map ;
public class GlobalVar {
Map < String , WeakReference < Object >> variables = new HashMap < String , WeakReference < Object >> ( ) ;
private static final GlobalVar instance = new GlobalVar ( ) ;
private GlobalVar ( ) {
}
public static GlobalVar getInstance ( ) {
return instance ;
}
public void save ( String id , Object object ) {
variables . put ( id , new WeakReference < Object > ( object ) ) ;
}
public Object retrieve ( String id ) {
WeakReference < Object > objectWeakReference = variables . get ( id ) ;
if ( objectWeakReference == null ) {
return null ;
} else {
return objectWeakReference . get ( ) ;
}
}
public void remove ( String id ) {
variables . remove ( id ) ;
}
public void <unk> ( ) {
variables . clear ( ) ;
}
}
package com . my . siggen ;
public final class BuildConfig {
public final static boolean DEBUG = true ;
package com . my . siggen . logic . math ;
public class SineLookUpTable {
static int precision = <num> ;
static int multiplyingFactor = ( int ) Math . pow ( <num> , precision ) ;
static int arraySize = ( int ) ( <num> * Math . PI * multiplyingFactor ) ;
static double [ ] value = new double [ arraySize ] ;
private static SineLookUpTable instance = null ;
private SineLookUpTable ( ) {
System . out . println ( " ) ;
for ( int i = <num> ; i < arraySize ; i ++ ) {
value [ i ] = Math . sin ( i * <num> / multiplyingFactor ) ;
}
System . out . println ( " ) ;
}
public static double sineOf ( double number ) {
if ( instance == null ) {
instance = new SineLookUpTable ( ) ;
}
int rangeNum = ( int ) ( number * multiplyingFactor )  arraySize * ( ( int ) ( number * multiplyingFactor ) / arraySize ) ;
if ( rangeNum < <num> || rangeNum >= arraySize ) {
System . out . println ( " ) ;
return <num> ;
}
return value [ rangeNum ] ;
}
}
package com . example . functiongenerator ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . Menu ;
import android . view . View ;
import android . widget . EditText ;
public class MainActivity extends Activity {
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . activity_main ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
getMenuInflater ( ) . inflate ( R . menu . activity_main , menu ) ;
return true ;
}
public void exitApplication ( View v ) {
System . out . println ( " ) ;
System . exit ( <num> ) ;
}
public void <unk> ( View v ) {
System . out . println ( " ) ;
Intent intent = new Intent ( this , SineWaveActivity . class ) ;
EditText sineWaveFrequency = ( EditText ) findViewById ( R . id . editTextFrequency ) ;
String message = sineWaveFrequency . getText ( ) . toString ( ) ;
if ( message == null || message . length ( ) == <num> ) {
message = " ;
}
intent . putExtra ( " , message ) ;
startActivity ( intent ) ;
}
public void <unk> ( View v ) {
System . out . println ( " ) ;
Intent intent = new Intent ( this , SquareWaveActivity . class ) ;
EditText editText = ( EditText ) findViewById ( R . id . editTextFrequency ) ;
String message = editText . getText ( ) . toString ( ) ;
if ( message == null || message . length ( ) == <num> ) {
message = " ;
}
intent . putExtra ( " , message ) ;
startActivity ( intent ) ;
}
}
package com . my . siggen . logic ;
public interface AudioWaveLogic {
public void play ( ) ;
}
package com . my . siggen ;
import android . app . Activity ;
import android . content . Intent ;
import android . media . AudioFormat ;
import android . media . AudioRecord ;
import android . os . Bundle ;
import android . view . Menu ;
import android . view . View ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . RadioButton ;
import android . widget . SeekBar ;
import android . widget . Toast ;
import android . widget . SeekBar . OnSeekBarChangeListener ;
import android . widget . TextView ;
import com . my . siggen . logic . AudioService ;
import com . my . siggen . logic . AudioThreadIntentService ;
public class MainActivity extends Activity {
public static boolean stopLoop = false ;
public static boolean startStopToggleStatus = Constants . StartStopToggleButton . STOP ;
public SeekBar seekBar = null ;
public TextView textViewLowFreq = null ;
public TextView textViewHighFreq = null ;
public TextView textViewCurrFreq = null ;
public EditText editTextLowerFreq = null ;
public EditText editTextHigherFreq = null ;
public Button buttonStartStopToggle = null ;
Intent intentAudioService = null ;
Intent intenAudioThreadIntentService = null ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . activity_main ) ;
intentAudioService = new Intent ( this , AudioService . class ) ;
intenAudioThreadIntentService = new Intent ( this , AudioThreadIntentService . class ) ;
textViewLowFreq = ( TextView ) this . findViewById ( R . id . textViewLowerFreq ) ;
textViewLowFreq . setText ( String . valueOf ( Constants . DEFAULT_LOWER_FREQ ) ) ;
textViewHighFreq = ( TextView ) this . findViewById ( R . id . textViewHighFreq ) ;
textViewHighFreq . setText ( String . valueOf ( Constants . DEFAULT_HIGHER_FREQ ) ) ;
textViewCurrFreq = ( TextView ) this . findViewById ( R . id . textViewCurrFreq ) ;
textViewCurrFreq . setText ( textViewLowFreq . getText ( ) ) ;
editTextLowerFreq = ( EditText ) this . findViewById ( R . id . editTextLowerFreq ) ;
editTextLowerFreq . setText ( String . valueOf ( Constants . DEFAULT_LOWER_FREQ ) ) ;
editTextHigherFreq = ( EditText ) this . findViewById ( R . id . editTextHigherFreq ) ;
editTextHigherFreq . setText ( String . valueOf ( Constants . DEFAULT_HIGHER_FREQ ) ) ;
seekBar = ( SeekBar ) this . findViewById ( R . id . seekBarFreq ) ;
seekBar . setOnSeekBarChangeListener ( new OnSeekBarChangeListener ( ) {
@Override
public void onStopTrackingTouch ( SeekBar arg0 ) {
}
@Override
public void onStartTrackingTouch ( SeekBar arg0 ) {
}
@Override
public void onProgressChanged ( SeekBar arg0 , int arg1 , boolean arg2 ) {
Integer lowerFreq = Integer . valueOf ( editTextLowerFreq . getText ( ) . toString ( ) ) ;
Integer higherFreq = Integer . valueOf ( editTextHigherFreq . getText ( ) . toString ( ) ) ;
Integer currentFreq = lowerFreq + ( higherFreq  lowerFreq ) * arg1 / <num> ;
textViewLowFreq . setText ( lowerFreq . toString ( ) ) ;
textViewCurrFreq . setText ( currentFreq . toString ( ) ) ;
textViewHighFreq . setText ( higherFreq . toString ( ) ) ;
GlobalVar . getInstance ( ) . save ( Constants . VARIABLES_ . CURRENT_FREQ , currentFreq ) ;
}
} ) ;
buttonStartStopToggle = ( Button ) this . findViewById ( R . id . buttonStartStopToggle ) ;
System . out . println ( " ) ;
Toast . makeText ( getApplicationContext ( ) , " , Toast . LENGTH_LONG ) . show ( ) ;
System . out . println ( " ) ;
for ( int rate : new int [ ] { <num> , <num> , <num> , <num> , <num> } ) {
int bufferSize = AudioRecord . getMinBufferSize ( rate , AudioFormat . <unk> , AudioFormat . ENCODING_PCM_16BIT ) ;
if ( bufferSize > <num> ) {
Toast . makeText ( getApplicationContext ( ) , String . valueOf ( rate ) , Toast . LENGTH_LONG ) . show ( ) ;
}
}
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
getMenuInflater ( ) . inflate ( R . menu . main , menu ) ;
return true ;
}
public void <unk> ( View v ) {
System . out . println ( " + startStopToggleStatus ) ;
startService ( intenAudioThreadIntentService ) ;
startStopToggleStatus = ! startStopToggleStatus ;
if ( startStopToggleStatus == Constants . StartStopToggleButton . START ) {
buttonStartStopToggle . setText ( Constants . StartStopToggleButton . STOP_STRING ) ;
} else if ( startStopToggleStatus == Constants . StartStopToggleButton . STOP ) {
buttonStartStopToggle . setText ( Constants . StartStopToggleButton . START_STRING ) ;
} else {
buttonStartStopToggle . setText ( Constants . StartStopToggleButton . INVALID_STRING ) ;
}
AudioService . AUDIOSERVICE_STOP = startStopToggleStatus ;
if ( startStopToggleStatus == Constants . StartStopToggleButton . START ) {
startService ( intentAudioService ) ;
} else if ( startStopToggleStatus == Constants . StartStopToggleButton . STOP ) {
stopService ( intentAudioService ) ;
}
stopLoop = startStopToggleStatus ;
System . out . println ( " + startStopToggleStatus ) ;
}
public void <unk> ( View v ) {
boolean checked = ( ( RadioButton ) v ) . isChecked ( ) ;
switch ( v . getId ( ) ) {
case R . id . radioSineWave :
if ( checked )
GlobalVar . getInstance ( ) . save ( Constants . VARIABLES_ . WAVE_TYPE , Constants . VARIABLES_ . SINE_0 ) ;
break ;
case R . id . radioSquareWave :
if ( checked )
GlobalVar . getInstance ( ) . save ( Constants . VARIABLES_ . WAVE_TYPE , Constants . VARIABLES_ . SQUARE_1 ) ;
break ;
}
}
}
package com . my . siggen . logic ;
import android . media . AudioFormat ;
import android . media . AudioRecord ;
import com . my . siggen . Constants ;
import com . my . siggen . GlobalVar ;
import com . my . siggen . logic . math . SineLookUpTable ;
public class SineWaveLogic implements AudioWaveLogic {
private static final int duration = AudioThreadIntentService . duration ;
private static final int sampleRate = AudioThreadIntentService . sampleRate ;
private static final int numSamples = sampleRate * duration ;
private double sample [ ] = new double [ numSamples ] ;
public static double freqOfTone = AudioThreadIntentService . freqOfTone ;
private byte generatedSnd [ ] = new byte [ <num> * numSamples ] ;
public void play ( double freqOfTone ) {
SineWaveLogic . freqOfTone = freqOfTone ;
}
@Override
public void play ( ) {
Object freqOfToneValue = GlobalVar . getInstance ( ) . retrieve ( Constants . VARIABLES_ . CURRENT_FREQ ) ;
if ( freqOfToneValue != null ) {
SineWaveLogic . freqOfTone = ( ( Integer ) freqOfToneValue ) . doubleValue ( ) ;
}
long initTime = System . currentTimeMillis ( ) ;
System . out . println ( " + freqOfTone ) ;
double multiplyFactor = <num> * Math . PI / ( sampleRate / freqOfTone ) ;
for ( int i = <num> ; i < numSamples ; i ++ ) {
sample [ i ] = SineLookUpTable . sineOf ( multiplyFactor * i ) ;
}
AudioThreadIntentService . sample = sample ;
System . out . println ( " + sample . length ) ;
System . out . println ( " ) ;
int idx = <num> ;
for ( double dVal : sample ) {
short val = ( short ) ( dVal * <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( val & <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( ( val & <num> ) >>> <num> ) ;
}
AudioThreadIntentService . generatedSnd = generatedSnd ;
System . out . println ( " + ( System . currentTimeMillis ( )  initTime ) + " ) ;
System . out . println ( " ) ;
int bufferSize = AudioRecord . getMinBufferSize ( <num> , AudioFormat . CHANNEL_CONFIGURATION_MONO , AudioFormat . ENCODING_PCM_16BIT ) ;
System . out . println ( " + bufferSize ) ;
System . out . println ( " ) ;
}
public void releaseAudioTrack ( ) {
}
}
package com . my . siggen ;
public final class R {
public static final class attr {
}
public static final class dimen {
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
}
public static final class drawable {
public static final int ic_launcher = <num> ;
}
public static final class id {
public static final int TextView01 = <num> ;
public static final int TextView02 = <num> ;
public static final int action_settings = <num> ;
public static final int buttonStartStopToggle = <num> ;
public static final int editTextHigherFreq = <num> ;
public static final int editTextLowerFreq = <num> ;
public static final int <unk> = <num> ;
public static final int radioSineWave = <num> ;
public static final int radioSquareWave = <num> ;
public static final int <unk> = <num> ;
public static final int seekBarFreq = <num> ;
public static final int textView1 = <num> ;
public static final int textView2 = <num> ;
public static final int textViewCurrFreq = <num> ;
public static final int textViewHighFreq = <num> ;
public static final int textViewLowerFreq = <num> ;
public static final int <unk> = <num> ;
}
public static final class layout {
public static final int activity_main = <num> ;
}
public static final class menu {
public static final int main = <num> ;
}
public static final class string {
public static final int action_settings = <num> ;
public static final int app_name = <num> ;
public static final int hello_world = <num> ;
}
public static final class style {
public static final int AppBaseTheme = <num> ;
public static final int AppTheme = <num> ;
}
}
package com . example . functiongenerator ;
import android . app . Activity ;
import android . content . Intent ;
import android . media . AudioFormat ;
import android . media . AudioManager ;
import android . media . AudioTrack ;
import android . os . Bundle ;
import android . view . Menu ;
public class SineWaveActivity extends Activity {
private final int duration = <num> ;
private final int sampleRate = <num> ;
private final int numSamples = sampleRate * duration ;
private final double sample [ ] = new double [ numSamples ] ;
private double freqOfTone = <num> ;
private final byte generatedSnd [ ] = new byte [ <num> * numSamples ] ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . activity_sine_wave ) ;
Intent intent = getIntent ( ) ;
freqOfTone = Double . parseDouble ( intent . getStringExtra ( " ) ) ;
long initTime = System . currentTimeMillis ( ) ;
System . out . println ( " ) ;
for ( int i = <num> ; i < numSamples ; i ++ ) {
sample [ i ] = Math . sin ( <num> * Math . PI * i / ( sampleRate / freqOfTone ) ) ;
}
System . out . println ( " ) ;
int idx = <num> ;
for ( double dVal : sample ) {
short val = ( short ) ( dVal * <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( val & <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( ( val & <num> ) >>> <num> ) ;
}
System . out . println ( " + ( System . currentTimeMillis ( )  initTime ) + " ) ;
System . out . println ( " ) ;
AudioTrack audioTrack = new AudioTrack ( AudioManager . STREAM_MUSIC , <num> , AudioFormat . CHANNEL_CONFIGURATION_MONO ,
AudioFormat . ENCODING_PCM_16BIT , numSamples , AudioTrack . MODE_STATIC ) ;
audioTrack . write ( generatedSnd , <num> , numSamples ) ;
audioTrack . play ( ) ;
System . out . println ( " ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
getMenuInflater ( ) . inflate ( R . menu . activity_sine_wave , menu ) ;
return true ;
}
}
package com . my . siggen . logic ;
import com . my . siggen . Constants ;
import com . my . siggen . GlobalVar ;
import android . media . AudioFormat ;
import android . media . AudioManager ;
import android . media . AudioTrack ;
public class SquareWaveLogic implements AudioWaveLogic {
private static final int duration = <num> ;
private static final int sampleRate = <num> ;
private static final int numSamples = sampleRate * duration ;
private static final double sample [ ] = new double [ numSamples ] ;
public static double freqOfTone = <num> ;
private final byte generatedSnd [ ] = new byte [ <num> * numSamples ] ;
public static AudioTrack audioTrack = null ;
static {
audioTrack = new AudioTrack ( AudioManager . STREAM_MUSIC , <num> , AudioFormat . CHANNEL_CONFIGURATION_MONO ,
AudioFormat . ENCODING_PCM_16BIT , numSamples , AudioTrack . MODE_STREAM ) ;
audioTrack . play ( ) ;
}
public void play ( double freqOfTone ) {
SquareWaveLogic . freqOfTone = freqOfTone ;
}
@Override
public void play ( ) {
Object freqOfToneValue = GlobalVar . getInstance ( ) . retrieve ( Constants . VARIABLES_ . CURRENT_FREQ ) ;
if ( freqOfToneValue != null ) {
SquareWaveLogic . freqOfTone = ( ( Integer ) freqOfToneValue ) . doubleValue ( ) ;
}
long initTime = System . currentTimeMillis ( ) ;
System . out . println ( " ) ;
for ( int i = <num> ; i < numSamples ; i ++ ) {
if ( ( ( int ) Math . floor ( i * freqOfTone / sampleRate ) ) % <num> == <num> ) {
sample [ i ] = <num> ;
} else {
sample [ i ] = <num> ;
}
}
System . out . println ( " ) ;
int idx = <num> ;
for ( double dVal : sample ) {
short val = ( short ) ( dVal * <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( val & <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( ( val & <num> ) >>> <num> ) ;
}
System . out . println ( " + ( System . currentTimeMillis ( )  initTime ) + " ) ;
System . out . println ( " ) ;
audioTrack . write ( generatedSnd , <num> , numSamples ) ;
System . out . println ( " ) ;
}
public void releaseAudioTrack ( ) {
audioTrack . release ( ) ;
}
}
package com . my . siggen . logic ;
import android . app . IntentService ;
import android . content . Intent ;
import android . media . AudioFormat ;
import android . media . AudioManager ;
import android . media . AudioTrack ;
public class AudioThreadIntentService extends IntentService {
public AudioThreadIntentService ( ) {
super ( " ) ;
}
public static final int duration = <num> ;
public static final int sampleRate = <num> ;
public static final int numSamples = sampleRate * duration ;
public static double sample [ ] = new double [ numSamples ] ;
public static double freqOfTone = <num> ;
public static byte generatedSnd [ ] = new byte [ <num> * numSamples ] ;
public static AudioTrack audioTrack = null ;
static {
audioTrack = new AudioTrack ( AudioManager . STREAM_MUSIC , <num> , AudioFormat . CHANNEL_CONFIGURATION_MONO ,
AudioFormat . ENCODING_PCM_16BIT , numSamples , AudioTrack . MODE_STREAM ) ;
audioTrack . play ( ) ;
}
@Override
protected void onHandleIntent ( Intent intent ) {
int idx = <num> ;
while ( true ) {
for ( double dVal : sample ) {
short val = ( short ) ( dVal * <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( val & <num> ) ;
generatedSnd [ idx ++ ] = ( byte ) ( ( val & <num> ) >>> <num> ) ;
}
System . out . println ( " + audioTrack . write ( generatedSnd , <num> , numSamples ) ) ;
}
}
}
package com . my . siggen . logic ;
import com . my . siggen . Constants ;
import com . my . siggen . GlobalVar ;
import android . app . IntentService ;
import android . content . Intent ;
public class AudioService extends IntentService {
public static boolean AUDIOSERVICE_STOP = false ;
public AudioService ( ) {
super ( " ) ;
}
@Override
protected void onHandleIntent ( Intent intent ) {
Integer waveType = null ;
AudioWaveLogic audioWaveLogic = null ;
while ( ! AUDIOSERVICE_STOP ) {
waveType = ( Integer ) GlobalVar . getInstance ( ) . retrieve ( Constants . VARIABLES_ . WAVE_TYPE ) ;
if ( waveType == null ) {
waveType = Constants . VARIABLES_ . SINE_0 ;
}
switch ( waveType . intValue ( ) ) {
case Constants . VARIABLES_ . SINE_0 :
audioWaveLogic = new SineWaveLogic ( ) ;
break ;
case Constants . VARIABLES_ . SQUARE_1 :
audioWaveLogic = new SquareWaveLogic ( ) ;
break ;
default :
break ;
}
audioWaveLogic . play ( ) ;
}
}
}
package com . example . functiongenerator ;
public final class BuildConfig {
public final static boolean DEBUG = true ;
package es . mrjon . androidmpd ;
import android . widget . TextView ;
public class TextViewStatusDisplay implements StatusDisplay {
private final TextView view ;
public TextViewStatusDisplay ( TextView view ) {
this . view = view ;
}
public void display ( String status ) {
view . setText ( status ) ;
}
}
package es . mrjon . androidmpd ;
import android . util . Log ;
import java . util . ArrayList ;
import java . util . Collection ;
import java . util . List ;
import org . bff . javampd . MPD ;
import org . bff . javampd . exception . MPDException ;
import org . bff . javampd . objects . MPDArtist ;
public class MetadataCache {
private MPD mpd ;
private Collection < MPDArtist > artists ;
public MetadataCache ( MPD mpd ) throws MPDException {
this . mpd = mpd ;
}
public void update ( ) throws MPDException {
artists = mpd . getMPDDatabase ( ) . <unk> ( ) ;
}
public List < String > getSearchTerms ( List < String > recognizedPhrases ) {
List < String > searchTerms = new ArrayList < String > ( ) ;
try {
if ( artists == null ) { update ( ) ; }
Log . v ( Constants . LOG_TAG , " + artists . size ( ) + " ) ;
for ( String phrase : recognizedPhrases ) {
for ( MPDArtist artist : artists ) {
if ( artist . getName ( ) . toLowerCase ( ) . contains ( phrase ) ) {
searchTerms . add ( artist . getName ( ) ) ;
}
}
}
} catch ( MPDException e ) {
Log . e ( Constants . LOG_TAG , " , e ) ;
}
if ( searchTerms . size ( ) == <num> ) {
searchTerms . add ( recognizedPhrases . get ( <num> ) ) ;
}
return searchTerms ;
}
}
package es . mrjon . androidmpd ;
import org . bff . javampd . objects . MPDSong ;
public class MPDSongListItem {
private final MPDSong song ;
public MPDSongListItem ( MPDSong song ) {
this . song = song ;
}
public String toString ( ) {
return String . format ( " , song . getArtist ( ) , song . getTitle ( ) ) ;
}
public MPDSong getSong ( ) {
return song ;
}
}
package es . mrjon . androidmpd ;
import android . os . AsyncTask ;
import android . util . Log ;
import android . widget . ListView ;
import android . widget . TextView ;
import java . util . ArrayList ;
import java . util . List ;
import org . bff . javampd . MPD ;
import org . bff . javampd . exception . MPDException ;
import org . bff . javampd . objects . MPDSong ;
public class SearchTask extends AsyncTask < String , String , List < MPDSong > > {
private final MPD mpd ;
private final MetadataCache metadataCache ;
private final AsyncTask < Void , ? , ? > successCallback ;
private final StatusDisplay status ;
private final ListView playListView ;
public SearchTask (
MPD mpd ,
MetadataCache metadataCache ,
StatusDisplay status ,
ListView playListView ,
AsyncTask < Void , ? , ? > successCallback ) {
this . mpd = mpd ;
this . metadataCache = metadataCache ;
this . status = status ;
this . playListView = playListView ;
this . successCallback = successCallback ;
}
public void onPreExecute ( ) {
status . display ( " ) ;
}
public List < MPDSong > doInBackground ( String . . . searchTerms ) {
List < String > userSearches = new ArrayList < String > ( ) ;
for ( int i = <num> ; i < searchTerms . length ; i ++ ) {
userSearches . add ( searchTerms [ i ] ) ;
}
List < String > mpdSearches = metadataCache . getSearchTerms ( userSearches ) ;
List < MPDSong > results = new ArrayList < MPDSong > ( ) ;
try {
for ( String mpdSearch : mpdSearches ) {
if ( isCancelled ( ) ) { return null ; }
publishProgress ( mpdSearch ) ;
results . addAll ( mpd . getMPDDatabase ( ) . <unk> ( mpdSearch ) ) ;
}
mpd . getMPDPlaylist ( ) . <unk> ( ) ;
mpd . getMPDPlaylist ( ) . <unk> ( results ) ;
mpd . getMPDPlayer ( ) . play ( ) ;
} catch ( MPDException e ) {
Log . e ( Constants . LOG_TAG , e . toString ( ) ) ;
}
return results ;
}
public void onProgressUpdate ( String . . . updates ) {
if ( updates != null && updates . length > <num> ) {
status . display ( " + updates [ <num> ] + " ) ;
}
}
public void onPostExecute ( List < MPDSong > r ) {
if ( r == null ) {
status . display ( " ) ;
} else {
status . display ( " + r . size ( ) + " ) ;
if ( successCallback != null ) {
successCallback . execute ( ) ;
}
}
}
}
package es . mrjon . androidmpd ;
import android . content . Context ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . ArrayAdapter ;
import android . widget . TextView ;
import java . util . List ;
public class PlayListAdapter extends ArrayAdapter < MPDSongListItem > {
private final List < MPDSongListItem > items ;
private final LayoutInflater inflater ;
public PlayListAdapter ( Context context , List < MPDSongListItem > items ) {
super ( context , R . layout . playlist_row , items ) ;
this . items = items ;
this . inflater = ( LayoutInflater ) context
. getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
View rowView ;
if ( convertView == null ) {
rowView = inflater . inflate ( R . layout . playlist_row , parent , false ) ;
} else {
rowView = convertView ;
}
TextView titleText = ( TextView ) rowView . findViewById ( R . id . <unk> ) ;
titleText . setText ( items . get ( position ) . getSong ( ) . getTitle ( ) ) ;
TextView artistText = ( TextView ) rowView . findViewById ( R . id . artist ) ;
artistText . setText ( items . get ( position ) . getSong ( ) . getArtist ( ) . toString ( ) ) ;
return rowView ;
}
}
package es . mrjon . androidmpd ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . EditText ;
public class SelectServerActivity extends Activity {
public static final String SERVER = " ;
public static final String PORT = " ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . <unk> ) ;
Button saveButton = ( Button ) findViewById ( R . id . <unk> ) ;
final EditText serverText = ( EditText ) findViewById ( R . id . <unk> ) ;
final EditText portText = ( EditText ) findViewById ( R . id . <unk> ) ;
serverText . setText ( getIntent ( ) . getStringExtra ( SERVER ) ) ;
portText . setText ( " + getIntent ( ) . getIntExtra ( PORT , <num> ) ) ;
final SelectServerActivity thisActivity = this ;
saveButton . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
int port = Integer . parseInt ( portText . getText ( ) . toString ( ) ) ;
Intent intent = thisActivity . getIntent ( ) ;
intent . putExtra ( SERVER , serverText . getText ( ) . toString ( ) ) ;
intent . putExtra ( PORT , port ) ;
thisActivity . setResult ( RESULT_OK , intent ) ;
thisActivity . finish ( ) ;
}
} ) ;
}
}
package es . mrjon . androidmpd ;
public class Constants {
public static final String LOG_TAG = " ;
}
package es . mrjon . androidmpd ;
public interface StatusDisplay {
public void display ( String status ) ;
}
package es . mrjon . androidmpd ;
import android . os . AsyncTask ;
import android . util . Log ;
import org . bff . javampd . MPD ;
import org . bff . javampd . exception . MPDException ;
import org . bff . javampd . objects . MPDSong ;
public class PlaySongTask extends AsyncTask < MPDSongListItem , Void , MPDSongListItem > {
private final MPD mpd ;
private final StatusDisplay status ;
public PlaySongTask ( MPD mpd , StatusDisplay status ) {
if ( mpd == null ) { throw new IllegalArgumentException ( " ) ; }
if ( status == null ) { throw new IllegalArgumentException ( " ) ; }
this . mpd = mpd ;
this . status = status ;
}
public MPDSongListItem doInBackground ( MPDSongListItem . . . songs ) {
if ( songs == null || songs . length == <num> || songs [ <num> ] == null ) {
Log . e ( Constants . LOG_TAG , " ) ;
} else {
try {
mpd . getMPDPlayer ( ) . <unk> ( songs [ <num> ] . getSong ( ) ) ;
return songs [ <num> ] ;
} catch ( MPDException e ) {
Log . e ( Constants . LOG_TAG , " , e ) ;
}
}
return null ;
}
public void onPostExecute ( MPDSongListItem playedSong ) {
if ( playedSong != null ) {
status . display ( " + playedSong ) ;
} else {
status . display ( " ) ;
}
}
}
package es . mrjon . androidmpd ;
import android . content . Context ;
import android . os . AsyncTask ;
import android . util . Log ;
import android . widget . ArrayAdapter ;
import android . widget . ListView ;
import android . widget . TextView ;
import java . util . ArrayList ;
import java . util . List ;
import org . bff . javampd . MPD ;
import org . bff . javampd . exception . MPDException ;
import org . bff . javampd . objects . MPDSong ;
public class UpdatePlaylistTask extends AsyncTask < Void , Void , List < MPDSongListItem > > {
private final Context context ;
private final MPD mpd ;
private final StatusDisplay status ;
private final ListView playListView ;
public UpdatePlaylistTask (
Context context , MPD mpd , StatusDisplay status , ListView playListView ) {
if ( context == null ) { throw new IllegalArgumentException ( " ) ; }
if ( mpd == null ) { throw new IllegalArgumentException ( " ) ; }
if ( status == null ) { throw new IllegalArgumentException ( " ) ; }
if ( playListView == null ) { throw new IllegalArgumentException ( " ) ; }
this . context = context ;
this . mpd = mpd ;
this . status = status ;
this . playListView = playListView ;
}
public List < MPDSongListItem > doInBackground ( Void . . . ignored ) {
if ( ! mpd . isConnected ( ) ) { return null ; }
List < MPDSongListItem > playList = new ArrayList < MPDSongListItem > ( ) ;
for ( MPDSong song : mpd . getMPDPlaylist ( ) . <unk> ( ) ) {
String rowContents =
String . format ( " , song . getArtist ( ) , song . getTitle ( ) ) ;
playList . add ( new MPDSongListItem ( song ) ) ;
Log . v ( Constants . LOG_TAG , " + rowContents ) ;
}
return playList ;
}
public void onPostExecute ( List < MPDSongListItem > playList ) {
if ( playList == null ) {
status . display ( " ) ;
} else {
status . display ( " ) ;
playListView . setAdapter (
new PlayListAdapter ( context , playList ) ) ;
}
}
}
package es . mrjon . androidmpd ;
import android . app . Activity ;
import android . content . Context ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . os . Bundle ;
import android . speech . RecognizerIntent ;
import android . util . Log ;
import android . view . KeyEvent ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . ArrayAdapter ;
import android . widget . Button ;
import android . widget . ListView ;
import android . widget . TextView ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import org . bff . javampd . MPD ;
import org . bff . javampd . MPDPlayer ;
import org . bff . javampd . exception . MPDException ;
import org . bff . javampd . objects . MPDSong ;
import java . net . UnknownHostException ;
import java . util . ArrayList ;
import java . util . List ;
public class <unk> extends Activity {
private MPD mpd ;
private static final int RECOGNIZER_REQUEST_CODE = <num> ;
private static final int SELECT_SERVER_CODE = <num> ;
private static final String HOSTNAME_PREFERENCE = " ;
private static final String PORT_PREFERENCE = " ;
private ListView playListView ;
private StatusDisplay status ;
private MetadataCache metadataCache ;
private String DEFAULT_HOSTNAME = " ;
private int DEFAULT_PORT = <num> ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
TextView statusTextView = ( TextView ) findViewById ( R . id . status_text ) ;
status = new TextViewStatusDisplay ( statusTextView ) ;
playListView = ( ListView ) findViewById ( R . id . <unk> ) ;
reconnect ( ) ;
initializeListeners ( ) ;
}
private void reconnect ( ) {
SharedPreferences preferences = getPreferences ( MODE_PRIVATE ) ;
String hostname = preferences . getString ( HOSTNAME_PREFERENCE , DEFAULT_HOSTNAME ) ;
int port = preferences . getInt ( PORT_PREFERENCE , DEFAULT_PORT ) ;
try {
if ( mpd != null && mpd . isConnected ( ) ) {
mpd . close ( ) ;
}
mpd = new MPD ( hostname , port ) ;
Log . v ( Constants . LOG_TAG , " + mpd . getVersion ( ) ) ;
Log . v ( Constants . LOG_TAG , " + mpd . getUptime ( ) ) ;
MPDPlayer . PlayerStatus playerStatus = mpd . getMPDPlayer ( ) . getStatus ( ) ;
final Button pauseButton = ( Button ) findViewById ( R . id . pause_button ) ;
if ( playerStatus == MPDPlayer . PlayerStatus . STATUS_PAUSED ||
playerStatus == MPDPlayer . PlayerStatus . STATUS_STOPPED ) {
pauseButton . setText ( " ) ;
} else {
pauseButton . setText ( " ) ;
}
metadataCache = new MetadataCache ( mpd ) ;
UpdatePlaylistTask task = new UpdatePlaylistTask (
this , mpd , status , playListView ) ;
task . execute ( ) ;
} catch ( MPDException e ) {
Log . e ( Constants . LOG_TAG , " , e ) ;
status . display ( " + e . toString ( ) ) ;
return ;
} catch ( UnknownHostException e ) {
Log . e ( Constants . LOG_TAG , " , e ) ;
status . display ( " + hostname + " + port ) ;
return ;
}
}
@Override
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) {
if ( requestCode == RECOGNIZER_REQUEST_CODE ) {
if ( resultCode == RESULT_OK ) {
handleSpeechRecognitionResult ( data ) ;
} else {
status . display ( " ) ;
}
} else if ( requestCode == SELECT_SERVER_CODE ) {
if ( resultCode == RESULT_OK ) {
handleSelectServerResult ( data ) ;
} else {
status . display ( " ) ;
}
}
super . onActivityResult ( requestCode , resultCode , data ) ;
}
private void handleSelectServerResult ( Intent data ) {
String hostname = data . getStringExtra ( SelectServerActivity . SERVER ) ;
int port = data . getIntExtra ( SelectServerActivity . PORT , DEFAULT_PORT ) ;
status . display ( " + hostname + " + port ) ;
SharedPreferences preferences = getPreferences ( MODE_PRIVATE ) ;
SharedPreferences . Editor editor = preferences . edit ( ) ;
editor . putString ( HOSTNAME_PREFERENCE , hostname ) ;
editor . putInt ( PORT_PREFERENCE , port ) ;
editor . commit ( ) ;
reconnect ( ) ;
}
private void handleSpeechRecognitionResult ( Intent data ) {
List < String > matches = data . getStringArrayListExtra (
RecognizerIntent . EXTRA_RESULTS ) ;
for ( String match : matches ) {
Log . v ( Constants . LOG_TAG , " + match ) ;
}
UpdatePlaylistTask updatePlaylist = new UpdatePlaylistTask (
this , mpd , status , playListView ) ;
SearchTask task = new SearchTask (
mpd , metadataCache , status , playListView , updatePlaylist ) ;
task . execute ( matches . toArray ( new String [ ] { } ) ) ;
}
@Override
public void onDestroy ( ) {
try {
if ( mpd != null ) {
mpd . close ( ) ;
}
} catch ( MPDException e ) {
Log . e ( Constants . LOG_TAG , " , e ) ;
}
super . onDestroy ( ) ;
}
@Override
public boolean onKeyDown ( int keyCode , KeyEvent event ) {
final int VOLUME_STEP = <num> ;
if ( keyCode == KeyEvent . KEYCODE_VOLUME_UP ) {
try {
mpd . getMPDPlayer ( ) . setVolume (
mpd . getMPDPlayer ( ) . getVolume ( ) + VOLUME_STEP ) ;
} catch ( MPDException e ) {
Log . e ( Constants . LOG_TAG , " , e ) ;
}
return true ;
} else if ( keyCode == KeyEvent . KEYCODE_VOLUME_DOWN ) {
try {
mpd . getMPDPlayer ( ) . setVolume (
mpd . getMPDPlayer ( ) . getVolume ( )  VOLUME_STEP ) ;
} catch ( MPDException e ) {
Log . e ( Constants . LOG_TAG , " , e ) ;
}
return true ;
} else {
return super . onKeyDown ( keyCode , event ) ;
}
}
@Override
public boolean onKeyUp ( int keyCode , KeyEvent event ) {
if ( keyCode == KeyEvent . KEYCODE_VOLUME_UP ||
keyCode == KeyEvent . KEYCODE_VOLUME_DOWN ) {
return true ;
}
return super . onKeyDown ( keyCode , event ) ;
}
private void initializeListeners ( ) {
final Button pauseButton = ( Button ) findViewById ( R . id . pause_button ) ;
pauseButton . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
try {
MPDPlayer . PlayerStatus status = mpd . getMPDPlayer ( ) . getStatus ( ) ;
if ( status == MPDPlayer . PlayerStatus . STATUS_PAUSED ||
status == MPDPlayer . PlayerStatus . STATUS_STOPPED ) {
mpd . getMPDPlayer ( ) . play ( ) ;
pauseButton . setText ( " ) ;
} else {
mpd . getMPDPlayer ( ) . pause ( ) ;
pauseButton . setText ( " ) ;
}
} catch ( MPDException e ) {
Log . e ( Constants . LOG_TAG , " , e ) ;
}
}
} ) ;
Button backButton = ( Button ) findViewById ( R . id . back_button ) ;
backButton . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
try {
mpd . getMPDPlayer ( ) . <unk> ( ) ;
} catch ( MPDException e ) {
Log . e ( Constants . LOG_TAG , " , e ) ;
}
}
} ) ;
Button forwardButton = ( Button ) findViewById ( R . id . <unk> ) ;
forwardButton . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
try {
mpd . getMPDPlayer ( ) . <unk> ( ) ;
} catch ( MPDException e ) {
Log . e ( Constants . LOG_TAG , " , e ) ;
}
}
} ) ;
Button searchButton = ( Button ) findViewById ( R . id . search_button ) ;
searchButton . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
Intent intent = new Intent ( RecognizerIntent . ACTION_RECOGNIZE_SPEECH ) ;
intent . putExtra ( RecognizerIntent . EXTRA_LANGUAGE_MODEL ,
RecognizerIntent . LANGUAGE_MODEL_FREE_FORM ) ;
intent . putExtra ( RecognizerIntent . EXTRA_PROMPT , " ) ;
startActivityForResult ( intent , RECOGNIZER_REQUEST_CODE ) ;
}
} ) ;
Button settingsButton = ( Button ) findViewById ( R . id . settings_button ) ;
final Context c = this ;
settingsButton . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
SharedPreferences preferences = getPreferences ( MODE_PRIVATE ) ;
String hostname = preferences . getString ( HOSTNAME_PREFERENCE , DEFAULT_HOSTNAME ) ;
int port = preferences . getInt ( PORT_PREFERENCE , DEFAULT_PORT ) ;
Intent intent = new Intent ( c , SelectServerActivity . class ) ;
intent . putExtra ( SelectServerActivity . SERVER , hostname ) ;
intent . putExtra ( SelectServerActivity . PORT , port ) ;
startActivityForResult ( intent , SELECT_SERVER_CODE ) ;
}
} ) ;
playListView . setOnItemClickListener ( new OnItemClickListener ( ) {
public void onItemClick (
AdapterView < ? > adapter , View view , int position , long id ) {
MPDSongListItem song = ( MPDSongListItem ) adapter . getItemAtPosition ( position ) ;
PlaySongTask task = new PlaySongTask ( mpd , status ) ;
task . execute ( song ) ;
}
} ) ;
}
}
package org . okiwi . pacman ;
import static org . junit . Assert . * ;
import org . junit . Test ;
public class <unk> {
@Test
public void test ( ) {
Direction direction = Direction . RIGHT ;
Coordinates newCoords = direction . move ( new Coordinates ( <num> , <num> ) ) ;
assertEquals ( <num> , newCoords . getPositionX ( ) ) ;
}
}
package org . okiwi . pacman ;
import static org . junit . Assert . * ;
import org . junit . Before ;
import org . junit . Test ;
public class <unk> {
Game game ;
@Before
public void setUp ( ) {
game = new Game ( ) ;
}
@Test
public void <unk> ( ) {
assertNull ( game . getPacman ( ) ) ;
}
@Test
public void <unk> ( ) {
game . start ( ) ;
assertTrue ( game . getPacman ( ) . isMoving ( ) ) ;
}
@Test
public void <unk> ( ) {
game . start ( ) ;
int dots = game . getRemainingDots ( ) ;
game . tick ( ) ;
assertEquals ( dots  <num> , game . getRemainingDots ( ) ) ;
}
@Test
public void <unk> ( ) {
game . start ( ) ;
int dots = game . getRemainingDots ( ) ;
game . tick ( ) ;
game . getPacman ( ) . setDirection ( Direction . LEFT ) ;
game . tick ( ) ;
assertEquals ( dots  <num> , game . getRemainingDots ( ) ) ;
}
@Test
public void <unk> ( ) {
game . start ( ) ;
int dots = game . getRemainingDots ( ) ;
game . tick ( ) ;
game . tick ( ) ;
assertEquals ( dots  <num> , game . getRemainingDots ( ) ) ;
}
}
package org . okiwi . pacman ;
public enum Direction {
UP {
@Override
Coordinates move ( int x , int y ) {
return new Coordinates ( x , y + <num> ) ;
}
} , RIGHT {
@Override
Coordinates move ( int x , int y ) {
return new Coordinates ( x + <num> , y ) ;
}
} , LEFT {
@Override
Coordinates move ( int x , int y ) {
return new Coordinates ( x  <num> , y ) ;
}
} , DOWN {
@Override
Coordinates move ( int x , int y ) {
return new Coordinates ( x , y  <num> ) ;
}
} ;
abstract Coordinates move ( int x , int y ) ;
public Coordinates move ( Coordinates coordinates ) {
return move ( coordinates . getPositionX ( ) , coordinates . getPositionY ( ) ) ;
}
}
package org . okiwi . pacman ;
public class Coordinates {
private final int positionX ;
private final int positionY ;
public Coordinates ( int positionX , int positionY ) {
this . positionX = positionX ;
this . positionY = positionY ;
}
public int getPositionX ( ) {
return positionX ;
}
public int getPositionY ( ) {
return positionY ;
}
}
package org . okiwi . pacman ;
import static org . junit . Assert . * ;
import org . hamcrest . core . Is ;
import org . hamcrest . core . IsNot ;
import org . junit . Assert ;
import org . junit . Before ;
import org . junit . Test ;
public class <unk> {
Pacman pacman ;
@Before
public void setUp ( ) {
pacman = new Pacman ( <num> , <num> ) ;
}
@Test
public void <unk> ( ) {
assertNotNull ( pacman ) ;
assertEquals ( <num> , pacman . getPositionX ( ) ) ;
assertEquals ( <num> , pacman . getPositionY ( ) ) ;
}
@Test
public void <unk> ( ) {
pacman . setDirection ( Direction . UP ) ;
assertEquals ( Direction . UP , pacman . getDirection ( ) ) ;
}
@Test
public void <unk> ( )
{
assertEquals ( Direction . RIGHT , pacman . getDirection ( ) ) ;
}
@Test
public void isMoving ( )
{
assertTrue ( pacman . isMoving ( ) ) ;
}
@Test
public void <unk> ( )
{
pacman . move ( ) ;
assertEquals ( pacman . getPositionX ( ) , <num> ) ;
}
@Test
public void <unk> ( )
{
pacman . move ( ) ;
pacman . move ( ) ;
assertEquals ( pacman . getPositionX ( ) , <num> ) ;
}
@Test
public void <unk> ( )
{
pacman . setDirection ( Direction . UP ) ;
pacman . move ( ) ;
assertEquals ( <num> , pacman . getPositionX ( ) ) ;
assertEquals ( <num> , pacman . getPositionY ( ) ) ;
}
@Test
public void <unk> ( )
{
pacman . setDirection ( Direction . DOWN ) ;
pacman . move ( ) ;
assertEquals ( <num> , pacman . getPositionX ( ) ) ;
assertEquals ( <num> , pacman . getPositionY ( ) ) ;
}
}
package org . okiwi . pacman ;
import org . okiwi . pacman . Direction ;
public class Pacman {
private Coordinates position ;
private Direction direction ;
public Pacman ( final int positionX , final int positionY ) {
this . position = new Coordinates ( positionX , positionY ) ;
this . direction = Direction . RIGHT ;
}
public int getPositionX ( ) {
return position . getPositionX ( ) ;
}
public int getPositionY ( ) {
return position . getPositionY ( ) ;
}
public void setDirection ( Direction direction ) {
this . direction = direction ;
}
public Direction getDirection ( ) {
return this . direction ;
}
public boolean isMoving ( ) {
return true ;
}
public void move ( ) {
this . position = this . getDirection ( ) . move ( position ) ;
}
}
package org . okiwi . pacman ;
public class Game {
private Pacman pacman ;
private int numberOfDots ;
private boolean grid [ ] ;
public Game ( ) {
this . numberOfDots = <num> ;
grid = new boolean [ numberOfDots ] ;
grid [ <num> ] = true ;
}
public Pacman getPacman ( ) {
return pacman ;
}
public void start ( ) {
pacman = new Pacman ( <num> , <num> ) ;
}
public int getRemainingDots ( ) {
return this . numberOfDots ;
}
public void tick ( ) {
pacman . move ( ) ;
if ( ! grid [ pacman . getPositionX ( ) ] ) {
this . numberOfDots  ;
this . grid [ pacman . getPositionX ( ) ] = true ;
}
}
}
import org . encog . ml . data . MLData ;
import org . encog . ml . data . basic . BasicMLData ;
import org . encog . neural . networks . BasicNetwork ;
import org . encog . util . arrayutil . NormalizationAction ;
import org . encog . util . arrayutil . NormalizedField ;
public class NeuralPilot {
private BasicNetwork network ;
private boolean track ;
private NormalizedField fuelStats ;
private NormalizedField altitudeStats ;
private NormalizedField velocityStats ;
public NeuralPilot ( BasicNetwork network , boolean track )
{
fuelStats = new NormalizedField ( NormalizationAction . Normalize , " , <num> , <num> ,  <num> , <num> ) ;
altitudeStats = new NormalizedField ( NormalizationAction . Normalize , " , <num> , <num> ,  <num> , <num> ) ;
velocityStats = new NormalizedField ( NormalizationAction . Normalize , " , LanderSimulator . TERMINAL_VELOCITY ,  LanderSimulator . TERMINAL_VELOCITY ,  <num> , <num> ) ;
this . track = track ;
this . network = network ;
}
public int <unk> ( )
{
LanderSimulator sim = new LanderSimulator ( ) ;
while ( sim . flying ( ) )
{
MLData input = new BasicMLData ( <num> ) ;
input . setData ( <num> , this . fuelStats . normalize ( sim . getFuel ( ) ) ) ;
input . setData ( <num> , this . fuelStats . normalize ( sim . getAltitude ( ) ) ) ;
input . setData ( <num> , this . fuelStats . normalize ( sim . getVelocity ( ) ) ) ;
MLData output = this . network . compute ( input ) ;
double value = output . getData ( <num> ) ;
boolean thrust ;
if ( value > <num> )
{
thrust = true ;
if ( track )
System . out . println ( " ) ;
}
else
thrust = false ;
sim . turn ( thrust ) ;
if ( track )
System . out . println ( sim . telemetry ( ) ) ;
}
return ( sim . score ( ) ) ;
}
}
import java . text . NumberFormat ;
public class LanderSimulator {
public static final double GRAVITY = <num> ;
public static final double THRUST = <num> ;
public static final double TERMINAL_VELOCITY = <num> ;
private int fuel ;
private int seconds ;
private double altitude ;
private double velocity ;
public LanderSimulator ( ) {
this . fuel = <num> ;
this . seconds = <num> ;
this . altitude = <num> ;
this . velocity = <num> ;
}
public void turn ( boolean thrust ) {
this . seconds ++ ;
this . velocity -= GRAVITY ;
this . altitude += this . velocity ;
if ( thrust && this . fuel > <num> ) {
this . fuel  ;
this . velocity += THRUST ;
}
this . velocity = Math . max (  TERMINAL_VELOCITY , this . velocity ) ;
this . velocity = Math . min ( TERMINAL_VELOCITY , this . velocity ) ;
if ( this . altitude < <num> )
this . altitude = <num> ;
}
public String telemetry ( ) {
NumberFormat nf = NumberFormat . getNumberInstance ( ) ;
nf . setMinimumFractionDigits ( <num> ) ;
nf . setMaximumFractionDigits ( <num> ) ;
StringBuilder result = new StringBuilder ( ) ;
result . append ( " ) ;
result . append ( seconds ) ;
result . append ( " ) ;
result . append ( this . fuel ) ;
result . append ( " ) ;
result . append ( nf . format ( velocity ) ) ;
result . append ( " ) ;
result . append ( ( int ) altitude ) ;
result . append ( " ) ;
return result . toString ( ) ;
}
public int score ( ) {
return ( int ) ( ( this . fuel * <num> ) + this . seconds + ( this . velocity * <num> ) ) ;
}
public int getFuel ( ) {
return fuel ;
}
public int getSeconds ( ) {
return seconds ;
}
public double getAltitude ( ) {
return altitude ;
}
public double getVelocity ( ) {
return velocity ;
}
public boolean flying ( ) {
return ( this . altitude > <num> ) ;
}
}
import org . encog . engine . network . activation . ActivationStep ;
import org . encog . ml . data . MLDataSet ;
import org . encog . ml . data . basic . BasicMLDataSet ;
import org . encog . neural . neat . NEATNetwork ;
import org . encog . neural . neat . NEATPopulation ;
import org . encog . neural . neat . training . NEATTraining ;
import org . encog . neural . networks . training . CalculateScore ;
import org . encog . neural . networks . training . TrainingSetScore ;
import org . encog . util . simple . EncogUtility ;
public class <unk> {
public static double XOR_INPUT [ ] [ ] = { { <num> , <num> } , { <num> , <num> } ,
{ <num> , <num> } , { <num> , <num> } } ;
public static double XOR_IDEAL [ ] [ ] = { { <num> } , { <num> } , { <num> } , { <num> } } ;
public static void main ( final String args [ ] ) {
MLDataSet trainingSet = new BasicMLDataSet ( XOR_INPUT , XOR_IDEAL ) ;
NEATPopulation pop = new NEATPopulation ( <num> , <num> , <num> ) ;
CalculateScore score = new TrainingSetScore ( trainingSet ) ;
ActivationStep step = new ActivationStep ( ) ;
step . setCenter ( <num> ) ;
pop . <unk> ( step ) ;
final NEATTraining train = new NEATTraining ( score , pop ) ;
EncogUtility . <unk> ( train , <num> ) ;
NEATNetwork network = ( NEATNetwork ) train . getMethod ( ) ;
System . out . println ( " ) ;
EncogUtility . evaluate ( network , trainingSet ) ;
}
}
import java . text . NumberFormat ;
import org . encog . ml . data . MLData ;
import org . encog . ml . data . MLDataSet ;
import org . encog . ml . data . basic . BasicMLData ;
import org . encog . ml . svm . SVM ;
import org . encog . ml . svm . training . SVMTrain ;
import org . encog . util . EngineArray ;
import org . encog . util . arrayutil . NormalizeArray ;
import org . encog . util . arrayutil . TemporalWindowArray ;
public class PredictSunspotSVM {
public final static double [ ] SUNSPOTS = {
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
0.3138 , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
0.3138 , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
0.0534 , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
0.0534 , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num> , <num> , <num> ,
<unk> , <num> , <num> , <num>
} ;
public final static int STARTING_YEAR = <num> ;
public final static int WINDOW_SIZE = <num> ;
public final static int <unk> = WINDOW_SIZE ;
public final static int <unk> = <num> ;
public final static int EVALUATE_START = <num> ;
public final static int EVALUATE_END = SUNSPOTS . length  <num> ;
public final static double MAX_ERROR = <num> ;
private double [ ] normalizedSunspots ;
private double [ ] closedLoopSunspots ;
public void normalizeSunspots ( double lo , double hi ) {
NormalizeArray norm = new NormalizeArray ( ) ;
norm . <unk> ( hi ) ;
norm . <unk> ( lo ) ;
normalizedSunspots = norm . process ( SUNSPOTS ) ;
double [ ] test = norm . process ( SUNSPOTS ) ;
closedLoopSunspots = EngineArray . arrayCopy ( normalizedSunspots ) ;
}
public MLDataSet generateTraining ( ) {
TemporalWindowArray temp = new TemporalWindowArray ( WINDOW_SIZE , <num> ) ;
temp . analyze ( this . normalizedSunspots ) ;
return temp . process ( this . normalizedSunspots ) ;
}
public SVM createNetwork ( )
{
SVM network = new SVM ( WINDOW_SIZE , true ) ;
return network ;
}
public void train ( SVM network , MLDataSet training )
{
final SVMTrain train = new SVMTrain ( network , training ) ;
train . iteration ( ) ;
}
public void predict ( SVM network )
{
NumberFormat f = NumberFormat . getNumberInstance ( ) ;
f . setMaximumFractionDigits ( <num> ) ;
f . setMinimumFractionDigits ( <num> ) ;
System . out . println ( " ) ;
for ( int year = EVALUATE_START ; year < EVALUATE_END ; year ++ )
{
MLData input = new BasicMLData ( WINDOW_SIZE ) ;
for ( int i = <num> ; i < input . size ( ) ; i ++ )
{
input . setData ( i , this . normalizedSunspots [ ( year  WINDOW_SIZE ) + i ] ) ;
}
MLData output = network . compute ( input ) ;
double prediction = output . getData ( <num> ) ;
this . closedLoopSunspots [ year ] = prediction ;
for ( int i = <num> ; i < input . size ( ) ; i ++ )
{
input . setData ( i , this . closedLoopSunspots [ ( year  WINDOW_SIZE ) + i ] ) ;
}
output = network . compute ( input ) ;
double closedLoopPrediction = output . getData ( <num> ) ;
System . out . println ( ( STARTING_YEAR + year )
+ " + f . format ( this . normalizedSunspots [ year ] )
+ " + f . format ( prediction )
+ " + f . format ( closedLoopPrediction )
) ;
}
}
public void run ( )
{
normalizeSunspots ( <num> , <num> ) ;
SVM network = createNetwork ( ) ;
MLDataSet training = generateTraining ( ) ;
train ( network , training ) ;
predict ( network ) ;
}
public static void main ( String args [ ] )
{
PredictSunspotSVM sunspot = new PredictSunspotSVM ( ) ;
sunspot . run ( ) ;
}
}
package net . <unk> . erik . android . <unk> ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . os . Bundle ;
import android . provider . Settings ;
public class AvionActivity extends Activity
{
@Override
public void onCreate ( Bundle savedInstanceState )
{
super . onCreate ( savedInstanceState ) ;
boolean isEnabled = ( Settings . System . getInt ( getContentResolver ( ) , Settings . System . AIRPLANE_MODE_ON , <num> ) == <num> ) ;
Settings . System . putInt ( getContentResolver ( ) , Settings . System . AIRPLANE_MODE_ON , isEnabled ? <num> : <num> ) ;
final Intent intent = new Intent ( Intent . ACTION_AIRPLANE_MODE_CHANGED ) ;
intent . putExtra ( " , ! isEnabled ) ;
sendBroadcast ( intent ) ;
final AlertDialog alertDialog = new AlertDialog . Builder ( this ) . create ( ) ;
alertDialog . setIcon ( R . drawable . ic_launcher ) ;
alertDialog . setTitle ( R . string . title ) ;
if ( isEnabled )
{
alertDialog . setMessage ( getString ( R . string . deactivated ) ) ;
}
else
{
alertDialog . setMessage ( getString ( R . string . activated ) ) ;
}
alertDialog . setButton ( getString ( R . string . ok ) , new DialogInterface . OnClickListener ( )
{
public void onClick ( DialogInterface dialog , int which )
{
AvionActivity . this . finish ( ) ;
}
} ) ;
alertDialog . show ( ) ;
}
import java . io . * ;
class <unk>
{
public static void main ( String [ ] argv )
{
board board = new board ( ) ;
board . draw ( ) ;
player player = new player ( ) ;
boolean gameRunning = true ;
int alt = <num> ;
while ( gameRunning == true ) {
boolean result = false ;
if ( alt == <num> ) {
alt = <num> ;
} else {
if ( alt == <num> ) {
alt = <num> ;
}
}
result = player . takeTurn ( alt , board ) ;
if ( result == true ) {
break ;
}
}
}
}
class player
{
inputHandler input = new inputHandler ( ) ;
public boolean takeTurn ( int player , board board ) {
boolean result = false ;
if ( player == <num> ) {
System . out . print ( " ) ;
int in = Integer . parseInt ( input . string_input ( ) ) ;
board . add_entry ( " , in  <num> ) ;
board . draw ( ) ;
result = board . check_status ( " ) ;
if ( result == true ) {
System . out . println ( " ) ;
}
}
if ( player == <num> ) {
System . out . print ( " ) ;
int in = Integer . parseInt ( input . string_input ( ) ) ;
board . add_entry ( " , in  <num> ) ;
board . draw ( ) ;
result = board . check_status ( " ) ;
if ( result == true ) {
System . out . println ( " ) ;
}
}
return result ;
}
}
class board
{
String v [ ] = { " , " , " , " , " , " , " , " , " } ;
public int draw ( )
{
System . out . println ( " ) ;
String [ ] line = {
" ,
" ,
" + v [ <num> ] + " + v [ <num> ] + " + v [ <num> ] + " ,
" ,
" ,
" + v [ <num> ] + " + v [ <num> ] + " + v [ <num> ] + " ,
" ,
" ,
" + v [ <num> ] + " + v [ <num> ] + " + v [ <num> ] + " ,
"
} ;
for ( String entry : line ) {
System . out . println ( entry ) ;
}
return <num> ;
}
public boolean check_status ( String player ) {
boolean result = false ;
int column = <num> ;
while ( column <= <num> ) {
if ( v [ column  <num> ] == player && v [ column + <num> ] == player && v [ column + <num> ] == player ) { result = true ; }
column += <num> ;
}
int increment [ ] = { <num> , <num> , <num> } ;
while ( increment [ <num> ] <= <num> ) {
if ( v [ increment [ <num> ] ] == player && v [ increment [ <num> ] ] == player && v [ increment [ <num> ] ] == player ) { result = true ; }
for ( int i = <num> ; i <= <num> ; i ++ ) {
increment [ i ] += <num> ;
}
}
if ( v [ <num> ] == player && v [ <num> ] == player && v [ <num> ] == player ) { result = true ; }
if ( v [ <num> ] == player && v [ <num> ] == player && v [ <num> ] == player ) { result = true ; }
return result ;
}
public int add_entry ( String letter , int location )
{
boolean space_open = true ;
if ( v [ location ] . equals ( " ) || v [ location ] . equals ( " ) ) {
space_open = false ;
}
if ( space_open == true ) {
v [ location ] = letter ;
}
return <num> ;
}
}
class inputHandler {
public String string_input ( ) {
String userInput ;
userInput = new String ( ) ;
try {
BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ;
userInput = in . readLine ( ) ;
} catch ( IOException e ) { }
return userInput ;
}
}
package org . fastmemclient ;
import java . util . * ;
public class MemcachedClient {
private static Vector < Server > serverList = null ;
public MemcachedClient ( ) {
if ( null == serverList ) {
serverList = new Vector < Server > ( ) ;
}
}
public void AddServer ( String ip , Integer port ) {
serverList . add ( new Server ( ip , port ) ) ;
}
private Client getClient ( String key ) {
Server server = selectServer ( key ) ;
Client client = server . selectClient ( ) ;
return client ;
}
private Server selectServer ( String key ) {
return serverList . firstElement ( ) ;
}
public void set ( String key , String value ) {
String command = " + " + key + " + <num> + " + <num> + " + value . length ( ) + " ;
String data = value + " ;
Client client = getClient ( key ) ;
client . send ( command ) ;
client . send ( data ) ;
String response = client . receive ( ) ;
System . out . println ( " + response ) ;
client . close ( ) ;
}
public String get ( String key ) {
String command = " + key + " ;
Client client = getClient ( key ) ;
client . send ( command ) ;
String firstReceiveData = client . receive ( ) ;
String secondReceiveData = client . receive ( ) ;
System . out . println ( firstReceiveData ) ;
System . out . println ( secondReceiveData ) ;
client . close ( ) ;
return secondReceiveData ;
}
public void delete ( String key ) {
String command = " + " + key + " + " ;
Client client = getClient ( key ) ;
client . send ( command ) ;
String response = client . receive ( ) ;
System . out . println ( " + response ) ;
client . close ( ) ;
}
public void cas ( String key , String value , Integer cas ) {
String command = " + " + key + " + <num> + " + <num> + " + value . length ( ) + " + cas + " + " ;
String data = value + " ;
Client client = getClient ( key ) ;
client . send ( command ) ;
client . send ( data ) ;
String response = client . receive ( ) ;
System . out . println ( " + response ) ;
client . close ( ) ;
}
public static void main ( String argv [ ] ) {
MemcachedClient client = new MemcachedClient ( ) ;
client . AddServer ( " , <num> ) ;
client . cas ( " , " , <num> ) ;
}
}
package org . fastmemclient ;
import java . util . * ;
public class Server {
private String ip ;
private Integer port ;
private Vector < Client > availableClientList ;
public Server ( String ip , Integer port ) {
this . ip = ip ;
this . port = port ;
availableClientList = new Vector < Client > ( ) ;
}
public Client selectClient ( ) {
if ( true == availableClientList . isEmpty ( ) )
{
return new Client ( ip , port , this ) ;
} else {
return availableClientList . remove ( <num> ) ;
}
}
public void addClient ( Client client ) {
availableClientList . add ( client ) ;
}
}
package org . fastmemclient ;
import java . net . * ;
import java . io . * ;
public class Client {
private Socket socket ;
private BufferedReader in ;
private PrintWriter out ;
private Server server ;
public Client ( String ip , Integer port , Server server ) {
try {
socket = new Socket ( ip , port ) ;
in = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ;
out = new PrintWriter ( socket . getOutputStream ( ) , true ) ;
this . server = server ;
} catch ( UnknownHostException e1 ) {
e1 . printStackTrace ( ) ;
} catch ( IOException e1 ) {
e1 . printStackTrace ( ) ;
}
}
public void send ( String data ) {
out . print ( data ) ;
out . flush ( ) ;
}
public String receive ( ) {
try {
return in . readLine ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
public void close ( ) {
server . addClient ( this ) ;
}
}
package com . cobusbernard . shoppa . constants ;
public class Constants {
public final static int [ ] listColors = new int [ ] { <num> , <num> } ;
}
package com . cobusbernard . shoppa . adapter ;
import java . util . List ;
import android . content . Context ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . CheckBox ;
import android . widget . LinearLayout ;
import android . widget . TextView ;
import com . cobusbernard . shoppa . R ;
import com . cobusbernard . shoppa . constants . Constants ;
import com . cobusbernard . shoppa . data . ShoppingItem ;
public class ShoppingItemListAdapter extends BaseListAdapter < ShoppingItem > {
public ShoppingItemListAdapter ( Context c , List < ShoppingItem > list ) {
super ( c , list ) ;
}
@Override
public View getView ( int position , View convertView , ViewGroup parent ) {
LinearLayout rowLayout ;
ShoppingItem item = this . list . get ( position ) ;
rowLayout = ( LinearLayout ) LayoutInflater . from ( this . context ) . inflate ( R . layout . <unk> , parent ,
false ) ;
TextView itemTextView = ( TextView ) rowLayout . findViewById ( R . id . <unk> ) ;
itemTextView . setText ( item . getName ( ) ) ;
CheckBox itemCheckBox = ( CheckBox ) rowLayout . findViewById ( R . id . <unk> ) ;
itemCheckBox . setChecked ( item . isInBasket ( ) ) ;
rowLayout . setBackgroundColor ( Constants . listColors [ position % <num> ] ) ;
return rowLayout ;
}
@Override
public long getItemId ( int position ) {
return <num> ;
}
}
package com . cobusbernard . shoppa . services ;
import java . util . List ;
import com . cobusbernard . shoppa . data . ShoppingItem ;
public interface IShoppaService {
public List < ShoppingItem > getShoppingList ( ) ;
}
package com . cobusbernard . shoppa . adapter ;
import java . util . List ;
import android . content . Context ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . BaseAdapter ;
public abstract class BaseListAdapter < T > extends BaseAdapter {
protected List < T > list ;
protected Context context ;
public BaseListAdapter ( Context context , List < T > list ) {
this . list = list ;
this . context = context ;
}
@Override
public int getCount ( ) {
return this . list . size ( ) ;
}
@Override
public Object getItem ( int position ) {
return this . list . get ( position ) ;
}
@Override
public abstract long getItemId ( int position ) ;
public void <unk> ( int id ) {
notifyDataSetChanged ( ) ;
}
@Override
public abstract View getView ( int position , View convertView , ViewGroup parent ) ;
}
package com . cobusbernard . shoppa . data ;
public class ShoppingItem implements Comparable < ShoppingItem > {
private String name ;
private boolean inBasket ;
public ShoppingItem ( String name , boolean inBasket ) {
super ( ) ;
this . name = name ;
this . inBasket = inBasket ;
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
public boolean isInBasket ( ) {
return inBasket ;
}
public void <unk> ( boolean inBasket ) {
this . inBasket = inBasket ;
}
@Override
public int compareTo ( ShoppingItem another ) {
return this . name . compareTo ( another . getName ( ) ) ;
}
}
package com . cobusbernard . shoppa . services ;
import java . util . ArrayList ;
import java . util . List ;
import com . cobusbernard . shoppa . data . ShoppingItem ;
public class ShoppaService implements IShoppaService {
@Override
public List < ShoppingItem > getShoppingList ( ) {
ArrayList < ShoppingItem > list = new ArrayList < ShoppingItem > ( ) ;
list . add ( new ShoppingItem ( " , false ) ) ;
list . add ( new ShoppingItem ( " , true ) ) ;
list . add ( new ShoppingItem ( " , false ) ) ;
list . add ( new ShoppingItem ( " , false ) ) ;
return list ;
}
}
package com . cobusbernard . shoppa ;
import java . util . ArrayList ;
import java . util . List ;
import android . app . TabActivity ;
import android . content . Context ;
import android . os . Bundle ;
import android . view . LayoutInflater ;
import android . view . MotionEvent ;
import android . view . View ;
import android . view . View . OnTouchListener ;
import android . widget . LinearLayout ;
import android . widget . LinearLayout . LayoutParams ;
import android . widget . ListView ;
import android . widget . TabHost ;
import android . widget . TextView ;
import com . cobusbernard . shoppa . adapter . ShoppingItemListAdapter ;
import com . cobusbernard . shoppa . data . ShoppingItem ;
import com . cobusbernard . shoppa . services . ShoppaService ;
public class <unk> extends TabActivity {
private TabHost tabHost ;
private ListView allListView ;
private ListView basketListView ;
private ListView shelfListView ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
init ( ) ;
setupTabs ( ) ;
initAdapters ( ) ;
}
private void init ( ) {
this . tabHost = getTabHost ( ) ;
this . allListView = ( ListView ) findViewById ( R . id . <unk> ) ;
this . basketListView = ( ListView ) findViewById ( R . id . <unk> ) ;
this . shelfListView = ( ListView ) findViewById ( R . id . <unk> ) ;
}
private void initAdapters ( ) {
this . allListView . setAdapter ( new ShoppingItemListAdapter ( this . allListView . getContext ( ) ,
getItemList ( true , true ) ) ) ;
this . basketListView . setAdapter ( new ShoppingItemListAdapter ( this . basketListView . getContext ( ) ,
getItemList ( true , false ) ) ) ;
this . shelfListView . setAdapter ( new ShoppingItemListAdapter ( this . shelfListView . getContext ( ) ,
getItemList ( false , false ) ) ) ;
}
private void setupTabs ( ) {
this . tabHost . addTab ( this . tabHost . newTabSpec ( " )
. setIndicator ( getString ( R . string . <unk> ) )
. setContent ( R . id . <unk> ) ) ;
this . tabHost . addTab ( this . tabHost . newTabSpec ( " )
. setIndicator ( getString ( R . string . <unk> ) )
. setContent ( R . id . <unk> ) ) ;
this . tabHost . addTab ( this . tabHost . newTabSpec ( " )
. setIndicator ( getString ( R . string . <unk> ) )
. setContent ( R . id . <unk> ) ) ;
this . tabHost . setCurrentTab ( <num> ) ;
}
public static LinearLayout <unk> ( Context context , String label ) {
LayoutInflater li = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ;
final LinearLayout ll = ( LinearLayout ) li . inflate ( R . layout . <unk> , null ) ;
LayoutParams layoutParams = new LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT , label . length ( ) + <num> ) ;
ll . setLayoutParams ( layoutParams ) ;
final TextView tv = ( TextView ) ll . findViewById ( R . id . <unk> ) ;
tv . setOnTouchListener ( new OnTouchListener ( ) {
public boolean onTouch ( View v , MotionEvent event ) {
ll . onTouchEvent ( event ) ;
return false ;
}
} ) ;
tv . setText ( label ) ;
return ll ;
}
private List < ShoppingItem > getItemList ( boolean includeInBasket , boolean includeAll ) {
List < ShoppingItem > list = new ArrayList < ShoppingItem > ( ) ;
for ( ShoppingItem item : ( new ShoppaService ( ) ) . getShoppingList ( ) ) {
if ( ( item . isInBasket ( ) == includeInBasket ) || includeAll ) {
list . add ( item ) ;
}
}
return list ;
}
package com . redhat . engineering . jenkins . custom . matrix ;
import hudson . model . ParameterValue ;
import hudson . model . ParametersAction ;
import hudson . model . Run ;
import hudson . model . StringParameterValue ;
import java . util . List ;
public abstract class Util {
public static ParameterValue <unk> ( List < ParameterValue > pvs , String key ) {
for ( ParameterValue pv : pvs ) {
if ( pv . getName ( ) . equals ( key ) ) {
return pv ;
}
}
return null ;
}
}
package com . redhat . engineering . jenkins . custom . matrix ;
import hudson . matrix . * ;
import hudson . model . * ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . logging . Logger ;
import javax . servlet . ServletException ;
import org . jfree . util . Log ;
import org . kohsuke . stapler . StaplerRequest ;
import org . kohsuke . stapler . StaplerResponse ;
public class CustomMatrixProjectAction implements Action {
private MatrixProject project ;
private CustomMatrixState state ;
private ConfigurationFilteringMethod confFilteringMethod ;
private static final Logger logger = Logger . getLogger ( CustomMatrixProjectAction . class . getName ( ) ) ;
private String combinationFilter ;
enum BuildType {
MATRIXBUILD , <unk> , MATRIXPROJECT , UNKNOWN
}
enum ConfigurationFilteringMethod {
MATRIX , COMBINATIONFILTER
}
public CustomMatrixProjectAction ( MatrixProject project ) {
if ( project == null ) {
throw new IllegalArgumentException ( " ) ;
}
this . project = project ;
state = CustomMatrixState . getInstance ( ) ;
state . addProject ( project . toString ( ) , project . getAxes ( ) ) ;
confFilteringMethod = ConfigurationFilteringMethod . MATRIX ;
}
public String getDisplayName ( ) {
return Definitions . __DISPLAY_NAME ;
}
public String getIconFileName ( ) {
return Definitions . __ICON_FILE_NAME ;
}
public String getUrlName ( ) {
return Definitions . __URL_NAME ;
}
public MatrixProject getProject ( ) {
return project ;
}
public boolean isCombinationChecked ( Combination c ) {
return CustomMatrixState . getInstance ( ) . isCombinationChecked ( project . toString ( ) , c ) ;
}
private void setAllCheckedFalse ( ) {
CustomMatrixState . getInstance ( ) . setAllCheckedFalse ( project . toString ( ) ) ;
}
public boolean combinationExists ( MatrixProject mp , Combination c ) {
MatrixConfiguration mc = mp . getItem ( c ) ;
if ( mc == null || ! mc . <unk> ( ) ) {
return false ;
}
return true ;
}
public boolean combinationExists ( AbstractBuild < ? , ? > build , Combination c )
{
MatrixProject mp = null ;
if ( build instanceof MatrixBuild ) {
mp = ( MatrixProject ) build . getProject ( ) ;
} else if ( build instanceof MatrixRun ) {
mp = ( ( MatrixRun ) build ) . <unk> ( ) . getProject ( ) ;
} else {
Log . warn ( " ) ;
return false ;
}
return combinationExists ( mp , c ) ;
}
public void doConfigSubmit ( StaplerRequest req , StaplerResponse rsp ) throws ServletException ,
IOException , InterruptedException {
AbstractBuild < ? , ? > build = req . <unk> ( AbstractBuild . class ) ;
BuildType type ;
if ( build != null ) {
type = BuildType . MATRIXBUILD ;
} else if ( req . <unk> ( MatrixProject . class ) != null ) {
type = BuildType . MATRIXPROJECT ;
} else {
type = BuildType . UNKNOWN ;
}
List < ParameterValue > values = new ArrayList < ParameterValue > ( ) ;
confFilteringMethod = ConfigurationFilteringMethod . valueOf ( req . getParameter ( " ) ) ;
if ( confFilteringMethod == ConfigurationFilteringMethod . COMBINATIONFILTER ) {
combinationFilter = req . getParameter ( " ) ;
state . addCombinationFilter ( project . toString ( ) , combinationFilter ) ;
} else {
state . removeCombinationFilter ( project . toString ( ) ) ;
String input ;
for ( MatrixConfiguration conf : project . <unk> ( ) ) {
Combination cb = conf . getCombination ( ) ;
input = req . getParameter ( cb . toString ( ) ) ;
if ( input != null ) {
state . setCombinationChecked ( project . toString ( ) , cb , true ) ;
}
}
}
if ( build != null ) {
ParametersAction actions = build . getAction ( ParametersAction . class ) ;
if ( actions != null ) {
List < ParameterValue > list = actions . getParameters ( ) ;
for ( ParameterValue pv : list ) {
if ( ! pv . getName ( ) . equals ( Definitions . __UUID ) ) {
values . add ( pv ) ;
}
}
}
}
Hudson . getInstance ( ) . getQueue ( )
. schedule ( project , <num> , new ParametersAction ( values ) ,
new <unk> ( new Cause . UserCause ( ) ) ) ;
if ( type . equals ( BuildType . MATRIXBUILD ) ) {
rsp . sendRedirect ( " ) ;
} else {
rsp . sendRedirect ( " ) ;
}
}
public boolean getMatrixChecked ( ) {
if ( confFilteringMethod == ConfigurationFilteringMethod . MATRIX ) {
return true ;
}
return false ;
}
public boolean getCombinationFilterChecked ( ) {
if ( confFilteringMethod == ConfigurationFilteringMethod . COMBINATIONFILTER ) {
return true ;
}
return false ;
}
public String getCombinationFilter ( ) {
return combinationFilter ;
}
public String getAxes ( ) {
return project . getAxes ( ) . toString ( ) ;
}
}
package com . redhat . engineering . jenkins . custom . matrix ;
import com . redhat . engineering . jenkins . custom . matrix . Definitions ;
import hudson . matrix . Axis ;
import hudson . matrix . AxisList ;
import hudson . matrix . Combination ;
import hudson . matrix . MatrixBuild ;
import hudson . matrix . MatrixProject ;
import hudson . model . AbstractBuild ;
import hudson . model . Cause ;
import hudson . model . FreeStyleProject ;
import hudson . model . <unk> ;
import hudson . model . ParameterValue ;
import hudson . model . ParameterDefinition ;
import hudson . model . ParametersAction ;
import hudson . model . ParametersDefinitionProperty ;
import hudson . model . StringParameterDefinition ;
import hudson . model . StringParameterValue ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
import java . util . concurrent . ExecutionException ;
import com . redhat . engineering . jenkins . custom . matrix . CustomMatrixProjectAction ;
import com . redhat . engineering . jenkins . custom . matrix . CustomMatrixProjectAction . BuildType ;
import net . sf . json . JSONObject ;
import org . jvnet . hudson . test . HudsonTestCase ;
public class <unk> extends HudsonTestCase {
public void <unk> ( ) throws IOException {
init ( ) ;
MatrixProject mp = createMatrixProject ( " ) ;
CustomMatrixProjectAction mra = new CustomMatrixProjectAction ( mp ) ;
assertEquals ( mra . getDisplayName ( ) , Definitions . __DISPLAY_NAME ) ;
}
public void <unk> ( ) throws IOException {
init ( ) ;
MatrixProject mp = createMatrixProject ( " ) ;
CustomMatrixProjectAction mra = new CustomMatrixProjectAction ( mp ) ;
assertEquals ( mra . getIconFileName ( ) , Definitions . __ICON_FILE_NAME ) ;
}
public void <unk> ( ) throws IOException {
init ( ) ;
MatrixProject mp = createMatrixProject ( " ) ;
CustomMatrixProjectAction mra = new CustomMatrixProjectAction ( mp ) ;
assertEquals ( mra . getUrlName ( ) , Definitions . __URL_NAME ) ;
}
public void <unk> ( ) {
BuildType bt = BuildType . MATRIXBUILD ;
}
public void <unk> ( ) throws InterruptedException , ExecutionException , IOException {
init ( ) ;
MatrixProject mp = createMatrixProject ( " ) ;
mp . setAxes ( axes ) ;
List < ParameterDefinition > list = new ArrayList < ParameterDefinition > ( ) ;
list . add ( new StringParameterDefinition ( " , " ) ) ;
ParametersDefinitionProperty pdp = new ParametersDefinitionProperty ( list ) ;
mp . addProperty ( pdp ) ;
List < ParameterValue > values = new ArrayList < ParameterValue > ( ) ;
values . add ( new StringParameterValue ( " , " ) ) ;
MatrixBuild mb = mp . scheduleBuild2 ( <num> , new Cause . UserCause ( ) , new ParametersAction ( values ) ) . get ( ) ;
CustomMatrixProjectAction mra = new CustomMatrixProjectAction ( mp ) ;
assertTrue ( mra . combinationExists ( mb , c_good ) ) ;
}
public void <unk> ( ) throws InterruptedException , ExecutionException , IOException {
init ( ) ;
MatrixProject mp = createMatrixProject ( " ) ;
mp . setAxes ( axes ) ;
List < ParameterDefinition > list = new ArrayList < ParameterDefinition > ( ) ;
list . add ( new StringParameterDefinition ( " , " ) ) ;
ParametersDefinitionProperty pdp = new ParametersDefinitionProperty ( list ) ;
mp . addProperty ( pdp ) ;
List < ParameterValue > values = new ArrayList < ParameterValue > ( ) ;
values . add ( new StringParameterValue ( " , " ) ) ;
MatrixBuild mb = mp . scheduleBuild2 ( <num> , new Cause . UserCause ( ) , new ParametersAction ( values ) ) . get ( ) ;
CustomMatrixProjectAction mra = new CustomMatrixProjectAction ( mp ) ;
assertFalse ( mra . combinationExists ( mb , c_bad ) ) ;
}
private AxisList axes = null ;
private Combination c_good = null ;
private Combination c_bad = null ;
public void init ( ) {
axes = new AxisList ( new Axis ( " , " , " ) , new Axis ( " , " , " ) ) ;
Map < String , String > r = new HashMap < String , String > ( ) ;
r . put ( " , " ) ;
r . put ( " , " ) ;
c_good = new Combination ( r ) ;
Map < String , String > r2 = new HashMap < String , String > ( ) ;
r2 . put ( " , " ) ;
r2 . put ( " , " ) ;
c_bad = new Combination ( r2 ) ;
}
}
package com . redhat . engineering . jenkins . custom . matrix ;
import hudson . matrix . Combination ;
import hudson . matrix . MatrixBuild ;
import hudson . matrix . MatrixProject ;
import hudson . model . AbstractBuild ;
import hudson . model . Action ;
import hudson . model . Actionable ;
import java . io . IOException ;
import javax . servlet . ServletException ;
import org . kohsuke . stapler . StaplerRequest ;
import org . kohsuke . stapler . StaplerResponse ;
public class CustomMatrixBuildAction implements Action {
private MatrixBuild build ;
private CustomMatrixProjectAction projectAction ;
public CustomMatrixBuildAction ( MatrixBuild build , CustomMatrixProjectAction projectAction ) {
this . build = build ;
this . projectAction = projectAction ;
}
public String getIconFileName ( ) {
return projectAction . getIconFileName ( ) ;
}
public String getDisplayName ( ) {
return projectAction . getDisplayName ( ) ;
}
public String getUrlName ( ) {
return projectAction . getUrlName ( ) ;
}
public MatrixBuild getBuild ( ) {
return build ;
}
public boolean isCombinationChecked ( Combination c ) {
return projectAction . isCombinationChecked ( c ) ;
}
public boolean combinationExists ( MatrixProject mp , Combination c ) {
return projectAction . combinationExists ( build , c ) ;
}
public boolean combinationExists ( AbstractBuild < ? , ? > build , Combination c ) {
return projectAction . combinationExists ( build , c ) ;
}
public void doConfigSubmit ( StaplerRequest req , StaplerResponse rsp ) throws ServletException ,
IOException , InterruptedException {
projectAction . doConfigSubmit ( req , rsp ) ;
}
public boolean getMatrixChecked ( ) {
return projectAction . getMatrixChecked ( ) ;
}
public boolean getCombinationFilterChecked ( ) {
return projectAction . getCombinationFilterChecked ( ) ;
}
public String getCombinationFilter ( ) {
return projectAction . getCombinationFilter ( ) ;
}
public String getAxes ( ) {
return projectAction . getAxes ( ) ;
}
}
package com . redhat . engineering . jenkins . custom . matrix ;
import hudson . Extension ;
import hudson . matrix . MatrixProject ;
import hudson . model . AbstractProject ;
import hudson . model . Action ;
import hudson . model . TransientProjectActionFactory ;
import java . util . ArrayList ;
import java . util . Collection ;
import java . util . List ;
@Extension
public class <unk> extends TransientProjectActionFactory {
@Override
public Collection < ? extends Action > <unk> ( AbstractProject ap ) {
ArrayList < Action > actions = new ArrayList < Action > ( ) ;
if ( ap instanceof MatrixProject ) {
CustomMatrixProjectAction newAction = new CustomMatrixProjectAction ( ( MatrixProject ) ap ) ;
actions . add ( newAction ) ;
}
return actions ;
}
package com . redhat . engineering . jenkins . custom . matrix ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
import java . util . concurrent . ExecutionException ;
import hudson . matrix . Axis ;
import hudson . matrix . AxisList ;
import hudson . matrix . Combination ;
import hudson . matrix . MatrixRun ;
import hudson . matrix . MatrixBuild ;
import hudson . matrix . MatrixProject ;
import hudson . model . ParameterValue ;
import hudson . model . Result ;
import com . redhat . engineering . jenkins . custom . matrix . CustomMatrixState ;
import org . junit . BeforeClass ;
import org . jvnet . hudson . test . HudsonTestCase ;
public class <unk> extends HudsonTestCase {
private AxisList axes = null ;
private Combination c = null ;
@BeforeClass
public void init ( ) {
axes = new AxisList ( new Axis ( " , " , " , " ) , new Axis ( " , " , " , " ) ) ;
Map < String , String > r = new HashMap < String , String > ( ) ;
r . put ( " , " ) ;
r . put ( " , " ) ;
c = new Combination ( r ) ;
}
public void <unk> ( ) throws IOException , InterruptedException , ExecutionException {
init ( ) ;
}
public void testReloaded ( ) throws IOException , InterruptedException , ExecutionException {
init ( ) ;
MatrixProject mp = createMatrixProject ( " ) ;
mp . setAxes ( axes ) ;
List < ParameterValue > values = new ArrayList < ParameterValue > ( ) ;
MatrixBuild mb = mp . scheduleBuild2 ( <num> ) . get ( ) ;
MatrixRun mr = mb . getRun ( c ) ;
Result r = mr . getResult ( ) ;
assertNotNull ( mb ) ;
}
public void <unk> ( ) throws IOException , InterruptedException , ExecutionException {
init ( ) ;
MatrixProject mp = createMatrixProject ( " ) ;
mp . setAxes ( axes ) ;
MatrixBuild mb = mp . scheduleBuild2 ( <num> ) . get ( ) ;
MatrixRun mr = mb . getRun ( c ) ;
Result r = mr . getResult ( ) ;
assertNotNull ( mb ) ;
}
}
package com . redhat . engineering . jenkins . custom . matrix ;
import hudson . Extension ;
import hudson . matrix . MatrixBuild ;
import hudson . matrix . MatrixProject ;
import hudson . model . Run ;
import hudson . model . TaskListener ;
import hudson . model . listeners . RunListener ;
import java . util . List ;
@Extension
public class CustomMatrixListener extends RunListener < Run > {
public CustomMatrixListener ( ) {
super ( Run . class ) ;
}
@Override
public void onCompleted ( Run run , TaskListener listener ) {
if ( run instanceof MatrixBuild ) {
MatrixBuild build = ( MatrixBuild ) run ;
List < CustomMatrixProjectAction > list = build . getParent ( ) . getActions ( CustomMatrixProjectAction . class ) ;
if ( list . isEmpty ( ) ) {
MatrixProject mp = build . getParent ( ) ;
mp . getActions ( ) . add ( new CustomMatrixProjectAction ( mp ) ) ;
}
CustomMatrixBuildAction action = new CustomMatrixBuildAction ( build , list . get ( <num> ) ) ;
build . getActions ( ) . add ( action ) ;
}
}
}
package com . redhat . engineering . jenkins . custom . matrix ;
import hudson . matrix . AxisList ;
import hudson . matrix . Combination ;
import java . util . HashMap ;
import java . util . Iterator ;
import java . util . Map ;
import java . util . Set ;
public class CustomMatrixState {
private Map < String , Map < Combination , Boolean >> projectCheckedCombinations ;
private Map < String , String > projectCombinationFilter ;
private Map < String , AxisList > projectAxisList ;
private static final CustomMatrixState instance = new CustomMatrixState ( ) ;
private CustomMatrixState ( ) {
projectCheckedCombinations = new HashMap < String , Map < Combination , Boolean >> ( ) ;
projectCombinationFilter = new HashMap < String , String > ( ) ;
projectAxisList = new HashMap < String , AxisList > ( ) ;
}
public static CustomMatrixState getInstance ( ) {
return instance ;
}
public boolean isCombinationChecked ( String project , Combination combination ) {
if ( projectCheckedCombinations . containsKey ( project ) && projectCheckedCombinations . get ( project ) . containsKey ( combination ) ) {
return projectCheckedCombinations . get ( project ) . get ( combination ) ;
}
return true ;
}
public void setAllCheckedFalse ( String project ) {
if ( projectCheckedCombinations . containsKey ( project ) ) {
for ( Combination combination : projectCheckedCombinations . get ( project ) . keySet ( ) ) {
projectCheckedCombinations . get ( project ) . put ( combination , false ) ;
}
}
}
public void <unk> ( String project ) {
if ( projectCheckedCombinations . containsKey ( project ) ) {
for ( Combination combination : projectCheckedCombinations . get ( project ) . keySet ( ) ) {
projectCheckedCombinations . get ( project ) . put ( combination , true ) ;
}
}
}
public void setCombinationChecked ( String project , Combination combination , boolean b ) {
if ( projectCheckedCombinations . get ( project ) != null ) {
projectCheckedCombinations . get ( project ) . put ( combination , b ) ;
} else {
Map < Combination , Boolean > temp = new HashMap < Combination , Boolean > ( ) ;
projectCheckedCombinations . put ( project , temp ) ;
projectCheckedCombinations . get ( project ) . put ( combination , b ) ;
}
}
public boolean <unk> ( String project ) {
if ( projectCheckedCombinations . containsKey ( project ) ) {
return true ;
}
return false ;
}
public void addProject ( String project , AxisList list ) {
if ( ! projectCheckedCombinations . containsKey ( project ) ) {
Map < Combination , Boolean > temp = new HashMap < Combination , Boolean > ( ) ;
projectCheckedCombinations . put ( project , temp ) ;
for ( Combination c : list . list ( ) ) {
projectCheckedCombinations . get ( project ) . put ( c , true ) ;
}
projectAxisList . put ( project , list ) ;
}
}
public void addCombinationFilter ( String project , String combinationFilter ) {
projectCombinationFilter . put ( project , combinationFilter ) ;
rebuildConfiguration ( project ) ;
}
public void removeCombinationFilter ( String project ) {
if ( projectCombinationFilter . containsKey ( project ) &&
projectCombinationFilter . get ( project ) != null ) {
projectCombinationFilter . remove ( project ) ;
}
setAllCheckedFalse ( project ) ;
}
private void rebuildConfiguration ( String project ) {
for ( Combination combination : projectCheckedCombinations . get ( project ) . keySet ( ) ) {
if ( projectCombinationFilter . get ( project ) != null &&
combination . <unk> ( projectAxisList . get ( project ) , projectCombinationFilter . get ( project ) ) ) {
projectCheckedCombinations . get ( project ) . put ( combination , true ) ;
} else {
projectCheckedCombinations . get ( project ) . put ( combination , false ) ;
}
}
}
}
package com . redhat . engineering . jenkins . custom . matrix ;
import hudson . matrix . Axis ;
import hudson . matrix . AxisList ;
import hudson . matrix . Combination ;
import hudson . matrix . MatrixBuild ;
import hudson . matrix . MatrixProject ;
import hudson . matrix . MatrixRun ;
import hudson . model . ParameterValue ;
import hudson . model . Result ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
import java . util . concurrent . ExecutionException ;
import org . junit . BeforeClass ;
import org . jvnet . hudson . test . HudsonTestCase ;
public class <unk> extends HudsonTestCase {
private AxisList axes = null ;
private Combination c = null ;
@BeforeClass
public void init ( ) {
axes = new AxisList ( new Axis ( " , " , " , " ) , new Axis ( " , " , " , " ) ) ;
Map < String , String > r = new HashMap < String , String > ( ) ;
r . put ( " , " ) ;
r . put ( " , " ) ;
c = new Combination ( r ) ;
}
public void testReloaded ( ) throws IOException , InterruptedException , ExecutionException {
init ( ) ;
MatrixProject mp = createMatrixProject ( " ) ;
mp . setAxes ( axes ) ;
List < ParameterValue > values = new ArrayList < ParameterValue > ( ) ;
MatrixBuild mb = mp . scheduleBuild2 ( <num> ) . get ( ) ;
MatrixRun mr = mb . getRun ( c ) ;
Result r = mr . getResult ( ) ;
assertNotNull ( mb ) ;
}
}
package com . redhat . engineering . jenkins . custom . matrix ;
public abstract class Definitions
{
public static final String <unk> = " ;
public static final String <unk> = " ;
public static final String __UUID = " ;
public static final String <unk> = " ;
public static final String __DISPLAY_NAME = " ;
public static final String __ICON_FILE_NAME = " ;
public static final String __URL_NAME = " ;
}
package com . redhat . engineering . jenkins . custom . matrix ;
import hudson . Extension ;
import hudson . matrix . MatrixBuild ;
import hudson . matrix . MatrixConfiguration ;
import hudson . matrix . listeners . MatrixBuildListener ;
@Extension
public class <unk> extends MatrixBuildListener {
public boolean <unk> ( MatrixBuild b , MatrixConfiguration c ) {
return CustomMatrixState . getInstance ( ) . isCombinationChecked ( b . getParent ( ) . toString ( ) , c . getCombination ( ) ) ;
}
}
import java . util . concurrent . atomic . AtomicInteger ;
public class MinesweeperThread extends Thread {
final Board board ;
final AtomicInteger [ ] cell_color_array ;
final int screen_width ,
screen_height ,
board_width ,
board_height ,
mines ;
public MinesweeperThread ( int board_width , int board_height , int screen_width , int screen_height , int mines , AtomicInteger [ ] cell_color_array ) {
this . board_width = board_width ;
this . board_height = board_height ;
this . screen_width = screen_width ;
this . screen_height = screen_height ;
this . mines = mines ;
board = new Board ( board_width , board_height , screen_width , screen_height , mines , cell_color_array ) ;
this . cell_color_array = cell_color_array ;
}
public void run ( ) {
while ( true ) {
board . new_game ( ) ;
while ( ! board . lost && ! board . won ) {
boolean made_a_move = false ;
for ( int x = <num> ; x < board . board_width ; x ++ ) {
for ( int y = <num> ; y < board . board_height ; y ++ ) {
int surrounding_flags = board . total_arround_cell ( x , y , " , true ) ;
if ( surrounding_flags == board . view_cell ( x , y ) &&
( boolean ) board . board [ x ] [ y ] . uncovered ) {
made_a_move = board . middle_click ( x , y ) || made_a_move ;
}
}
}
for ( int x = <num> ; x < board . board_width ; x ++ ) {
for ( int y = <num> ; y < board . board_height ; y ++ ) {
if ( board . view_cell ( x , y ) > <num> ) {
int surrounding_empty_spaces = board . total_arround_cell ( x , y , " , false ) ;
if ( surrounding_empty_spaces == board . view_cell ( x , y ) ) {
made_a_move = board . right_click ( x  <num> , y  <num> ) || made_a_move ;
made_a_move = board . right_click ( x  <num> , y ) || made_a_move ;
made_a_move = board . right_click ( x  <num> , y + <num> ) || made_a_move ;
made_a_move = board . right_click ( x , y + <num> ) || made_a_move ;
made_a_move = board . right_click ( x + <num> , y + <num> ) || made_a_move ;
made_a_move = board . right_click ( x + <num> , y ) || made_a_move ;
made_a_move = board . right_click ( x + <num> , y  <num> ) || made_a_move ;
made_a_move = board . right_click ( x , y  <num> ) || made_a_move ;
}
}
}
}
while ( ! made_a_move ) {
int x = ( int ) ( Math . random ( ) * board . board_width ) ;
int y = ( int ) ( Math . random ( ) * board . board_height ) ;
made_a_move = board . left_click ( x , y ) ;
}
board . won = board . check_win ( ) ;
}
}
}
}
import static java . lang . System . out ;
import java . util . concurrent . atomic . AtomicInteger ;
import processing . core . * ;
@SuppressWarnings("serial")
public class <unk> extends PApplet {
final int THREADS = <num> ;
final int MULTIPLIER = <num> ;
final int WID = <num> * MULTIPLIER ;
final int HEI = <num> * MULTIPLIER ;
final int MINES = ( int ) ( <num> * MULTIPLIER * MULTIPLIER ) ;
final double [ ] MINE_RATIOS = new double [ ] { <num> , <num> , <num> , <num> , <num> , <num> } ;
final int DIM_AMOUNT = <num> ;
MinesweeperThread [ ] threads ;
AtomicInteger [ ] cell_color_array ;
@SuppressWarnings("deprecation")
final int S_WID = screen . width ;
@SuppressWarnings("deprecation")
final int S_HEI = screen . height ;
float pixel_cell_ratio_width ;
float pixel_cell_ratio_height ;
public static void main ( String args [ ] ) {
PApplet . main ( new String [ ] { " , " , " , " } ) ;
}
public void setup ( ) {
size ( S_WID , S_HEI , P2D ) ;
frameRate ( <num> ) ;
noCursor ( ) ;
cell_color_array = new AtomicInteger [ WID * HEI ] ;
for ( int i = <num> ; i < cell_color_array . length ; i ++ ) {
cell_color_array [ i ] = new AtomicInteger ( <num> ) ;
}
threads = new MinesweeperThread [ THREADS ] ;
for ( int i = <num> ; i < threads . length ; i ++ ) {
threads [ i ] = new MinesweeperThread ( WID , HEI , S_WID , S_HEI , ( int ) ( MINES * MINE_RATIOS [ i % MINE_RATIOS . length ] ) , cell_color_array ) ;
}
for ( int i = <num> ; i < threads . length ; i ++ ) {
threads [ i ] . start ( ) ;
}
this . pixel_cell_ratio_width = ( ( float ) S_WID ) / WID ;
this . pixel_cell_ratio_height = ( ( float ) S_HEI ) / HEI ;
}
public void draw ( ) {
int current_pixel = <num> ;
int seperated_colors [ ] = new int [ <num> ] ;
if ( frameCount == <num> ) loadPixels ( ) ;
for ( int i = <num> ; i < cell_color_array . length ; i ++ ) {
int expected_CAS ;
do {
expected_CAS = cell_color_array [ i ] . get ( ) ;
current_pixel = expected_CAS ;
seperated_colors [ <num> ] = ( current_pixel & <num> ) >> <num> ;
seperated_colors [ <num> ] = ( current_pixel & <num> ) >> <num> ;
seperated_colors [ <num> ] = ( current_pixel & <num> ) >> <num> ;
for ( int color = <num> ; color < <num> ; color ++ ) {
if ( seperated_colors [ color ]  DIM_AMOUNT > <num> ) {
seperated_colors [ color ] -= DIM_AMOUNT ;
} else {
seperated_colors [ color ] = <num> ;
}
}
current_pixel = ( <num> << <num> ) | ( seperated_colors [ <num> ] << <num> ) | ( seperated_colors [ <num> ] << <num> ) | seperated_colors [ <num> ] ;
} while ( ! ( cell_color_array [ i ] . compareAndSet ( expected_CAS , current_pixel ) ) ) ;
final int px = i % WID ;
final int py = i / WID ;
final int start_x = ( int ) ( px * pixel_cell_ratio_width ) ;
final int start_y = ( int ) ( py * pixel_cell_ratio_height ) ;
final int end_x = ( int ) ( ( px + <num> ) * pixel_cell_ratio_width ) ;
final int end_y = ( int ) ( ( py + <num> ) * pixel_cell_ratio_height ) ;
for ( int iy = start_y ; iy < end_y ; iy ++ ) {
for ( int ix = start_x ; ix < end_x ; ix ++ ) {
pixels [ iy * S_WID + ix ] = current_pixel ;
}
}
}
updatePixels ( ) ;
if ( frameCount % <num> == <num> ) out . println ( frameRate ) ;
}
public void keyPressed ( ) {
}
public void mouseMoved ( ) {
}
public void mousePressed ( ) {
}
}
import static java . lang . System . out ;
import java . util . concurrent . atomic . AtomicInteger ;
import processing . core . * ;
@SuppressWarnings("serial")
public class <unk> extends PApplet {
final int THREADS = <num> ;
final int MULTIPLIER = <num> ;
final int WID = <num> * MULTIPLIER ;
final int HEI = <num> * MULTIPLIER ;
final int MINES = ( int ) ( <num> * MULTIPLIER * MULTIPLIER ) ;
final double [ ] MINE_RATIOS = new double [ ] { <num> , <num> , <num> , <num> , <num> , <num> } ;
final int DIM_AMOUNT = <num> ;
MinesweeperThread [ ] threads ;
AtomicInteger [ ] cell_color_array ;
@SuppressWarnings("deprecation")
final int S_WID = screen . width ;
@SuppressWarnings("deprecation")
final int S_HEI = screen . height ;
float pixel_cell_ratio_width ;
float pixel_cell_ratio_height ;
public static void main ( String args [ ] ) {
PApplet . main ( new String [ ] { " , " , " , " } ) ;
}
public void setup ( ) {
size ( S_WID , S_HEI , P2D ) ;
frameRate ( <num> ) ;
noCursor ( ) ;
cell_color_array = new AtomicInteger [ WID * HEI ] ;
for ( int i = <num> ; i < cell_color_array . length ; i ++ ) {
cell_color_array [ i ] = new AtomicInteger ( <num> ) ;
}
threads = new MinesweeperThread [ THREADS ] ;
for ( int i = <num> ; i < threads . length ; i ++ ) {
threads [ i ] = new MinesweeperThread ( WID , HEI , S_WID , S_HEI , ( int ) ( MINES * MINE_RATIOS [ i % MINE_RATIOS . length ] ) , cell_color_array ) ;
}
for ( int i = <num> ; i < threads . length ; i ++ ) {
threads [ i ] . start ( ) ;
}
this . pixel_cell_ratio_width = ( ( float ) S_WID ) / WID ;
this . pixel_cell_ratio_height = ( ( float ) S_HEI ) / HEI ;
}
public void draw ( ) {
int current_pixel = <num> ;
int seperated_colors [ ] = new int [ <num> ] ;
if ( frameCount == <num> ) loadPixels ( ) ;
for ( int i = <num> ; i < cell_color_array . length ; i ++ ) {
int expected_CAS ;
do {
expected_CAS = cell_color_array [ i ] . get ( ) ;
current_pixel = expected_CAS ;
seperated_colors [ <num> ] = ( current_pixel & <num> ) >> <num> ;
seperated_colors [ <num> ] = ( current_pixel & <num> ) >> <num> ;
seperated_colors [ <num> ] = ( current_pixel & <num> ) >> <num> ;
for ( int color = <num> ; color < <num> ; color ++ ) {
if ( seperated_colors [ color ]  DIM_AMOUNT > <num> ) {
seperated_colors [ color ] -= DIM_AMOUNT ;
} else {
seperated_colors [ color ] = <num> ;
}
}
current_pixel = ( <num> << <num> ) | ( seperated_colors [ <num> ] << <num> ) | ( seperated_colors [ <num> ] << <num> ) | seperated_colors [ <num> ] ;
} while ( ! ( cell_color_array [ i ] . compareAndSet ( expected_CAS , current_pixel ) ) ) ;
final int px = i % WID ;
final int py = i / WID ;
final int start_x = ( int ) ( px * pixel_cell_ratio_width ) ;
final int start_y = ( int ) ( py * pixel_cell_ratio_height ) ;
final int end_x = ( int ) ( ( px + <num> ) * pixel_cell_ratio_width ) ;
final int end_y = ( int ) ( ( py + <num> ) * pixel_cell_ratio_height ) ;
for ( int iy = start_y ; iy < end_y ; iy ++ ) {
for ( int ix = start_x ; ix < end_x ; ix ++ ) {
pixels [ iy * S_WID + ix ] = current_pixel ;
}
}
}
updatePixels ( ) ;
if ( frameCount % <num> == <num> ) out . println ( frameRate ) ;
}
public void keyPressed ( ) {
}
public void mouseMoved ( ) {
}
public void mousePressed ( ) {
}
}
public class Cell {
public boolean mine ,
flagged ,
uncovered ;
public int surrounding_mines ;
public Cell ( ) {
mine = false ;
flagged = false ;
uncovered = false ;
surrounding_mines = <num> ;
}
}
import java . util . concurrent . atomic . AtomicInteger ;
import static java . lang . System . out ;
public class Board {
public boolean won , lost ;
public Cell [ ] [ ] board ;
public final int board_width ;
public final int board_height ;
public final int screen_width ;
public final int screen_height ;
public final int mines ;
private boolean first_move ;
private AtomicInteger [ ] cell_color_array ;
public Board ( int board_width , int board_height , int screen_width , int screen_height , int mines , AtomicInteger [ ] cell_color_array ) {
this . board_width = board_width ;
this . board_height = board_height ;
this . screen_width = screen_width ;
this . screen_height = screen_height ;
this . mines = mines ;
this . cell_color_array = cell_color_array ;
}
public void new_game ( ) {
generate_board ( ) ;
}
private void generate_board ( ) {
board = new Cell [ board_width ] [ board_height ] ;
first_move = true ;
lost = false ;
won = false ;
for ( int x = <num> ; x < board_width ; x ++ ) {
for ( int y = <num> ; y < board_height ; y ++ ) {
board [ x ] [ y ] = new Cell ( ) ;
}
}
int mines_left = mines ;
while ( mines_left > <num> ) {
int x = ( int ) ( Math . random ( ) * board_width ) ;
int y = ( int ) ( Math . random ( ) * board_height ) ;
if ( ! ( ( boolean ) board [ x ] [ y ] . mine ) ) {
board [ x ] [ y ] . mine = true ;
mines_left  ;
}
}
generate_surrounding_mines_metadata ( ) ;
}
private void generate_surrounding_mines_metadata ( ) {
for ( int x = <num> ; x < board_width ; x ++ ) {
for ( int y = <num> ; y < board_height ; y ++ ) {
board [ x ] [ y ] . surrounding_mines = total_arround_cell ( x , y , " , true ) ;
}
}
}
public int total_arround_cell ( int x , int y , String key , boolean GET_TRUE_KEYS ) {
int surrounding_true_cells = <num> ;
switch ( key ) {
case " :
if ( ! out_of_bounds ( x  <num> , y  <num> ) ) if ( ( boolean ) board [ x  <num> ] [ y  <num> ] . mine ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x , y  <num> ) ) if ( ( boolean ) board [ x ] [ y  <num> ] . mine ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x + <num> , y  <num> ) ) if ( ( boolean ) board [ x + <num> ] [ y  <num> ] . mine ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x + <num> , y ) ) if ( ( boolean ) board [ x + <num> ] [ y ] . mine ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x + <num> , y + <num> ) ) if ( ( boolean ) board [ x + <num> ] [ y + <num> ] . mine ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x , y + <num> ) ) if ( ( boolean ) board [ x ] [ y + <num> ] . mine ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x  <num> , y + <num> ) ) if ( ( boolean ) board [ x  <num> ] [ y + <num> ] . mine ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x  <num> , y ) ) if ( ( boolean ) board [ x  <num> ] [ y ] . mine ) surrounding_true_cells ++ ;
break ;
case " :
if ( ! out_of_bounds ( x  <num> , y  <num> ) ) if ( ( boolean ) board [ x  <num> ] [ y  <num> ] . uncovered ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x , y  <num> ) ) if ( ( boolean ) board [ x ] [ y  <num> ] . uncovered ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x + <num> , y  <num> ) ) if ( ( boolean ) board [ x + <num> ] [ y  <num> ] . uncovered ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x + <num> , y ) ) if ( ( boolean ) board [ x + <num> ] [ y ] . uncovered ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x + <num> , y + <num> ) ) if ( ( boolean ) board [ x + <num> ] [ y + <num> ] . uncovered ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x , y + <num> ) ) if ( ( boolean ) board [ x ] [ y + <num> ] . uncovered ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x  <num> , y + <num> ) ) if ( ( boolean ) board [ x  <num> ] [ y + <num> ] . uncovered ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x  <num> , y ) ) if ( ( boolean ) board [ x  <num> ] [ y ] . uncovered ) surrounding_true_cells ++ ;
break ;
case " :
if ( ! out_of_bounds ( x  <num> , y  <num> ) ) if ( ( boolean ) board [ x  <num> ] [ y  <num> ] . flagged ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x , y  <num> ) ) if ( ( boolean ) board [ x ] [ y  <num> ] . flagged ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x + <num> , y  <num> ) ) if ( ( boolean ) board [ x + <num> ] [ y  <num> ] . flagged ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x + <num> , y ) ) if ( ( boolean ) board [ x + <num> ] [ y ] . flagged ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x + <num> , y + <num> ) ) if ( ( boolean ) board [ x + <num> ] [ y + <num> ] . flagged ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x , y + <num> ) ) if ( ( boolean ) board [ x ] [ y + <num> ] . flagged ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x  <num> , y + <num> ) ) if ( ( boolean ) board [ x  <num> ] [ y + <num> ] . flagged ) surrounding_true_cells ++ ;
if ( ! out_of_bounds ( x  <num> , y ) ) if ( ( boolean ) board [ x  <num> ] [ y ] . flagged ) surrounding_true_cells ++ ;
break ;
}
if ( GET_TRUE_KEYS ) return surrounding_true_cells ;
return <num>  surrounding_true_cells ;
}
public boolean left_click ( int x , int y ) {
if ( out_of_bounds ( x , y ) || won || lost ) return false ;
boolean made_a_move = false ;
if ( ! ( boolean ) board [ x ] [ y ] . flagged ) made_a_move = reveal ( x , y ) ;
return made_a_move ;
}
public boolean middle_click ( int x , int y ) {
if ( out_of_bounds ( x , y ) || won || lost ) return false ;
boolean made_a_move = false ;
made_a_move = left_click ( x  <num> , y  <num> ) || made_a_move ;
made_a_move = left_click ( x , y  <num> ) || made_a_move ;
made_a_move = left_click ( x + <num> , y  <num> ) || made_a_move ;
made_a_move = left_click ( x + <num> , y ) || made_a_move ;
made_a_move = left_click ( x + <num> , y + <num> ) || made_a_move ;
made_a_move = left_click ( x , y + <num> ) || made_a_move ;
made_a_move = left_click ( x  <num> , y + <num> ) || made_a_move ;
made_a_move = left_click ( x  <num> , y ) || made_a_move ;
return made_a_move ;
}
public boolean right_click ( int x , int y ) {
if ( toggle_flag ( x , y ) ) {
return true ;
} return false ;
}
private boolean toggle_flag ( int x , int y ) {
if ( out_of_bounds ( x , y ) ) return false ;
if ( ! ( ( boolean ) board [ x ] [ y ] . uncovered ) && ! ( ( boolean ) board [ x ] [ y ] . flagged ) ) {
board [ x ] [ y ] . flagged = true ;
set_pixels_array ( x , y ) ;
return true ;
}
return false ;
}
private boolean reveal ( int x , int y ) {
if ( out_of_bounds ( x , y ) || won || lost ) return false ;
if ( ( boolean ) board [ x ] [ y ] . mine && ! ( ( boolean ) board [ x ] [ y ] . flagged ) ) {
if ( first_move ) {
first_move = false ;
board [ x ] [ y ] . mine = false ;
boolean moved = false ;
for ( int iy = <num> ; iy < board_height ; iy ++ ) {
for ( int ix = <num> ; ix < board_width && ! moved ; ix ++ ) {
if ( ! ( boolean ) board [ ix ] [ iy ] . mine ) {
board [ ix ] [ iy ] . mine = true ;
moved = true ;
}
}
}
generate_surrounding_mines_metadata ( ) ;
reveal ( x , y ) ;
return true ;
}
lost = true ;
return true ;
}
first_move = false ;
if ( ( boolean ) board [ x ] [ y ] . uncovered ) {
return false ;
} else {
board [ x ] [ y ] . uncovered = true ;
if ( ( int ) board [ x ] [ y ] . surrounding_mines == <num> ) {
reveal ( x  <num> , y  <num> ) ;
reveal ( x , y  <num> ) ;
reveal ( x + <num> , y  <num> ) ;
reveal ( x + <num> , y ) ;
reveal ( x + <num> , y + <num> ) ;
reveal ( x , y + <num> ) ;
reveal ( x  <num> , y + <num> ) ;
reveal ( x  <num> , y ) ;
}
set_pixels_array ( x , y ) ;
return true ;
}
}
private void set_pixels_array ( int x , int y ) {
int color ;
if ( ( boolean ) board [ x ] [ y ] . flagged ) {
color = <num> ;
} else if ( ( boolean ) board [ x ] [ y ] . uncovered ) {
int surrounding_mines = ( int ) board [ x ] [ y ] . surrounding_mines ;
int alpha = <num> ;
int grey = <num> / <num> * surrounding_mines ;
color = ( alpha << <num> ) + ( grey << <num> ) + ( grey << <num> ) + ( grey << <num> ) ;
} else {
color = <num> ;
}
cell_color_array [ ( y * ( board_width ) ) + x ] . set ( color ) ;
}
public boolean check_win ( ) {
for ( int x = <num> ; x < board_width ; x ++ ) {
for ( int y = <num> ; y < board_height ; y ++ ) {
if ( ! ( boolean ) board [ x ] [ y ] . uncovered && ! ( boolean ) board [ x ] [ y ] . mine ) return false ;
}
}
return true ;
}
public void <unk> ( ) {
out . println ( " ) ;
for ( int y = <num> ; y < board_height ; y ++ ) {
out . print ( y + " ) ;
for ( int x = <num> ; x < board_width ; x ++ ) {
if ( ( boolean ) board [ x ] [ y ] . flagged ) {
out . print ( " ) ;
} else if ( ( boolean ) board [ x ] [ y ] . mine ) {
out . print ( " ) ;
} else if ( ( boolean ) board [ x ] [ y ] . uncovered ) {
int surrounding_mines = ( int ) board [ x ] [ y ] . surrounding_mines ;
if ( surrounding_mines == <num> ) {
out . print ( " ) ;
} else {
out . print ( " + surrounding_mines ) ;
}
} else {
out . print ( " ) ;
}
}
out . println ( ) ;
}
}
private boolean out_of_bounds ( int x , int y ) {
return ( x >= board_width || x < <num> || y >= board_height || y < <num> ) ;
}
public int view_cell ( int x , int y ) {
if ( out_of_bounds ( x , y ) ) return  <num> ;
if ( ( boolean ) board [ x ] [ y ] . uncovered ) {
return ( int ) board [ x ] [ y ] . surrounding_mines ;
}
return  <num> ;
}
}
package util ;
import java . io . BufferedInputStream ;
import java . io . BufferedReader ;
import java . io . File ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . InputStreamReader ;
import java . io . PrintStream ;
import java . util . Timer ;
import java . util . TimerTask ;
public final class CommandExecutor {
public static int executeCmd ( String [ ] cmdArr , String [ ] envArgs , File dir , int timeout ) {
try {
final Process proc = Runtime . getRuntime ( ) . exec ( cmdArr , envArgs , dir ) ;
StreamRedirector std = new StreamRedirector ( proc . getInputStream ( ) , System . out ) ;
StreamRedirector err = new StreamRedirector ( proc . getErrorStream ( ) , System . err ) ;
std . start ( ) ;
err . start ( ) ;
Timer timer = new Timer ( ) ;
if ( timeout > <num> ) {
TimerTask killTask = new TimerTask ( ) {
@Override
public void run ( ) {
proc . destroy ( ) ;
System . out . println ( proc . toString ( ) + " ) ;
}
} ;
timer . schedule ( killTask , timeout ) ;
}
int exitCode = proc . waitFor ( ) ;
if ( timeout > <num> ) {
timer . cancel ( ) ;
}
return exitCode ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
} catch ( InterruptedException e ) {
e . printStackTrace ( ) ;
}
return  <num> ;
}
private static class StreamRedirector extends Thread {
private InputStream input = null ;
private PrintStream output = null ;
public StreamRedirector ( InputStream pInput , PrintStream pOutput ) {
this . input = pInput ;
this . output = pOutput ;
this . setDaemon ( true ) ;
}
public void run ( ) {
BufferedReader br = new BufferedReader ( new InputStreamReader ( this . input ) ) ;
String s ;
try {
while ( ( s = br . readLine ( ) ) != null ) {
output . println ( s ) ;
}
} catch ( IOException e ) {
throw new RuntimeException ( e ) ;
}
}
}
}
package util ;
import static org . junit . Assert . * ;
import org . junit . Test ;
public class <unk> {
@Test
public void <unk> ( ) {
String [ ] cmd = new String [ ] { " } ;
assertEquals ( <num> , CommandExecutor . executeCmd ( cmd , null , null , <num> ) ) ;
}
}
package com . uruwolf . vominer ;
import com . uruwolf . vominer . data . Sector ;
import com . uruwolf . vominer . data . SectorDataSource ;
import android . app . Activity ;
import android . os . Bundle ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . TextView ;
public class SectorNotesActivity extends Activity {
private String system ;
private String alpha ;
private String num ;
private SectorDataSource data ;
private Sector sector ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . <unk> ) ;
data = new SectorDataSource ( this ) ;
data . open ( ) ;
Bundle extras = getIntent ( ) . getExtras ( ) ;
system = extras . getString ( " ) ;
alpha = extras . getString ( " ) ;
num = extras . getString ( " ) ;
String title = String . format ( getResources ( ) . getString ( R . string . sector_full_title ) , system , alpha , num ) ;
( ( TextView ) findViewById ( R . id . <unk> ) ) . setText ( title ) ;
( ( Button ) findViewById ( R . id . closeButton ) ) . setOnClickListener ( new OnClickListener ( ) {
public void onClick ( View v ) {
shutdown ( ) ;
}
} ) ;
}
private void shutdown ( ) {
this . finish ( ) ;
}
@Override
public void onPause ( ) {
super . onPause ( ) ;
sector . setNotes ( ( ( EditText ) findViewById ( R . id . sectorNotes ) ) . getText ( ) . toString ( ) ) ;
data . updateSectorNotes ( sector ) ;
data . close ( ) ;
}
@Override
public void onResume ( ) {
super . onResume ( ) ;
data . open ( ) ;
sector = data . populate ( new Sector ( system , alpha , num ,  <num> , " ) ) ;
( ( EditText ) findViewById ( R . id . sectorNotes ) ) . setText ( sector . getNotes ( ) ) ;
}
}
package com . uruwolf . vominer . data ;
import java . util . ArrayList ;
import android . content . ContentValues ;
import android . content . Context ;
import android . database . Cursor ;
import android . database . SQLException ;
import android . database . sqlite . SQLiteDatabase ;
public class SectorDataSource {
private SQLiteDatabase database ;
private SQLiteHelper dbHelper ;
public SectorDataSource ( Context context ) {
dbHelper = new SQLiteHelper ( context ) ;
}
public void open ( ) throws SQLException {
database = dbHelper . getWritableDatabase ( ) ;
}
public void close ( ) {
dbHelper . close ( ) ;
}
public Sector populate ( Sector info ) {
if ( info . getSystem ( ) == " || info . getAplhaCoord ( ) == " || info . getNumCoord ( ) == " )
throw new IllegalArgumentException ( " ) ;
Sector sector = loadSector ( info ) ;
if ( sector == null )
return create ( info ) ;
return sector ;
}
private Sector loadSector ( Sector id ) {
if ( id . getSystem ( ) == " || id . getAplhaCoord ( ) == " || id . getNumCoord ( ) == " )
throw new IllegalArgumentException ( " ) ;
Sector sector = null ;
String whereString = SQLiteHelper . COL_SECTORS_SYSTEM + " +
SQLiteHelper . COL_SECTORS_ALPHA + " +
SQLiteHelper . COL_SECTORS_NUM + " ;
String [ ] whereList = { id . getSystem ( ) , id . getAplhaCoord ( ) , id . getNumCoord ( ) } ;
Cursor cursor = database . query ( SQLiteHelper . TABLE_SECTORS ,
null ,
whereString ,
whereList ,
null ,
null ,
null
) ;
if ( cursor . getCount ( ) > <num> ) {
cursor . moveToFirst ( ) ;
sector = populateMinerals ( cursorToSector ( cursor ) ) ;
}
cursor . close ( ) ;
return sector ;
}
private Sector create ( Sector sector ) {
ContentValues values = new ContentValues ( ) ;
values . put ( SQLiteHelper . COL_SECTORS_SYSTEM , sector . getSystem ( ) ) ;
values . put ( SQLiteHelper . COL_SECTORS_ALPHA , sector . getAplhaCoord ( ) ) ;
values . put ( SQLiteHelper . COL_SECTORS_NUM , sector . getNumCoord ( ) ) ;
values . put ( SQLiteHelper . COL_SECTORS_NOTES , sector . getNotes ( ) ) ;
database . insertOrThrow ( SQLiteHelper . TABLE_SECTORS , null , values ) ;
return sector ;
}
private Sector cursorToSector ( Cursor cursor ) {
Sector sector = new Sector ( ) ;
sector . setId ( cursor . getInt ( <num> ) ) ;
sector . setSystem ( cursor . getString ( <num> ) ) ;
sector . setAplhaCoord ( cursor . getString ( <num> ) ) ;
sector . setNumCoord ( cursor . getString ( <num> ) ) ;
sector . setNotes ( cursor . getString ( <num> ) ) ;
return sector ;
}
private Sector populateMinerals ( Sector sector ) {
if ( sector . getId ( ) < <num> )
throw new IllegalArgumentException ( " ) ;
String whereString = SQLiteHelper . COL_SECTOR_MINERALS_SECTOR + " ;
String [ ] whereList = { sector . getId ( ) + " } ;
Cursor cursor = database . query ( SQLiteHelper . TABLE_SECTOR_MINERALS ,
null ,
whereString ,
whereList ,
null ,
null ,
null
) ;
if ( cursor . moveToFirst ( ) ) {
do {
sector . addMineral ( cursorToMineral ( cursor ) ) ;
} while ( cursor . moveToNext ( ) ) ;
}
return sector ;
}
private Mineral cursorToMineral ( Cursor cursor ) {
Mineral mineral = new Mineral ( ) ;
mineral . setMineral ( cursor . getString ( <num> ) ) ;
return mineral ;
}
public void addMineralToSector ( Sector sector , Mineral mineral ) {
if ( sector . getId ( ) < <num> )
throw new IllegalArgumentException ( " ) ;
ContentValues values = new ContentValues ( ) ;
values . put ( SQLiteHelper . COL_SECTOR_MINERALS_MINERAL , mineral . getMineral ( ) ) ;
values . put ( SQLiteHelper . COL_SECTOR_MINERALS_SECTOR , sector . getId ( ) ) ;
mineral . setId ( database . insert ( SQLiteHelper . TABLE_SECTOR_MINERALS , null , values ) ) ;
sector . addMineral ( mineral ) ;
}
public void removeMineralFromSector ( Sector sector , Mineral mineral ) {
if ( sector . getId ( ) < <num> )
throw new IllegalArgumentException ( " ) ;
String where = SQLiteHelper . COL_SECTOR_MINERALS_SECTOR + " +
SQLiteHelper . COL_SECTOR_MINERALS_MINERAL + " ;
String [ ] whereData = { sector . getId ( ) + " , mineral . getMineral ( ) } ;
database . delete ( SQLiteHelper . TABLE_SECTOR_MINERALS , where , whereData ) ;
}
public void updateSectorNotes ( Sector sector ) {
if ( sector . getId ( ) <= <num> )
throw new IllegalArgumentException ( " ) ;
ContentValues values = new ContentValues ( ) ;
values . put ( SQLiteHelper . COL_SECTORS_NOTES , sector . getNotes ( ) ) ;
database . update ( SQLiteHelper . TABLE_SECTORS , values , SQLiteHelper . COL_ID + " + sector . getId ( ) , null ) ;
}
public ArrayList < Sector > getSectorsContainingMineral ( String mineral ) {
String query = " + SQLiteHelper . TABLE_SECTORS + " +
" + SQLiteHelper . TABLE_SECTORS + " +
" + SQLiteHelper . TABLE_SECTORS + " + SQLiteHelper . COL_ID +
" +
" + SQLiteHelper . COL_SECTOR_MINERALS_SECTOR +
" + SQLiteHelper . TABLE_SECTOR_MINERALS +
" + SQLiteHelper . COL_SECTOR_MINERALS_MINERAL + " + mineral + " +
" ;
Cursor cursor = database . rawQuery ( query , null ) ;
ArrayList < Sector > sectorList = new ArrayList < Sector > ( ) ;
if ( cursor . moveToFirst ( ) ) {
do {
sectorList . add ( cursorToSector ( cursor ) ) ;
} while ( cursor . moveToNext ( ) ) ;
}
return sectorList ;
}
public ArrayList < Sector > getSectorsContainingMineral ( Mineral mineral ) {
return getSectorsContainingMineral ( mineral . getMineral ( ) ) ;
}
}
package com . uruwolf . vominer . data ;
import android . content . Context ;
import android . database . sqlite . SQLiteDatabase ;
import android . database . sqlite . SQLiteOpenHelper ;
import android . util . Log ;
public class SQLiteHelper extends SQLiteOpenHelper {
public static final String TABLE_SECTORS = " ;
public static final String TABLE_SECTOR_MINERALS = " ;
public static final String COL_ID = " ;
public static final String COL_SECTORS_SYSTEM = " ;
public static final String COL_SECTORS_ALPHA = " ;
public static final String COL_SECTORS_NUM = " ;
public static final String COL_SECTORS_NOTES = " ;
public static final String COL_SECTOR_MINERALS_SECTOR = " ;
public static final String COL_SECTOR_MINERALS_MINERAL = " ;
private static final String DATABSE_NAME = " ;
public static final int DATABSE_VERSION = <num> ;
public SQLiteHelper ( Context context ) {
super ( context , DATABSE_NAME , null , DATABSE_VERSION ) ;
}
@Override
public void onCreate ( SQLiteDatabase db ) {
String createSectorsQuery = " + TABLE_SECTORS + " +
COL_ID + " +
COL_SECTORS_SYSTEM + " +
COL_SECTORS_ALPHA + " +
COL_SECTORS_NUM + " +
COL_SECTORS_NOTES + " +
" ;
String createMineralsQuery = " + TABLE_SECTOR_MINERALS + " +
COL_ID + " +
COL_SECTOR_MINERALS_SECTOR + " +
COL_SECTOR_MINERALS_MINERAL + " +
" + COL_SECTOR_MINERALS_SECTOR + " + TABLE_SECTORS + " + COL_ID + " +
" ;
Log . d ( com . uruwolf . vominer . VoMinerActivity . TAG , " ) ;
db . execSQL ( createSectorsQuery ) ;
db . execSQL ( createMineralsQuery ) ;
Log . d ( com . uruwolf . vominer . VoMinerActivity . TAG , " ) ;
}
@Override
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) {
Log . d ( com . uruwolf . vominer . VoMinerActivity . TAG , " ) ;
}
}
package com . uruwolf . vominer . data ;
import java . util . ArrayList ;
import java . util . List ;
public class Sector {
private int id ;
private String system ;
private String alphaCoord ;
private String numCoord ;
private String notes ;
private final List < Mineral > mineralList ;
public Sector ( ) {
this ( " , " , " ,  <num> , " ) ;
}
public Sector ( String system , String alpha , String num , int id , String notes ) {
mineralList = new ArrayList < Mineral > ( ) ;
setSystem ( system ) ;
setAplhaCoord ( alpha ) ;
setNumCoord ( num ) ;
setId ( id ) ;
setNotes ( notes ) ;
}
public String getSystem ( ) {
return system ;
}
public void setSystem ( String system ) {
this . system = system ;
}
public String getAplhaCoord ( ) {
return alphaCoord ;
}
public void setAplhaCoord ( String alphaCoord ) {
this . alphaCoord = alphaCoord ;
}
public String getNumCoord ( ) {
return numCoord ;
}
public void setNumCoord ( String numCoord ) {
this . numCoord = numCoord ;
}
public String getNotes ( ) {
return notes ;
}
public void setNotes ( String notes ) {
this . notes = notes ;
}
public int getId ( ) {
return id ;
}
public void setId ( int id ) {
this . id = id ;
}
public void addMineral ( Mineral newMineral ) {
newMineral . setSector ( this ) ;
mineralList . add ( newMineral ) ;
}
public void <unk> ( Mineral toRemove ) {
toRemove . setSector ( null ) ;
mineralList . remove ( toRemove ) ;
}
public List < Mineral > getMinerals ( ) {
return mineralList ;
}
public boolean equal ( Object obj ) {
if ( obj instanceof Sector ) {
Sector newS = ( Sector ) obj ;
return ( newS . getSystem ( ) . equals ( system ) &&
newS . getAplhaCoord ( ) . equals ( alphaCoord ) &&
newS . getNumCoord ( ) . equals ( numCoord ) ) ;
}
return false ;
}
}
package com . uruwolf . vominer ;
import java . util . ArrayList ;
import java . util . List ;
import com . uruwolf . vominer . data . Sector ;
import com . uruwolf . vominer . data . SectorDataSource ;
import android . app . Activity ;
import android . os . Bundle ;
import android . widget . ArrayAdapter ;
import android . widget . ListView ;
import android . widget . TextView ;
public class SectorListActivity extends Activity {
private String mineral ;
private SectorDataSource data ;
private ArrayList < String > sectorStrings ;
private ArrayAdapter < String > listAdapter ;
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . <unk> ) ;
data = new SectorDataSource ( this ) ;
data . open ( ) ;
mineral = getIntent ( ) . getExtras ( ) . getString ( " ) ;
( ( TextView ) findViewById ( R . id . search_result_explain ) ) . setText (
String . format ( getResources ( ) . getString ( R . string . search_result_explain ) , mineral )
) ;
ListView list = ( ListView ) findViewById ( R . id . search_result ) ;
sectorStrings = new ArrayList < String > ( ) ;
listAdapter = new ArrayAdapter < String > ( this ,
android . R . layout . simple_list_item_1 ,
sectorStrings ) ;
list . setAdapter ( listAdapter ) ;
}
@Override
public void onPause ( ) {
super . onPause ( ) ;
data . close ( ) ;
}
@Override
public void onResume ( ) {
super . onResume ( ) ;
data . open ( ) ;
List < Sector > sectors = data . getSectorsContainingMineral ( mineral ) ;
sectorStrings . clear ( ) ;
for ( Sector sec : sectors ) {
sectorStrings . add ( String . format (
getResources ( ) . getString ( R . string . sector_full_title ) ,
sec . getSystem ( ) ,
sec . getAplhaCoord ( ) ,
sec . getNumCoord ( )
) ) ;
}
listAdapter . notifyDataSetChanged ( ) ;
}
}
package com . uruwolf . vominer ;
import java . util . ArrayList ;
import java . util . Arrays ;
import java . util . List ;
import com . uruwolf . vominer . data . * ;
import android . app . Activity ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . net . Uri ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . * ;
import android . view . View . * ;
import android . widget . * ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . AdapterView . OnItemSelectedListener ;
public class VoMinerActivity extends Activity implements OnItemSelectedListener , OnClickListener , OnItemClickListener {
public static final String TAG = " ;
public static final String PREFS_NAME = " ;
private static final String PREF_LAST_SYSTEM = " ;
private static final String PREF_LAST_SECTOR_APLHA = " ;
private static final String PREF_LAST_SECTOR_NUM = " ;
private SectorDataSource data ;
private Sector currentSector ;
private List < String > mineralList ;
private ArrayAdapter < String > mineralAdapter ;
private String emptyMineralString = " ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
data = new SectorDataSource ( this ) ;
data . open ( ) ;
Spinner systemList = ( Spinner ) findViewById ( R . id . systemList ) ;
Spinner gridAplhaList = ( Spinner ) findViewById ( R . id . gridAlphaList ) ;
Spinner gridNumList = ( Spinner ) findViewById ( R . id . gridNumList ) ;
systemList . setOnItemSelectedListener ( this ) ;
gridAplhaList . setOnItemSelectedListener ( this ) ;
gridNumList . setOnItemSelectedListener ( this ) ;
SharedPreferences settings = getSharedPreferences ( PREFS_NAME , <num> ) ;
ArrayAdapter < String > systemAdapter = new ArrayAdapter < String > ( this ,
android . R . layout . simple_list_item_1 ,
Static . systemList ) ;
systemAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
systemList . setAdapter ( systemAdapter ) ;
ArrayAdapter < String > gridAlphaAdapter = new ArrayAdapter < String > ( this ,
android . R . layout . simple_list_item_1 ,
Static . alphaCoordList ) ;
gridAlphaAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
gridAplhaList . setAdapter ( gridAlphaAdapter ) ;
ArrayAdapter < String > gridNumAdapter = new ArrayAdapter < String > ( this ,
android . R . layout . simple_list_item_1 ,
Static . numCoordList ) ;
gridNumAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
gridNumList . setAdapter ( gridNumAdapter ) ;
systemList . setSelection ( ( ( ArrayAdapter < String > ) systemList . getAdapter ( ) ) . getPosition (
settings . getString ( PREF_LAST_SYSTEM , " ) ) ) ;
gridAplhaList . setSelection ( ( ( ArrayAdapter < String > ) gridAplhaList . getAdapter ( ) ) . getPosition (
settings . getString ( PREF_LAST_SECTOR_APLHA , " ) ) ) ;
gridNumList . setSelection ( ( ( ArrayAdapter < String > ) gridNumList . getAdapter ( ) ) . getPosition (
settings . getString ( PREF_LAST_SECTOR_NUM , " ) ) ) ;
( ( Button ) findViewById ( R . id . <unk> ) ) . setOnClickListener ( this ) ;
( ( ListView ) findViewById ( R . id . oreList ) ) . setOnItemClickListener ( this ) ;
Spinner oreSpinner = ( Spinner ) findViewById ( R . id . mineralList ) ;
mineralList = new ArrayList < String > ( Static . mineralList ) ;
mineralAdapter = new ArrayAdapter < String > ( this ,
android . R . layout . simple_list_item_1 ,
mineralList ) ;
mineralAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
oreSpinner . setAdapter ( mineralAdapter ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
MenuInflater inflater = getMenuInflater ( ) ;
inflater . inflate ( R . menu . menu , menu ) ;
return true ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case R . id . <unk> :
showSectorNotes ( ) ;
return true ;
case R . id . menu_search :
showSearch ( ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
private void showSectorNotes ( ) {
Intent intent = new Intent ( this , SectorNotesActivity . class ) ;
intent . putExtra ( " , currentSector . getSystem ( ) ) ;
intent . putExtra ( " , currentSector . getAplhaCoord ( ) ) ;
intent . putExtra ( " , currentSector . getNumCoord ( ) ) ;
startActivity ( intent ) ;
}
private void showSearch ( ) {
startActivity ( new Intent ( this , MineralSearchActivity . class ) ) ;
}
@Override
public void onPause ( ) {
super . onPause ( ) ;
SharedPreferences . Editor editor = getSharedPreferences ( PREFS_NAME , <num> ) . edit ( ) ;
Sector selected = getSelectedSector ( ) ;
editor . putString ( PREF_LAST_SYSTEM , selected . getSystem ( ) ) ;
editor . putString ( PREF_LAST_SECTOR_APLHA , selected . getAplhaCoord ( ) ) ;
editor . putString ( PREF_LAST_SECTOR_NUM , selected . getNumCoord ( ) ) ;
editor . commit ( ) ;
data . close ( ) ;
}
@Override
public void onResume ( ) {
super . onResume ( ) ;
data . open ( ) ;
}
public void onItemSelected ( AdapterView < ? > parentView , View <unk> , int position , long id ) {
refreshCurrentSector ( ) ;
setMineralLists ( currentSector ) ;
}
private void refreshCurrentSector ( ) {
currentSector = data . populate ( getSelectedSector ( ) ) ;
}
public Sector getSelectedSector ( ) {
Sector info = new Sector ( ( String ) ( ( Spinner ) findViewById ( R . id . systemList ) ) . getSelectedItem ( ) ,
( String ) ( ( Spinner ) findViewById ( R . id . gridAlphaList ) ) . getSelectedItem ( ) ,
( String ) ( ( Spinner ) findViewById ( R . id . gridNumList ) ) . getSelectedItem ( ) ,
1 , " ) ;
return data . populate ( info ) ;
}
public void onNothingSelected ( AdapterView < ? > parentView ) {
}
public void onClick ( View v ) {
Mineral mineral = new Mineral ( ) ;
String mineralName = ( String ) ( ( Spinner ) findViewById ( R . id . mineralList ) ) . getSelectedItem ( ) ;
if ( ! mineralName . equals ( emptyMineralString ) ) {
mineral . setMineral ( mineralName ) ;
data . addMineralToSector ( currentSector , mineral ) ;
setMineralLists ( currentSector ) ;
}
}
public void onItemClick ( AdapterView < ? > parent , View view , int pos , long id ) {
String mineralName = ( String ) ( ( ListView ) findViewById ( R . id . oreList ) ) . getItemAtPosition ( pos ) ;
data . removeMineralFromSector ( currentSector , new Mineral ( null , mineralName ) ) ;
refreshCurrentSector ( ) ;
setMineralLists ( currentSector ) ;
}
private void setMineralLists ( Sector sector ) {
mineralList . clear ( ) ;
mineralList . addAll ( Static . mineralList ) ;
ArrayAdapter < String > oreListAdapter = new ArrayAdapter < String > ( this ,
android . R . layout . simple_list_item_1 ,
new ArrayList < String > ( ) ) ;
( ( ListView ) findViewById ( R . id . oreList ) ) . setAdapter ( oreListAdapter ) ;
for ( Mineral mineral : sector . getMinerals ( ) ) {
mineralList . remove ( mineral . getMineral ( ) ) ;
oreListAdapter . add ( mineral . getMineral ( ) ) ;
}
if ( mineralList . size ( ) == <num> )
mineralList . add ( emptyMineralString ) ;
mineralAdapter . notifyDataSetChanged ( ) ;
oreListAdapter . notifyDataSetChanged ( ) ;
}
package com . uruwolf . vominer ;
import com . uruwolf . vominer . data . Static ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . ArrayAdapter ;
import android . widget . Button ;
import android . widget . Spinner ;
public class MineralSearchActivity extends Activity implements OnClickListener {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . <unk> ) ;
Spinner systemSpinner = ( Spinner ) findViewById ( R . id . mineralSearchList ) ;
ArrayAdapter < String > systemAdapter = new ArrayAdapter < String > ( this ,
android . R . layout . simple_list_item_1 ,
Static . mineralList ) ;
systemAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
systemSpinner . setAdapter ( systemAdapter ) ;
( ( Button ) findViewById ( R . id . <unk> ) ) . setOnClickListener ( this ) ;
}
public void onClick ( View v ) {
Intent intent = new Intent ( this , SectorListActivity . class ) ;
intent . putExtra ( " , ( String ) ( ( Spinner ) findViewById ( R . id . mineralSearchList ) ) . getSelectedItem ( ) ) ;
startActivity ( intent ) ;
finish ( ) ;
}
}
package com . uruwolf . vominer . data ;
import java . util . ArrayList ;
import java . util . Arrays ;
public class Static {
public static final ArrayList < String > mineralList = new ArrayList < String > ( Arrays . asList (
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
"
) ) ;
public static final ArrayList < String > systemList = new ArrayList < String > ( Arrays . asList (
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
"
) ) ;
public static final ArrayList < String > alphaCoordList = new ArrayList < String > ( Arrays . asList (
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
"
) ) ;
public static final ArrayList < String > numCoordList = new ArrayList < String > ( Arrays . asList (
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
"
) ) ;
}
package com . uruwolf . vominer . data ;
public class Mineral {
private Sector sector ;
private String mineral ;
private long id ;
public Mineral ( ) {
this ( null , " ) ;
}
public Mineral ( Sector sector , String mineral ) {
setSector ( sector ) ;
setMineral ( mineral ) ;
}
public Sector <unk> ( ) {
return sector ;
}
public void setSector ( Sector sector ) {
this . sector = sector ;
}
public String getMineral ( ) {
return mineral ;
}
public void setMineral ( String mineral ) {
this . mineral = mineral ;
}
public long getId ( ) {
return id ;
}
public void setId ( long id ) {
this . id = id ;
}
}
package unifier . util ;
import java . io . Writer ;
import java . io . IOException ;
public abstract class FormattingWriter {
protected Writer writer ;
protected FormattingWriter ( Writer writer ) {
this . writer = writer ;
}
public abstract void indent ( ) ;
public abstract int changeIndent ( int i ) ;
public abstract void ln ( int i ) ;
public void ln ( ) {
ln ( <num> ) ;
}
public void flush ( ) {
try {
writer . flush ( ) ;
} catch ( IOException e ) {
throw new RuntimeException ( e ) ;
}
}
public Writer writer ( ) {
return writer ;
}
public void write ( String text ) {
try {
writer . write ( text ) ;
} catch ( IOException e ) {
throw new RuntimeException ( e ) ;
}
}
public void write ( char ch ) {
try {
writer . write ( ch ) ;
} catch ( IOException e ) {
throw new RuntimeException ( e ) ;
}
}
public String toString ( ) {
return writer . toString ( ) ;
}
}
package unifier . asfsdf ;
import java . util . HashMap ;
import java . util . Map ;
import java . io . FileNotFoundException ;
public class SdfDefinition {
private Map < String , Module > modules = new HashMap < String , Module > ( ) ;
public boolean <unk> ( String moduleName ) {
return modules . containsKey ( moduleName ) ;
}
public Module getModule ( String moduleName ) throws SdfDefinitionException {
if ( modules . containsKey ( moduleName ) ) {
return modules . get ( moduleName ) ;
} else {
throw new SdfDefinitionException ( " + moduleName + " ) ;
}
}
public SdfDefinition <unk> ( Module module ) throws SdfDefinitionException {
if ( module . getName ( ) . trim ( ) . compareTo ( " ) == <num> ) {
throw new SdfDefinitionException ( " ) ;
} else {
modules . put ( module . getName ( ) , module ) ;
}
return this ;
}
}
package unifier . rsm ;
import java . util . Set ;
import java . util . HashSet ;
import unifier . util . FormattingWriter ;
public class Enum extends BuiltInType {
private Set < String > values = new HashSet < String > ( ) ;
public Set < String > getValues ( ) {
Set < String > result = new HashSet < String > ( ) ;
result . addAll ( values ) ;
return result ;
}
public void addValue ( String value ) {
values . add ( value ) ;
}
public void <unk> ( Set < String > values ) {
this . values . addAll ( values ) ;
}
public void specification ( FormattingWriter writer ) {
int i ;
writer . write ( " ) ; writer . write ( getName ( ) ) ; writer . write ( " ) ; writer . ln ( + <num> ) ;
writer . write ( " ) ;
i = <num> ;
for ( String value : values ) {
writer . write ( value ) ;
if ( i < values . size ( ) ) writer . write ( " ) ;
i ++ ;
}
writer . write ( " ) ;
writer . ln (  <num> ) ;
writer . write ( " ) ;
}
public boolean isADT ( ) {
return false ;
}
}
package unifier . asfsdf ;
public class Condition {
private String left = " ;
private String right = " ;
private ConditionKind kind ;
public Condition ( ) { }
public Condition ( String lhp , String rhp , ConditionKind kind ) {
this . left = lhp ;
this . right = rhp ;
this . kind = kind ;
}
public String getLeft ( ) {
return left ;
}
public Condition setLeft ( String left ) {
this . left = left ;
return this ;
}
public String getRight ( ) {
return right ;
}
public Condition setRight ( String right ) {
this . right = right ;
return this ;
}
public ConditionKind getKind ( ) {
return kind ;
}
public Condition setKind ( ConditionKind kind ) {
this . kind = kind ;
return this ;
}
}
package unifier ;
import javax . swing . border . TitledBorder ;
import javax . swing . JCheckBox ;
import javax . swing . BorderFactory ;
import javax . swing . JPanel ;
import java . awt . Insets ;
import javax . swing . JButton ;
import java . awt . Color ;
import java . awt . Dimension ;
import javax . swing . JList ;
import java . awt . GridBagConstraints ;
import javax . swing . JTextArea ;
import java . awt . FlowLayout ;
import javax . swing . ListSelectionModel ;
import javax . swing . JTextField ;
import javax . swing . JScrollPane ;
import java . awt . GridBagLayout ;
import javax . swing . border . EtchedBorder ;
import javax . swing . JTabbedPane ;
import javax . swing . JLabel ;
import javax . swing . JSplitPane ;
import java . awt . * ;
import javax . swing . JFrame ;
import java . util . logging . Logger ;
import meta . DB ;
import meta . ModelRegDef ;
import java . sql . SQLException ;
import meta . ExtensionRegDef ;
import javax . swing . JOptionPane ;
import java . io . StringReader ;
import java . io . StringWriter ;
import meta . ModuleDef ;
import SynthesisLoaderClasses . SynthesisLoader ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import java . io . * ;
import java . io . * ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseAdapter ;
import unifier . util . TextFileJList ;
import unifier . util . RepositoryCleaner ;
import unifier . util . FormattingWriter ;
import unifier . util . DefaultFormattingWriter ;
import unifier . asfsdf . SdfDefinitionException ;
import unifier . asfsdf . Module ;
import unifier . rsm . ReferenceSchemaModelException ;
import java . awt . event . WindowEvent ;
import java . awt . event . WindowAdapter ;
import db . Like ;
import meta . SchemaDef ;
import java . util . Set ;
import unifier . util . ElementChooserDialog ;
import db . Query ;
import unifier . util . StringChooserDialog ;
import unifier . util . TextFile ;
import unifier . asfsdf . SdfCreator ;
import org . antlr . runtime . RecognitionException ;
import org . ipi . schemaeditor . SchemaEditorGui ;
public class ExtensionRegistrar extends CenteredFrame {
public ExtensionRegistrar ( DB db ) throws SQLException {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
center ( ) ;
logger = Logger . getLogger ( " ) ;
this . db = db ;
}
public ExtensionRegistrar ( ExtensionRegDef extension ) throws SQLException {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
center ( ) ;
logger = Logger . getLogger ( " ) ;
db = ( DB ) extension . _db ( ) ;
this . extension = extension ;
openExtension ( ) ;
}
private void jbInit ( ) throws Exception {
this . setDefaultCloseOperation ( HIDE_ON_CLOSE ) ;
this . setTitle ( " ) ;
this . addWindowListener ( new ExtensionRegistrar_this_windowAdapter ( this ) ) ;
this . getContentPane ( ) . setLayout ( gridBagLayoutMR ) ;
jPanelRegCard . setLayout ( gridBagLayoutRC ) ;
jPanelExtensionSyntax . setLayout ( gridBagLayoutMS ) ;
jLabelTitle . setText ( " ) ;
jTextFieldShortTitle . setText ( " ) ;
jPanelRegCard . setBorder ( null ) ;
jPanelRegCard . setToolTipText ( " ) ;
jButtonUpdateRegCard . setToolTipText (
" ) ;
jButtonUpdateRegCard . setText ( " ) ;
jButtonUpdateRegCard . addActionListener ( new
ExtensionRegistrar_jButtonUpdateRegCard_actionAdapter ( this ) ) ;
jPanelRCButtons . setLayout ( flowLayoutRCB ) ;
jButtonDeleteCard . setToolTipText (
" ) ;
jButtonDeleteCard . setText ( " ) ;
jButtonDeleteCard . addActionListener ( new
ExtensionRegistrar_jButtonDeleteCard_actionAdapter ( this ) ) ;
jPanelRCButtons . setBorder ( BorderFactory . createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) ) ;
jButtonBrowseModelSyntaxFile . setToolTipText (
" ) ;
jButtonBrowseModelSyntaxFile . setText ( " ) ;
jButtonBrowseModelSyntaxFile . addActionListener ( new
ExtensionRegistrar_jButtonBrowseModelSyntaxFile_actionAdapter ( this ) ) ;
jButtonUpdateModelSyntax . setToolTipText (
" ) ;
jButtonUpdateModelSyntax . setText ( " ) ;
jButtonUpdateModelSyntax . addActionListener ( new
ExtensionRegistrar_jButtonUpdateModelSyntax_actionAdapter ( this ) ) ;
jTabbedPaneActivities . setMinimumSize ( new Dimension ( <num> , <num> ) ) ;
jTabbedPaneActivities . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jPanelSemantics . setLayout ( gridBagLayoutAMNS ) ;
jButtonUpdateAmnSemantics . setToolTipText (
" ) ;
jButtonUpdateAmnSemantics . setText ( " ) ;
jButtonUpdateAmnSemantics . addActionListener ( new
ExtensionRegistrar_jButtonUpdateAmnSemantics_actionAdapter ( this ) ) ;
jTextAreaVerbalSemantics . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaVerbalSemantics . setText ( " ) ;
jScrollPaneVerbalSemantics . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jPanelReferenceSchema . setLayout ( gridBagLayoutVOD ) ;
jButtonCreateReferenceSchemaTemplate . setToolTipText (
" ) ;
jButtonCreateReferenceSchemaTemplate . setActionCommand (
" ) ;
jButtonCreateReferenceSchemaTemplate . setText ( " ) ;
jButtonCreateReferenceSchemaTemplate . addActionListener ( new
ExtensionRegistrar_jButtonCreateReferenceSchemaTemplate_actionAdapter ( this ) ) ;
jScrollPaneReferenceSchemaTemplate . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jTextAreaReferenceSchemaTemplate . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaReferenceSchemaTemplate . setEditable ( true ) ;
jTextAreaReferenceSchemaTemplate . setText ( " ) ;
jButtonVODUpdate . setToolTipText (
" ) ;
jButtonVODUpdate . setText ( " ) ;
jButtonVODUpdate . addActionListener ( new
ExtensionRegistrar_jButtonVODUpdate_actionAdapter ( this ) ) ;
jButtonVODEdit . setToolTipText ( " ) ;
jButtonVODEdit . setText ( " ) ;
jButtonVODEdit . addActionListener ( new
ExtensionRegistrar_jButtonVODEdit_actionAdapter ( this ) ) ;
jSplitPaneReferenceSchema . setOrientation ( JSplitPane . HORIZONTAL_SPLIT ) ;
jSplitPaneReferenceSchema . setOneTouchExpandable ( true ) ;
jTextAreaModelSyntax . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaModelSyntax . setText ( " ) ;
jScrollPaneModelSyntaxFiles . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jScrollPaneModelSyntax . setBorder ( BorderFactory . createEmptyBorder ( ) ) ;
jSplitPaneSemantics . setOrientation ( JSplitPane . VERTICAL_SPLIT ) ;
jSplitPaneSemantics . setOneTouchExpandable ( true ) ;
jSplitPaneModelSyntax . setOneTouchExpandable ( true ) ;
jPanelReferenceSchemaEditor . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jPanelReferenceSchemaEditor . setLayout ( borderLayoutSchemaEditor ) ;
jTextAreaVerbalAmnSemantics . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaVerbalAmnSemantics . setToolTipText ( " ) ;
jScrollPaneVerbalAmnSemantics . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jLabelTranslator2AmnVersion . setText ( " ) ;
jTextFieldTranslator2AmnVersion . setText ( " ) ;
jScrollPaneExtensionDescription . setBorder ( new TitledBorder (
BorderFactory . createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jButtonDeleteModelSyntaxFile . setToolTipText (
" ) ;
jButtonDeleteModelSyntaxFile . setText ( " ) ;
jButtonDeleteModelSyntaxFile . addActionListener ( new
ExtensionRegistrar_jButtonDeleteModelSyntaxFile_actionAdapter ( this ) ) ;
jTextAreaExtensionDescription . setFont ( new java . awt . Font (
" , Font . PLAIN , <num> ) ) ;
jLabelExtendedModel . setText ( " ) ;
jTextFieldExtendedModel . setEditable ( false ) ;
jTextFieldExtendedModel . setText ( " ) ;
jButtonExploreExtension . setToolTipText (
" ) ;
jButtonExploreExtension . setText ( " ) ;
jButtonExploreExtension . addActionListener ( new
ExtensionRegistrar_jButtonExploreExtension_actionAdapter ( this ) ) ;
jButtonExportSyntaxFile . setToolTipText (
" ) ;
jButtonExportSyntaxFile . setText ( " ) ;
jButtonExportSyntaxFile . addActionListener ( new
ExtensionRegistrar_jButtonExportSyntaxFile_actionAdapter ( this ) ) ;
jListModelSyntaxFiles . addMouseListener ( new
ExtensionRegistrar_jListModelSyntaxFiles_mouseAdapter ( this ) ) ;
jButtonBrowseReferenceSchema . setToolTipText (
" ) ;
jButtonBrowseReferenceSchema . setText ( " ) ;
jButtonBrowseReferenceSchema . addActionListener ( new
ExtensionRegistrar_jButtonBrowseReferenceSchema_actionAdapter ( this ) ) ;
jPanelRCButtons . add ( jButtonUpdateRegCard ) ;
jPanelRCButtons . add ( jButtonDeleteCard ) ;
jScrollPaneExtensionDescription . getViewport ( ) . add (
jTextAreaExtensionDescription ) ;
jTabbedPaneActivities . add ( jPanelRegCard , " ) ;
jTabbedPaneActivities . add ( jPanelExtensionSyntax , " ) ;
jTabbedPaneActivities . add ( jPanelSemantics , " ) ;
jPanelModelSyntaxButtons . add ( jButtonBrowseModelSyntaxFile ) ;
jPanelModelSyntaxButtons . add ( jButtonDeleteModelSyntaxFile ) ;
jPanelModelSyntaxButtons . add ( jButtonExportSyntaxFile ) ;
jPanelModelSyntaxButtons . add ( jButtonUpdateModelSyntax ) ;
jPanelVODButtons . add ( jButtonCreateReferenceSchemaTemplate ) ;
jPanelVODButtons . add ( jButtonVODEdit ) ;
jPanelVODButtons . add ( jButtonBrowseReferenceSchema ) ;
jPanelVODButtons . add ( jButtonVODUpdate ) ;
jPanelReferenceSchema . add ( jSplitPaneReferenceSchema , new
GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jSplitPaneReferenceSchema . add ( jScrollPaneReferenceSchemaTemplate , JSplitPane . LEFT ) ;
jSplitPaneReferenceSchema . add ( jPanelReferenceSchemaEditor ,
JSplitPane . RIGHT ) ;
jScrollPaneReferenceSchemaTemplate . getViewport ( ) . add ( jTextAreaReferenceSchemaTemplate ) ;
jSplitPaneModelSyntax . add ( jScrollPaneModelSyntaxFiles , JSplitPane . LEFT ) ;
jSplitPaneModelSyntax . add ( jScrollPaneModelSyntax , JSplitPane . RIGHT ) ;
jPanelExtensionSyntax . add ( jPanelModelSyntaxButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneModelSyntax . getViewport ( ) . add ( jTextAreaModelSyntax ) ;
jScrollPaneModelSyntaxFiles . getViewport ( ) . add ( jListModelSyntaxFiles ) ;
jPanelExtensionSyntax . add ( jSplitPaneModelSyntax ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jSplitPaneSemantics . add ( jScrollPaneVerbalSemantics , JSplitPane . TOP ) ;
jSplitPaneSemantics . add ( jScrollPaneVerbalAmnSemantics ,
JSplitPane . BOTTOM ) ;
jPanelSemantics . add ( jLabelTranslator2AmnVersion ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jTextFieldTranslator2AmnVersion ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneVerbalAmnSemantics . getViewport ( ) . add (
jTextAreaVerbalAmnSemantics ) ;
jScrollPaneVerbalSemantics . getViewport ( ) . add ( jTextAreaVerbalSemantics ) ;
jPanelSemantics . add ( jPanelSemanticsButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . SOUTHWEST , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemanticsButtons . add ( jButtonUpdateAmnSemantics ) ;
jPanelSemantics . add ( jSplitPaneSemantics ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelReferenceSchema . add ( jPanelVODButtons ,
new
GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
this . getContentPane ( ) . add ( jTabbedPaneActivities ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . SOUTHWEST , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jLabelExtendedModel ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jScrollPaneExtensionDescription ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jLabelTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jPanelRCButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jTextFieldShortTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jTextFieldExtendedModel ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jButtonExploreExtension ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jTabbedPaneActivities . add ( jPanelReferenceSchema ,
" ) ;
for ( int i = <num> ; i <= <num> ; i ++ ) {
jTabbedPaneActivities . setEnabledAt ( i , false ) ;
}
setDividersLocations ( ) ;
}
GridBagLayout gridBagLayoutMR = new GridBagLayout ( ) ;
JTabbedPane jTabbedPaneActivities = new JTabbedPane ( ) ;
JPanel jPanelRegCard = new JPanel ( ) ;
GridBagLayout gridBagLayoutRC = new GridBagLayout ( ) ;
JPanel jPanelExtensionSyntax = new JPanel ( ) ;
GridBagLayout gridBagLayoutMS = new GridBagLayout ( ) ;
JLabel jLabelTitle = new JLabel ( ) ;
JTextField jTextFieldShortTitle = new JTextField ( ) ;
JPanel jPanelRCButtons = new JPanel ( ) ;
JButton jButtonUpdateRegCard = new JButton ( ) ;
FlowLayout flowLayoutRCB = new FlowLayout ( ) ;
JButton jButtonDeleteCard = new JButton ( ) ;
TitledBorder titledBorder3 = new TitledBorder ( " ) ;
JPanel jPanelModelSyntaxButtons = new JPanel ( ) ;
JButton jButtonBrowseModelSyntaxFile = new JButton ( ) ;
JButton jButtonUpdateModelSyntax = new JButton ( ) ;
JPanel jPanelSemantics = new JPanel ( ) ;
GridBagLayout gridBagLayoutAMNS = new GridBagLayout ( ) ;
JPanel jPanelSemanticsButtons = new JPanel ( ) ;
JButton jButtonUpdateAmnSemantics = new JButton ( ) ;
JSplitPane jSplitPaneSemantics = new JSplitPane ( ) ;
JScrollPane jScrollPaneVerbalSemantics = new JScrollPane ( ) ;
JTextArea jTextAreaVerbalSemantics = new JTextArea ( ) ;
JPanel jPanelReferenceSchema = new JPanel ( ) ;
GridBagLayout gridBagLayoutVOD = new GridBagLayout ( ) ;
JScrollPane jScrollPaneReferenceSchemaTemplate = new JScrollPane ( ) ;
JPanel jPanelVODButtons = new JPanel ( ) ;
JButton jButtonCreateReferenceSchemaTemplate = new JButton ( ) ;
JTextArea jTextAreaReferenceSchemaTemplate = new JTextArea ( ) ;
JButton jButtonVODUpdate = new JButton ( ) ;
JButton jButtonVODEdit = new JButton ( ) ;
JSplitPane jSplitPaneReferenceSchema = new JSplitPane ( ) ;
JPanel jPanelReferenceSchemaEditor = new JPanel ( ) ;
JSplitPane jSplitPaneModelSyntax = new JSplitPane ( ) ;
JScrollPane jScrollPaneModelSyntaxFiles = new JScrollPane ( ) ;
JScrollPane jScrollPaneModelSyntax = new JScrollPane ( ) ;
JTextArea jTextAreaModelSyntax = new JTextArea ( ) ;
TextFileJList jListModelSyntaxFiles = new TextFileJList ( jTextAreaModelSyntax ) ;
JScrollPane jScrollPaneVerbalAmnSemantics = new JScrollPane ( ) ;
JTextArea jTextAreaVerbalAmnSemantics = new JTextArea ( ) ;
JLabel jLabelTranslator2AmnVersion = new JLabel ( ) ;
JTextField jTextFieldTranslator2AmnVersion = new JTextField ( ) ;
JScrollPane jScrollPaneExtensionDescription = new JScrollPane ( ) ;
JTextArea jTextAreaExtensionDescription = new JTextArea ( ) ;
JButton jButtonDeleteModelSyntaxFile = new JButton ( ) ;
JLabel jLabelExtendedModel = new JLabel ( ) ;
JTextField jTextFieldExtendedModel = new JTextField ( ) ;
JButton jButtonExploreExtension = new JButton ( ) ;
JButton jButtonExportSyntaxFile = new JButton ( ) ;
JButton jButtonBrowseReferenceSchema = new JButton ( ) ;
BorderLayout borderLayoutSchemaEditor = new BorderLayout ( ) ;
public void this_windowClosing ( WindowEvent e ) {
}
public void jButtonExploreExtension_actionPerformed ( ActionEvent e ) {
exploreExtension ( ) ;
}
public void jButtonUpdateRegCard_actionPerformed ( ActionEvent e ) {
try {
this . updateExtensionRegCard ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonDeleteCard_actionPerformed ( ActionEvent e ) {
try {
this . removeExtension ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonBrowseModelSyntaxFile_actionPerformed ( ActionEvent e ) {
try {
jListModelSyntaxFiles . addFile ( " , " ) ;
} catch ( FileNotFoundException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonDeleteModelSyntaxFile_actionPerformed ( ActionEvent e ) {
jListModelSyntaxFiles . removeSelectedFile ( ) ;
}
public void jButtonUpdateModelSyntax_actionPerformed ( ActionEvent e ) {
try {
updateAbstractSyntax ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonUpdateAmnSemantics_actionPerformed ( ActionEvent e ) {
try {
updateSemantics ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonCreateReferenceSchemaTemplate_actionPerformed ( ActionEvent e ) {
try {
createReferenceSchemaTemplate ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( SdfDefinitionException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( SDF2RSException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( ReferenceSchemaModelException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( RecognitionException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( java . io . IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonVODEdit_actionPerformed ( ActionEvent e ) {
try {
editReferenceSchema ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonBrowseReferenceSchema_actionPerformed ( ActionEvent e ) {
try {
browseReferenceSchema ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonVODUpdate_actionPerformed ( ActionEvent e ) {
try {
updateReferenceSchema ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonExportSyntaxFile_actionPerformed ( ActionEvent e ) {
try {
jListModelSyntaxFiles . exportSelectedFile ( " , " ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jListModelSyntaxFiles_mouseClicked ( MouseEvent e ) {
jListModelSyntaxFiles . updateLastSelectedContent ( ) ;
}
private void setDividersLocations ( ) {
jSplitPaneModelSyntax . setDividerLocation ( <num> ) ;
jSplitPaneSemantics . setDividerLocation ( <num> ) ;
jSplitPaneReferenceSchema . setDividerLocation ( <num> ) ;
}
private Logger logger ;
private DB db ;
private ExtensionRegDef extension ;
private SchemaEditorGui schemaEditor = null ;
private void createNewExtension ( ) throws SQLException {
extension = db . <unk> ( ) ;
}
private void openExtension ( ) throws SQLException {
jTextFieldShortTitle . setText ( extension . get_name ( ) ) ;
jTextAreaExtensionDescription . setText ( extension . get_description ( ) ) ;
jListModelSyntaxFiles . fillFromFileContainerSet ( extension . get_abstrSyntax ( ) ) ;
jTextAreaVerbalSemantics . setText ( extension . <unk> ( ) ) ;
jTextAreaVerbalAmnSemantics . setText ( extension . get_verbAmnSem ( ) ) ;
jTextFieldTranslator2AmnVersion . setText ( extension . get_transToAmn ( ) ) ;
jTextAreaReferenceSchemaTemplate . setText ( extension . get_refSchTmpl ( ) ) ;
if ( extension . get_extending ( ) != null ) {
jTextFieldExtendedModel . setText ( extension . get_extending ( ) . get_name ( ) ) ;
}
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
if ( extension . get_abstrSyntax ( ) . size ( ) != <num> ) {
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
}
if ( extension . get_refSchema ( ) != null ) {
showReferenceSchemaEditor ( ) ;
}
}
private void updateExtensionRegCard ( ) throws SQLException {
if ( jTextFieldShortTitle . getText ( ) . trim ( ) . compareTo ( " ) != <num> ) {
if ( extension == null ) createNewExtension ( ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
} else {
JOptionPane . showMessageDialog ( null , " ) ;
return ;
}
extension . set_name ( jTextFieldShortTitle . getText ( ) ) ;
extension . set_description ( jTextAreaExtensionDescription . getText ( ) ) ;
}
private void removeExtension ( ) throws SQLException {
int answer = JOptionPane . showConfirmDialog (
null ,
" + jTextFieldShortTitle . getText ( ) + " ,
" ,
JOptionPane . YES_NO_OPTION ) ;
if ( answer == <num> ) {
RepositoryCleaner . delete ( extension ) ;
this . dispose ( ) ;
}
}
private void updateAbstractSyntax ( ) throws SQLException {
jListModelSyntaxFiles . loadFilesToRepository ( db , extension . get_abstrSyntax ( ) ) ;
if ( extension . get_abstrSyntax ( ) . size ( ) != <num> ) {
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
}
}
private void updateSemantics ( ) throws SQLException {
extension . <unk> ( jTextAreaVerbalSemantics . getText ( ) ) ;
extension . set_verbAmnSem ( jTextAreaVerbalAmnSemantics . getText ( ) ) ;
extension . <unk> ( jTextFieldTranslator2AmnVersion . getText ( ) ) ;
}
private void createReferenceSchemaTemplate ( ) throws SQLException , SdfDefinitionException ,
SDF2RSException , ReferenceSchemaModelException , java . io . IOException ,
RecognitionException {
SdfCreator sdfCreator = new SdfCreator ( ) ;
Module module = null ;
Set < String > terminals = null ;
for ( int i = <num> ; i < jListModelSyntaxFiles . getModel ( ) . getSize ( ) ; i ++ ) {
TextFile file = ( TextFile ) jListModelSyntaxFiles . getModel ( ) . getElementAt ( i ) ;
Reader reader ;
reader = new StringReader ( file . getContent ( ) ) ;
terminals = StringChooserDialog . showStringChooserDialog ( " , ( new SdfCreator ( ) ) . getSortNames ( reader ) ) ;
reader . close ( ) ;
reader = new StringReader ( file . getContent ( ) ) ;
module = sdfCreator . processSdf ( reader , terminals ) ;
reader . close ( ) ;
}
FormattingWriter writer = new DefaultFormattingWriter ( new StringWriter ( ) , <num> , " , " ) ;
SDF2RS sdf2so = new SDF2RS ( module , writer ) ;
sdf2so . generateSchema ( ) ;
jTextAreaReferenceSchemaTemplate . setText ( writer . toString ( ) ) ;
}
private void editReferenceSchema ( ) throws SQLException {
StringReader reader = new StringReader ( jTextAreaReferenceSchemaTemplate . getText ( ) ) ;
ModuleDef module ;
closeReferenceSchemaEditor ( ) ;
if ( extension . get_refSchema ( ) != null ) {
RepositoryCleaner . delete ( extension . get_refSchema ( ) ) ;
}
module = ( new SynthesisLoader ( ) ) . loadFile ( db , reader , false ) ;
extension . set_refSchema ( module ) ;
updateReferenceSchemaImport ( ) ;
showReferenceSchemaEditor ( ) ;
}
private void browseReferenceSchema ( ) throws SQLException {
SchemaDef unifierSchemaDef = null ;
ModuleDef module = null ;
Set schemas ;
schemas = db . get_schema ( new Query ( new Like ( SchemaDef . _name , " ) ) ) ;
for ( Object obj : schemas ) {
unifierSchemaDef = ( SchemaDef ) obj ;
}
if ( unifierSchemaDef == null )
logger . info ( " ) ;
else {
module = ( ModuleDef ) ElementChooserDialog . showElementChooserDialog ( " , unifierSchemaDef . get_modules ( ) ) ;
if ( module != null )
extension . set_refSchema ( module ) ;
}
updateReferenceSchemaImport ( ) ;
showReferenceSchemaEditor ( ) ;
}
private void closeReferenceSchemaEditor ( ) {
if ( schemaEditor != null ) {
schemaEditor . end ( ) ;
jPanelReferenceSchemaEditor . remove ( schemaEditor ) ;
}
logger . info ( " ) ;
}
private void showReferenceSchemaEditor ( ) throws SQLException {
SchemaEditorGui gui = null ;
ModuleDef refSchema = null ;
refSchema = extension . get_refSchema ( ) ;
if ( refSchema != null ) {
closeReferenceSchemaEditor ( ) ;
gui = new SchemaEditorGui ( ) ;
schemaEditor = gui ;
jPanelReferenceSchemaEditor . add ( " , gui ) ;
gui . start ( refSchema ) ;
validate ( ) ;
repaint ( ) ;
}
}
private void updateReferenceSchema ( ) throws SQLException {
extension . set_refSchTmpl ( jTextAreaReferenceSchemaTemplate . getText ( ) ) ;
}
public void showExtendedModel ( ) throws SQLException {
if ( extension != null && extension . get_extending ( ) != null ) {
jTextFieldExtendedModel . setText ( extension . get_extending ( ) . get_name ( ) ) ;
updateReferenceSchemaImport ( ) ;
}
}
private void updateReferenceSchemaImport ( ) throws SQLException {
ModuleDef extendingRefSchema = null , extendedRefSchema = null ;
if ( extension != null && extension . get_extending ( ) != null ) {
extendingRefSchema = extension . get_refSchema ( ) ;
extendedRefSchema = extension . get_extending ( ) . get_refSchema ( ) ;
if ( extendingRefSchema != null && extendedRefSchema != null ) {
extendingRefSchema . get_imports ( ) . add ( extendedRefSchema ) ;
}
}
}
private void exploreExtension ( ) {
ExtensionExplorer explorer ;
if ( extension == null ) {
JOptionPane . showMessageDialog ( null , " ) ;
return ;
}
logger . info ( " ) ;
explorer = new ExtensionExplorer ( this , extension ) ;
}
}
class ExtensionRegistrar_jButtonBrowseReferenceSchema_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonBrowseReferenceSchema_actionAdapter (
ExtensionRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonBrowseReferenceSchema_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_this_windowAdapter extends WindowAdapter {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_this_windowAdapter ( ExtensionRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void windowClosing ( WindowEvent e ) {
adaptee . this_windowClosing ( e ) ;
}
}
class ExtensionRegistrar_jListModelSyntaxFiles_mouseAdapter extends
MouseAdapter {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jListModelSyntaxFiles_mouseAdapter ( ExtensionRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void mouseClicked ( MouseEvent e ) {
adaptee . jListModelSyntaxFiles_mouseClicked ( e ) ;
}
}
class ExtensionRegistrar_jButtonExportSyntaxFile_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonExportSyntaxFile_actionAdapter ( ExtensionRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonExportSyntaxFile_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_jButtonVODUpdate_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonVODUpdate_actionAdapter ( ExtensionRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonVODUpdate_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_jButtonVODEdit_actionAdapter implements ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonVODEdit_actionAdapter ( ExtensionRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonVODEdit_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_jButtonCreateReferenceSchemaTemplate_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonCreateReferenceSchemaTemplate_actionAdapter ( ExtensionRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonCreateReferenceSchemaTemplate_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_jButtonUpdateAmnSemantics_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonUpdateAmnSemantics_actionAdapter (
ExtensionRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonUpdateAmnSemantics_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_jButtonUpdateModelSyntax_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonUpdateModelSyntax_actionAdapter (
ExtensionRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonUpdateModelSyntax_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_jButtonDeleteModelSyntaxFile_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonDeleteModelSyntaxFile_actionAdapter (
ExtensionRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonDeleteModelSyntaxFile_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_jButtonBrowseModelSyntaxFile_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonBrowseModelSyntaxFile_actionAdapter (
ExtensionRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonBrowseModelSyntaxFile_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_jButtonDeleteCard_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonDeleteCard_actionAdapter ( ExtensionRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonDeleteCard_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_jButtonUpdateRegCard_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonUpdateRegCard_actionAdapter ( ExtensionRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonUpdateRegCard_actionPerformed ( e ) ;
}
}
class ExtensionRegistrar_jButtonExploreExtension_actionAdapter implements
ActionListener {
private ExtensionRegistrar adaptee ;
ExtensionRegistrar_jButtonExploreExtension_actionAdapter ( ExtensionRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonExploreExtension_actionPerformed ( e ) ;
}
}
package unifier ;
import unifier . similarity . Similarity ;
import java . util . Set ;
import java . util . HashSet ;
import unifier . similarity . Element ;
import unifier . similarity . Association ;
import java . io . Reader ;
import unifier . asfsdf . Module ;
import unifier . asfsdf . SdfCreator ;
import java . io . FileReader ;
import java . io . FileNotFoundException ;
import unifier . asfsdf . SdfDefinitionException ;
import org . antlr . runtime . RecognitionException ;
import java . io . IOException ;
import unifier . util . FormattingWriter ;
import unifier . util . DefaultFormattingWriter ;
import unifier . asfsdf . Variable ;
import unifier . asfsdf . SortName ;
import unifier . asfsdf . Declaration ;
import unifier . asfsdf . AsfSsdfFormattingWriter ;
public class <unk> {
public static void main ( String [ ] args ) throws FileNotFoundException ,
SdfDefinitionException , RecognitionException , IOException ,
TranslatorTemplateConstructionException {
Set < Similarity > sims = new HashSet < Similarity > ( ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " , <num> ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " , <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " , <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
for ( Similarity s : sims ) System . out . println ( s ) ;
Reader r1 , r2 , r3 ;
Module source , target ;
SdfCreator c1 = new SdfCreator ( ) , c2 = new SdfCreator ( ) ;
Set < String > terminals = new HashSet < String > ( ) ;
FormattingWriter w1 , w2 ;
TranslatorTemplateConstructor constructor ;
AsfSsdfFormattingWriter asfw1 , asfw2 ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
r1 = new FileReader ( " ) ;
r2 = new FileReader ( " ) ;
r3 = new FileReader ( " ) ;
source = c1 . processSdf ( r2 , terminals ) ;
c2 . processSdf ( r1 , terminals ) ;
target = c2 . processSdf ( r3 , terminals ) ;
asfw1 = new AsfSsdfFormattingWriter ( DefaultFormattingWriter . createSystemOutWriter ( ) ) ;
asfw2 = new AsfSsdfFormattingWriter ( DefaultFormattingWriter . createSystemOutWriter ( ) ) ;
w1 = DefaultFormattingWriter . createFileWriter ( " ) ;
w2 = DefaultFormattingWriter . createFileWriter ( " ) ;
constructor = new TranslatorTemplateConstructor ( source , target , sims , w1 , w2 ) ;
constructor . writeTranslatorTemplate ( ) ;
w1 . flush ( ) ;
w2 . flush ( ) ;
}
private static void info ( String s ) {
System . out . println ( s ) ;
}
}
package unifier ;
import unifier . util . FormattingWriter ;
import unifier . asfsdf . Module ;
import java . util . Set ;
import javax . swing . ListSelectionModel ;
import unifier . util . ChooserDialog ;
import javax . swing . DefaultListCellRenderer ;
import unifier . util . StringHelper ;
import java . util . logging . Logger ;
import unifier . asfsdf . Sort ;
import unifier . asfsdf . SdfDefinitionException ;
import unifier . asfsdf . Terminal ;
import unifier . SDF2RSException ;
import unifier . asfsdf . Alternative ;
import unifier . asfsdf . Nonterminal ;
import unifier . asfsdf . AbstractSortDef ;
import unifier . asfsdf . Declaration ;
import unifier . rsm . Type ;
import unifier . rsm . ADT ;
import unifier . rsm . ReferenceSchemaModelException ;
import unifier . asfsdf . Enumeration ;
import unifier . util . MutableInteger ;
import unifier . asfsdf . DeclarationElement ;
import unifier . asfsdf . Optional ;
import unifier . rsm . AssociationMetaclass ;
import unifier . rsm . Attribute ;
import unifier . asfsdf . List ;
import unifier . asfsdf . ListMultiplicity ;
import unifier . rsm . SetType ;
public class SDF2RS {
public SDF2RS ( Module syntax , FormattingWriter writer ) {
this . syntax = syntax ;
this . writer = writer ;
module = new unifier . rsm . Module ( ) ;
}
private Logger logger = Logger . getLogger ( " ) ;
private FormattingWriter writer ;
private unifier . rsm . Module module ;
private Module syntax ;
public void generateSchema ( ) throws SdfDefinitionException , SDF2RSException , ReferenceSchemaModelException {
logger . info ( " + syntax . getName ( ) ) ;
module . setName ( StringHelper . getLastComponentOfPath ( syntax . getName ( ) ) + " ) ;
generateTypes ( ) ;
module . specification ( writer ) ;
logger . info ( " ) ;
}
private void generateTypes ( ) throws SdfDefinitionException , SDF2RSException ,
ReferenceSchemaModelException {
for ( String sortName : syntax . getSortNames ( ) ) {
Sort sort = syntax . getSort ( sortName ) ;
generateType ( sort ) ;
}
}
private Type generateType ( Sort sort ) throws SdfDefinitionException , SDF2RSException , ReferenceSchemaModelException {
Type result ;
if ( sort == null ) return null ;
logger . info ( " + sort . getName ( ) ) ;
result = module . getType ( sort . getName ( ) ) ;
if ( result != null ) return result ;
if ( sort . isTerminal ( ) ) {
Type type = new ADT ( ) ;
type . setName ( sort . getName ( ) ) ;
module . addType ( type ) ;
result = type ;
logger . info ( " + type . getName ( ) ) ;
} else
if ( sort . isEnumerationSort ( ) ) {
result = generateEnum ( sort ) ;
} else
if ( sort . isAlternativeSort ( ) ) {
result = analizeAlternativeSort ( sort ) ;
} else
if ( ! sort . isListSort ( ) ) {
result = analizeDeclarationSort ( sort ) ;
}
return result ;
}
private unifier . rsm . Enum generateEnum ( Sort sort ) throws SDF2RSException , SdfDefinitionException , ReferenceSchemaModelException {
if ( ! sort . isEnumerationSort ( ) )
throw new SDF2RSException ( " ) ;
unifier . rsm . Enum result = new unifier . rsm . Enum ( ) ;
Enumeration sortDef = ( Enumeration ) ( ( Nonterminal ) sort ) . getDefinition ( ) ;
result . setName ( sort . getName ( ) ) ;
for ( String value : sortDef . getElements ( ) ) result . addValue ( value ) ;
module . addType ( result ) ;
logger . info ( " + result . getName ( ) ) ;
return result ;
}
private ADT analizeAlternativeSort ( Sort sort ) throws SDF2RSException , SdfDefinitionException , ReferenceSchemaModelException {
if ( ! sort . isAlternativeSort ( ) )
throw new SDF2RSException ( " ) ;
Alternative alt = ( Alternative ) ( ( Nonterminal ) sort ) . getDefinition ( ) ;
ADT type = new ADT ( ) ;
type . setName ( sort . getName ( ) ) ;
module . addType ( type ) ;
logger . info ( " + type . getName ( ) ) ;
for ( Object obj : alt . getElements ( ) ) {
AbstractSortDef sortDef = ( AbstractSortDef ) obj ;
if ( sortDef . isDeclaration ( ) && ( ( Declaration ) sortDef ) . consistsOfOneSortName ( ) ) {
String subsortName = ( ( Declaration ) sortDef ) . getNameIfSimple ( ) ;
Sort subsort = syntax . getSort ( subsortName ) ;
Type subtype = generateType ( subsort ) ;
if ( subtype != null && subtype . isADT ( ) )
( ( ADT ) subtype ) . addSupertype ( type ) ;
} else {
logger . info ( " ) ;
}
}
return type ;
}
private ADT analizeDeclarationSort ( Sort sort ) throws SDF2RSException , SdfDefinitionException , ReferenceSchemaModelException {
if ( ! sort . isDeclarationSort ( ) )
throw new SDF2RSException ( " ) ;
Declaration decl = ( Declaration ) ( ( Nonterminal ) sort ) . getDefinition ( ) ;
ADT type = new ADT ( ) ;
MutableInteger assocNumber = new MutableInteger ( <num> ) ;
type . setName ( sort . getName ( ) ) ;
module . addType ( type ) ;
logger . info ( " + type . getName ( ) ) ;
analizeDeclaration ( decl , type , false , assocNumber ) ;
return type ;
}
private void analizeDeclaration ( Declaration decl , ADT type , boolean optional , MutableInteger assocNumber ) throws
SdfDefinitionException , ReferenceSchemaModelException , SDF2RSException {
logger . info ( " + type . getName ( ) ) ;
if ( decl . isSimple ( ) ) logger . info ( decl . getNameIfSimple ( ) ) ;
String assocName = " ;
int minCard = <num> ;
int maxCard = <num> ;
AssociationMetaclass category ;
Attribute assoc ;
Type attributeType = null ;
if ( decl . consistsOfOneSortName ( ) && ! optional ) {
String subsortName = decl . getNameIfSimple ( ) ;
logger . info ( " + subsortName ) ;
Sort subsort = syntax . getSort ( subsortName ) ;
Type subtype = generateType ( subsort ) ;
if ( subtype != null && subtype . isADT ( ) )
( ( ADT ) subtype ) . addSupertype ( type ) ;
return ;
}
if ( optional ) minCard = <num> ; else minCard = <num> ;
for ( DeclarationElement elm : decl . getElements ( ) ) {
logger . info ( " + type . getName ( ) ) ;
if ( elm . isLiteral ( ) ) {
assocName = assocName + elm . getNameIfSimple ( ) ;
} else
if ( elm . isOptional ( ) && ( ( Optional ) elm ) . originalSortIsDeclaration ( ) ) {
Declaration inner = ( Declaration ) ( ( Optional ) elm ) . getOriginalSort ( ) ;
analizeDeclaration ( inner , type , true , assocNumber ) ;
} else
if ( elm . isList ( ) || elm . isSortName ( ) ) {
if ( ! elm . isSimple ( ) ) break ;
if ( syntax . getSort ( elm . getNameIfSimple ( ) ) == null ) {
logger . info ( " + elm . getNameIfSimple ( ) + " ) ;
break ;
}
if ( assocName . compareTo ( " ) == <num> || ! StringHelper . isIdentifier ( assocName ) ) {
assocNumber . inc ( ) ;
assocName = type . getName ( ) + " + assocNumber ;
}
if ( elm . isList ( ) ) {
maxCard =  <num> ;
attributeType = generateType ( syntax . getSort ( elm . getNameIfSimple ( ) ) ) ;
if ( ( ( List ) elm ) . getMultiplicity ( ) . equals ( ListMultiplicity . AT_LEAST_ZERO_TIME ) ) minCard = <num> ;
} else
if ( elm . isSortName ( ) && syntax . getSort ( elm . getNameIfSimple ( ) ) . isListSort ( ) ) {
maxCard =  <num> ;
Nonterminal sort = ( Nonterminal ) syntax . getSort ( elm . getNameIfSimple ( ) ) ;
Declaration inner = ( Declaration ) sort . getDefinition ( ) ;
List list = ( List ) inner . getElements ( ) . iterator ( ) . next ( ) ;
attributeType = generateType ( syntax . getSort ( list . getNameIfSimple ( ) ) ) ;
if ( list . getMultiplicity ( ) . equals ( ListMultiplicity . AT_LEAST_ZERO_TIME ) ) minCard = <num> ;
} else
if ( elm . isSortName ( ) && ! syntax . getSort ( elm . getNameIfSimple ( ) ) . isListSort ( ) ) {
maxCard = <num> ;
attributeType = generateType ( syntax . getSort ( elm . getNameIfSimple ( ) ) ) ;
}
if ( maxCard ==  <num> )
attributeType = new SetType ( attributeType ) ;
category = new AssociationMetaclass ( assocName + " , minCard , maxCard , <num> , <num> ) ;
module . addClass ( category ) ;
assoc = new Attribute ( assocName , attributeType , category ) ;
type . addAttribute ( assoc ) ;
assocName = " ;
}
else logger . info ( " ) ;
}
}
}
package unifier . util ;
public class MutableInteger {
private int value ;
public MutableInteger ( int value ) {
this . value = value ;
}
public void setValue ( int value ) {
this . value = value ;
}
public int getValue ( ) {
return value ;
}
public String toString ( ) {
return " + value ;
}
public void inc ( ) {
value ++ ;
}
public boolean equals ( Object obj ) {
boolean result = false ;
if ( obj instanceof MutableInteger && ( ( MutableInteger ) obj ) . getValue ( ) == value )
return true ;
return result ;
}
public int hashCode ( ) {
return value ;
}
}
package unifier . util ;
import java . io . IOException ;
public class BrowserControl {
public static void displayURL ( String url ) {
boolean windows = isWindowsPlatform ( ) ;
String cmd = null ;
try {
if ( windows ) {
cmd = WIN_PATH + " + WIN_FLAG + " + url ;
Process p = Runtime . getRuntime ( ) . exec ( cmd ) ;
} else {
cmd = UNIX_PATH + " + UNIX_FLAG + " + url + " ;
Process p = Runtime . getRuntime ( ) . exec ( cmd ) ;
try {
int exitCode = p . waitFor ( ) ;
if ( exitCode != <num> ) {
cmd = UNIX_PATH + " + url ;
p = Runtime . getRuntime ( ) . exec ( cmd ) ;
}
} catch ( InterruptedException x ) {
System . err . println ( " +
cmd + " ) ;
System . err . println ( " + x ) ;
}
}
} catch ( IOException x ) {
System . err . println ( " + cmd ) ;
System . err . println ( " + x ) ;
}
}
public static boolean isWindowsPlatform ( ) {
String os = System . getProperty ( " ) ;
if ( os != null && os . startsWith ( WIN_ID ) )
return true ;
else
return false ;
}
private static final String WIN_ID = " ;
private static final String WIN_PATH = " ;
private static final String WIN_FLAG = " ;
private static final String UNIX_PATH = " ;
private static final String UNIX_FLAG = " ;
}
package unifier . util ;
import unifier . asfsdf . Module ;
import meta . AbstrModelRegDef ;
import java . io . Reader ;
import java . util . Set ;
import java . io . StringReader ;
import unifier . asfsdf . SdfCreator ;
import javax . swing . DefaultListModel ;
import meta . FileContainerDef ;
import java . util . HashSet ;
import java . sql . SQLException ;
import java . io . IOException ;
import unifier . asfsdf . SdfDefinitionException ;
import org . antlr . runtime . RecognitionException ;
public class SdfForModelSyntaxCreator {
public static Module createSdf ( AbstrModelRegDef model ) throws SQLException ,
IOException , SdfDefinitionException , RecognitionException {
Set < TextFile > grammar = new HashSet < TextFile > ( ) ;
SdfCreator sdfCreator = new SdfCreator ( ) ;
Module module = null ;
Set < String > terminals = null ;
for ( Object fc : model . get_abstrSyntax ( ) ) {
if ( fc instanceof FileContainerDef ) {
FileContainerDef fileCont = ( FileContainerDef ) fc ;
grammar . add ( new TextFile ( fileCont . get_name ( ) , fileCont . get_file ( ) ) ) ;
}
}
for ( TextFile file : grammar ) {
Reader reader ;
reader = new StringReader ( file . getContent ( ) ) ;
terminals = StringChooserDialog . showStringChooserDialog ( " , ( new SdfCreator ( ) ) . getSortNames ( reader ) ) ;
reader . close ( ) ;
reader = new StringReader ( file . getContent ( ) ) ;
module = sdfCreator . processSdf ( reader , terminals ) ;
reader . close ( ) ;
}
return module ;
}
}
package unifier . asfsdf ;
import java . util . Map ;
import java . util . HashMap ;
public class Terminal extends Sort {
public Terminal ( ) { }
public Terminal ( String name ) {
this . name = name ;
}
public boolean isTerminal ( ) {
return true ;
}
public boolean isListSort ( ) {
return false ;
}
public boolean isEnumerationSort ( ) {
return false ;
}
public boolean isAlternativeSort ( ) throws SdfDefinitionException {
return false ;
}
public boolean isDeclarationSort ( ) throws SdfDefinitionException {
return false ;
}
public Terminal setName ( String name ) {
this . name = name ;
return this ;
}
public String toTerm ( ) {
return this . name ;
}
public Map < Variable , Integer > getVariableInstances ( ) {
Map < Variable , Integer > map = new HashMap < Variable , Integer > ( ) ;
map . put ( new Variable ( name , new Declaration ( new SortName ( name ) ) ) , <num> ) ;
return map ;
}
}
package unifier . asfsdf ;
public class Variable extends Named {
private Declaration sort ;
public Variable ( String name , Declaration sort ) {
this . name = name ;
this . sort = sort ;
}
public Variable ( Declaration sort ) throws SdfDefinitionException {
this . sort = sort ;
if ( sort . isSimple ( ) ) this . name = sort . getVariableName ( ) ;
else throw new SdfDefinitionException ( " ) ;
}
public Declaration getDeclaration ( ) {
return sort ;
}
public Variable <unk> ( Declaration sort ) {
this . sort = sort ;
return this ;
}
public Variable setName ( String name ) {
this . name = name ;
return this ;
}
public boolean equals ( Object obj ) {
if ( ! ( obj instanceof Variable ) )
return false ;
else
return ( this . name . compareTo ( ( ( Variable ) obj ) . getName ( ) ) == <num> ) ;
}
public int hashCode ( ) {
return name . hashCode ( ) ;
}
}
package unifier . asfsdf ;
import java . util . List ;
import java . util . ArrayList ;
public class Alternative extends AbstractSortDef {
private List < AbstractSortDef > elements = new ArrayList < AbstractSortDef > ( ) ;
public List getElements ( ) {
return elements ;
}
public Alternative addElement ( AbstractSortDef sort ) {
elements . add ( sort ) ;
return this ;
}
public boolean isDeclaration ( ) {
return false ;
}
public boolean isAlternative ( ) {
return true ;
}
public boolean isEnumeration ( ) {
return false ;
}
public boolean isList ( ) {
return false ;
}
}
package unifier . asfsdf ;
import java . util . Map ;
import java . util . HashMap ;
public class Nonterminal extends Sort {
private AbstractSortDef definition = null ;
public boolean isTerminal ( ) {
return false ;
}
public boolean isListSort ( ) throws SdfDefinitionException {
if ( definition != null ) {
return definition . isList ( ) ;
} else {
throw new SdfDefinitionException ( " + this . name + " ) ;
}
}
public boolean isEnumerationSort ( ) throws SdfDefinitionException {
if ( definition != null ) {
return definition . isEnumeration ( ) ;
} else {
throw new SdfDefinitionException ( " + this . name + " ) ;
}
}
public boolean isAlternativeSort ( ) throws SdfDefinitionException {
if ( definition != null ) {
return definition . isAlternative ( ) ;
} else {
throw new SdfDefinitionException ( " + this . name + " ) ;
}
}
public boolean isDeclarationSort ( ) throws SdfDefinitionException {
if ( definition != null ) {
return definition . isDeclaration ( ) ;
} else {
throw new SdfDefinitionException ( " + this . name + " ) ;
}
}
public Nonterminal setName ( String name ) {
this . name = name ;
return this ;
}
public AbstractSortDef getDefinition ( ) {
return definition ;
}
public Nonterminal setDefinition ( AbstractSortDef def ) {
definition = def ;
return this ;
}
public String toTerm ( ) throws SdfDefinitionException {
String result = " ;
if ( definition != null ) {
if ( definition . isAlternative ( ) || definition . isEnumeration ( ) ) {
result = name ;
} else
if ( definition . isDeclaration ( ) ) {
result = ( ( Declaration ) definition ) . toTerm ( ) ;
}
}
return result ;
}
public Map < Variable , Integer > getVariableInstances ( ) throws SdfDefinitionException {
Map < Variable , Integer > map = null ;
if ( definition != null ) {
if ( definition . isAlternative ( ) || definition . isEnumeration ( ) ) {
map = new HashMap < Variable , Integer > ( ) ;
map . put ( new Variable ( name , new Declaration ( new SortName ( name ) ) ) , <num> ) ;
} else
if ( definition . isDeclaration ( ) ) {
map = ( ( Declaration ) definition ) . getVariableInstances ( ) ;
}
}
return map ;
}
}
package unifier . sdfparser ;
import org . antlr . runtime . * ;
import java . util . Stack ;
import java . util . List ;
import java . util . ArrayList ;
public class SdfLexer extends Lexer {
public static final int STAR = <num> ;
public static final int LETTER = <num> ;
public static final int LBRACE = <num> ;
public static final int ATTRIBUTE = <num> ;
public static final int CONTEXTFREE = <num> ;
public static final int SEPARATOR = <num> ;
public static final int ID = <num> ;
public static final int MARKEDSYMBOL = <num> ;
public static final int EOF =  <num> ;
public static final int LPAREN = <num> ;
public static final int SORTS = <num> ;
public static final int LBRACKET = <num> ;
public static final int MULTIPLICITY = <num> ;
public static final int SYNTAX = <num> ;
public static final int RPAREN = <num> ;
public static final int GREATER = <num> ;
public static final int SLASH = <num> ;
public static final int EXPORTS = <num> ;
public static final int COMMA = <num> ;
public static final int LEFT = <num> ;
public static final int ORIGIN = <num> ;
public static final int PRODUCTION = <num> ;
public static final int DEFINITION = <num> ;
public static final int IMP = <num> ;
public static final int PLUS = <num> ;
public static final int DIGIT = <num> ;
public static final int RBRACKET = <num> ;
public static final int COMPOUNDSYMBOL = <num> ;
public static final int STARTSYMBOLS = <num> ;
public static final int SMALLLETTER = <num> ;
public static final int RBRACE = <num> ;
public static final int CAPITALLETTER = <num> ;
public static final int WHITESPACE = <num> ;
public static final int SORT = <num> ;
public static final int UNDERSCORE = <num> ;
public static final int RIGHT = <num> ;
public static final int MINUS = <num> ;
public static final int MODULE = <num> ;
public static final int Tokens = <num> ;
public static final int LIST = <num> ;
public static final int MODULENAME = <num> ;
public static final int PARAMETERIZEDSYMBOL = <num> ;
public static final int GROUP = <num> ;
public static final int QUESTION = <num> ;
public static final int PRIORITY = <num> ;
public static final int BOLD_IMP = <num> ;
public static final int SL_COMMENT = <num> ;
public static final int LDOUBLEBRACKET = <num> ;
public static final int RDOUBLEBRACKET = <num> ;
public static final int HIDDENS = <num> ;
public static final int IMPORTS = <num> ;
public static final int PRIORITIES = <num> ;
public static final int STRING = <num> ;
public SdfLexer ( ) { ; }
public SdfLexer ( CharStream input ) {
super ( input ) ;
}
public String getGrammarFileName ( ) { return " ; }
public final void mDEFINITION ( ) throws RecognitionException {
try {
int _type = DEFINITION ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mMODULE ( ) throws RecognitionException {
try {
int _type = MODULE ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mIMPORTS ( ) throws RecognitionException {
try {
int _type = IMPORTS ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mEXPORTS ( ) throws RecognitionException {
try {
int _type = EXPORTS ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mHIDDENS ( ) throws RecognitionException {
try {
int _type = HIDDENS ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mCONTEXTFREE ( ) throws RecognitionException {
try {
int _type = CONTEXTFREE ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mSYNTAX ( ) throws RecognitionException {
try {
int _type = SYNTAX ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mPRIORITIES ( ) throws RecognitionException {
try {
int _type = PRIORITIES ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mSTARTSYMBOLS ( ) throws RecognitionException {
try {
int _type = STARTSYMBOLS ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mSORTS ( ) throws RecognitionException {
try {
int _type = SORTS ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mMODULENAME ( ) throws RecognitionException {
try {
int _type = MODULENAME ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mPRIORITY ( ) throws RecognitionException {
try {
int _type = PRIORITY ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mSORT ( ) throws RecognitionException {
try {
int _type = SORT ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mGROUP ( ) throws RecognitionException {
try {
int _type = GROUP ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mCOMPOUNDSYMBOL ( ) throws RecognitionException {
try {
int _type = COMPOUNDSYMBOL ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mMARKEDSYMBOL ( ) throws RecognitionException {
try {
int _type = MARKEDSYMBOL ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mPARAMETERIZEDSYMBOL ( ) throws RecognitionException {
try {
int _type = PARAMETERIZEDSYMBOL ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mLIST ( ) throws RecognitionException {
try {
int _type = LIST ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mORIGIN ( ) throws RecognitionException {
try {
int _type = ORIGIN ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mSEPARATOR ( ) throws RecognitionException {
try {
int _type = SEPARATOR ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mMULTIPLICITY ( ) throws RecognitionException {
try {
int _type = MULTIPLICITY ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mPRODUCTION ( ) throws RecognitionException {
try {
int _type = PRODUCTION ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mLEFT ( ) throws RecognitionException {
try {
int _type = LEFT ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mRIGHT ( ) throws RecognitionException {
try {
int _type = RIGHT ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mATTRIBUTE ( ) throws RecognitionException {
try {
int _type = ATTRIBUTE ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void <unk> ( ) throws RecognitionException {
try {
{
matchRange ( <num>  , <num>  ) ;
}
}
finally {
}
}
public final void <unk> ( ) throws RecognitionException {
try {
{
if ( ( input . LA ( <num> ) >= A' && input . LA ( <num> ) <= Z' ) || ( input . LA ( <num> ) >= a' && input . LA ( <num> ) <= z' ) ) {
input . consume ( ) ;
}
else {
MismatchedSetException mse =
new MismatchedSetException ( null , input ) ;
recover ( mse ) ; throw mse ;
}
}
}
finally {
}
}
public final void <unk> ( ) throws RecognitionException {
try {
{
matchRange ( A' , Z' ) ;
}
}
finally {
}
}
public final void <unk> ( ) throws RecognitionException {
try {
{
matchRange ( a' , z' ) ;
}
}
finally {
}
}
public final void <unk> ( ) throws RecognitionException {
try {
{
match ( -' ) ;
}
}
finally {
}
}
public final void <unk> ( ) throws RecognitionException {
try {
{
match ( _' ) ;
}
}
finally {
}
}
public final void mPLUS ( ) throws RecognitionException {
try {
int _type = PLUS ;
{
match ( +' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mSTAR ( ) throws RecognitionException {
try {
int _type = STAR ;
{
match ( *' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mLBRACKET ( ) throws RecognitionException {
try {
int _type = LBRACKET ;
{
match ( [' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mRBRACKET ( ) throws RecognitionException {
try {
int _type = RBRACKET ;
{
match ( ]' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mLDOUBLEBRACKET ( ) throws RecognitionException {
try {
int _type = LDOUBLEBRACKET ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mRDOUBLEBRACKET ( ) throws RecognitionException {
try {
int _type = RDOUBLEBRACKET ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mLPAREN ( ) throws RecognitionException {
try {
int _type = LPAREN ;
{
match ( (' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mRPAREN ( ) throws RecognitionException {
try {
int _type = RPAREN ;
{
match ( )' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mCOMMA ( ) throws RecognitionException {
try {
int _type = COMMA ;
{
match ( ,' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mSLASH ( ) throws RecognitionException {
try {
int _type = SLASH ;
{
match ( /' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mBOLD_IMP ( ) throws RecognitionException {
try {
int _type = BOLD_IMP ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mIMP ( ) throws RecognitionException {
try {
int _type = IMP ;
{
match ( " ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mLBRACE ( ) throws RecognitionException {
try {
int _type = LBRACE ;
{
match ( {' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mRBRACE ( ) throws RecognitionException {
try {
int _type = RBRACE ;
{
match ( }' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mGREATER ( ) throws RecognitionException {
try {
int _type = GREATER ;
{
match ( >' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mQUESTION ( ) throws RecognitionException {
try {
int _type = QUESTION ;
{
match ( ?' ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mID ( ) throws RecognitionException {
try {
int _type = ID ;
{
int cnt1 = <num> ;
loop1 :
do {
int alt1 = <num> ;
int LA1_0 = input . LA ( <num> ) ;
if ( ( LA1_0 == -' || ( LA1_0 >= <num>  && LA1_0 <= <num>  ) || ( LA1_0 >= A' && LA1_0 <= Z' ) || LA1_0 == _' || ( LA1_0 >= a' && LA1_0 <= z' ) ) ) {
alt1 = <num> ;
}
switch ( alt1 ) {
case <num> :
{
if ( input . LA ( <num> ) == -' || ( input . LA ( <num> ) >= <num>  && input . LA ( <num> ) <= <num>  ) || ( input . LA ( <num> ) >= A' && input . LA ( <num> ) <= Z' ) || input . LA ( <num> ) == _' || ( input . LA ( <num> ) >= a' && input . LA ( <num> ) <= z' ) ) {
input . consume ( ) ;
}
else {
MismatchedSetException mse =
new MismatchedSetException ( null , input ) ;
recover ( mse ) ; throw mse ;
}
}
break ;
default :
if ( cnt1 >= <num> ) break loop1 ;
EarlyExitException eee =
new EarlyExitException ( <num> , input ) ;
throw eee ;
}
cnt1 ++ ;
} while ( true ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mSTRING ( ) throws RecognitionException {
try {
int _type = STRING ;
{
match ( \"' ) ;
loop2 :
do {
int alt2 = <num> ;
int LA2_0 = input . LA ( <num> ) ;
if ( ( LA2_0 == \"' ) ) {
int LA2_1 = input . LA ( <num> ) ;
if ( ( LA2_1 == \"' ) ) {
alt2 = <num> ;
}
}
else if ( ( ( LA2_0 >=  ' && LA2_0 <= \t' ) || ( LA2_0 >= '
&& LA2_0 <= !' ) || ( LA2_0 >= #' && LA2_0 <= ' ) ) ) {
alt2 = <num> ;
}
switch ( alt2 ) {
case <num> :
{
if ( ( input . LA ( <num> ) >=  ' && input . LA ( <num> ) <= \t' ) || ( input . LA ( <num> ) >= '
&& input . LA ( <num> ) <= !' ) || ( input . LA ( <num> ) >= #' && input . LA ( <num> ) <= ' ) ) {
input . consume ( ) ;
}
else {
MismatchedSetException mse =
new MismatchedSetException ( null , input ) ;
recover ( mse ) ; throw mse ;
}
}
break ;
case <num> :
{
match ( \"' ) ;
match ( \"' ) ;
}
break ;
default :
break loop2 ;
}
} while ( true ) ;
match ( \"' ) ;
setText ( getText ( ) . substring ( <num> , getText ( ) . length ( )  <num> ) ) ;
}
this . type = _type ;
}
finally {
}
}
public final void mWHITESPACE ( ) throws RecognitionException {
try {
int _type = WHITESPACE ;
{
int cnt3 = <num> ;
loop3 :
do {
int alt3 = <num> ;
int LA3_0 = input . LA ( <num> ) ;
if ( ( ( LA3_0 >= \t' && LA3_0 <= \n' ) || ( LA3_0 >= \f' && LA3_0 <= \r' ) || LA3_0 ==  ' ) ) {
alt3 = <num> ;
}
switch ( alt3 ) {
case <num> :
{
if ( ( input . LA ( <num> ) >= \t' && input . LA ( <num> ) <= \n' ) || ( input . LA ( <num> ) >= \f' && input . LA ( <num> ) <= \r' ) || input . LA ( <num> ) ==  ' ) {
input . consume ( ) ;
}
else {
MismatchedSetException mse =
new MismatchedSetException ( null , input ) ;
recover ( mse ) ; throw mse ;
}
}
break ;
default :
if ( cnt3 >= <num> ) break loop3 ;
EarlyExitException eee =
new EarlyExitException ( <num> , input ) ;
throw eee ;
}
cnt3 ++ ;
} while ( true ) ;
channel = HIDDEN ;
}
this . type = _type ;
}
finally {
}
}
public final void mSL_COMMENT ( ) throws RecognitionException {
try {
int _type = SL_COMMENT ;
{
match ( " ) ;
loop4 :
do {
int alt4 = <num> ;
int LA4_0 = input . LA ( <num> ) ;
if ( ( LA4_0 == \n' || ( LA4_0 >= \f' && LA4_0 <= \r' ) ) ) {
alt4 = <num> ;
}
else if ( ( ( LA4_0 >=  ' && LA4_0 <= \t' ) || LA4_0 == '
|| ( LA4_0 >= <unk> && LA4_0 <= ' ) ) ) {
alt4 = <num> ;
}
switch ( alt4 ) {
case <num> :
{
<unk> ( ) ;
}
break ;
default :
break loop4 ;
}
} while ( true ) ;
if ( input . LA ( <num> ) == \n' || ( input . LA ( <num> ) >= \f' && input . LA ( <num> ) <= \r' ) ) {
input . consume ( ) ;
}
else {
MismatchedSetException mse =
new MismatchedSetException ( null , input ) ;
recover ( mse ) ; throw mse ;
}
channel = HIDDEN ;
}
this . type = _type ;
}
finally {
}
}
public void <unk> ( ) throws RecognitionException {
int alt5 = <num> ;
switch ( input . LA ( <num> ) ) {
case d' :
{
int LA5_1 = input . LA ( <num> ) ;
if ( ( LA5_1 == e' ) ) {
int LA5_32 = input . LA ( <num> ) ;
if ( ( LA5_32 == f' ) ) {
int LA5_57 = input . LA ( <num> ) ;
if ( ( LA5_57 == i' ) ) {
int LA5_79 = input . LA ( <num> ) ;
if ( ( LA5_79 == n' ) ) {
int LA5_101 = input . LA ( <num> ) ;
if ( ( LA5_101 == i' ) ) {
int LA5_124 = input . LA ( <num> ) ;
if ( ( LA5_124 == t' ) ) {
int LA5_145 = input . LA ( <num> ) ;
if ( ( LA5_145 == i' ) ) {
int LA5_165 = input . LA ( <num> ) ;
if ( ( LA5_165 == o' ) ) {
int LA5_183 = input . LA ( <num> ) ;
if ( ( LA5_183 == n' ) ) {
int LA5_198 = input . LA ( <num> ) ;
if ( ( LA5_198 == -' || ( LA5_198 >= <num>  && LA5_198 <= <num>  ) || ( LA5_198 >= A' && LA5_198 <= Z' ) || LA5_198 == _' || ( LA5_198 >= a' && LA5_198 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case m' :
{
switch ( input . LA ( <num> ) ) {
case a' :
{
int LA5_33 = input . LA ( <num> ) ;
if ( ( LA5_33 == r' ) ) {
int LA5_58 = input . LA ( <num> ) ;
if ( ( LA5_58 == k' ) ) {
int LA5_80 = input . LA ( <num> ) ;
if ( ( LA5_80 == e' ) ) {
int LA5_102 = input . LA ( <num> ) ;
if ( ( LA5_102 == d' ) ) {
int LA5_125 = input . LA ( <num> ) ;
if ( ( LA5_125 == S' ) ) {
int LA5_146 = input . LA ( <num> ) ;
if ( ( LA5_146 == y' ) ) {
int LA5_166 = input . LA ( <num> ) ;
if ( ( LA5_166 == m' ) ) {
int LA5_184 = input . LA ( <num> ) ;
if ( ( LA5_184 == b' ) ) {
int LA5_199 = input . LA ( <num> ) ;
if ( ( LA5_199 == o' ) ) {
int LA5_212 = input . LA ( <num> ) ;
if ( ( LA5_212 == l' ) ) {
int LA5_221 = input . LA ( <num> ) ;
if ( ( LA5_221 == -' || ( LA5_221 >= <num>  && LA5_221 <= <num>  ) || ( LA5_221 >= A' && LA5_221 <= Z' ) || LA5_221 == _' || ( LA5_221 >= a' && LA5_221 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case o' :
{
int LA5_34 = input . LA ( <num> ) ;
if ( ( LA5_34 == d' ) ) {
int LA5_59 = input . LA ( <num> ) ;
if ( ( LA5_59 == u' ) ) {
int LA5_81 = input . LA ( <num> ) ;
if ( ( LA5_81 == l' ) ) {
int LA5_103 = input . LA ( <num> ) ;
if ( ( LA5_103 == e' ) ) {
switch ( input . LA ( <num> ) ) {
case N' :
{
int LA5_147 = input . LA ( <num> ) ;
if ( ( LA5_147 == a' ) ) {
int LA5_167 = input . LA ( <num> ) ;
if ( ( LA5_167 == m' ) ) {
int LA5_185 = input . LA ( <num> ) ;
if ( ( LA5_185 == e' ) ) {
int LA5_200 = input . LA ( <num> ) ;
if ( ( LA5_200 == -' || ( LA5_200 >= <num>  && LA5_200 <= <num>  ) || ( LA5_200 >= A' && LA5_200 <= Z' ) || LA5_200 == _' || ( LA5_200 >= a' && LA5_200 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case -' :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case A' :
case B' :
case C' :
case D' :
case E' :
case F' :
case G' :
case H' :
case I' :
case J' :
case K' :
case L' :
case M' :
case O' :
case P' :
case Q' :
case R' :
case S' :
case T' :
case U' :
case V' :
case W' :
case X' :
case Y' :
case Z' :
case _' :
case a' :
case b' :
case c' :
case d' :
case e' :
case f' :
case g' :
case h' :
case i' :
case j' :
case k' :
case l' :
case m' :
case n' :
case o' :
case p' :
case q' :
case r' :
case s' :
case t' :
case u' :
case v' :
case w' :
case x' :
case y' :
case z' :
{
alt5 = <num> ;
}
break ;
default :
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case u' :
{
int LA5_35 = input . LA ( <num> ) ;
if ( ( LA5_35 == l' ) ) {
int LA5_60 = input . LA ( <num> ) ;
if ( ( LA5_60 == t' ) ) {
int LA5_82 = input . LA ( <num> ) ;
if ( ( LA5_82 == i' ) ) {
int LA5_104 = input . LA ( <num> ) ;
if ( ( LA5_104 == p' ) ) {
int LA5_127 = input . LA ( <num> ) ;
if ( ( LA5_127 == l' ) ) {
int LA5_149 = input . LA ( <num> ) ;
if ( ( LA5_149 == i' ) ) {
int LA5_168 = input . LA ( <num> ) ;
if ( ( LA5_168 == c' ) ) {
int LA5_186 = input . LA ( <num> ) ;
if ( ( LA5_186 == i' ) ) {
int LA5_201 = input . LA ( <num> ) ;
if ( ( LA5_201 == t' ) ) {
int LA5_214 = input . LA ( <num> ) ;
if ( ( LA5_214 == y' ) ) {
int LA5_222 = input . LA ( <num> ) ;
if ( ( LA5_222 == -' || ( LA5_222 >= <num>  && LA5_222 <= <num>  ) || ( LA5_222 >= A' && LA5_222 <= Z' ) || LA5_222 == _' || ( LA5_222 >= a' && LA5_222 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
default :
alt5 = <num> ; }
}
break ;
case i' :
{
int LA5_3 = input . LA ( <num> ) ;
if ( ( LA5_3 == m' ) ) {
int LA5_36 = input . LA ( <num> ) ;
if ( ( LA5_36 == p' ) ) {
int LA5_61 = input . LA ( <num> ) ;
if ( ( LA5_61 == o' ) ) {
int LA5_83 = input . LA ( <num> ) ;
if ( ( LA5_83 == r' ) ) {
int LA5_105 = input . LA ( <num> ) ;
if ( ( LA5_105 == t' ) ) {
int LA5_128 = input . LA ( <num> ) ;
if ( ( LA5_128 == s' ) ) {
int LA5_150 = input . LA ( <num> ) ;
if ( ( LA5_150 == -' || ( LA5_150 >= <num>  && LA5_150 <= <num>  ) || ( LA5_150 >= A' && LA5_150 <= Z' ) || LA5_150 == _' || ( LA5_150 >= a' && LA5_150 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case e' :
{
int LA5_4 = input . LA ( <num> ) ;
if ( ( LA5_4 == x' ) ) {
int LA5_37 = input . LA ( <num> ) ;
if ( ( LA5_37 == p' ) ) {
int LA5_62 = input . LA ( <num> ) ;
if ( ( LA5_62 == o' ) ) {
int LA5_84 = input . LA ( <num> ) ;
if ( ( LA5_84 == r' ) ) {
int LA5_106 = input . LA ( <num> ) ;
if ( ( LA5_106 == t' ) ) {
int LA5_129 = input . LA ( <num> ) ;
if ( ( LA5_129 == s' ) ) {
int LA5_151 = input . LA ( <num> ) ;
if ( ( LA5_151 == -' || ( LA5_151 >= <num>  && LA5_151 <= <num>  ) || ( LA5_151 >= A' && LA5_151 <= Z' ) || LA5_151 == _' || ( LA5_151 >= a' && LA5_151 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case h' :
{
int LA5_5 = input . LA ( <num> ) ;
if ( ( LA5_5 == i' ) ) {
int LA5_38 = input . LA ( <num> ) ;
if ( ( LA5_38 == d' ) ) {
int LA5_63 = input . LA ( <num> ) ;
if ( ( LA5_63 == d' ) ) {
int LA5_85 = input . LA ( <num> ) ;
if ( ( LA5_85 == e' ) ) {
int LA5_107 = input . LA ( <num> ) ;
if ( ( LA5_107 == n' ) ) {
int LA5_130 = input . LA ( <num> ) ;
if ( ( LA5_130 == s' ) ) {
int LA5_152 = input . LA ( <num> ) ;
if ( ( LA5_152 == -' || ( LA5_152 >= <num>  && LA5_152 <= <num>  ) || ( LA5_152 >= A' && LA5_152 <= Z' ) || LA5_152 == _' || ( LA5_152 >= a' && LA5_152 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case c' :
{
int LA5_6 = input . LA ( <num> ) ;
if ( ( LA5_6 == o' ) ) {
switch ( input . LA ( <num> ) ) {
case n' :
{
int LA5_64 = input . LA ( <num> ) ;
if ( ( LA5_64 == t' ) ) {
int LA5_86 = input . LA ( <num> ) ;
if ( ( LA5_86 == e' ) ) {
int LA5_108 = input . LA ( <num> ) ;
if ( ( LA5_108 == x' ) ) {
int LA5_131 = input . LA ( <num> ) ;
if ( ( LA5_131 == t' ) ) {
int LA5_153 = input . LA ( <num> ) ;
if ( ( LA5_153 == -' ) ) {
int LA5_172 = input . LA ( <num> ) ;
if ( ( LA5_172 == f' ) ) {
int LA5_187 = input . LA ( <num> ) ;
if ( ( LA5_187 == r' ) ) {
int LA5_202 = input . LA ( <num> ) ;
if ( ( LA5_202 == e' ) ) {
int LA5_215 = input . LA ( <num> ) ;
if ( ( LA5_215 == e' ) ) {
int LA5_223 = input . LA ( <num> ) ;
if ( ( LA5_223 == -' || ( LA5_223 >= <num>  && LA5_223 <= <num>  ) || ( LA5_223 >= A' && LA5_223 <= Z' ) || LA5_223 == _' || ( LA5_223 >= a' && LA5_223 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case m' :
{
int LA5_65 = input . LA ( <num> ) ;
if ( ( LA5_65 == p' ) ) {
int LA5_87 = input . LA ( <num> ) ;
if ( ( LA5_87 == o' ) ) {
int LA5_109 = input . LA ( <num> ) ;
if ( ( LA5_109 == u' ) ) {
int LA5_132 = input . LA ( <num> ) ;
if ( ( LA5_132 == n' ) ) {
int LA5_154 = input . LA ( <num> ) ;
if ( ( LA5_154 == d' ) ) {
int LA5_173 = input . LA ( <num> ) ;
if ( ( LA5_173 == S' ) ) {
int LA5_188 = input . LA ( <num> ) ;
if ( ( LA5_188 == y' ) ) {
int LA5_203 = input . LA ( <num> ) ;
if ( ( LA5_203 == m' ) ) {
int LA5_216 = input . LA ( <num> ) ;
if ( ( LA5_216 == b' ) ) {
int LA5_224 = input . LA ( <num> ) ;
if ( ( LA5_224 == o' ) ) {
int LA5_230 = input . LA ( <num> ) ;
if ( ( LA5_230 == l' ) ) {
int LA5_233 = input . LA ( <num> ) ;
if ( ( LA5_233 == -' || ( LA5_233 >= <num>  && LA5_233 <= <num>  ) || ( LA5_233 >= A' && LA5_233 <= Z' ) || LA5_233 == _' || ( LA5_233 >= a' && LA5_233 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
default :
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case s' :
{
switch ( input . LA ( <num> ) ) {
case e' :
{
int LA5_40 = input . LA ( <num> ) ;
if ( ( LA5_40 == p' ) ) {
int LA5_66 = input . LA ( <num> ) ;
if ( ( LA5_66 == e' ) ) {
int LA5_88 = input . LA ( <num> ) ;
if ( ( LA5_88 == r' ) ) {
int LA5_110 = input . LA ( <num> ) ;
if ( ( LA5_110 == a' ) ) {
int LA5_133 = input . LA ( <num> ) ;
if ( ( LA5_133 == t' ) ) {
int LA5_155 = input . LA ( <num> ) ;
if ( ( LA5_155 == o' ) ) {
int LA5_174 = input . LA ( <num> ) ;
if ( ( LA5_174 == r' ) ) {
int LA5_189 = input . LA ( <num> ) ;
if ( ( LA5_189 == -' || ( LA5_189 >= <num>  && LA5_189 <= <num>  ) || ( LA5_189 >= A' && LA5_189 <= Z' ) || LA5_189 == _' || ( LA5_189 >= a' && LA5_189 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case y' :
{
int LA5_41 = input . LA ( <num> ) ;
if ( ( LA5_41 == n' ) ) {
int LA5_67 = input . LA ( <num> ) ;
if ( ( LA5_67 == t' ) ) {
int LA5_89 = input . LA ( <num> ) ;
if ( ( LA5_89 == a' ) ) {
int LA5_111 = input . LA ( <num> ) ;
if ( ( LA5_111 == x' ) ) {
int LA5_134 = input . LA ( <num> ) ;
if ( ( LA5_134 == -' || ( LA5_134 >= <num>  && LA5_134 <= <num>  ) || ( LA5_134 >= A' && LA5_134 <= Z' ) || LA5_134 == _' || ( LA5_134 >= a' && LA5_134 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case t' :
{
int LA5_42 = input . LA ( <num> ) ;
if ( ( LA5_42 == a' ) ) {
int LA5_68 = input . LA ( <num> ) ;
if ( ( LA5_68 == r' ) ) {
int LA5_90 = input . LA ( <num> ) ;
if ( ( LA5_90 == t' ) ) {
int LA5_112 = input . LA ( <num> ) ;
if ( ( LA5_112 == -' ) ) {
int LA5_135 = input . LA ( <num> ) ;
if ( ( LA5_135 == s' ) ) {
int LA5_157 = input . LA ( <num> ) ;
if ( ( LA5_157 == y' ) ) {
int LA5_175 = input . LA ( <num> ) ;
if ( ( LA5_175 == m' ) ) {
int LA5_190 = input . LA ( <num> ) ;
if ( ( LA5_190 == b' ) ) {
int LA5_205 = input . LA ( <num> ) ;
if ( ( LA5_205 == o' ) ) {
int LA5_217 = input . LA ( <num> ) ;
if ( ( LA5_217 == l' ) ) {
int LA5_225 = input . LA ( <num> ) ;
if ( ( LA5_225 == s' ) ) {
int LA5_231 = input . LA ( <num> ) ;
if ( ( LA5_231 == -' || ( LA5_231 >= <num>  && LA5_231 <= <num>  ) || ( LA5_231 >= A' && LA5_231 <= Z' ) || LA5_231 == _' || ( LA5_231 >= a' && LA5_231 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case o' :
{
int LA5_43 = input . LA ( <num> ) ;
if ( ( LA5_43 == r' ) ) {
int LA5_69 = input . LA ( <num> ) ;
if ( ( LA5_69 == t' ) ) {
switch ( input . LA ( <num> ) ) {
case s' :
{
int LA5_113 = input . LA ( <num> ) ;
if ( ( LA5_113 == -' || ( LA5_113 >= <num>  && LA5_113 <= <num>  ) || ( LA5_113 >= A' && LA5_113 <= Z' ) || LA5_113 == _' || ( LA5_113 >= a' && LA5_113 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
break ;
case -' :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case A' :
case B' :
case C' :
case D' :
case E' :
case F' :
case G' :
case H' :
case I' :
case J' :
case K' :
case L' :
case M' :
case N' :
case O' :
case P' :
case Q' :
case R' :
case S' :
case T' :
case U' :
case V' :
case W' :
case X' :
case Y' :
case Z' :
case _' :
case a' :
case b' :
case c' :
case d' :
case e' :
case f' :
case g' :
case h' :
case i' :
case j' :
case k' :
case l' :
case m' :
case n' :
case o' :
case p' :
case q' :
case r' :
case t' :
case u' :
case v' :
case w' :
case x' :
case y' :
case z' :
{
alt5 = <num> ;
}
break ;
default :
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
default :
alt5 = <num> ; }
}
break ;
case p' :
{
switch ( input . LA ( <num> ) ) {
case a' :
{
int LA5_44 = input . LA ( <num> ) ;
if ( ( LA5_44 == r' ) ) {
int LA5_70 = input . LA ( <num> ) ;
if ( ( LA5_70 == a' ) ) {
int LA5_92 = input . LA ( <num> ) ;
if ( ( LA5_92 == m' ) ) {
int LA5_115 = input . LA ( <num> ) ;
if ( ( LA5_115 == e' ) ) {
int LA5_137 = input . LA ( <num> ) ;
if ( ( LA5_137 == t' ) ) {
int LA5_158 = input . LA ( <num> ) ;
if ( ( LA5_158 == e' ) ) {
int LA5_176 = input . LA ( <num> ) ;
if ( ( LA5_176 == r' ) ) {
int LA5_191 = input . LA ( <num> ) ;
if ( ( LA5_191 == i' ) ) {
int LA5_206 = input . LA ( <num> ) ;
if ( ( LA5_206 == z' ) ) {
int LA5_218 = input . LA ( <num> ) ;
if ( ( LA5_218 == e' ) ) {
int LA5_226 = input . LA ( <num> ) ;
if ( ( LA5_226 == d' ) ) {
int LA5_232 = input . LA ( <num> ) ;
if ( ( LA5_232 == S' ) ) {
int LA5_235 = input . LA ( <num> ) ;
if ( ( LA5_235 == y' ) ) {
int LA5_237 = input . LA ( <num> ) ;
if ( ( LA5_237 == m' ) ) {
int LA5_238 = input . LA ( <num> ) ;
if ( ( LA5_238 == b' ) ) {
int LA5_239 = input . LA ( <num> ) ;
if ( ( LA5_239 == o' ) ) {
int LA5_240 = input . LA ( <num> ) ;
if ( ( LA5_240 == l' ) ) {
int LA5_241 = input . LA ( <num> ) ;
if ( ( LA5_241 == -' || ( LA5_241 >= <num>  && LA5_241 <= <num>  ) || ( LA5_241 >= A' && LA5_241 <= Z' ) || LA5_241 == _' || ( LA5_241 >= a' && LA5_241 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case r' :
{
switch ( input . LA ( <num> ) ) {
case i' :
{
int LA5_71 = input . LA ( <num> ) ;
if ( ( LA5_71 == o' ) ) {
int LA5_93 = input . LA ( <num> ) ;
if ( ( LA5_93 == r' ) ) {
int LA5_116 = input . LA ( <num> ) ;
if ( ( LA5_116 == i' ) ) {
int LA5_138 = input . LA ( <num> ) ;
if ( ( LA5_138 == t' ) ) {
switch ( input . LA ( <num> ) ) {
case y' :
{
int LA5_177 = input . LA ( <num> ) ;
if ( ( LA5_177 == -' || ( LA5_177 >= <num>  && LA5_177 <= <num>  ) || ( LA5_177 >= A' && LA5_177 <= Z' ) || LA5_177 == _' || ( LA5_177 >= a' && LA5_177 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
break ;
case i' :
{
int LA5_178 = input . LA ( <num> ) ;
if ( ( LA5_178 == e' ) ) {
int LA5_193 = input . LA ( <num> ) ;
if ( ( LA5_193 == s' ) ) {
int LA5_207 = input . LA ( <num> ) ;
if ( ( LA5_207 == -' || ( LA5_207 >= <num>  && LA5_207 <= <num>  ) || ( LA5_207 >= A' && LA5_207 <= Z' ) || LA5_207 == _' || ( LA5_207 >= a' && LA5_207 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
default :
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case o' :
{
int LA5_72 = input . LA ( <num> ) ;
if ( ( LA5_72 == d' ) ) {
int LA5_94 = input . LA ( <num> ) ;
if ( ( LA5_94 == u' ) ) {
int LA5_117 = input . LA ( <num> ) ;
if ( ( LA5_117 == c' ) ) {
int LA5_139 = input . LA ( <num> ) ;
if ( ( LA5_139 == t' ) ) {
int LA5_160 = input . LA ( <num> ) ;
if ( ( LA5_160 == i' ) ) {
int LA5_179 = input . LA ( <num> ) ;
if ( ( LA5_179 == o' ) ) {
int LA5_194 = input . LA ( <num> ) ;
if ( ( LA5_194 == n' ) ) {
int LA5_208 = input . LA ( <num> ) ;
if ( ( LA5_208 == -' || ( LA5_208 >= <num>  && LA5_208 <= <num>  ) || ( LA5_208 >= A' && LA5_208 <= Z' ) || LA5_208 == _' || ( LA5_208 >= a' && LA5_208 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
default :
alt5 = <num> ; }
}
break ;
default :
alt5 = <num> ; }
}
break ;
case g' :
{
int LA5_9 = input . LA ( <num> ) ;
if ( ( LA5_9 == r' ) ) {
int LA5_46 = input . LA ( <num> ) ;
if ( ( LA5_46 == o' ) ) {
int LA5_73 = input . LA ( <num> ) ;
if ( ( LA5_73 == u' ) ) {
int LA5_95 = input . LA ( <num> ) ;
if ( ( LA5_95 == p' ) ) {
int LA5_118 = input . LA ( <num> ) ;
if ( ( LA5_118 == -' || ( LA5_118 >= <num>  && LA5_118 <= <num>  ) || ( LA5_118 >= A' && LA5_118 <= Z' ) || LA5_118 == _' || ( LA5_118 >= a' && LA5_118 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case l' :
{
switch ( input . LA ( <num> ) ) {
case i' :
{
int LA5_47 = input . LA ( <num> ) ;
if ( ( LA5_47 == s' ) ) {
int LA5_74 = input . LA ( <num> ) ;
if ( ( LA5_74 == t' ) ) {
int LA5_96 = input . LA ( <num> ) ;
if ( ( LA5_96 == -' || ( LA5_96 >= <num>  && LA5_96 <= <num>  ) || ( LA5_96 >= A' && LA5_96 <= Z' ) || LA5_96 == _' || ( LA5_96 >= a' && LA5_96 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case e' :
{
int LA5_48 = input . LA ( <num> ) ;
if ( ( LA5_48 == f' ) ) {
int LA5_75 = input . LA ( <num> ) ;
if ( ( LA5_75 == t' ) ) {
int LA5_97 = input . LA ( <num> ) ;
if ( ( LA5_97 == P' ) ) {
int LA5_120 = input . LA ( <num> ) ;
if ( ( LA5_120 == a' ) ) {
int LA5_141 = input . LA ( <num> ) ;
if ( ( LA5_141 == r' ) ) {
int LA5_161 = input . LA ( <num> ) ;
if ( ( LA5_161 == t' ) ) {
int LA5_180 = input . LA ( <num> ) ;
if ( ( LA5_180 == -' || ( LA5_180 >= <num>  && LA5_180 <= <num>  ) || ( LA5_180 >= A' && LA5_180 <= Z' ) || LA5_180 == _' || ( LA5_180 >= a' && LA5_180 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
default :
alt5 = <num> ; }
}
break ;
case o' :
{
int LA5_11 = input . LA ( <num> ) ;
if ( ( LA5_11 == r' ) ) {
int LA5_49 = input . LA ( <num> ) ;
if ( ( LA5_49 == i' ) ) {
int LA5_76 = input . LA ( <num> ) ;
if ( ( LA5_76 == g' ) ) {
int LA5_98 = input . LA ( <num> ) ;
if ( ( LA5_98 == i' ) ) {
int LA5_121 = input . LA ( <num> ) ;
if ( ( LA5_121 == n' ) ) {
int LA5_142 = input . LA ( <num> ) ;
if ( ( LA5_142 == -' || ( LA5_142 >= <num>  && LA5_142 <= <num>  ) || ( LA5_142 >= A' && LA5_142 <= Z' ) || LA5_142 == _' || ( LA5_142 >= a' && LA5_142 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case r' :
{
int LA5_12 = input . LA ( <num> ) ;
if ( ( LA5_12 == i' ) ) {
int LA5_50 = input . LA ( <num> ) ;
if ( ( LA5_50 == g' ) ) {
int LA5_77 = input . LA ( <num> ) ;
if ( ( LA5_77 == h' ) ) {
int LA5_99 = input . LA ( <num> ) ;
if ( ( LA5_99 == t' ) ) {
int LA5_122 = input . LA ( <num> ) ;
if ( ( LA5_122 == P' ) ) {
int LA5_143 = input . LA ( <num> ) ;
if ( ( LA5_143 == a' ) ) {
int LA5_163 = input . LA ( <num> ) ;
if ( ( LA5_163 == r' ) ) {
int LA5_181 = input . LA ( <num> ) ;
if ( ( LA5_181 == t' ) ) {
int LA5_196 = input . LA ( <num> ) ;
if ( ( LA5_196 == -' || ( LA5_196 >= <num>  && LA5_196 <= <num>  ) || ( LA5_196 >= A' && LA5_196 <= Z' ) || LA5_196 == _' || ( LA5_196 >= a' && LA5_196 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case a' :
{
int LA5_13 = input . LA ( <num> ) ;
if ( ( LA5_13 == t' ) ) {
int LA5_51 = input . LA ( <num> ) ;
if ( ( LA5_51 == t' ) ) {
int LA5_78 = input . LA ( <num> ) ;
if ( ( LA5_78 == r' ) ) {
int LA5_100 = input . LA ( <num> ) ;
if ( ( LA5_100 == i' ) ) {
int LA5_123 = input . LA ( <num> ) ;
if ( ( LA5_123 == b' ) ) {
int LA5_144 = input . LA ( <num> ) ;
if ( ( LA5_144 == u' ) ) {
int LA5_164 = input . LA ( <num> ) ;
if ( ( LA5_164 == t' ) ) {
int LA5_182 = input . LA ( <num> ) ;
if ( ( LA5_182 == e' ) ) {
int LA5_197 = input . LA ( <num> ) ;
if ( ( LA5_197 == -' || ( LA5_197 >= <num>  && LA5_197 <= <num>  ) || ( LA5_197 >= A' && LA5_197 <= Z' ) || LA5_197 == _' || ( LA5_197 >= a' && LA5_197 <= z' ) ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
else {
alt5 = <num> ; }
}
break ;
case +' :
{
alt5 = <num> ;
}
break ;
case *' :
{
alt5 = <num> ;
}
break ;
case [' :
{
int LA5_16 = input . LA ( <num> ) ;
if ( ( LA5_16 == [' ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
break ;
case ]' :
{
int LA5_17 = input . LA ( <num> ) ;
if ( ( LA5_17 == ]' ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
break ;
case (' :
{
alt5 = <num> ;
}
break ;
case )' :
{
alt5 = <num> ;
}
break ;
case ,' :
{
alt5 = <num> ;
}
break ;
case /' :
{
alt5 = <num> ;
}
break ;
case =' :
{
alt5 = <num> ;
}
break ;
case -' :
{
int LA5_23 = input . LA ( <num> ) ;
if ( ( LA5_23 == >' ) ) {
alt5 = <num> ;
}
else {
alt5 = <num> ; }
}
break ;
case {' :
{
alt5 = <num> ;
}
break ;
case }' :
{
alt5 = <num> ;
}
break ;
case >' :
{
alt5 = <num> ;
}
break ;
case ?' :
{
alt5 = <num> ;
}
break ;
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case A' :
case B' :
case C' :
case D' :
case E' :
case F' :
case G' :
case H' :
case I' :
case J' :
case K' :
case L' :
case M' :
case N' :
case O' :
case P' :
case Q' :
case R' :
case S' :
case T' :
case U' :
case V' :
case W' :
case X' :
case Y' :
case Z' :
case _' :
case b' :
case f' :
case j' :
case k' :
case n' :
case q' :
case t' :
case u' :
case v' :
case w' :
case x' :
case y' :
case z' :
{
alt5 = <num> ;
}
break ;
case \"' :
{
alt5 = <num> ;
}
break ;
case \t' :
case \n' :
case \f' :
case \r' :
case  ' :
{
alt5 = <num> ;
}
break ;
case %' :
{
alt5 = <num> ;
}
break ;
default :
NoViableAltException nvae =
new NoViableAltException ( " , <num> , <num> , input ) ;
throw nvae ;
}
switch ( alt5 ) {
case <num> :
{
mDEFINITION ( ) ;
}
break ;
case <num> :
{
mMODULE ( ) ;
}
break ;
case <num> :
{
mIMPORTS ( ) ;
}
break ;
case <num> :
{
mEXPORTS ( ) ;
}
break ;
case <num> :
{
mHIDDENS ( ) ;
}
break ;
case <num> :
{
mCONTEXTFREE ( ) ;
}
break ;
case <num> :
{
mSYNTAX ( ) ;
}
break ;
case <num> :
{
mPRIORITIES ( ) ;
}
break ;
case <num> :
{
mSTARTSYMBOLS ( ) ;
}
break ;
case <num> :
{
mSORTS ( ) ;
}
break ;
case <num> :
{
mMODULENAME ( ) ;
}
break ;
case <num> :
{
mPRIORITY ( ) ;
}
break ;
case <num> :
{
mSORT ( ) ;
}
break ;
case <num> :
{
mGROUP ( ) ;
}
break ;
case <num> :
{
mCOMPOUNDSYMBOL ( ) ;
}
break ;
case <num> :
{
mMARKEDSYMBOL ( ) ;
}
break ;
case <num> :
{
mPARAMETERIZEDSYMBOL ( ) ;
}
break ;
case <num> :
{
mLIST ( ) ;
}
break ;
case <num> :
{
mORIGIN ( ) ;
}
break ;
case <num> :
{
mSEPARATOR ( ) ;
}
break ;
case <num> :
{
mMULTIPLICITY ( ) ;
}
break ;
case <num> :
{
mPRODUCTION ( ) ;
}
break ;
case <num> :
{
mLEFT ( ) ;
}
break ;
case <num> :
{
mRIGHT ( ) ;
}
break ;
case <num> :
{
mATTRIBUTE ( ) ;
}
break ;
case <num> :
{
mPLUS ( ) ;
}
break ;
case <num> :
{
mSTAR ( ) ;
}
break ;
case <num> :
{
mLBRACKET ( ) ;
}
break ;
case <num> :
{
mRBRACKET ( ) ;
}
break ;
case <num> :
{
mLDOUBLEBRACKET ( ) ;
}
break ;
case <num> :
{
mRDOUBLEBRACKET ( ) ;
}
break ;
case <num> :
{
mLPAREN ( ) ;
}
break ;
case <num> :
{
mRPAREN ( ) ;
}
break ;
case <num> :
{
mCOMMA ( ) ;
}
break ;
case <num> :
{
mSLASH ( ) ;
}
break ;
case <num> :
{
mBOLD_IMP ( ) ;
}
break ;
case <num> :
{
mIMP ( ) ;
}
break ;
case <num> :
{
mLBRACE ( ) ;
}
break ;
case <num> :
{
mRBRACE ( ) ;
}
break ;
case <num> :
{
mGREATER ( ) ;
}
break ;
case <num> :
{
mQUESTION ( ) ;
}
break ;
case <num> :
{
mID ( ) ;
}
break ;
case <num> :
{
mSTRING ( ) ;
}
break ;
case <num> :
{
mWHITESPACE ( ) ;
}
break ;
case <num> :
{
mSL_COMMENT ( ) ;
}
break ;
}
}
package unifier . asfsdf ;
import java . util . List ;
public abstract class AbstractSortDef {
public abstract List getElements ( ) ;
public abstract boolean isDeclaration ( ) ;
public abstract boolean isAlternative ( ) ;
public abstract boolean isEnumeration ( ) ;
public abstract boolean isList ( ) ;
}
package unifier . util ;
import java . util . * ;
import javax . swing . * ;
import java . sql . * ;
import db . * ;
import meta . * ;
import java . util . logging . Logger ;
public class RepositoryCleaner {
static DB db = null ;
private static Logger logger = Logger . getLogger ( " ) ;
public static void cleanup ( DB adb ) throws SQLException {
Set s ;
Iterator i ;
db = adb ;
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . get_script ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
}
public static void delete ( Def def ) throws SQLException {
Set s ;
Iterator i ;
if ( def == null )
return ;
else {
logger . info ( " + " ) ;
}
if ( db == null )
db = ( DB ) def . _db ( ) ;
if ( def . <unk> ( ) ) {
s = ( ( SchemaDef ) def ) . get_modules ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( new Query ( new Eq ( RelevanceDef . _schema , def ) ) ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( new Query ( new Eq ( <unk> . _schema , def ) ) ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( new Query ( new Eq ( <unk> . _schema , def ) ) ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = db . <unk> ( new Query ( new Eq ( <unk> . _schema , def ) ) ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
}
else if ( def . is_module ( ) ) {
s = ( ( ModuleDef ) def ) . get_containedTypes ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = ( ( ModuleDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = ( ( ModuleDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = ( ( ModuleDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
Def d = ( ( ModuleDef ) def ) . <unk> ( ) ;
if ( d != null ) {
delete ( d ) ;
}
}
else if ( def . is_adt ( ) ) {
s = ( ( ADTDef ) def ) . get_attributes ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = ( ( ADTDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
}
else if ( def . is_attribute ( ) ) {
Def d = ( ( AttributeDef ) def ) . get_type ( ) ;
if ( d != null ) {
if ( d . <unk> ( ) || d . is_set ( ) ) {
delete ( d ) ;
}
}
s = ( ( AttributeDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
}
if ( def . <unk> ( ) ) {
delete ( ( ( <unk> ) def ) . <unk> ( ) ) ;
}
if ( def . <unk> ( ) ) {
s = ( ( FrameDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = ( ( FrameDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
s = ( ( FrameDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) ) {
delete ( ( Def ) i . next ( ) ) ;
}
}
if ( def . <unk> ( ) ) {
delete ( ( ( <unk> ) def ) . <unk> ( ) ) ;
}
if ( def . <unk> ( ) ) {
s = ( ( ScriptDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) )
delete ( ( Def ) i . next ( ) ) ;
s = ( ( ScriptDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) )
delete ( ( Def ) i . next ( ) ) ;
s = ( ( ScriptDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) )
delete ( ( Def ) i . next ( ) ) ;
}
if ( def . <unk> ( ) ) {
delete ( ( ( StateDef ) def ) . <unk> ( ) ) ;
delete ( ( ( StateDef ) def ) . <unk> ( ) ) ;
}
if ( def . <unk> ( ) ) {
s = ( ( TransitionDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) )
delete ( ( Def ) i . next ( ) ) ;
s = ( ( TransitionDef ) def ) . <unk> ( ) ;
i = s . iterator ( ) ;
while ( i . hasNext ( ) )
delete ( ( Def ) i . next ( ) ) ;
delete ( ( ( TransitionDef ) def ) . <unk> ( ) ) ;
}
if ( def . <unk> ( ) ) {
AbstrModelRegDef model = ( AbstrModelRegDef ) def ;
for ( Object fc : model . get_abstrSyntax ( ) ) {
( ( Def ) fc ) . delete ( ) ;
}
if ( model . get_refSchema ( ) != null ) delete ( model . get_refSchema ( ) ) ;
}
if ( def . <unk> ( ) ) {
ModelRegDef model = ( ModelRegDef ) def ;
for ( Object sample : model . get_samples ( ) ) delete ( ( Def ) sample ) ;
for ( Object sim : model . <unk> ( ) ) delete ( ( Def ) sim ) ;
for ( Object fc : model . get_transTargetModel ( ) ) delete ( ( Def ) fc ) ;
for ( Object fc : model . get_transToAmn ( ) ) delete ( ( Def ) fc ) ;
}
if ( def . <unk> ( ) ) {
SampleRegDef sample = ( SampleRegDef ) def ;
for ( Object fc : sample . get_amnSpec ( ) ) delete ( ( Def ) fc ) ;
for ( Object fc : sample . get_targetAmnSpec ( ) ) delete ( ( Def ) fc ) ;
for ( Object fc : sample . get_recAmnSpec ( ) ) delete ( ( Def ) fc ) ;
for ( Object fc : sample . get_recTargetAmnSpec ( ) ) delete ( ( Def ) fc ) ;
}
if ( ! def . <unk> ( ) ) {
logger . info ( " + def . toString ( ) + " ) ;
def . delete ( ) ;
logger . info ( " + def . toString ( ) + " ) ;
}
}
}
package unifier ;
import unifier . util . FormattingWriter ;
import java . util . Set ;
import unifier . similarity . Similarity ;
import unifier . util . DefaultFormattingWriter ;
import java . util . logging . Logger ;
import unifier . util . StringHelper ;
import unifier . asfsdf . * ;
import java . util . HashSet ;
import unifier . similarity . Element ;
import java . util . HashMap ;
import java . util . Map ;
import unifier . similarity . Association ;
public class TranslatorTemplateConstructor {
TranslatorTemplateConstructor ( FormattingWriter signatureWriter , FormattingWriter equationsWriter ) {
this . signatureWriter = signatureWriter ;
this . equationsWriter = equationsWriter ;
}
TranslatorTemplateConstructor (
Module source ,
Module target ,
Set < Similarity > sims ,
FormattingWriter signatureWriter ,
FormattingWriter equationsWriter ) {
this . source = source ;
this . target = target ;
this . sims = sims ;
this . signatureWriter = signatureWriter ;
this . equationsWriter = equationsWriter ;
}
private Logger logger = Logger . getLogger ( " ) ;
private Module source ;
private Module target ;
private Set < Similarity > sims ;
private FormattingWriter signatureWriter ;
private FormattingWriter equationsWriter ;
private Module translator = new Module ( ) ;
private Set < String > sortNamesToProcess = new HashSet < String > ( ) ;
private String processedSortName = " ;
public void writeTranslatorTemplate ( ) throws
TranslatorTemplateConstructionException , SdfDefinitionException {
generateTranslatorTemplate ( ) ;
writeSignatures ( ) ;
writeEquations ( ) ;
}
private void writeSignatures ( ) throws SdfDefinitionException {
AsfSsdfFormattingWriter writer = new AsfSsdfFormattingWriter ( signatureWriter ) ;
writer . translatorHeader ( translator ) ;
}
private void writeEquations ( ) throws SdfDefinitionException {
AsfSsdfFormattingWriter writer = new AsfSsdfFormattingWriter ( equationsWriter ) ;
writer . equations ( translator ) ;
}
private void generateTranslatorTemplate ( ) throws TranslatorTemplateConstructionException , SdfDefinitionException {
generateTranslatorName ( ) ;
generateImports ( ) ;
translator . getStartSymbols ( ) . addAll ( target . getStartSymbols ( ) ) ;
generateVariables ( ) ;
generateSignaturesAndEquations ( ) ;
}
private void generateTranslatorName ( ) throws TranslatorTemplateConstructionException {
if ( StringHelper . isNullEmptyOrBlank ( source . getName ( ) ) ) {
throw new TranslatorTemplateConstructionException ( " ) ;
}
if ( StringHelper . isNullEmptyOrBlank ( target . getName ( ) ) ) {
throw new TranslatorTemplateConstructionException ( " ) ;
}
translator . setName ( " +
StringHelper . getLastComponentOfPath ( source . getName ( ) ) +
" +
StringHelper . getLastComponentOfPath ( target . getName ( ) ) +
" +
StringHelper . getLastComponentOfPath ( source . getName ( ) ) +
" +
StringHelper . getLastComponentOfPath ( target . getName ( ) ) +
" ) ;
}
private void generateImports ( ) {
translator . addImport ( source . getName ( ) ) ;
translator . addImport ( target . getName ( ) ) ;
}
private void generateVariables ( ) {
for ( String name : source . getSortNames ( ) ) {
translator . addDomainSortVariable ( new Variable ( name , new Declaration ( new SortName ( name ) ) ) ) ;
}
for ( String name : target . getSortNames ( ) ) {
translator . addRangeSortVariable ( new Variable ( name , new Declaration ( new SortName ( name ) ) ) ) ;
}
}
private void generateSignaturesAndEquations ( ) throws SdfDefinitionException , TranslatorTemplateConstructionException {
sortNamesToProcess . clear ( ) ;
sortNamesToProcess . addAll ( target . getSortNames ( ) ) ;
while ( sortNamesToProcess . size ( ) > <num> ) {
String s = sortNamesToProcess . iterator ( ) . next ( ) ;
Sort sort = target . getSort ( s ) ;
sortNamesToProcess . remove ( s ) ;
processSort ( sort ) ;
}
}
private void processSort ( Sort sort ) throws TranslatorTemplateConstructionException , SdfDefinitionException {
Signature signature ;
String previousProcessedSortName ;
previousProcessedSortName = processedSortName ;
processedSortName = sort . getName ( ) ;
signature = createSignature ( sort ) ;
if ( sort . isTerminal ( ) ) {
}
else {
Nonterminal nonterm = ( Nonterminal ) sort ;
AbstractSortDef sortDef = nonterm . getDefinition ( ) ;
if ( sortDef == null ) {
throw new TranslatorTemplateConstructionException ( " +
sort . getName ( ) + " ) ;
} else
if ( sortDef . isAlternative ( ) || sortDef . isEnumeration ( ) ) {
} else
if ( sortDef . isDeclaration ( ) ) {
processDeclaration ( ( Declaration ) sortDef , signature ) ;
}
}
processedSortName = previousProcessedSortName ;
}
private Signature createSignature ( Sort sort ) throws SdfDefinitionException {
String sortName = sort . getName ( ) ;
Signature signature = new Signature ( ) ;
signature . setName ( sort . getSignatureName ( ) ) ;
signature . setReturnSort ( new Declaration ( new SortName ( sortName ) ) ) ;
Set < String > params = getTopmostSourceSupersorts ( getRelevantElements ( sortName ) ) ;
for ( String par : params ) {
signature . addParam ( new Declaration ( new SortName ( par ) ) ) ;
}
translator . addSignature ( signature ) ;
return signature ;
}
private Set < String > getRelevantElements ( String targetElm ) {
Set < String > result = new HashSet < String > ( ) ;
if ( sims == null ) return result ;
for ( Similarity s : sims ) {
if ( s . getTo ( ) . getName ( ) . compareTo ( targetElm ) == <num> ) {
Element sourceElm = s . getOf ( ) ;
if ( ! sourceElm . isAssociation ( ) ) {
result . add ( sourceElm . getName ( ) ) ;
}
}
}
return result ;
}
private Set < String > getTopmostSourceSupersorts ( Set < String > sortNames ) throws
SdfDefinitionException {
Set < String > result = new HashSet < String > ( ) ;
result . addAll ( sortNames ) ;
for ( String sub : sortNames ) {
for ( String sup : sortNames ) {
if ( sub . compareTo ( sup ) != <num> && isSubsortInSource ( sup , sub ) ) {
result . remove ( sub ) ;
}
}
}
return result ;
}
private boolean isSubsortInSource ( String superSortName , String subsortCandidateName ) throws
SdfDefinitionException {
boolean result = false ;
Sort superSort = source . getSort ( superSortName ) ;
if ( ! superSort . isTerminal ( ) ) {
Nonterminal nonterm = ( Nonterminal ) superSort ;
AbstractSortDef sortDef = nonterm . getDefinition ( ) ;
if ( sortDef . isAlternative ( ) ) {
for ( Object alternative : sortDef . getElements ( ) ) {
if ( ( ( AbstractSortDef ) alternative ) . isDeclaration ( ) ) {
if ( ( ( Declaration ) alternative ) . getElements ( ) . size ( ) == <num> ) {
DeclarationElement elm = ( ( Declaration ) alternative ) . getElements ( ) . iterator ( ) . next ( ) ;
if ( elm . isSortName ( ) ) {
String elmSortName = ( ( SortName ) elm ) . getValue ( ) ;
if ( elmSortName . compareTo ( subsortCandidateName ) == <num> ) return true ;
else if ( isSubsortInSource ( elmSortName , subsortCandidateName ) )
result = true ;
}
}
}
}
}
}
return result ;
}
private void processDeclaration ( Declaration decl , Signature signature ) throws
SdfDefinitionException , TranslatorTemplateConstructionException {
String declStringRepr = " ;
Map < Variable , Integer > variableInstances ;
Equation equation = new Equation ( ) ;
String equationParams ;
Set < Condition > conditions ;
declStringRepr = decl . toTerm ( ) ;
variableInstances = decl . getVariableInstances ( ) ;
for ( Variable var : variableInstances . keySet ( ) )
translator . addRangeSortVariable ( var ) ;
conditions = generateEquationConditions ( variableInstances ) ;
equationParams = signatureParamsToTermList ( signature , ParameterTermSeparator . NEWLINE ) ;
equation . setTag ( signature . getName ( ) ) ;
equation . setDefinedFunctionName ( signature . getName ( ) ) ;
equation . setParams ( equationParams ) ;
equation . setBody ( declStringRepr ) ;
equation . getConditions ( ) . addAll ( conditions ) ;
translator . addEquation ( equation ) ;
}
private String signatureParamsToTermList ( Signature signature , ParameterTermSeparator sep ) throws
TranslatorTemplateConstructionException , SdfDefinitionException {
Map < Variable , Integer > variableInstances = null ;
String term = " ;
String result = " ;
int i = <num> ;
int paramNumber ;
paramNumber = signature . getParams ( ) . size ( ) ;
if ( paramNumber != <num> ) result += sep . toString ( ) ;
for ( Declaration paramDecl : signature . getParams ( ) ) {
if ( paramDecl . consistsOfOneSortName ( ) ) {
String paramSortName = ( ( SortName ) paramDecl . getElements ( ) . iterator ( ) . next ( ) ) . getValue ( ) ;
Sort paramSort = source . getSort ( paramSortName ) ;
term = paramSort . toTerm ( ) ;
variableInstances = paramSort . getVariableInstances ( ) ;
} else {
term = paramDecl . toTerm ( ) ;
variableInstances = paramDecl . getVariableInstances ( ) ;
}
result += term ;
if ( i != paramNumber ) result += " ;
result += sep . toString ( ) ;
for ( Variable var : variableInstances . keySet ( ) )
translator . addDomainSortVariable ( var ) ;
i ++ ;
}
return result ;
}
private String signatureToTerm ( Signature signature , ParameterTermSeparator sep ) throws
SdfDefinitionException , TranslatorTemplateConstructionException {
String result ;
result = signature . getName ( ) + " ;
result += signatureParamsToTermList ( signature , sep ) ;
result += " ;
return result ;
}
private Set < Condition > generateEquationConditions ( Map < Variable , Integer > variableInstances ) throws
TranslatorTemplateConstructionException , SdfDefinitionException {
Set < Condition > result = new HashSet < Condition > ( ) ;
for ( Variable var : variableInstances . keySet ( ) ) {
Declaration decl = var . getDeclaration ( ) ;
String originalSortName = " ;
Sort originalSort ;
Signature sig = null ;
logger . info ( " + var . getName ( ) ) ;
if ( ! decl . isSimple ( ) )
throw new TranslatorTemplateConstructionException ( " ) ;
originalSortName = decl . getNameIfSimple ( ) ;
originalSort = target . getSort ( originalSortName ) ;
if ( originalSort == null ) continue ;
if ( sortNamesToProcess . contains ( originalSortName ) ) {
sortNamesToProcess . remove ( originalSortName ) ;
processSort ( originalSort ) ;
}
if ( ( decl . consistsOfOneSortName ( ) || decl . consistsOfOneSimpleOptional ( ) ) && ! originalSort . isListSort ( ) ) {
sig = translator . getSignature ( originalSort . getSignatureName ( ) ) ;
} else
if ( decl . isList ( ) || ( decl . consistsOfOneSortName ( ) && originalSort . isListSort ( ) ) ) {
Set < Association > relAssoc ;
Set < String > additionalRelevSorts ;
if ( decl . consistsOfOneSortName ( ) && originalSort . isListSort ( ) ) {
decl = ( Declaration ) ( ( Nonterminal ) originalSort ) . getDefinition ( ) ;
originalSortName = decl . getNameIfSimple ( ) ;
originalSort = target . getSort ( originalSortName ) ;
logger . info ( " + originalSortName ) ;
} else
logger . info ( " + originalSortName ) ;
relAssoc = getConsistentRelevantAssociations ( processedSortName , originalSortName ) ;
logger . info ( " + relAssoc . size ( ) ) ;
additionalRelevSorts = getTopmostSourceSupersorts ( getRelevantElements ( originalSortName ) ) ;
for ( Association assoc : relAssoc )
additionalRelevSorts . remove ( assoc . getRange ( ) ) ;
sig = translator . getSignature ( decl . getSignatureName ( ) ) ;
if ( sig != null && relAssoc . size ( ) > <num> ) {
target . removeSignature ( sig ) ;
sig = null ;
}
if ( sig == null ) {
sig = new Signature ( ) ;
sig . setName ( decl . getSignatureName ( ) ) ;
sig . setReturnSort ( decl ) ;
for ( Association assoc : relAssoc ) {
String sep = source . getSeparatorOfListSort ( assoc . getDomain ( ) , assoc . getRange ( ) ) ;
sig . addParam ( new Declaration ( new List ( assoc . getRange ( ) , sep ) ) ) ;
}
for ( String sortName : additionalRelevSorts )
sig . addParam ( new Declaration ( new SortName ( sortName ) ) ) ;
translator . addSignature ( sig ) ;
logger . info ( " + this . signatureToTerm ( sig , ParameterTermSeparator . SPACE ) ) ;
if ( relAssoc . size ( ) == <num> )
generateListSortTranslationEquations ( sig , ( List ) decl . getElements ( ) . iterator ( ) . next ( ) ) ;
}
}
for ( int i = <num> ; i <= variableInstances . get ( var ) . intValue ( ) ; i ++ ) {
Condition cond = new Condition ( ) ;
cond . setKind ( ConditionKind . MATCHING ) ;
if ( i > <num> ) cond . setLeft ( var . getName ( ) + i ) ;
else cond . setLeft ( var . getName ( ) ) ;
cond . setRight ( signatureToTerm ( sig , ParameterTermSeparator . SPACE ) ) ;
result . add ( cond ) ;
}
}
return result ;
}
private Set < Association > getConsistentRelevantAssociations ( String domain , String range ) {
Set < Association > result = new HashSet < Association > ( ) ;
if ( sims == null ) return result ;
for ( Similarity s : sims ) {
Element sourceElm = s . getOf ( ) ;
Element targetElm = s . getTo ( ) ;
if ( sourceElm . isAssociation ( ) && targetElm . isAssociation ( ) ) {
Association sourceAssoc = ( Association ) sourceElm ;
Association targetAssoc = ( Association ) targetElm ;
if ( targetAssoc . getDomain ( ) . compareTo ( domain ) == <num> &&
targetAssoc . getRange ( ) . compareTo ( range ) == <num> &&
getRelevantElements ( domain ) . contains ( sourceAssoc . getDomain ( ) ) &&
getRelevantElements ( range ) . contains ( sourceAssoc . getRange ( ) )
) {
result . add ( sourceAssoc ) ;
}
}
}
return result ;
}
private void generateListSortTranslationEquations ( Signature listTranslationSignature , List targetList )
throws SdfDefinitionException , TranslatorTemplateConstructionException {
Equation emptyListProcessingEq = new Equation ( ) ;
Equation nonEmptyListProcessingEq = new Equation ( ) ;
String targetSortName = " ;
String targetSortSigName = " ;
String targetListVarName = " ;
String targetSeparator = targetList . getSeparator ( ) ;
Condition headCondition = new Condition ( ) ;
Condition taleCondition = new Condition ( ) ;
Signature listElementTranslationSignature = null ;
List sourceList = null ;
Sort targetSort = null ;
logger . info ( " ) ;
if ( targetList . isSimple ( ) ) {
targetSortSigName = targetList . getSignatureNameIfSimple ( ) ;
targetSortName = targetList . getNameIfSimple ( ) ;
targetListVarName = targetList . getVariableName ( ) ;
targetSort = target . getSort ( targetSortName ) ;
}
else
throw new TranslatorTemplateConstructionException ( " ) ;
if ( translator . getSignatureNames ( ) . contains ( targetSort . getSignatureName ( ) ) )
listElementTranslationSignature = translator . getSignature ( targetSort . getSignatureName ( ) ) ;
else
throw new TranslatorTemplateConstructionException ( " ) ;
if ( listTranslationSignature . getParams ( ) . size ( ) == <num> )
throw new TranslatorTemplateConstructionException ( " ) ;
else
if ( ! listTranslationSignature . getParams ( ) . get ( <num> ) . isList ( ) )
throw new TranslatorTemplateConstructionException ( " ) ;
else
sourceList = ( List ) listTranslationSignature . getParams ( ) . get ( <num> ) . getElements ( ) . iterator ( ) . next ( ) ;
if ( ! sourceList . isSimple ( ) )
throw new TranslatorTemplateConstructionException ( " ) ;
emptyListProcessingEq . setTag ( listTranslationSignature . getName ( ) + " ) ;
emptyListProcessingEq . setDefinedFunctionName ( listTranslationSignature . getName ( ) ) ;
translator . addEquation ( emptyListProcessingEq ) ;
nonEmptyListProcessingEq . setTag ( listTranslationSignature . getName ( ) ) ;
nonEmptyListProcessingEq . setDefinedFunctionName ( listTranslationSignature . getName ( ) ) ;
nonEmptyListProcessingEq . setBody ( targetSortName + " + targetSeparator + " + targetListVarName ) ;
nonEmptyListProcessingEq . setParams ( sourceList . getNameIfSimple ( ) + " + sourceList . getSeparator ( ) + " +
signatureParamsToTermList ( listTranslationSignature , ParameterTermSeparator . SPACE ) ) ;
headCondition . setKind ( ConditionKind . MATCHING ) ;
headCondition . setLeft ( targetSortName ) ;
headCondition . setRight ( signatureToTerm ( listElementTranslationSignature , ParameterTermSeparator . SPACE ) ) ;
taleCondition . setKind ( ConditionKind . MATCHING ) ;
taleCondition . setLeft ( targetListVarName ) ;
taleCondition . setRight ( signatureToTerm ( listTranslationSignature , ParameterTermSeparator . SPACE ) ) ;
nonEmptyListProcessingEq . addCondition ( headCondition ) ;
nonEmptyListProcessingEq . addCondition ( taleCondition ) ;
translator . addEquation ( nonEmptyListProcessingEq ) ;
}
}
enum ParameterTermSeparator {
SPACE ( " ) ,
NEWLINE ( " ) ;
private String stringValue = " ;
ParameterTermSeparator ( String value ) {
stringValue = value ;
}
public String toString ( ) {
return stringValue ;
}
}
package unifier . asfsdf ;
import java . util . List ;
import java . util . ArrayList ;
import unifier . util . StringHelper ;
import java . util . Map ;
import java . util . HashMap ;
import java . util . Set ;
import java . util . HashSet ;
public class Declaration extends AbstractSortDef {
private List < DeclarationElement > elements = new ArrayList < DeclarationElement > ( ) ;
public Declaration ( ) { } ;
public Declaration ( DeclarationElement elm ) {
elements . add ( elm ) ;
}
public List < DeclarationElement > getElements ( ) {
return elements ;
}
public Declaration addElement ( DeclarationElement elm ) {
elements . add ( elm ) ;
return this ;
}
public Declaration addElements ( List < DeclarationElement > elms ) {
elements . addAll ( elms ) ;
return this ;
}
public boolean isDeclaration ( ) {
return true ;
}
public boolean isAlternative ( ) {
return false ;
}
public boolean isEnumeration ( ) {
return false ;
}
public boolean isSimple ( ) {
if ( elements . size ( ) == <num> && elements . iterator ( ) . next ( ) . isSimple ( ) ) return true ;
else return false ;
}
public String getNameIfSimple ( ) throws SdfDefinitionException {
if ( this . isSimple ( ) ) {
return elements . iterator ( ) . next ( ) . getNameIfSimple ( ) ;
} else {
throw new SdfDefinitionException ( " ) ;
}
}
public boolean consistsOfOneSortName ( ) {
if ( elements . size ( ) == <num> && elements . iterator ( ) . next ( ) . isSortName ( ) ) return true ;
else return false ;
}
public boolean consistsOfOneLiteral ( ) {
if ( elements . size ( ) == <num> && elements . iterator ( ) . next ( ) . isLiteral ( ) ) return true ;
else return false ;
}
public boolean consistsOfOneSimpleOptional ( ) {
DeclarationElement elm = elements . iterator ( ) . next ( ) ;
if ( elements . size ( ) == <num> && elm . isDerivedSort ( ) &&
( ( DerivedSort ) elm ) . isOptional ( ) &&
( ( Optional ) elm ) . originalSortDeclConsistsOfOneSortName ( )
)
return true ;
else
return false ;
}
public boolean isList ( ) {
if ( elements . size ( ) == <num> && elements . iterator ( ) . next ( ) . isList ( ) )
return true ;
else return false ;
}
public String getSignatureName ( ) throws SdfDefinitionException {
if ( isSimple ( ) ) {
return " + this . getVariableName ( ) ;
} else
throw new SdfDefinitionException ( " ) ;
}
public String getVariableName ( ) throws SdfDefinitionException {
if ( isSimple ( ) ) {
return elements . iterator ( ) . next ( ) . getVariableName ( ) ;
} else
throw new SdfDefinitionException ( " ) ;
}
boolean termRepresentationGenerated = false ;
private String termRepr = " ;
private Map < Variable , Integer > variableInstances ;
public String toTerm ( ) throws SdfDefinitionException {
if ( ! termRepresentationGenerated ) {
variableInstances = new HashMap < Variable , Integer > ( ) ;
generateTermRepresentation ( ) ;
}
return termRepr ;
}
public Map < Variable , Integer > getVariableInstances ( ) throws SdfDefinitionException {
if ( ! termRepresentationGenerated ) generateTermRepresentation ( ) ;
return variableInstances ;
}
private void generateTermRepresentation ( ) throws SdfDefinitionException {
generateTermRepresentation ( elements ) ;
}
private void generateTermRepresentation ( List < DeclarationElement > elms ) throws SdfDefinitionException {
for ( DeclarationElement elm : elms ) {
if ( elm . isSimple ( ) ) {
Variable var ;
int n ;
termRepr = termRepr + elm . getVariableName ( ) ;
if ( ! elm . isLiteral ( ) ) {
var = new Variable ( new Declaration ( elm ) ) ;
addVariableInstance ( var ) ;
n = variableInstances . get ( var ) . intValue ( ) ;
if ( n > <num> ) termRepr = termRepr + n ;
}
termRepr = termRepr + " ;
} else
if ( elm . isDerivedSort ( ) &&
( ( DerivedSort ) elm ) . isOptional ( ) &&
( ( DerivedSort ) elm ) . originalSortIsDeclaration ( ) ) {
generateTermRepresentation ( ( ( DerivedSort ) elm ) . getOriginalSort ( ) . getElements ( ) ) ;
} else
throw new SdfDefinitionException ( " ) ;
}
termRepresentationGenerated = true ;
}
private void addVariableInstance ( Variable var ) {
int numberOfInstances ;
if ( variableInstances . containsKey ( var ) ) {
numberOfInstances = variableInstances . get ( var ) . intValue ( ) ;
numberOfInstances ++ ;
variableInstances . remove ( var ) ;
variableInstances . put ( var , new Integer ( numberOfInstances ) ) ;
} else {
variableInstances . put ( var , new Integer ( <num> ) ) ;
}
}
}
package unifier ;
import unifier . asfsdf . * ;
import unifier . util . DefaultFormattingWriter ;
import java . io . * ;
import unifier . util . StringHelper ;
import javax . swing . DefaultListCellRenderer ;
import unifier . util . ChooserDialog ;
import javax . swing . ListSelectionModel ;
import java . util . Set ;
import java . util . HashSet ;
import unifier . rsm . ReferenceSchemaModelException ;
public class Test {
public static void main ( String [ ] args ) throws IOException ,
SdfDefinitionException , SDF2RSException {
Module module = new Module ( ) ;
createModule ( module ) ;
}
private static void createModule ( Module module ) throws SdfDefinitionException {
module . setName ( " ) .
addImport ( " ) .
addImport ( " ) .
addStartSymbol ( " ) .
addStartSymbol ( " ) ;
Signature s1 = new Signature ( ) ;
Signature s2 = new Signature ( ) ;
Signature s3 = new Signature ( ) ;
Signature s4 = new Signature ( ) ;
s1 . setName ( " ) .
addParam ( new Declaration ( new SortName ( " ) ) ) .
addParam ( new Declaration ( new Optional ( " ) ) ) .
setReturnSort ( new Declaration ( new SortName ( " ) ) ) ;
s2 . setName ( " ) .
addParam ( new Declaration ( new List ( " ) ) ) .
setReturnSort ( new Declaration ( new List ( " ,
" ) ) ) ;
s3 . setName ( " ) .
addParam ( new Declaration ( new List ( " ) ) ) .
setReturnSort ( new Declaration ( new Optional ( ( new Declaration ( ) ) .
addElement ( new Literal ( " ) ) .
addElement ( new Literal ( " ) ) .
addElement ( new SortName ( " ) ) .
addElement ( new Literal ( " ) ) ) ) ) ;
s4 . setName ( " ) .
addParam ( new Declaration ( new List ( " ) ) ) .
addParam ( new Declaration ( new List ( " ) ) ) .
setReturnSort ( new Declaration ( new List (
" ) ) ) ;
module . addSignature ( s1 ) . addSignature ( s2 ) . addSignature ( s3 ) . addSignature ( s4 ) ;
module . addDomainSortVariable ( new Variable ( " ,
new Declaration ( new SortName ( " ) ) ) ) ;
module . addDomainSortVariable ( new Variable ( " ,
new Declaration ( new List ( " ) ) ) ) ;
module . addDomainSortVariable ( new Variable ( " ,
new Declaration ( new Optional ( " ) ) ) ) ;
module . addRangeSortVariable ( new Variable ( " ,
new Declaration ( new SortName ( " ) ) ) ) ;
module . addEquation ( ( new Equation ( " ,
" ) ) . setBody (
" ) ) ;
module . addEquation (
( new Equation ( " , " ) ) .
setBody ( " ) .
setParams ( " ) .
addCondition ( new Condition ( " ,
" ,
ConditionKind . MATCHING ) ) .
addCondition ( new Condition ( " ,
" ,
ConditionKind . NEGATIVE_MATCHING ) ) ) ;
}
private static void <unk> ( Module module ) throws IOException ,
SdfDefinitionException {
AsfSsdfFormattingWriter writer1 = new AsfSsdfFormattingWriter (
DefaultFormattingWriter . createFileWriter ( " ) ) ;
writer1 . translatorHeader ( module ) ;
AsfSsdfFormattingWriter writer2 = new AsfSsdfFormattingWriter (
DefaultFormattingWriter . createFileWriter ( " ) ) ;
writer2 . equations ( module ) ;
System . out . println ( StringHelper . getLastComponentOfPath (
" ) ) ;
}
private static void <unk> ( ) {
Set < String > testNames = new HashSet < String > ( ) ;
testNames . add ( " ) ;
testNames . add ( " ) ;
testNames . add ( " ) ;
testNames = ChooserDialog . showChooserDialog (
" ,
" ,
" ,
ListSelectionModel . MULTIPLE_INTERVAL_SELECTION ,
testNames ,
new DefaultListCellRenderer ( )
) ;
for ( String s : testNames ) System . out . println ( s ) ;
}
private static void <unk> ( Module module ) throws SDF2RSException ,
SdfDefinitionException , IOException , ReferenceSchemaModelException {
SDF2RS sdf2rs ;
sdf2rs = new SDF2RS ( module , DefaultFormattingWriter . createFileWriter ( " ) ) ;
sdf2rs . generateSchema ( ) ;
}
}
package unifier . asfsdf ;
public abstract class DeclarationElement {
public abstract boolean isDerivedSort ( ) ;
public abstract boolean isLiteral ( ) ;
public abstract boolean isSortName ( ) ;
public abstract boolean isList ( ) ;
public abstract boolean isOptionalLiteral ( ) ;
public abstract boolean isOptional ( ) ;
public abstract boolean isSimple ( ) ;
public abstract String getNameIfSimple ( ) throws SdfDefinitionException ;
public abstract String getVariableName ( ) throws SdfDefinitionException ;
}
package unifier . util ;
import javax . swing . DefaultListCellRenderer ;
import javax . swing . JList ;
import meta . ModelRegDef ;
import java . awt . Component ;
import java . sql . SQLException ;
import meta . ExtensionRegDef ;
public class ExtensionRegDefCellRenderer extends DefaultListCellRenderer {
public Component getListCellRendererComponent (
JList list ,
Object value ,
int index ,
boolean iss ,
boolean chf )
{
if ( value instanceof ExtensionRegDef ) {
ExtensionRegDef model = ( ExtensionRegDef ) value ;
String modelName = " ;
try {
modelName = model . get_name ( ) ;
} catch ( SQLException ex ) {
}
super . getListCellRendererComponent ( list , modelName , index , iss , chf ) ;
}
else {
super . getListCellRendererComponent ( list , value , index , iss , chf ) ;
}
return this ;
}
}
package unifier . rsm ;
import unifier . util . FormattingWriter ;
public class AssociationMetaclass extends Class {
private int minCard = <num> ;
private int maxCard = <num> ;
private int minInverseCard = <num> ;
private int maxInverseCard = <num> ;
public AssociationMetaclass ( ) {
}
public AssociationMetaclass ( String name , int minCard , int maxCard , int minInverseCard , int maxInverseCard ) {
this . name = name ;
this . minCard = minCard ;
this . maxCard = maxCard ;
this . minInverseCard = minInverseCard ;
this . maxInverseCard = maxInverseCard ;
}
public int <unk> ( ) {
return minCard ;
}
public void <unk> ( int card ) {
minCard = card ;
}
public int getMaxCard ( ) {
return maxCard ;
}
public void <unk> ( int card ) {
maxCard = card ;
}
public int <unk> ( ) {
return minInverseCard ;
}
public void <unk> ( int card ) {
minInverseCard = card ;
}
public int <unk> ( ) {
return maxInverseCard ;
}
public void <unk> ( int card ) {
maxInverseCard = card ;
}
public void specification ( FormattingWriter writer ) {
writer . write ( " ) ; writer . write ( getName ( ) ) ; writer . write ( " ) ;
writer . write ( " ) ; writer . ln ( + <num> ) ;
writer . write ( " ) ; writer . ln ( + <num> ) ;
writer . write ( " ) ;
writer . write ( " ) ;
if ( minCard ==  <num> ) writer . write ( " ) ; else writer . write ( " + minCard ) ;
writer . write ( " ) ;
if ( maxCard ==  <num> ) writer . write ( " ) ; else writer . write ( " + maxCard ) ;
writer . write ( " ) ;
if ( minInverseCard ==  <num> ) writer . write ( " ) ; else writer . write ( " + minInverseCard ) ;
writer . write ( " ) ;
if ( maxInverseCard ==  <num> ) writer . write ( " ) ; else writer . write ( " + maxInverseCard ) ;
writer . write ( " ) ;
writer . write ( " ) ;
writer . ln (  <num> ) ;
writer . write ( " ) ;
writer . ln (  <num> ) ;
writer . write ( " ) ;
}
}
package unifier . util ;
import javax . swing . JDialog ;
import java . awt . event . ActionEvent ;
import javax . swing . DefaultListModel ;
import javax . swing . JPanel ;
import java . awt . Insets ;
import java . util . Set ;
import java . awt . event . ActionListener ;
import javax . swing . JButton ;
import java . awt . Dimension ;
import java . awt . GridBagConstraints ;
import javax . swing . JList ;
import java . awt . FlowLayout ;
import javax . swing . ListSelectionModel ;
import javax . swing . JScrollPane ;
import java . awt . GridBagLayout ;
import javax . swing . JRadioButton ;
import java . awt . * ;
import javax . swing . ButtonGroup ;
public class ModelKindChooserDialog extends JDialog {
private ModelKindChooserDialog ( ) {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
}
private void jbInit ( ) throws Exception {
this . setModal ( true ) ;
this . setResizable ( true ) ;
this . setTitle ( " ) ;
this . getContentPane ( ) . setLayout ( gridBagLayoutECD ) ;
jButtonOK . setToolTipText ( " ) ;
jButtonOK . addActionListener ( new
ModelKindChooserDialog_jButtonOK_actionAdapter ( this ) ) ;
jButtonOK . setText ( " ) ;
jPanelButtons . setLayout ( flowLayoutButtons ) ;
jRadioButtonTarget . setToolTipText (
" ) ;
jRadioButtonTarget . setActionCommand ( " ) ;
jRadioButtonTarget . setText ( " ) ;
jRadioButtonTarget . addActionListener ( new
ModelKindChooserDialog_jRadioButtonTarget_actionAdapter ( this ) ) ;
jRadioButtonSource . setToolTipText (
" ) ;
jRadioButtonSource . setActionCommand ( " ) ;
jRadioButtonSource . setSelected ( true ) ;
jRadioButtonSource . setText ( " ) ;
jRadioButtonSource . addActionListener ( new
ModelKindChooserDialog_jRadioButtonSource_actionAdapter ( this ) ) ;
jPanelButtons . setMinimumSize ( new Dimension ( <num> , <num> ) ) ;
jPanelButtons . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jPanelButtons . add ( jButtonOK ) ;
this . getContentPane ( ) . add ( jRadioButtonTarget ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
this . getContentPane ( ) . add ( jRadioButtonSource ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
this . getContentPane ( ) . add ( jPanelButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
}
GridBagLayout gridBagLayoutECD = new GridBagLayout ( ) ;
JPanel jPanelButtons = new JPanel ( ) ;
FlowLayout flowLayoutButtons = new FlowLayout ( ) ;
JButton jButtonOK = new JButton ( ) ;
JRadioButton jRadioButtonTarget = new JRadioButton ( ) ;
JRadioButton jRadioButtonSource = new JRadioButton ( ) ;
public static boolean showModelKindChooserDialog ( ) {
ModelKindChooserDialog dialog = new ModelKindChooserDialog ( ) ;
dialog . pack ( ) ;
dialog . validate ( ) ;
dialog . setVisible ( true ) ;
return dialog . isTarget ;
}
private boolean isTarget = false ;
public void jButtonOK_actionPerformed ( ActionEvent e ) {
this . dispose ( ) ;
}
public void jRadioButtonSource_actionPerformed ( ActionEvent e ) {
jRadioButtonTarget . setSelected ( false ) ;
isTarget = false ;
}
public void jRadioButtonTarget_actionPerformed ( ActionEvent e ) {
jRadioButtonSource . setSelected ( false ) ;
isTarget = true ;
}
}
class ModelKindChooserDialog_jRadioButtonTarget_actionAdapter implements
ActionListener {
private ModelKindChooserDialog adaptee ;
ModelKindChooserDialog_jRadioButtonTarget_actionAdapter (
ModelKindChooserDialog adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jRadioButtonTarget_actionPerformed ( e ) ;
}
}
class ModelKindChooserDialog_jRadioButtonSource_actionAdapter implements
ActionListener {
private ModelKindChooserDialog adaptee ;
ModelKindChooserDialog_jRadioButtonSource_actionAdapter (
ModelKindChooserDialog adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jRadioButtonSource_actionPerformed ( e ) ;
}
}
class ModelKindChooserDialog_jButtonOK_actionAdapter implements ActionListener {
private ModelKindChooserDialog adaptee ;
ModelKindChooserDialog_jButtonOK_actionAdapter ( ModelKindChooserDialog adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonOK_actionPerformed ( e ) ;
}
}
package unifier . asfsdf ;
public class SdfDefinitionException extends Exception {
public SdfDefinitionException ( String message ) {
super ( message ) ;
}
}
package unifier ;
public class Start {
public static void main ( String args [ ] ) {
ModelManager registrar = new ModelManager ( ) ;
}
}
package unifier . asfsdf ;
import org . antlr . runtime . tree . Tree ;
import unifier . sdfparser . SdfLexer ;
import java . util . HashSet ;
import java . util . Set ;
import java . util . logging . Logger ;
import java . io . Reader ;
import org . antlr . runtime . CommonTokenStream ;
import org . antlr . runtime . ANTLRReaderStream ;
import unifier . sdfparser . SdfParser ;
import java . io . IOException ;
import org . antlr . runtime . RecognitionException ;
import org . antlr . runtime . tree . CommonTree ;
public class SdfCreator {
Logger logger = Logger . getLogger ( " ) ;
Module resultModule ;
Set < String > terminalSortNames ;
public SdfCreator ( ) {
resultModule = new Module ( ) ;
terminalSortNames = new HashSet < String > ( ) ;
}
public Set < String > getSortNames ( Reader reader ) throws IOException ,
RecognitionException , SdfDefinitionException {
Set < String > result = new HashSet < String > ( ) ;
SdfLexer lex = new SdfLexer ( new ANTLRReaderStream ( reader ) ) ;
CommonTokenStream tokens = new CommonTokenStream ( lex ) ;
SdfParser g = new SdfParser ( tokens ) ;
SdfParser . module_return r = g . module ( ) ;
CommonTree tree = ( CommonTree ) r . getTree ( ) ;
resultModule = new Module ( ) ;
module ( tree ) ;
result . addAll ( resultModule . getSortNames ( ) ) ;
return result ;
}
public Module processSdf ( Reader reader , Set < String > terminalSortNames )
throws IOException , RecognitionException , SdfDefinitionException {
SdfLexer lex = new SdfLexer ( new ANTLRReaderStream ( reader ) ) ;
CommonTokenStream tokens = new CommonTokenStream ( lex ) ;
SdfParser g = new SdfParser ( tokens ) ;
SdfParser . module_return r = g . module ( ) ;
CommonTree tree = ( CommonTree ) r . getTree ( ) ;
if ( terminalSortNames != null )
this . terminalSortNames . addAll ( terminalSortNames ) ;
module ( tree ) ;
return resultModule ;
}
private void module ( Tree tree ) throws
SdfDefinitionException {
if ( tree . <unk> ( ) ) return ;
for ( int i = <num> ; i < tree . getChildCount ( ) ; i ++ ) {
Tree child = tree . getChild ( i ) ;
switch ( child . getType ( ) ) {
case SdfLexer . MODULENAME :
resultModule . setName ( moduleName ( child ) ) ;
break ;
case SdfLexer . IMPORTS :
imports ( child ) ;
break ;
case SdfLexer . EXPORTS :
exports ( child ) ;
break ;
}
}
}
private String moduleName ( Tree tree ) {
String result = " ;
for ( int i = <num> ; i < tree . getChildCount ( ) ; i ++ ) {
Tree child = tree . getChild ( i ) ;
switch ( child . getType ( ) ) {
case SdfLexer . ID :
if ( i != tree . getChildCount ( )  <num> ) result = result + child . getText ( ) + " ;
else result = result + child . getText ( ) ;
break ;
}
}
return result ;
}
private void imports ( Tree tree ) {
for ( int i = <num> ; i < tree . getChildCount ( ) ; i ++ ) {
Tree child = tree . getChild ( i ) ;
switch ( child . getType ( ) ) {
case SdfLexer . MODULENAME :
resultModule . addImport ( moduleName ( child ) ) ;
break ;
}
}
}
private void exports ( Tree tree ) throws SdfDefinitionException {
for ( int i = <num> ; i < tree . getChildCount ( ) ; i ++ ) {
Tree child = tree . getChild ( i ) ;
switch ( child . getType ( ) ) {
case SdfLexer . STARTSYMBOLS :
startSymbols ( child ) ;
break ;
case SdfLexer . SORTS :
sorts ( child ) ;
break ;
case SdfLexer . SYNTAX :
syntax ( child ) ;
break ;
}
}
}
private void startSymbols ( Tree tree ) throws SdfDefinitionException {
for ( int i = <num> ; i < tree . getChildCount ( ) ; i ++ ) {
Tree child = tree . getChild ( i ) ;
switch ( child . getType ( ) ) {
case SdfLexer . SORT :
resultModule . addStartSymbol ( sort ( child ) ) ;
break ;
}
}
}
private String sort ( Tree tree ) {
for ( int i = <num> ; i < tree . getChildCount ( ) ; i ++ ) {
Tree child = tree . getChild ( i ) ;
switch ( child . getType ( ) ) {
case SdfLexer . ID :
return child . getText ( ) ;
}
}
return null ;
}
private void sorts ( Tree tree ) throws SdfDefinitionException {
for ( int i = <num> ; i < tree . getChildCount ( ) ; i ++ ) {
Tree child = tree . getChild ( i ) ;
switch ( child . getType ( ) ) {
case SdfLexer . SORT :
Sort sort = null ;
String sortName = sort ( child ) ;
if ( this . terminalSortNames . contains ( sortName ) ) sort = ( new Terminal ( ) ) . setName ( sortName ) ;
else sort = ( new Nonterminal ( ) ) . setName ( sortName ) ;
resultModule . addSort ( sort ) ;
break ;
}
}
}
private void syntax ( Tree tree ) throws SdfDefinitionException {
for ( int i = <num> ; i < tree . getChildCount ( ) ; i ++ ) {
Tree child = tree . getChild ( i ) ;
switch ( child . getType ( ) ) {
case SdfLexer . PRODUCTION :
production ( child ) ;
break ;
}
}
}
private void production ( Tree tree ) throws SdfDefinitionException {
Tree right ;
Tree left ;
Nonterminal sort ;
String sortName ;
String enumElm ;
AbstractSortDef definition ;
if ( tree . getChildCount ( ) < <num> ||
tree . getChild ( <num> ) . getType ( ) != SdfLexer . LEFT ||
tree . getChild ( <num> ) . getType ( ) != SdfLexer . RIGHT
)
return ;
left = tree . getChild ( <num> ) ;
right = tree . getChild ( <num> ) ;
if ( right . getChildCount ( ) != <num> || right . getChild ( <num> ) . getType ( ) != SdfLexer . SORT ) return ;
sortName = sort ( right . getChild ( <num> ) ) ;
if ( terminalSortNames . contains ( sortName ) ) return ;
sort = ( Nonterminal ) resultModule . getSort ( sortName ) ;
if ( sort == null ) {
sort = new Nonterminal ( ) ;
sort . setName ( sortName ) ;
resultModule . addSort ( sort ) ;
}
definition = sort . getDefinition ( ) ;
enumElm = getEnumeration ( left ) ;
if ( enumElm != null && definition == null ) {
definition = new Enumeration ( ) ;
sort . setDefinition ( definition ) ;
( ( Enumeration ) definition ) . addElement ( enumElm ) ;
} else
if ( enumElm != null && definition . isEnumeration ( ) ) {
( ( Enumeration ) definition ) . addElement ( enumElm ) ;
} else
if ( enumElm == null && definition == null ) {
sort . setDefinition ( symbols ( left ) ) ;
} else
if ( enumElm == null && definition . isEnumeration ( ) ) {
Alternative alternative = new Alternative ( ) ;
sort . setDefinition ( alternative ) ;
alternative . addElement ( symbols ( left ) ) ;
for ( String s : ( ( Enumeration ) definition ) . getElements ( ) ) {
alternative . addElement ( ( new Declaration ( ) ) . addElement ( new Literal ( s ) ) ) ;
}
} else
if ( definition . isAlternative ( ) ) {
( ( Alternative ) definition ) . addElement ( symbols ( left ) ) ;
} else
if ( definition . isDeclaration ( ) ) {
Alternative alternative = new Alternative ( ) ;
sort . setDefinition ( alternative ) ;
alternative . addElement ( definition ) ;
alternative . addElement ( symbols ( left ) ) ;
}
}
private String getEnumeration ( Tree tree ) {
String result = " ;
for ( int i = <num> ; i < tree . getChildCount ( ) ; i ++ ) {
Tree child = tree . getChild ( i ) ;
switch ( child . getType ( ) ) {
case SdfLexer . STRING :
if ( i != tree . getChildCount ( )  <num> ) result = result + child . getText ( ) + " ;
else result = result + child . getText ( ) ;
break ;
default :
return null ;
}
}
return result ;
}
private Declaration symbols ( Tree tree ) {
Declaration result = new Declaration ( ) ;
for ( int i = <num> ; i < tree . getChildCount ( ) ; i ++ ) {
Tree child = tree . getChild ( i ) ;
switch ( child . getType ( ) ) {
case SdfLexer . STRING :
result . addElement ( new Literal ( child . getText ( ) ) ) ;
break ;
case SdfLexer . SORT :
result . addElement ( new SortName ( sort ( child ) ) ) ;
break ;
case SdfLexer . LIST :
result . addElement ( list ( child ) ) ;
break ;
case SdfLexer . MARKEDSYMBOL :
result . addElement ( markedSymbol ( child ) ) ;
break ;
case SdfLexer . COMPOUNDSYMBOL :
result . addElements ( symbols ( child ) . getElements ( ) ) ;
break ;
}
}
return result ;
}
private Declaration symbol ( Tree tree ) {
Declaration result = new Declaration ( ) ;
switch ( tree . getType ( ) ) {
case SdfLexer . STRING :
result . addElement ( new Literal ( tree . getText ( ) ) ) ;
break ;
case SdfLexer . SORT :
result . addElement ( new SortName ( sort ( tree ) ) ) ;
break ;
case SdfLexer . LIST :
result . addElement ( list ( tree ) ) ;
break ;
case SdfLexer . MARKEDSYMBOL :
result . addElement ( markedSymbol ( tree ) ) ;
break ;
case SdfLexer . COMPOUNDSYMBOL :
result . addElements ( symbols ( tree ) . getElements ( ) ) ;
break ;
}
return result ;
}
private List list ( Tree tree ) {
List result = new List ( ) ;
if ( tree . getChildCount ( ) != <num> ) return null ;
result . setOriginalSort ( symbol ( tree . getChild ( <num> ) . getChild ( <num> ) ) ) ;
result . setSeparator ( tree . getChild ( <num> ) . getChild ( <num> ) . getText ( ) ) ;
switch ( tree . getChild ( <num> ) . getChild ( <num> ) . getType ( ) ) {
case SdfLexer . PLUS :
result . setMultiplicity ( ListMultiplicity . AT_LEAST_ONE_TIME ) ;
break ;
case SdfLexer . STAR :
result . setMultiplicity ( ListMultiplicity . AT_LEAST_ZERO_TIME ) ;
break ;
}
return result ;
}
private DerivedSort markedSymbol ( Tree tree ) {
DerivedSort result = null ;
if ( tree . getChildCount ( ) != <num> ) return null ;
switch ( tree . getChild ( <num> ) . getType ( ) ) {
case SdfLexer . PLUS :
result = new List ( ) ;
( ( List ) result ) . setMultiplicity ( ListMultiplicity . AT_LEAST_ONE_TIME ) ;
break ;
case SdfLexer . STAR :
result = new List ( ) ;
( ( List ) result ) . setMultiplicity ( ListMultiplicity . AT_LEAST_ZERO_TIME ) ;
break ;
case SdfLexer . QUESTION :
result = new Optional ( ) ;
break ;
}
result . setOriginalSort ( symbol ( tree . getChild ( <num> ) ) ) ;
return result ;
}
}
package unifier . util ;
import java . io . * ;
import javax . swing . * ;
import javax . swing . filechooser . * ;
public class ExtensionChoosableFileFilter extends javax . swing . filechooser . FileFilter {
private String description = null ;
private String exts = null ;
public ExtensionChoosableFileFilter ( String aext , String desc ) {
exts = aext ;
description = desc ;
}
public boolean accept ( File f ) {
if ( f == null ) return false ;
if ( f . isDirectory ( ) ) return true ;
if ( exts . compareTo ( " ) == <num> ) return true ;
String extension = getExtension ( f ) ;
if ( extension == null ) return false ;
return ( exts . indexOf ( " + extension + " ) !=  <num> ) ;
}
public String getExtension ( File f ) {
if ( f != null ) {
String filename = f . getName ( ) ;
int i = filename . lastIndexOf ( .' ) ;
if ( i > <num> && i < filename . length ( )  <num> )
return filename . substring ( i + <num> ) . toLowerCase ( ) ;
}
return null ;
}
public String getDescription ( ) {
return description ;
}
}
package unifier . rsm ;
import unifier . util . FormattingWriter ;
public class SetType extends BuiltInType {
public SetType ( ) { }
public SetType ( Type typeOfElement ) {
this . typeOfElement = typeOfElement ;
}
private Type typeOfElement = null ;
public Type <unk> ( ) {
return typeOfElement ;
}
public void <unk> ( Type type ) {
typeOfElement = type ;
}
public String getDesignator ( ) {
return " + typeOfElement . getName ( ) + " ;
}
public void specification ( FormattingWriter writer ) {
writer . write ( " ) ; writer . write ( getName ( ) ) ; writer . write ( " ) ; writer . ln ( + <num> ) ;
writer . write ( getDesignator ( ) ) ;
writer . ln (  <num> ) ;
writer . write ( " ) ;
}
public boolean isADT ( ) {
return false ;
}
}
package unifier ;
import javax . swing . JSplitPane ;
import java . awt . * ;
import javax . swing . JScrollPane ;
import javax . swing . JPanel ;
import javax . swing . JButton ;
import javax . swing . JList ;
import javax . swing . JTextArea ;
import javax . swing . BorderFactory ;
import javax . swing . border . TitledBorder ;
import javax . swing . JFrame ;
import java . util . logging . Logger ;
import meta . DB ;
import meta . ExtensionRegDef ;
import javax . swing . DefaultListModel ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseAdapter ;
import java . sql . * ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import meta . ModelRegDef ;
import javax . swing . JMenuBar ;
import javax . swing . JMenu ;
import javax . swing . JMenuItem ;
import unifier . util . ExtensionRegDefCellRenderer ;
public class ExtensionExplorer extends CenteredFrame {
public ExtensionExplorer ( ) {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
center ( ) ;
logger = Logger . getLogger ( " ) ;
}
public ExtensionExplorer ( DB db ) {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
logger = Logger . getLogger ( " ) ;
this . db = db ;
center ( ) ;
showExistingExstensions ( ) ;
}
private void jbInit ( ) throws Exception {
this . setJMenuBar ( jMenuBarExtensionExplorer ) ;
this . setTitle ( " ) ;
this . getContentPane ( ) . setLayout ( gridBagLayoutEE ) ;
jButtonOpen . setToolTipText (
" ) ;
jButtonOpen . setText ( " ) ;
jButtonOpen . addActionListener ( new
ExtensionExplorer_jButtonOpen_actionAdapter ( this ) ) ;
jSplitPaneExtensionExplorer . setOrientation ( JSplitPane . HORIZONTAL_SPLIT ) ;
jSplitPaneExtensionExplorer . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jTextAreaExtensionDescription . setFont ( new java . awt . Font (
" , Font . PLAIN , <num> ) ) ;
jTextAreaExtensionDescription . setEditable ( false ) ;
jTextAreaExtensionDescription . setText ( " ) ;
jScrollPaneExtensionExplorer . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jScrollPaneExtensionDescription . setBorder ( new TitledBorder (
BorderFactory . createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jButtonSubmitAsExtendedModel . setEnabled ( false ) ;
jButtonSubmitAsExtendedModel . setActionCommand (
" ) ;
jButtonSubmitAsExtendedModel . setText ( " ) ;
jButtonSubmitAsExtendedModel . addActionListener ( new
ExtensionExplorer_jButtonSubmitAsExtendingModel_actionAdapter ( this ) ) ;
jListExtensionExplorer . addMouseListener ( new
ExtensionExplorer_jListExtensionExplorer_mouseAdapter ( this ) ) ;
jButtonSubmitAsRefinedExtension . setEnabled ( false ) ;
jButtonSubmitAsRefinedExtension . setText ( " ) ;
jButtonSubmitAsRefinedExtension . addActionListener ( new
ExtensionExplorer_jButtonSubmitAsRefinedExtension_actionAdapter ( this ) ) ;
jMenuActions . setText ( " ) ;
jMenuItemSubmitExtendedModel . setEnabled ( false ) ;
jMenuItemSubmitExtendedModel . setActionCommand (
" ) ;
jMenuItemSubmitExtendedModel . setText ( " ) ;
jMenuItemSubmitExtendedModel . addActionListener ( new
ExtensionExplorer_jMenuItemSubmitExtendingModel_actionAdapter ( this ) ) ;
jMenuItemSubmitRefinedExtension . setEnabled ( false ) ;
jMenuItemSubmitRefinedExtension . setText (
" ) ;
jMenuItemSubmitRefinedExtension . addActionListener ( new
ExtensionExplorer_jMenuItemSubmitRefinedExtension_actionAdapter ( this ) ) ;
jPanelExtensionExplorerButtons . add ( jButtonOpen ) ;
jPanelExtensionExplorerButtons . add ( jButtonSubmitAsExtendedModel ) ;
jPanelExtensionExplorerButtons . add ( jButtonSubmitAsRefinedExtension ) ;
jSplitPaneExtensionExplorer . add ( jScrollPaneExtensionExplorer , JSplitPane . LEFT ) ;
jScrollPaneExtensionExplorer . getViewport ( ) . add ( jListExtensionExplorer ) ;
jSplitPaneExtensionExplorer . add ( jScrollPaneExtensionDescription , JSplitPane . RIGHT ) ;
jScrollPaneExtensionDescription . getViewport ( ) . add (
jTextAreaExtensionDescription ) ;
this . getContentPane ( ) . add ( jSplitPaneExtensionExplorer ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
this . getContentPane ( ) . add ( jPanelExtensionExplorerButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jMenuBarExtensionExplorer . add ( jMenuActions ) ;
jMenuActions . add ( jMenuItemSubmitExtendedModel ) ;
jMenuActions . add ( jMenuItemSubmitRefinedExtension ) ;
jListExtensionExplorer . setCellRenderer ( new ExtensionRegDefCellRenderer ( ) ) ;
jListExtensionExplorer . setModel ( new DefaultListModel ( ) ) ;
setDividersLocations ( ) ;
}
GridBagLayout gridBagLayoutEE = new GridBagLayout ( ) ;
JPanel jPanelExtensionExplorerButtons = new JPanel ( ) ;
JButton jButtonOpen = new JButton ( ) ;
JSplitPane jSplitPaneExtensionExplorer = new JSplitPane ( ) ;
JScrollPane jScrollPaneExtensionExplorer = new JScrollPane ( ) ;
JScrollPane jScrollPaneExtensionDescription = new JScrollPane ( ) ;
JList jListExtensionExplorer = new JList ( ) ;
JTextArea jTextAreaExtensionDescription = new JTextArea ( ) ;
JButton jButtonSubmitAsExtendedModel = new JButton ( ) ;
JButton jButtonSubmitAsRefinedExtension = new JButton ( ) ;
public void jListExtensionExplorer_mouseClicked ( MouseEvent e ) {
if ( ! jListExtensionExplorer . isSelectionEmpty ( ) ) {
ExtensionRegDef selection = ( ExtensionRegDef ) jListExtensionExplorer . getSelectedValue ( ) ;
try {
jTextAreaExtensionDescription . setText ( selection . get_description ( ) ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
}
public void jButtonOpen_actionPerformed ( ActionEvent e ) {
try {
openExtension ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonSubmitAsExtendingModel_actionPerformed ( ActionEvent e ) {
try {
submitExtendedModel ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonSubmitAsRefinedExtension_actionPerformed ( ActionEvent e ) {
try {
submitRefinedModel ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jMenuItemSubmitExtendingModel_actionPerformed ( ActionEvent e ) {
try {
submitExtendedModel ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jMenuItemSubmitRefinedExtension_actionPerformed ( ActionEvent e ) {
try {
submitRefinedModel ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
private void setDividersLocations ( ) {
jSplitPaneExtensionExplorer . setDividerLocation ( <num> ) ;
}
public ExtensionExplorer ( ExtensionRegistrar parent , ExtensionRegDef extension ) {
this ( ( DB ) extension . _db ( ) ) ;
parentExtensionRegistrar = parent ;
extendingModel = extension ;
jButtonSubmitAsExtendedModel . setEnabled ( true ) ;
jMenuItemSubmitExtendedModel . setEnabled ( true ) ;
}
public ExtensionExplorer ( ModelRegistrar parent , ModelRegDef model ) throws SQLException {
this ( ( DB ) model . _db ( ) ) ;
parentModelRegistrar = parent ;
refiningModel = model ;
if ( refiningModel . get_target ( ) ) {
jButtonSubmitAsRefinedExtension . setText ( " ) ;
jMenuItemSubmitRefinedExtension . setText ( " ) ;
}
else {
jButtonSubmitAsRefinedExtension . setText ( " ) ;
jMenuItemSubmitRefinedExtension . setText ( " ) ;
}
jButtonSubmitAsRefinedExtension . setEnabled ( true ) ;
jMenuItemSubmitRefinedExtension . setEnabled ( true ) ;
}
private Logger logger ;
private DB db ;
private ExtensionRegistrar parentExtensionRegistrar ;
private ExtensionRegDef extendingModel ;
private ModelRegistrar parentModelRegistrar ;
private ModelRegDef refiningModel ;
JMenuBar jMenuBarExtensionExplorer = new JMenuBar ( ) ;
JMenu jMenuActions = new JMenu ( ) ;
JMenuItem jMenuItemSubmitExtendedModel = new JMenuItem ( ) ;
JMenuItem jMenuItemSubmitRefinedExtension = new JMenuItem ( ) ;
private void showExistingExstensions ( ) {
for ( Object e : db . <unk> ( ) ) {
ExtensionRegDef ext = ( ExtensionRegDef ) e ;
( ( DefaultListModel ) jListExtensionExplorer . getModel ( ) ) . addElement ( ext ) ;
}
}
private void openExtension ( ) throws SQLException {
if ( ( ( ExtensionRegDef ) jListExtensionExplorer . getSelectedValue ( ) ) . get_name ( ) == null ) return ;
if ( ! jListExtensionExplorer . isSelectionEmpty ( ) ) {
ExtensionRegistrar registrar ;
logger . info ( " ) ;
registrar = new ExtensionRegistrar ( ( ExtensionRegDef ) jListExtensionExplorer . getSelectedValue ( ) ) ;
jListExtensionExplorer . clearSelection ( ) ;
}
}
private void submitExtendedModel ( ) throws SQLException {
if ( ! jListExtensionExplorer . isSelectionEmpty ( ) && extendingModel != null ) {
extendingModel . <unk> ( ( ExtensionRegDef ) jListExtensionExplorer . getSelectedValue ( ) ) ;
parentExtensionRegistrar . showExtendedModel ( ) ;
this . dispose ( ) ;
}
}
private void submitRefinedModel ( ) throws SQLException {
if ( ! jListExtensionExplorer . isSelectionEmpty ( ) && refiningModel != null ) {
refiningModel . <unk> ( ( ExtensionRegDef ) jListExtensionExplorer . getSelectedValue ( ) ) ;
parentModelRegistrar . showRefinedExtensionName ( ) ;
this . dispose ( ) ;
}
}
}
class ExtensionExplorer_jMenuItemSubmitExtendingModel_actionAdapter implements
ActionListener {
private ExtensionExplorer adaptee ;
ExtensionExplorer_jMenuItemSubmitExtendingModel_actionAdapter (
ExtensionExplorer adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jMenuItemSubmitExtendingModel_actionPerformed ( e ) ;
}
}
class ExtensionExplorer_jMenuItemSubmitRefinedExtension_actionAdapter implements
ActionListener {
private ExtensionExplorer adaptee ;
ExtensionExplorer_jMenuItemSubmitRefinedExtension_actionAdapter (
ExtensionExplorer adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jMenuItemSubmitRefinedExtension_actionPerformed ( e ) ;
}
}
class ExtensionExplorer_jButtonSubmitAsRefinedExtension_actionAdapter implements
ActionListener {
private ExtensionExplorer adaptee ;
ExtensionExplorer_jButtonSubmitAsRefinedExtension_actionAdapter (
ExtensionExplorer adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonSubmitAsRefinedExtension_actionPerformed ( e ) ;
}
}
class ExtensionExplorer_jButtonSubmitAsExtendingModel_actionAdapter implements
ActionListener {
private ExtensionExplorer adaptee ;
ExtensionExplorer_jButtonSubmitAsExtendingModel_actionAdapter (
ExtensionExplorer adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonSubmitAsExtendingModel_actionPerformed ( e ) ;
}
}
class ExtensionExplorer_jButtonOpen_actionAdapter implements ActionListener {
private ExtensionExplorer adaptee ;
ExtensionExplorer_jButtonOpen_actionAdapter ( ExtensionExplorer adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonOpen_actionPerformed ( e ) ;
}
}
class ExtensionExplorer_jListExtensionExplorer_mouseAdapter extends
MouseAdapter {
private ExtensionExplorer adaptee ;
ExtensionExplorer_jListExtensionExplorer_mouseAdapter ( ExtensionExplorer
adaptee ) {
this . adaptee = adaptee ;
}
public void mouseClicked ( MouseEvent e ) {
adaptee . jListExtensionExplorer_mouseClicked ( e ) ;
}
}
package unifier . rsm ;
import java . util . Map ;
import java . util . HashMap ;
import unifier . util . StringHelper ;
import java . util . Set ;
import unifier . util . FormattingWriter ;
public class Module extends Element {
private Map < String , Type > types = new HashMap < String , Type > ( ) ;
private Map < String , Class > classes = new HashMap < String , Class > ( ) ;
public void addType ( Type type ) throws ReferenceSchemaModelException {
if ( StringHelper . isNullEmptyOrBlank ( type . getName ( ) ) ) {
throw new ReferenceSchemaModelException ( " ) ;
} else {
types . put ( type . getName ( ) , type ) ;
}
}
public Set < String > getTypesNames ( ) {
return types . keySet ( ) ;
}
public Type getType ( String typeName ) {
return types . get ( typeName ) ;
}
public void addClass ( Class _class ) throws ReferenceSchemaModelException {
if ( StringHelper . isNullEmptyOrBlank ( _class . getName ( ) ) ) {
throw new ReferenceSchemaModelException ( " ) ;
} else {
classes . put ( _class . getName ( ) , _class ) ;
}
}
public Set < String > <unk> ( ) {
return classes . keySet ( ) ;
}
public Class getClass ( String typeName ) {
return classes . get ( typeName ) ;
}
public void specification ( FormattingWriter writer ) {
int i ;
writer . write ( " ) ; writer . write ( getName ( ) ) ; writer . write ( " ) ;
writer . write ( " ) ; writer . ln ( ) ; writer . ln ( ) ;
if ( types . size ( ) != <num> ) {
writer . write ( " ) ; writer . ln ( ) ; writer . ln ( ) ;
}
i = <num> ;
for ( String typeName : types . keySet ( ) ) {
types . get ( typeName ) . specification ( writer ) ;
if ( i < types . size ( ) ) writer . write ( " ) ; else writer . write ( " ) ;
writer . ln ( ) ; writer . ln ( ) ;
i ++ ;
}
if ( types . size ( ) != <num> ) {
writer . ln ( ) ; writer . ln ( ) ;
}
if ( classes . size ( ) != <num> ) {
writer . write ( " ) ; writer . ln ( ) ; writer . ln ( ) ;
}
i = <num> ;
for ( String className : classes . keySet ( ) ) {
classes . get ( className ) . specification ( writer ) ;
if ( i < classes . size ( ) ) writer . write ( " ) ; else writer . write ( " ) ;
writer . ln ( ) ;
i ++ ;
}
if ( classes . size ( ) != <num> ) {
writer . ln ( ) ; writer . ln ( ) ;
}
writer . write ( " ) ;
writer . flush ( ) ;
}
}
package unifier . asfsdf ;
public class Optional extends DerivedSort {
public boolean isOptional ( ) {
return true ;
}
public boolean isList ( ) {
return false ;
}
public Optional ( ) { }
public Optional ( String sort ) {
originalSort = new Declaration ( new SortName ( sort ) ) ;
}
public Optional ( AbstractSortDef sort ) {
originalSort = sort ;
}
public Optional setOriginalSort ( AbstractSortDef sort ) {
originalSort = sort ;
return this ;
}
public boolean isSimple ( ) {
if ( this . originalSort . isDeclaration ( ) &&
( ( ( Declaration ) this . originalSort ) . consistsOfOneLiteral ( )
| ( ( Declaration ) this . originalSort ) . consistsOfOneSortName ( ) )
)
return true ;
else return false ;
}
public String getNameIfSimple ( ) throws SdfDefinitionException {
if ( this . isSimple ( ) ) {
return ( ( Declaration ) this . originalSort ) . getElements ( ) . iterator ( ) . next ( ) . getNameIfSimple ( ) ;
} else {
throw new SdfDefinitionException ( " ) ;
}
}
public boolean originalSortDeclConsistsOfOneSortName ( ) {
if ( this . originalSort . isDeclaration ( ) &&
( ( Declaration ) this . originalSort ) . consistsOfOneSortName ( )
)
return true ;
else return false ;
}
public String getVariableName ( ) throws SdfDefinitionException {
String result = " ;
if ( this . isSimple ( ) ) {
result = result + ( ( Declaration ) originalSort ) . getVariableName ( ) + " ;
} else
throw new SdfDefinitionException ( " ) ;
return result ;
}
public boolean isOptionalLiteral ( ) {
if ( this . originalSort . isDeclaration ( ) &&
( ( Declaration ) this . originalSort ) . consistsOfOneLiteral ( )
)
return true ;
else return false ;
}
}
package sql . translator ;
import org . antlr . runtime . CommonToken ;
import org . antlr . runtime . tree . CommonTree ;
import org . antlr . runtime . tree . Tree ;
import org . antlr . stringtemplate . AutoIndentWriter ;
import org . antlr . stringtemplate . StringTemplate ;
import org . antlr . stringtemplate . StringTemplateGroup ;
import org . antlr . stringtemplate . StringTemplateWriter ;
import queryprogram . mds . Attribute ;
import queryprogram . mds . Class ;
import static sql . SqlParser . * ;
import sql . parser . SqlParserException ;
import sql . schema . Column ;
import sql . schema . SqlDataSourceSchema ;
import java . io . IOException ;
import java . io . Writer ;
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
public class SqlAstToSyfsTranslator {
private final static String CATALOG_CLASS_NAME = " ;
private final static String DEFAULT_RESULT_CLASS_NAME = " ;
private Resolver resolver ;
private Tree tree ;
private String resultClass = null ;
private StringTemplateGroup stg ;
private Map < String , Class > aliasToClassMap ;
private Map < String , DerivedColumn > columnNameToDerivedColumnMap = new HashMap < String , DerivedColumn > ( ) ;
private Writer writer ;
public SqlAstToSyfsTranslator ( Resolver resolver , Tree tree , StringTemplateGroup stg , Writer writer ) {
this . resolver = resolver ;
this . tree = tree ;
this . stg = stg ;
this . writer = writer ;
}
public void writeQuery ( ) throws IOException {
StringTemplate lpT = stg . getInstanceOf ( " ) ;
if ( tree . getType ( ) == UNION ) union ( tree , lpT ) ;
else select ( tree , lpT ) ;
StringTemplateWriter stWriter = new AutoIndentWriter ( writer ) ;
lpT . write ( stWriter ) ;
}
private void union ( Tree tree , StringTemplate lpT ) {
Tree tree1 = tree . getChild ( <num> ) ;
if ( tree1 . getType ( ) == UNION ) union ( tree1 , lpT ) ;
else select ( tree1 , lpT ) ;
select ( tree . getChild ( <num> ) , lpT ) ;
}
private void select ( Tree tree , StringTemplate lpT ) {
CommonTree selectTree = ( CommonTree ) tree ;
Tree t = selectTree . getChild ( <num> ) ;
if ( t . getType ( ) == <unk> ) {
if ( resultClass == null ) {
resultClass = t . getChild ( <num> ) . getText ( ) ;
selectTree . deleteChild ( <num> ) ;
} else throw new SqlParserException (
" , t ) ;
} else {
if ( resultClass == null ) resultClass = DEFAULT_RESULT_CLASS_NAME ;
}
Tree fromTree = tree . getChild ( <num> ) ;
collectClasses ( fromTree ) ;
deriveColumns ( ) ;
CommonTree selectListTree = ( CommonTree ) tree . getChild ( <num> ) ;
expandStars ( selectListTree ) ;
Tree whereTree = tree . getChild ( <num> ) ;
StringTemplate rule = stg . getInstanceOf ( " ) ;
StringTemplate head = stg . getInstanceOf ( " ) ;
rule . setAttribute ( " , head ) ;
head . setAttribute ( " , resultClass ) ;
head . setAttribute ( " , " ) ;
int exprCount = <num> ;
for ( int i = <num> ; i < selectListTree . getChildCount ( ) ; i ++ ) {
Tree columnExprTree = selectListTree . getChild ( i ) ;
Tree exprTree = columnExprTree . getChild ( <num> ) ;
StringTemplate reductElementT = stg . getInstanceOf ( " ) ;
String columnId = text ( columnExprTree . getChild ( <num> ) ) ;
if ( exprTree . getType ( ) == COLUMN_NAME ) {
if ( columnId == null ) columnId = text ( exprTree . getChild ( exprTree . getChildCount ( )  <num> ) ) ;
reductElementT . setAttribute ( " , translateColumnName ( exprTree ) ) ;
}
else {
String attrName = String . format ( " , exprCount ++ ) ;
if ( columnId == null ) columnId = attrName ;
StringTemplate idT = stg . getInstanceOf ( " ) ;
idT . setAttribute ( " , attrName ) ;
idT . setAttribute ( " , expr ( exprTree ) ) ;
rule . setAttribute ( " , idT ) ;
reductElementT . setAttribute ( " , attrName ) ;
}
reductElementT . setAttribute ( " , columnId ) ;
head . setAttribute ( " , reductElementT ) ;
}
if ( whereTree != null ) {
rule . setAttribute ( " , logicalOp ( whereTree . getChild ( <num> ) ) ) ;
}
SqlDataSourceSchema sqlSchema = ( SqlDataSourceSchema ) resolver . schema ;
List < DerivedColumn > derivedColumns = new ArrayList < DerivedColumn > ( ) ;
for ( DerivedColumn dc : columnNameToDerivedColumnMap . values ( ) ) if ( dc . useCount > <num> ) {
if ( ! derivedColumns . contains ( dc ) ) derivedColumns . add ( dc ) ;
dc . derivedName = dc . column . name ;
}
for ( DerivedColumn dc : derivedColumns ) {
for ( DerivedColumn _dc : derivedColumns ) if ( dc != _dc && dc . derivedName . equals ( _dc . derivedName ) ) {
dc . derivedName = dc . alias + " + dc . derivedName ;
_dc . derivedName = _dc . alias + " + _dc . derivedName ;
}
}
Map < String , StringTemplate > aliasToClassTMap = new HashMap < String , StringTemplate > ( aliasToClassMap . size ( ) ) ;
for ( DerivedColumn dc : derivedColumns ) {
StringTemplate cpT = aliasToClassTMap . get ( dc . alias ) ;
if ( cpT == null ) {
cpT = stg . getInstanceOf ( " ) ;
aliasToClassTMap . put ( dc . alias , cpT ) ;
cpT . setAttribute ( " , dc . alias ) ;
Class _class = aliasToClassMap . get ( dc . alias ) ;
cpT . setAttribute ( " , tableName ( sqlSchema . getOriginalClassFromTable ( _class ) ) ) ;
rule . setAttribute ( " , cpT ) ;
}
StringTemplate reductElemT = stg . getInstanceOf ( " ) ;
reductElemT . setAttribute ( " , dc . derivedName ) ;
reductElemT . setAttribute ( " , dc . column . path ) ;
cpT . setAttribute ( " , reductElemT ) ;
}
lpT . setAttribute ( " , rule ) ;
}
private String text ( Tree tree ) {
return tree != null ? tree . getText ( ) : null ;
}
private String tableName ( Class _class ) {
return _class . <unk> ( ) . getName ( ) + " + _class . getName ( ) ;
}
private Object logicalOp ( Tree logicalOpTree ) {
switch ( logicalOpTree . getType ( ) ) {
case AND :
StringTemplate conjT = stg . getInstanceOf ( " ) ;
conjT . setAttribute ( " , logicalOp ( logicalOpTree . getChild ( <num> ) ) ) ;
conjT . setAttribute ( " , logicalOp ( logicalOpTree . getChild ( <num> ) ) ) ;
return conjT ;
case <unk> :
StringTemplate arithPredT = stg . getInstanceOf ( " ) ;
arithPredT . setAttribute ( " , logicalOpTree . getText ( ) ) ;
arithPredT . setAttribute ( " , expr ( logicalOpTree . getChild ( <num> ) ) ) ;
arithPredT . setAttribute ( " , expr ( logicalOpTree . getChild ( <num> ) ) ) ;
return arithPredT ;
case <unk> :
Object xExpr = expr ( logicalOpTree . getChild ( <num> ) ) ;
Object aExpr = expr ( logicalOpTree . getChild ( <num> ) ) ;
Object bExpr = expr ( logicalOpTree . getChild ( <num> ) ) ;
StringTemplate leT1 = stg . getInstanceOf ( " ) ;
leT1 . setAttribute ( " , " ) ;
leT1 . setAttribute ( " , aExpr ) ;
leT1 . setAttribute ( " , xExpr ) ;
StringTemplate leT2 = stg . getInstanceOf ( " ) ;
leT2 . setAttribute ( " , " ) ;
leT2 . setAttribute ( " , xExpr ) ;
leT2 . setAttribute ( " , bExpr ) ;
StringTemplate andT = stg . getInstanceOf ( " ) ;
andT . setAttribute ( " , leT1 ) ;
andT . setAttribute ( " , leT2 ) ;
return andT ;
case <unk> :
StringTemplate likeFuncT = stg . getInstanceOf ( " ) ;
likeFuncT . setAttribute ( " , expr ( logicalOpTree . getChild ( <num> ) ) ) ;
likeFuncT . setAttribute ( " , logicalOpTree . getChild ( <num> ) . getText ( ) ) ;
if ( logicalOpTree . getChild ( <num> ) != null )
likeFuncT . setAttribute ( " , logicalOpTree . getChild ( <num> ) . getText ( ) ) ;
return likeFuncT ;
case <unk> :
SqlDataSourceSchema sqlSchema = ( SqlDataSourceSchema ) resolver . schema ;
StringTemplate matchT = stg . getInstanceOf ( " ) ;
for ( int i = <num> ; i < <num> ; i ++ ) {
Tree aliasTree = logicalOpTree . getChild ( i ) ;
String alias = aliasTree . getText ( ) ;
Class table = aliasToClassMap . get ( alias ) ;
if ( table == null ) throw new SqlParserException (
String . format ( " , alias ) , aliasTree ) ;
Class _class = sqlSchema . getOriginalClassFromTable ( table ) ;
if ( ! isCatalogClass ( _class ) ) throw new SqlParserException (
String . format ( " , tableName ( _class ) ) , aliasTree ) ;
matchT . setAttribute ( " , alias ) ;
}
String rad = logicalOpTree . getChild ( <num> ) . getText ( ) ;
matchT . setAttribute ( " , rad ) ;
return matchT ;
default :
throw new SqlParserException ( " , logicalOpTree ) ;
}
}
private boolean isCatalogClass ( Class _class ) {
return CATALOG_CLASS_NAME . equals ( _class . getName ( ) ) ||
_class . getSuperClasses ( ) . length > <num> && isCatalogClass ( _class . getSuperClasses ( ) [ <num> ] ) ;
}
private Object translateColumnName ( Tree columnNameTree ) {
Tree id1 = columnNameTree . getChild ( <num> ) ;
Tree id2 = columnNameTree . getChild ( <num> ) ;
String id = text ( id1 ) ;
if ( id2 != null ) id += " + text ( id2 ) ;
DerivedColumn dc = columnNameToDerivedColumnMap . get ( id ) ;
if ( dc == null ) throw new SqlParserException (
String . format ( " , id ) , id1 ) ;
else if ( dc == DerivedColumn . AMBIGUOUS_COLUMN_NAME ) throw new SqlParserException (
String . format ( " , id ) , id1 ) ;
dc . useCount ++ ;
return dc ;
}
private Object expr ( Tree exprTree ) {
switch ( exprTree . getType ( ) ) {
case <unk> :
StringTemplate arithBinOpT = stg . getInstanceOf ( " ) ;
arithBinOpT . setAttribute ( " , exprTree . getText ( ) ) ;
arithBinOpT . setAttribute ( " , expr ( exprTree . getChild ( <num> ) ) ) ;
arithBinOpT . setAttribute ( " , expr ( exprTree . getChild ( <num> ) ) ) ;
return arithBinOpT ;
case <unk> :
StringTemplate arithUnaryOpT = stg . getInstanceOf ( " ) ;
arithUnaryOpT . setAttribute ( " , exprTree . getText ( ) ) ;
arithUnaryOpT . setAttribute ( " , expr ( exprTree . getChild ( <num> ) ) ) ;
return arithUnaryOpT ;
case COLUMN_NAME :
return translateColumnName ( exprTree ) ;
case <unk> :
throw new SqlParserException ( " , exprTree ) ;
case SQL_FUNCTION :
StringTemplate funcT = stg . getInstanceOf ( " ) ;
boolean isSqlFunc = exprTree . getType ( ) == SQL_FUNCTION ;
if ( isSqlFunc ) {
funcT . setAttribute ( " , " ) ;
funcT . setAttribute ( " , exprTree . getText ( ) ) ;
}
else {
Tree objNameTree = exprTree . getChild ( <num> ) ;
for ( int i = <num> ; i < objNameTree . getChildCount ( ) ; i ++ )
funcT . setAttribute ( " , objNameTree . getChild ( i ) . getText ( ) ) ;
}
for ( int i = isSqlFunc ? <num> : <num> ; i < exprTree . getChildCount ( ) ; i ++ )
funcT . setAttribute ( " , expr ( exprTree . getChild ( i ) ) ) ;
return funcT ;
default :
return exprTree . getText ( ) ;
}
}
private void expandStars ( CommonTree selectListTree ) {
if ( selectListTree . getType ( ) == STAR ) {
selectListTree . token . setType ( SELECT_LIST ) ;
selectListTree . token . setText ( tokenNames [ SELECT_LIST ] ) ;
List < String > cols = new ArrayList < String > ( ) ;
for ( Map . Entry < String , Class > classEntry : aliasToClassMap . entrySet ( ) ) {
for ( Attribute attr : classEntry . getValue ( ) . getInstanceType ( ) . getAttributes ( ) ) {
if ( cols . contains ( attr . name ) ) throw new SqlParserException ( String . format (
" +
" , attr . name ) , selectListTree ) ;
cols . add ( attr . name ) ;
String alias = classEntry . getKey ( ) ;
selectListTree . addChild ( createColumnExpr ( alias , attr . name ) ) ;
}
}
} else {
for ( int i = <num> ; i < selectListTree . getChildCount ( ) ; i ++ ) {
if ( selectListTree . getChild ( i ) . getType ( ) == STAR ) {
Tree startTree = selectListTree . getChild ( i ) ;
selectListTree . deleteChild ( i ) ;
String alias = startTree . getChild ( <num> ) . getText ( ) ;
Tree aliasTree = startTree . getChild ( <num> ) ;
String alias1 = aliasTree . getText ( ) ;
Class _class1 = aliasToClassMap . get ( alias1 ) ;
if ( _class1 == null ) throw new SqlParserException (
String . format ( " , alias1 ) , aliasTree ) ;
Class _class = _class1 ;
for ( Attribute attr : _class . getInstanceType ( ) . getAttributes ( ) ) {
selectListTree . addChild ( createColumnExpr ( alias , attr . name ) ) ;
}
}
}
}
}
private CommonTree createColumnExpr ( String alias , String attrName ) {
CommonTree columnExprTree = new CommonTree ( new CommonToken ( <unk> ) ) ;
CommonTree columnNameTree = new CommonTree ( new CommonToken ( COLUMN_NAME ) ) ;
columnNameTree . addChild ( new CommonTree ( new CommonToken ( ID , alias ) ) ) ;
columnNameTree . addChild ( new CommonTree ( new CommonToken ( ID , attrName ) ) ) ;
columnExprTree . addChild ( columnNameTree ) ;
columnExprTree . addChild ( new CommonTree ( new CommonToken ( ID , attrName ) ) ) ;
return columnExprTree ;
}
private void collectClasses ( Tree fromTree ) {
int n = fromTree . getChildCount ( ) ;
aliasToClassMap = new HashMap < String , Class > ( n ) ;
for ( int i = <num> ; i < n ; i ++ ) {
Tree fromElemTree = fromTree . getChild ( i ) ;
Tree tableNameTree = fromElemTree . getChild ( <num> ) ;
Tree idTree1 = tableNameTree . getChild ( <num> ) ;
Class table = tableNameTree . getChild ( <num> ) != null
? resolver . resolveClass ( idTree1 , tableNameTree . getChild ( <num> ) )
: resolver . resolveClass ( idTree1 ) ;
String alias = text ( fromElemTree . getChild ( <num> ) ) ;
if ( alias == null ) alias = table . getName ( ) ;
if ( aliasToClassMap . containsKey ( alias ) ) throw new SqlParserException (
" , fromElemTree . getChild ( <num> ) ) ;
aliasToClassMap . put ( alias , table ) ;
}
}
private void deriveColumns ( ) {
for ( Map . Entry < String , Class > e : aliasToClassMap . entrySet ( ) ) {
String alias = e . getKey ( ) ;
Class _class = e . getValue ( ) ;
for ( Attribute a : _class . getInstanceType ( ) . getAttributes ( ) ) {
DerivedColumn dc = new DerivedColumn ( alias , ( Column ) a ) ;
columnNameToDerivedColumnMap . put ( alias + " + a . name , dc ) ;
_l : for ( Class _c : aliasToClassMap . values ( ) ) if ( _class != _c ) {
if ( _c . getInstanceType ( ) . <unk> ( a ) != null ) {
dc = DerivedColumn . AMBIGUOUS_COLUMN_NAME ;
break _l ;
}
}
columnNameToDerivedColumnMap . put ( a . name , dc ) ;
}
}
}
}
class DerivedColumn {
public final static DerivedColumn AMBIGUOUS_COLUMN_NAME = new DerivedColumn ( null , null ) ;
public String alias ;
public Column column ;
public String derivedName ;
public int useCount = <num> ;
DerivedColumn ( String alias , Column column ) {
this . alias = alias ;
this . column = column ;
}
public String toString ( ) {
return derivedName ;
}
@Override
public int hashCode ( ) {
return column . hashCode ( ) ;
}
@Override
public boolean equals ( Object obj ) {
DerivedColumn dc = ( DerivedColumn ) obj ;
return column . equals ( dc . column ) ;
}
}
package unifier . sdfparser ;
import java . io . * ;
import org . antlr . runtime . * ;
import org . antlr . runtime . debug . <unk> ;
import unifier . sdfparser . * ;
import org . antlr . runtime . tree . CommonTree ;
import antlr . debug . misc . <unk> ;
import unifier . asfsdf . SdfCreator ;
import unifier . asfsdf . Module ;
import unifier . asfsdf . AsfSsdfFormattingWriter ;
import unifier . util . FormattingWriter ;
import unifier . util . DefaultFormattingWriter ;
import java . util . HashSet ;
import java . util . Set ;
import unifier . SDF2RS ;
import unifier . util . StringHelper ;
import unifier . util . StringChooserDialog ;
public class <unk> {
public static void main ( String args [ ] ) throws Exception {
Reader r1 , r2 , r3 ;
try {
r1 = new FileReader ( " ) ;
r2 = new FileReader ( " ) ;
Set < String > terminals = new HashSet < String > ( ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
terminals . add ( " ) ;
r1 . close ( ) ;
r2 . close ( ) ;
r1 = new FileReader ( " ) ;
r2 = new FileReader ( " ) ;
r3 = new FileReader ( " ) ;
SdfCreator sdfCreator = new SdfCreator ( ) ;
Module module = sdfCreator . processSdf ( r3 , terminals ) ;
AsfSsdfFormattingWriter w = new AsfSsdfFormattingWriter ( DefaultFormattingWriter . createSystemOutWriter ( ) ) ;
w . translatorHeader ( module ) ;
SDF2RS sdf2rs = new SDF2RS ( module , DefaultFormattingWriter . createFileWriter ( " ) ) ;
sdf2rs . generateSchema ( ) ;
} catch ( RecognitionException e ) {
e . printStackTrace ( ) ;
}
}
}
package unifier . asfsdf ;
public enum ConditionKind {
MATCHING ( " ) ,
NEGATIVE_MATCHING ( " ) ,
POSITIVE ( " ) ,
<unk> ( " ) ;
private String stringValue = " ;
ConditionKind ( String value ) {
stringValue = value ;
}
public String toString ( ) {
return stringValue ;
}
}
package unifier . util ;
import javax . swing . DefaultListCellRenderer ;
import javax . swing . JList ;
import meta . ModelRegDef ;
import java . awt . Component ;
import java . sql . SQLException ;
import meta . FileContainerDef ;
public class TextFileCellRenderer extends DefaultListCellRenderer {
public Component getListCellRendererComponent (
JList list ,
Object value ,
int index ,
boolean iss ,
boolean chf )
{
if ( value instanceof TextFile ) {
TextFile file = ( TextFile ) value ;
String fileName = " ;
fileName = file . getName ( ) ;
super . getListCellRendererComponent ( list , fileName , index , iss , chf ) ;
}
else {
super . getListCellRendererComponent ( list , value , index , iss , chf ) ;
}
return this ;
}
}
package unifier . asfsdf ;
import unifier . util . FormattingWriter ;
import unifier . util . StringHelper ;
import unifier . asfsdf . SdfDefinitionException ;
import java . util . logging . Logger ;
public class AsfSsdfFormattingWriter {
Logger logger = Logger . getLogger ( " ) ;
private FormattingWriter writer ;
public AsfSsdfFormattingWriter ( FormattingWriter writer ) {
this . writer = writer ;
}
private void write ( String text ) {
writer . write ( text ) ;
}
private void ln ( ) {
writer . ln ( ) ;
}
private void ln ( int i ) {
writer . ln ( i ) ;
}
private void indent ( ) {
writer . indent ( ) ;
}
private void flush ( ) {
writer . flush ( ) ;
}
public void translatorHeader ( Module module ) throws SdfDefinitionException {
if ( module == null ) {
throw new SdfDefinitionException ( " ) ;
}
String moduleName = module . getName ( ) ;
if ( ! StringHelper . isNullEmptyOrBlank ( moduleName ) ) {
write ( module . getName ( ) ) ; ln ( ) ; ln ( ) ;
} else {
throw new SdfDefinitionException ( " ) ;
}
for ( String s : module . getImports ( ) ) {
if ( ! StringHelper . isNullEmptyOrBlank ( s ) ) {
write ( " + s ) ; ln ( ) ;
} else {
throw new SdfDefinitionException ( " ) ;
}
}
ln ( ) ; ln ( ) ;
write ( " ) ; ln ( ) ; ln ( ) ;
if ( module . getStartSymbols ( ) . size ( ) != <num> ) {
write ( " ) ; ln ( + <num> ) ;
for ( String s : module . getStartSymbols ( ) ) {
if ( ! StringHelper . isNullEmptyOrBlank ( s ) ) {
write ( s ) ; ln ( ) ;
} else {
throw new SdfDefinitionException ( " ) ;
}
}
}
ln (  <num> ) ;
if ( module . getSortNames ( ) . size ( ) != <num> ) {
write ( " ) ; ln ( + <num> ) ;
for ( String s : module . getSortNames ( ) ) {
if ( ! StringHelper . isNullEmptyOrBlank ( s ) ) {
write ( s ) ; ln ( ) ;
} else {
throw new SdfDefinitionException ( " ) ;
}
}
ln (  <num> ) ;
}
if ( module . getSortNames ( ) . size ( ) != <num> ) {
write ( " ) ; ln ( + <num> ) ; ln ( ) ;
for ( String s : module . getSortNames ( ) ) {
if ( ! module . getSort ( s ) . isTerminal ( ) ) {
abstractSortDef ( ( ( Nonterminal ) module . getSort ( s ) ) . getDefinition ( ) ) ;
write ( " + s ) ; ln ( ) ;
}
}
ln (  <num> ) ;
}
if ( module . getSignatureNames ( ) . size ( ) != <num> ) {
write ( " ) ; ln ( + <num> ) ; ln ( ) ;
for ( String sigName : module . getSignatureNames ( ) ) {
signature ( module . getSignature ( sigName ) ) ; ln ( ) ;
}
ln (  <num> ) ;
}
if ( module . getDomainSortVariables ( ) . size ( ) != <num> ) {
write ( " ) ; ln ( + <num> ) ;
for ( Variable var : module . getDomainSortVariables ( ) ) {
variable ( var ) ; ln ( ) ;
}
ln (  <num> ) ;
}
if ( module . getRangeSortVariables ( ) . size ( ) != <num> ) {
write ( " ) ; ln ( + <num> ) ;
for ( Variable var : module . getRangeSortVariables ( ) ) {
variable ( var ) ; ln ( ) ;
}
ln (  <num> ) ;
}
flush ( ) ;
}
public void signature ( Signature s ) throws SdfDefinitionException {
if ( s == null ) {
throw new SdfDefinitionException ( " ) ;
}
int i = <num> ;
int size = s . getParams ( ) . size ( ) ;
write ( s . getName ( ) + " ) ;
for ( Declaration d : s . getParams ( ) ) {
declaration ( d ) ;
i ++ ;
if ( i < size ) {
write ( " ) ;
}
}
write ( " ) ;
declaration ( s . getReturnSort ( ) ) ;
flush ( ) ;
}
private void declaration ( Declaration d ) throws SdfDefinitionException {
if ( d == null ) {
throw new SdfDefinitionException ( " ) ;
}
int i = <num> ;
int size = d . getElements ( ) . size ( ) ;
for ( DeclarationElement e : d . getElements ( ) ) {
declarationElement ( e ) ;
i ++ ;
if ( i < size ) {
write ( " ) ;
}
}
}
private void declarationElement ( DeclarationElement e ) throws SdfDefinitionException {
if ( e == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( e . isLiteral ( ) ) {
literal ( ( Literal ) e ) ;
}
else if ( e . isSortName ( ) ) {
sortName ( ( SortName ) e ) ;
}
else if ( e . isDerivedSort ( ) ) {
derivedSort ( ( DerivedSort ) e ) ;
}
}
private void literal ( Literal lit ) throws SdfDefinitionException {
if ( lit == null || StringHelper . isNullEmptyOrBlank ( lit . getValue ( ) ) ) {
throw new SdfDefinitionException ( " ) ;
}
write ( lit . getValue ( ) ) ;
}
private void sortName ( SortName sort ) throws SdfDefinitionException {
if ( sort == null || StringHelper . isNullEmptyOrBlank ( sort . getValue ( ) ) ) {
throw new SdfDefinitionException ( " ) ;
}
write ( sort . getValue ( ) ) ;
}
private void derivedSort ( DerivedSort sort ) throws SdfDefinitionException {
if ( sort == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( sort . getOriginalSort ( ) == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( sort . isOptional ( ) ) {
optional ( ( Optional ) sort ) ;
}
else if ( sort . isList ( ) ) {
list ( ( List ) sort ) ;
}
}
private void optional ( Optional opt ) throws SdfDefinitionException {
write ( " ) ;
abstractSortDef ( opt . getOriginalSort ( ) ) ;
write ( " ) ;
}
private void list ( List lst ) throws SdfDefinitionException {
if ( lst . getMultiplicity ( ) == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( ! lst . separatorIsEmpty ( ) ) {
write ( " ) ;
abstractSortDef ( lst . getOriginalSort ( ) ) ;
write ( " + StringHelper . toQuotation ( lst . getSeparator ( ) ) ) ;
write ( " ) ;
} else {
write ( " ) ;
abstractSortDef ( lst . getOriginalSort ( ) ) ;
write ( " ) ;
}
write ( lst . getMultiplicityToString ( ) ) ;
}
private void abstractSortDef ( AbstractSortDef sort ) throws SdfDefinitionException {
if ( sort == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( sort . isAlternative ( ) ) alternative ( ( Alternative ) sort ) ;
else if ( sort . isEnumeration ( ) ) enumeration ( ( Enumeration ) sort ) ;
else if ( sort . isDeclaration ( ) ) declaration ( ( Declaration ) sort ) ;
}
private void alternative ( Alternative alt ) throws SdfDefinitionException {
if ( alt == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( alt . getElements ( ) . size ( ) == <num> ) {
throw new SdfDefinitionException ( " ) ;
}
int i = <num> ;
int size = alt . getElements ( ) . size ( ) ;
write ( " ) ;
for ( Object sort : alt . getElements ( ) ) {
abstractSortDef ( ( AbstractSortDef ) sort ) ;
i ++ ;
if ( i < size ) {
write ( " ) ;
}
}
write ( " ) ;
}
private void enumeration ( Enumeration enm ) throws SdfDefinitionException {
if ( enm == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( enm . getElements ( ) . size ( ) == <num> ) {
throw new SdfDefinitionException ( " ) ;
}
int i = <num> ;
int size = enm . getElements ( ) . size ( ) ;
write ( " ) ;
for ( Object s : enm . getElements ( ) ) {
write ( StringHelper . toQuotation ( ( String ) s ) ) ;
i ++ ;
if ( i < size ) {
write ( " ) ;
}
}
write ( " ) ;
}
private void variable ( Variable var ) throws SdfDefinitionException {
if ( var == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( StringHelper . isNullEmptyOrBlank ( var . getName ( ) ) ) {
throw new SdfDefinitionException ( " ) ;
}
write ( StringHelper . toQuotation ( var . getName ( ) ) + " ) ;
declaration ( var . getDeclaration ( ) ) ;
}
public void equations ( Module module ) throws SdfDefinitionException {
if ( module == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( module . getEquations ( ) . size ( ) == <num> ) return ;
write ( " ) ; ln ( ) ; ln ( ) ;
for ( Equation eq : module . getEquations ( ) ) {
equation ( eq ) ; ln ( ) ; ln ( ) ;
}
flush ( ) ;
}
private void equation ( Equation eq ) throws SdfDefinitionException {
if ( eq == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( StringHelper . isNullEmptyOrBlank ( eq . getTag ( ) ) ) {
throw new SdfDefinitionException ( " ) ;
}
if ( StringHelper . isNullEmptyOrBlank ( eq . getDefinedFunctionName ( ) ) ) {
throw new SdfDefinitionException ( " ) ;
}
int i = <num> ;
int size = eq . getConditions ( ) . size ( ) ;
write ( " + eq . getTag ( ) + " ) ; ln ( ) ;
if ( size != <num> ) {
for ( Condition cond : eq . getConditions ( ) ) {
condition ( cond ) ;
i ++ ;
if ( i < size ) {
write ( " ) ; ln ( ) ;
} else {
ln ( ) ;
}
}
write ( " ) ; ln ( ) ;
}
write ( eq . getDefinedFunctionName ( ) + " + eq . getParams ( ) + " ) ; ln ( ) ;
write ( eq . getBody ( ) ) ;
}
private void condition ( Condition cond ) throws SdfDefinitionException {
if ( cond == null ) {
throw new SdfDefinitionException ( " ) ;
}
if ( StringHelper . isNullEmptyOrBlank ( cond . getLeft ( ) ) ) {
throw new SdfDefinitionException ( " ) ;
}
if ( StringHelper . isNullEmptyOrBlank ( cond . getRight ( ) ) ) {
throw new SdfDefinitionException ( " ) ;
}
if ( cond . getKind ( ) == null ) {
throw new SdfDefinitionException ( " ) ;
}
write ( cond . getLeft ( ) + " + cond . getKind ( ) . toString ( ) + " + cond . getRight ( ) ) ;
}
}
package unifier . asfsdf ;
public enum ListMultiplicity {
AT_LEAST_ZERO_TIME ( " , " ) ,
AT_LEAST_ONE_TIME ( " , " ) ;
private final String stringValue ;
private final String verbalForm ;
ListMultiplicity ( String value , String verbal ) {
stringValue = value ;
verbalForm = verbal ;
}
public String toString ( ) {
return stringValue ;
}
public String getVerbalForm ( ) {
return verbalForm ;
}
}
package unifier . rsm ;
public abstract class Type extends Element {
public String getDesignator ( ) {
return getName ( ) ;
}
public abstract boolean isADT ( ) ;
}
package unifier . util ;
import javax . swing . JDialog ;
import java . awt . event . ActionEvent ;
import javax . swing . DefaultListModel ;
import javax . swing . JPanel ;
import meta . ElementDef ;
import java . awt . Insets ;
import java . util . Set ;
import java . awt . event . ActionListener ;
import javax . swing . JButton ;
import java . awt . Dimension ;
import java . awt . GridBagConstraints ;
import javax . swing . JList ;
import java . awt . FlowLayout ;
import javax . swing . ListSelectionModel ;
import javax . swing . JScrollPane ;
import java . awt . GridBagLayout ;
import javax . swing . DefaultListCellRenderer ;
import java . util . HashSet ;
public class StringChooserDialog extends JDialog {
private StringChooserDialog ( ) {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
}
private void jbInit ( ) throws Exception {
this . setModal ( true ) ;
this . setTitle ( " ) ;
this . getContentPane ( ) . setLayout ( gridBagLayoutECD ) ;
jButtonOK . setToolTipText ( " ) ;
jButtonOK . addActionListener ( new
StringChooserDialog_jButtonOK_actionAdapter ( this ) ) ;
jListElements . setSelectionMode ( ListSelectionModel . MULTIPLE_INTERVAL_SELECTION ) ;
jScrollPaneElements . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jButtonCancel . setText ( " ) ;
jButtonCancel . addActionListener ( new
StringChooserDialog_jButtonCancel_actionAdapter ( this ) ) ;
this . getContentPane ( ) . add ( jScrollPaneElements ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneElements . getViewport ( ) . add ( jListElements ) ;
jButtonOK . setText ( " ) ;
jPanelButtons . setLayout ( flowLayoutButtons ) ;
this . getContentPane ( ) . add ( jPanelButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelButtons . add ( jButtonOK ) ;
jPanelButtons . add ( jButtonCancel ) ;
jListElements . setModel ( new DefaultListModel ( ) ) ;
jListElements . setCellRenderer ( new DefaultListCellRenderer ( ) ) ;
}
GridBagLayout gridBagLayoutECD = new GridBagLayout ( ) ;
JScrollPane jScrollPaneElements = new JScrollPane ( ) ;
JPanel jPanelButtons = new JPanel ( ) ;
FlowLayout flowLayoutButtons = new FlowLayout ( ) ;
JButton jButtonOK = new JButton ( ) ;
JList jListElements = new JList ( ) ;
JButton jButtonCancel = new JButton ( ) ;
private StringChooserDialog ( Set < String > elements ) {
this ( ) ;
if ( elements . size ( ) == <num> ) this . dispose ( ) ;
for ( String elm : elements ) {
( ( DefaultListModel ) jListElements . getModel ( ) ) . addElement ( elm ) ;
}
}
public static Set < String > showStringChooserDialog ( String title , Set < String > elements ) {
StringChooserDialog dialog = new StringChooserDialog ( elements ) ;
dialog . setTitle ( title ) ;
dialog . pack ( ) ;
dialog . validate ( ) ;
dialog . setVisible ( true ) ;
return dialog . getSelected ( ) ;
}
private Set < String > selected = new HashSet < String > ( ) ;
private Set < String > getSelected ( ) {
return selected ;
}
public void jButtonOK_actionPerformed ( ActionEvent e ) {
if ( ! jListElements . isSelectionEmpty ( ) ) {
for ( Object obj : jListElements . getSelectedValues ( ) )
selected . add ( ( String ) obj ) ;
this . dispose ( ) ;
}
}
public void jButtonCancel_actionPerformed ( ActionEvent e ) {
selected = null ;
this . dispose ( ) ;
}
}
class StringChooserDialog_jButtonCancel_actionAdapter implements
ActionListener {
private StringChooserDialog adaptee ;
StringChooserDialog_jButtonCancel_actionAdapter ( StringChooserDialog
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonCancel_actionPerformed ( e ) ;
}
}
class StringChooserDialog_jButtonOK_actionAdapter implements ActionListener {
private StringChooserDialog adaptee ;
StringChooserDialog_jButtonOK_actionAdapter ( StringChooserDialog adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonOK_actionPerformed ( e ) ;
}
}
package unifier ;
import javax . swing . JFrame ;
import javax . swing . JTabbedPane ;
import java . awt . * ;
import javax . swing . JTextField ;
import javax . swing . JPanel ;
import javax . swing . JLabel ;
import javax . swing . * ;
import javax . swing . border . TitledBorder ;
import javax . swing . border . Border ;
import javax . swing . border . EtchedBorder ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import meta . DB ;
import java . util . logging . Logger ;
import meta . * ;
import java . sql . SQLException ;
import java . util . Date ;
import java . text . DateFormat ;
import java . util . Calendar ;
import java . util . GregorianCalendar ;
import javax . swing . text . JTextComponent ;
import java . text . SimpleDateFormat ;
import javax . swing . text . DateFormatter ;
import javax . swing . text . MaskFormatter ;
import java . io . File ;
import javax . swing . filechooser . FileFilter ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseAdapter ;
import java . io . FileReader ;
import java . io . BufferedReader ;
import java . io . IOException ;
import java . io . StringWriter ;
import java . io . CharArrayReader ;
import java . io . StringReader ;
import SynthesisLoaderClasses . SynthesisLoader ;
import unifier . util . TextFileJList ;
import unifier . util . FileJTextArea ;
import unifier . util . DateHelper ;
import unifier . util . SampleRegDefCellRenderer ;
import unifier . util . BrowserControl ;
import unifier . util . TextFile ;
import unifier . util . RepositoryCleaner ;
import unifier . util . FormattingWriter ;
import unifier . util . DefaultFormattingWriter ;
import java . util . Set ;
import unifier . util . ElementDefCellRenderer ;
import <unk> . Module2BTranslator ;
import unifier . util . * ;
import unifier . asfsdf . * ;
import unifier . rsm . ReferenceSchemaModelException ;
import java . io . Reader ;
import org . antlr . runtime . RecognitionException ;
import java . awt . event . WindowEvent ;
import java . awt . event . WindowAdapter ;
import db . Query ;
import db . Like ;
import unifier . similarity . TestSimilarityCreator ;
import unifier . similarity . Similarity ;
import org . ipi . schemaeditor . SchemaEditorGui ;
import java . awt . event . KeyEvent ;
import org . ipi . <unk> . SchemaMappingGui ;
import unifier . similarity . SimilarityCreator ;
public class ModelRegistrar extends CenteredFrame {
public ModelRegistrar ( DB db ) throws SQLException {
logger = Logger . getLogger ( " ) ;
this . db = db ;
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
center ( ) ;
createNewModel ( ) ;
}
public ModelRegistrar ( ModelRegDef amodel ) throws SQLException {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
center ( ) ;
logger = Logger . getLogger ( " ) ;
db = ( DB ) amodel . _db ( ) ;
model = amodel ;
openModel ( ) ;
}
private void jbInit ( ) throws Exception {
this . setDefaultCloseOperation ( HIDE_ON_CLOSE ) ;
this . setTitle ( " ) ;
this . addWindowListener ( new ModelRegistrar_this_windowAdapter ( this ) ) ;
this . getContentPane ( ) . setLayout ( borderLayoutMR ) ;
jPanelRegCard . setLayout ( gridBagLayoutRC ) ;
jPanelModelSyntax . setLayout ( gridBagLayoutMS ) ;
jLabelShortTitle . setText ( " ) ;
jTextFieldShortTitle . setText ( " ) ;
jLabelFullTitle . setText ( " ) ;
jTextFieldFullTitle . setText ( " ) ;
jPanelRegCard . setBorder ( null ) ;
jPanelRegCard . setToolTipText ( " ) ;
jPanelSyntax . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) , " ) ) ;
jPanelSyntax . setToolTipText ( " ) ;
jPanelSyntax . setLayout ( gridBagLayoutRCS ) ;
jLabelSyntaxDocTitle . setText ( " ) ;
jLabelSyntaxDate . setText ( " ) ;
jLabelSyntaxLink . setText ( " ) ;
jTextFieldSyntaxDocTitle . setText ( " ) ;
jTextFieldSyntaxLink . setText ( " ) ;
jButtonBrowseSyntaxLink . setText ( " ) ;
jButtonBrowseSyntaxLink . addActionListener ( new
ModelRegistrar_jButtonBrowseSyntaxLink_actionAdapter ( this ) ) ;
jPanelSemantics . setLayout ( gridBagLayoutRCSem ) ;
jPanelSemantics . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jLabelSemanticsDocTitle . setText ( " ) ;
jTextFieldSemanticsDocTitle . setText ( " ) ;
jLabelSemanticsDate . setText ( " ) ;
jLabelSemanticsLink . setText ( " ) ;
jTextFieldSemanticsLink . setText ( " ) ;
jButtonBrowseSemantics . setText ( " ) ;
jButtonBrowseSemantics . addActionListener ( new
ModelRegistrar_jButtonBrowseSemantics_actionAdapter ( this ) ) ;
jButtonUpdateRegCard . setToolTipText (
" ) ;
jButtonUpdateRegCard . setText ( " ) ;
jButtonUpdateRegCard . setMnemonic ( KeyEvent . VK_U ) ;
jButtonUpdateRegCard . addActionListener ( new
ModelRegistrar_jButtonUpdateRegCard_actionAdapter ( this ) ) ;
jPanelRCButtons . setLayout ( flowLayoutRCB ) ;
jButtonDeleteCard . setToolTipText (
" ) ;
jButtonDeleteCard . setText ( " ) ;
jButtonDeleteCard . addActionListener ( new
ModelRegistrar_jButtonDeleteCard_actionAdapter ( this ) ) ;
jPanelRCButtons . setBorder ( BorderFactory . createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) ) ;
jButtonBrowseModelSyntaxFile . setToolTipText (
" ) ;
jButtonBrowseModelSyntaxFile . setText ( " ) ;
jButtonBrowseModelSyntaxFile . addActionListener ( new
ModelRegistrar_jButtonBrowseModelSyntaxFile_actionAdapter ( this ) ) ;
jButtonUpdateModelSyntax . setToolTipText (
" ) ;
jButtonUpdateModelSyntax . setText ( " ) ;
jButtonUpdateModelSyntax . addActionListener ( new
ModelRegistrar_jButtonUpdateModelSyntax_actionAdapter ( this ) ) ;
jTabbedPaneActivities . setMinimumSize ( new Dimension ( <num> , <num> ) ) ;
jTabbedPaneActivities . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jPanelAmnSemantics . setLayout ( gridBagLayoutAMNS ) ;
jButtonUpdateAmnSemantics . setToolTipText (
" ) ;
jButtonUpdateAmnSemantics . setText ( " ) ;
jButtonUpdateAmnSemantics . addActionListener ( new
ModelRegistrar_jButtonUpdateAmnSemantics_actionAdapter ( this ) ) ;
jButtonBrowseAmnTranslatorFile . setToolTipText (
" ) ;
jButtonBrowseAmnTranslatorFile . setText ( " ) ;
jButtonBrowseAmnTranslatorFile . addActionListener ( new
ModelRegistrar_jButtonBrowseAmnTranslatorFile_actionAdapter ( this ) ) ;
jTextAreaVerbalAmnSemantics . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaVerbalAmnSemantics . setText ( " ) ;
jScrollPaneVerbalAmnSemantics . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jPanelReferenceSchema . setLayout ( gridBagLayoutVOD ) ;
jButtonCreateReferenceSchemaTemplate . setToolTipText (
" ) ;
jButtonCreateReferenceSchemaTemplate . setText ( " ) ;
jButtonCreateReferenceSchemaTemplate . addActionListener ( new
ModelRegistrar_jButtonCreateReferenceSchemaTemplate_actionAdapter ( this ) ) ;
jScrollPaneReferenceSchemaTemplate . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jTextAreaReferenceSchemaTemplate . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaReferenceSchemaTemplate . setEditable ( true ) ;
jTextAreaReferenceSchemaTemplate . setText ( " ) ;
jButtonVODUpdate . setToolTipText (
" ) ;
jButtonVODUpdate . setText ( " ) ;
jButtonVODUpdate . addActionListener ( new
ModelRegistrar_jButtonVODUpdate_actionAdapter ( this ) ) ;
jButtonVODEdit . setToolTipText ( " ) ;
jButtonVODEdit . setText ( " ) ;
jButtonVODEdit . addActionListener ( new
ModelRegistrar_jButtonVODEdit_actionAdapter ( this ) ) ;
jSplitPaneReferenceSchema . setOrientation ( JSplitPane . HORIZONTAL_SPLIT ) ;
jSplitPaneReferenceSchema . setOneTouchExpandable ( true ) ;
jPanelReferenceSchemaIntegration . setLayout ( gridBagLayoutOI ) ;
jPanelTranslator . setLayout ( gridBagLayoutTr ) ;
jButtonBrowseTranslator . setToolTipText (
" ) ;
jButtonBrowseTranslator . setText ( " ) ;
jButtonBrowseTranslator . addActionListener ( new
ModelRegistrar_jButtonBrowseTranslator_actionAdapter ( this ) ) ;
jButtonGenerateTemplate . setToolTipText ( " ) ;
jButtonGenerateTemplate . setText ( " ) ;
jButtonGenerateTemplate . addActionListener ( new
ModelRegistrar_jButtonGenerateTemplate_actionAdapter ( this ) ) ;
jButtonExportTranslator . setToolTipText (
" ) ;
jButtonExportTranslator . setText ( " ) ;
jButtonExportTranslator . addActionListener ( new
ModelRegistrar_jButtonExportTranslator_actionAdapter ( this ) ) ;
jButtonUpdateTranslator . setToolTipText (
" ) ;
jButtonUpdateTranslator . setText ( " ) ;
jButtonUpdateTranslator . addActionListener ( new
ModelRegistrar_jButtonUpdateTranslator_actionAdapter ( this ) ) ;
jTextAreaVerbalRules . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaVerbalRules . setText ( " ) ;
jScrollPaneVerbalRules . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jPanelSamples . setLayout ( gridBagLayoutSam ) ;
jTabbedPaneSample . <unk> ( JTabbedPane . BOTTOM ) ;
jPanelSampleRegCard . setLayout ( gridBagLayoutSRC ) ;
jButtonNewSample . setToolTipText ( " ) ;
jButtonNewSample . setText ( " ) ;
jButtonNewSample . addActionListener ( new
ModelRegistrar_jButtonNewSample_actionAdapter ( this ) ) ;
jButtonDeleteSample . setToolTipText ( " ) ;
jButtonDeleteSample . setText ( " ) ;
jButtonDeleteSample . addActionListener ( new
ModelRegistrar_jButtonDeleteSample_actionAdapter ( this ) ) ;
jLabelSampleTitle . setText ( " ) ;
jTextFieldSampleTitle . setText ( " ) ;
jPanelSourceSampleSpec . setLayout ( gridBagLayoutSS ) ;
jPanelSourceSampleSpec . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jButtonExportSourceSampleSpec . setToolTipText ( " ) ;
jButtonExportSourceSampleSpec . setText ( " ) ;
jButtonExportSourceSampleSpec . addActionListener ( new
ModelRegistrar_jButtonExportSampleSpec_actionAdapter ( this ) ) ;
jButtonBrowseSourceSampleSpec . setToolTipText ( " ) ;
jButtonBrowseSourceSampleSpec . setText ( " ) ;
jButtonBrowseSourceSampleSpec . addActionListener ( new
ModelRegistrar_jButtonBrowseSampleSpec_actionAdapter ( this ) ) ;
jPanelSampleTargetSpec . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jPanelSampleTargetSpec . setLayout ( gridBagLayoutSCS ) ;
jButtonBrowseSampleTargetSpec . setToolTipText (
" ) ;
jButtonBrowseSampleTargetSpec . setText ( " ) ;
jButtonBrowseSampleTargetSpec . addActionListener ( new
ModelRegistrar_jButtonBrowseSampleTargetSpec_actionAdapter ( this ) ) ;
jCheckBoxSampleVerification . setBorder ( null ) ;
jCheckBoxSampleVerification . setText ( " ) ;
jCheckBoxSampleVerification . addMouseListener ( new
ModelRegistrar_jCheckBoxSampleVerification_mouseAdapter ( this ) ) ;
jButtonTranslateSampleTargetSpec2Amn . setToolTipText (
" ) ;
jButtonTranslateSampleTargetSpec2Amn . setText ( " ) ;
jButtonTranslateSampleTargetSpec2Amn . addActionListener ( new
ModelRegistrar_jButtonTranslateSampleTargetSpec2Amn_actionAdapter ( this ) ) ;
jPanelSampleVerification . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jTextAreaModelSyntax . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaModelSyntax . setText ( " ) ;
jScrollPaneModelSyntaxFiles . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jTextAreaTranslator2Amn . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaTranslator2Amn . setText ( " ) ;
jSplitPaneTranslator2Amn . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jSplitPaneTranslator2Amn . setOneTouchExpandable ( true ) ;
jScrollPaneTranslator2AmnFiles . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( EtchedBorder . RAISED , Color . white ,
new Color ( <num> , <num> , <num> ) ) , " ) ) ;
jScrollPaneModelSyntax . setBorder ( BorderFactory . createEmptyBorder ( ) ) ;
jScrollPaneTranslator2Amn . setBorder ( BorderFactory . createEmptyBorder ( ) ) ;
jSplitPaneAmnSemantics . setOrientation ( JSplitPane . VERTICAL_SPLIT ) ;
jSplitPaneAmnSemantics . setOneTouchExpandable ( true ) ;
jSplitPaneModelSyntax . setOneTouchExpandable ( true ) ;
jTextAreaTranslator2TM . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaTranslator2TM . setText ( " ) ;
jSplitPaneTranslator2TM . setBorder ( border2 ) ;
jSplitPaneTranslator2TM . setOneTouchExpandable ( true ) ;
jSplitPaneTranslator . setOrientation ( JSplitPane . VERTICAL_SPLIT ) ;
jSplitPaneTranslator . setOneTouchExpandable ( true ) ;
jScrollPaneTranslator2TMFiles . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( EtchedBorder . RAISED , Color . white ,
new Color ( <num> , <num> , <num> ) ) , " ) ) ;
jTextAreaSampleSpec . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaSampleSpec . setText ( " ) ;
jListExistingSamples . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ;
jListExistingSamples . addMouseListener ( new
ModelRegistrar_jListExistingSamples_mouseAdapter ( this ) ) ;
jScrollPaneExistingSamples . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jTextAreaSampleTargetSpec . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaSampleTargetSpec . setText ( " ) ;
jSplitPaneSamples . setOneTouchExpandable ( true ) ;
jPanelSourceSampleAmnSemantics . setLayout ( gridBagLayoutSAMNS ) ;
jSplitPaneSourceSampleAmnSemantics . setOrientation ( JSplitPane . VERTICAL_SPLIT ) ;
jSplitPaneSourceSampleAmnSemantics . setOneTouchExpandable ( true ) ;
jPanelSourceSampleAmnSemanticsNonRec . setLayout ( gridBagLayoutSAMNSNR ) ;
jButtonSourceSampleAmnSemanticsNonRecBrowse . setToolTipText (
" ) ;
jButtonSourceSampleAmnSemanticsNonRecBrowse . setText ( " ) ;
jButtonSourceSampleAmnSemanticsNonRecBrowse . addActionListener ( new
ModelRegistrar_jButtonSampleAmnSemanticsNonRecBrowse_actionAdapter ( this ) ) ;
jTextAreaSourceSampleAmnSemanticsNonRec . setFont ( new java . awt . Font (
" , Font . PLAIN , <num> ) ) ;
jTextAreaSourceSampleAmnSemanticsNonRec . setEditable ( false ) ;
jTextAreaSourceSampleAmnSemanticsNonRec . setText ( " ) ;
jPanelSourceSampleAmnSemanticsNonRec . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jScrollPaneSourceSampleAmnSemanticsNonRecFiles . setBorder ( new TitledBorder (
BorderFactory . createEtchedBorder ( EtchedBorder . RAISED ,
Color . white ,
new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jPanelSourceSampleAmnSemanticsRec . setLayout ( gridBagLayoutSAMNSR ) ;
jTextAreaSourceSampleAmnSemanticsRec . setFont ( new java . awt . Font (
" , Font . PLAIN , <num> ) ) ;
jTextAreaSourceSampleAmnSemanticsRec . setText ( " ) ;
jButtonSourceSampleAmnSemanticsRecDelete . setToolTipText (
" ) ;
jButtonSourceSampleAmnSemanticsRecDelete . setText ( " ) ;
jButtonSourceSampleAmnSemanticsRecDelete . addActionListener ( new
ModelRegistrar_jButtonSampleAmnSemanticsRecDelete_actionAdapter ( this ) ) ;
jButtonSourceSampleAmnSemanticsRecExport . setToolTipText (
" ) ;
jButtonSourceSampleAmnSemanticsRecExport . setText ( " ) ;
jButtonSourceSampleAmnSemanticsRecExport . addActionListener ( new
ModelRegistrar_jButtonSampleAmnSemanticsRecExport_actionAdapter ( this ) ) ;
jButtonSourceSampleAmnSemanticsRecBrowse . setToolTipText (
" ) ;
jButtonSourceSampleAmnSemanticsRecBrowse . setText ( " ) ;
jButtonSourceSampleAmnSemanticsRecBrowse . addActionListener ( new
ModelRegistrar_jButtonSampleAmnSemanticsRecBrowse_actionAdapter ( this ) ) ;
jButtonSourceSampleAmnSemanticsNonRecDelete . setToolTipText (
" ) ;
jButtonSourceSampleAmnSemanticsNonRecDelete . setText ( " ) ;
jButtonSourceSampleAmnSemanticsNonRecDelete . addActionListener ( new
ModelRegistrar_jButtonSampleAmnSemanticsNonRecDelete_actionAdapter ( this ) ) ;
jSplitPaneSourceSampleAmnSemanticsRec . setBorder ( new TitledBorder (
BorderFactory . createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jSplitPaneSourceSampleAmnSemanticsRec . setOneTouchExpandable ( true ) ;
jScrollPaneSourceSampleAmnSemanticsRecFiles . setBorder ( new TitledBorder (
BorderFactory . createEtchedBorder ( EtchedBorder . RAISED ,
Color . white ,
new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jSplitPaneTargetSampleAmnSemantics . setOrientation ( JSplitPane . VERTICAL_SPLIT ) ;
jSplitPaneTargetSampleAmnSemantics . setOneTouchExpandable ( true ) ;
jPanelTargetSampleAmnSemantics . setLayout ( gridBagLayoutCSAMNS ) ;
jPanelTargetSampleAmnSemanticsNonRec . setLayout ( gridBagLayoutCSAMNSNR ) ;
jTextAreaTargetSampleAmnSemanticsNonRec . setFont ( new java . awt . Font (
" , Font . PLAIN , <num> ) ) ;
jTextAreaTargetSampleAmnSemanticsNonRec . setEditable ( false ) ;
jTextAreaTargetSampleAmnSemanticsNonRec . setText ( " ) ;
jPanelTargetSampleAmnSemanticsRec . setLayout ( gridBagLayoutCSAMNSR ) ;
jButtonTargetSampleAmnSemanticsRecDelete . setToolTipText (
" ) ;
jButtonTargetSampleAmnSemanticsRecDelete . setText ( " ) ;
jButtonTargetSampleAmnSemanticsRecDelete . addActionListener ( new
ModelRegistrar_jButtonTargetSampleAmnSemanticsRecDelete_actionAdapter ( this ) ) ;
jButtonTargetSampleAmnSemanticsRecExport . setToolTipText (
" ) ;
jButtonTargetSampleAmnSemanticsRecExport . setText ( " ) ;
jButtonTargetSampleAmnSemanticsRecExport . addActionListener ( new
ModelRegistrar_jButtonTargetSampleAmnSemanticsRecExport_actionAdapter ( this ) ) ;
jButtonTargetSampleAmnSemanticsRecBrowse . setToolTipText (
" ) ;
jButtonTargetSampleAmnSemanticsRecBrowse . setText ( " ) ;
jButtonTargetSampleAmnSemanticsRecBrowse . addActionListener ( new
ModelRegistrar_jButtonTargetSampleAmnSemanticsRecBrowse_actionAdapter ( this ) ) ;
jTextAreaTargetSampleAmnSemanticsRec . setFont ( new java . awt . Font (
" , Font . PLAIN , <num> ) ) ;
jTextAreaTargetSampleAmnSemanticsRec . setText ( " ) ;
jPanelTargetSampleAmnSemanticsNonRec . setBorder ( new TitledBorder (
BorderFactory . createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jSplitPaneTargetSampleAmnSemanticsNonRec . setOneTouchExpandable ( true ) ;
jSplitPaneTargetSampleAmnSemanticsRec . setOneTouchExpandable ( true ) ;
jPanelTargetSampleAmnSemanticsRec . setBorder ( new TitledBorder (
BorderFactory . createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jScrollPaneTargetSampleAmnSemanticsNonRecFiles . setBorder ( new
TitledBorder ( BorderFactory . createEtchedBorder ( EtchedBorder .
RAISED , Color . white , new Color ( <num> , <num> , <num> ) ) , " ) ) ;
jPanelRefinementProof . setLayout ( gridBagLayoutSRP ) ;
jButtonRefinementProofBrowse . setText ( " ) ;
jButtonRefinementProofBrowse . addActionListener ( new
ModelRegistrar_jButtonRefinementProofBrowse_actionAdapter ( this ) ) ;
jTextAreaRefinementProof . setFont ( new java . awt . Font ( " ,
Font . PLAIN , <num> ) ) ;
jTextAreaRefinementProof . setText ( " ) ;
jScrollPaneTargetSampleAmnSemanticsRecFiles . setBorder ( new TitledBorder (
BorderFactory . createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jPanelReferenceSchemaEditor . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jFormattedTextFieldSyntaxDate . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jFormattedTextFieldSyntaxDate . setText ( " ) ;
jFormattedTextFieldSemanticsDate . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jFormattedTextFieldSemanticsDate . setText ( " ) ;
jButtonDeleteModelSyntaxFile . setToolTipText (
" ) ;
jButtonDeleteModelSyntaxFile . setText ( " ) ;
jButtonDeleteModelSyntaxFile . addActionListener ( new
ModelRegistrar_jButtonDeleteModelSyntaxFile_actionAdapter ( this ) ) ;
jButtonDeleteAmnTranslatorFile . setToolTipText (
" ) ;
jButtonDeleteAmnTranslatorFile . setText ( " ) ;
jButtonDeleteAmnTranslatorFile . addActionListener ( new
ModelRegistrar_jButtonDeleteAmnTranslatorFile_actionAdapter ( this ) ) ;
jButtonDeleteTranslator . setToolTipText (
" ) ;
jButtonDeleteTranslator . setText ( " ) ;
jButtonDeleteTranslator . addActionListener ( new
ModelRegistrar_jButtonDeleteTranslator_actionAdapter ( this ) ) ;
jListModelSyntaxFiles . addMouseListener ( new
ModelRegistrar_jListModelSyntaxFiles_mouseAdapter ( this ) ) ;
jListModelSyntaxFiles . setSelectionMode ( ListSelectionModel .
SINGLE_SELECTION ) ;
jSplitPaneSampleAmnSemanticsNonRec . setOneTouchExpandable ( true ) ;
jListTranslator2AmnFiles . addMouseListener ( new
ModelRegistrar_jListTranslator2AmnFiles_mouseAdapter ( this ) ) ;
jButtonExportModelSyntaxFile . setToolTipText ( " ) ;
jButtonExportModelSyntaxFile . setText ( " ) ;
jButtonExportModelSyntaxFile . addActionListener ( new
ModelRegistrar_jButtonExportModelSyntaxFile_actionAdapter ( this ) ) ;
jButtonExportAmnTranslatorFile . setToolTipText (
" ) ;
jButtonExportAmnTranslatorFile . setText ( " ) ;
jButtonExportAmnTranslatorFile . addActionListener ( new
ModelRegistrar_jButtonExportAmnTranslatorFile_actionAdapter ( this ) ) ;
jListTranslator2TMFiles . addMouseListener ( new
ModelRegistrar_jListTranslator2CMFiles_mouseAdapter ( this ) ) ;
jListSourceSampleAmnSemanticsNonRecFiles . addMouseListener ( new
ModelRegistrar_jListSampleAmnSemanticsNonRecFiles_mouseAdapter ( this ) ) ;
jListSourceSampleAmnSemanticsRecFiles . addMouseListener ( new
ModelRegistrar_jListSampleAmnSemanticsRecFiles_mouseAdapter ( this ) ) ;
jListTargetSampleAmnSemanticsNonRecFiles . addMouseListener ( new
ModelRegistrar_jListTargetSampleAmnSemanticsNonRecFiles_mouseAdapter ( this ) ) ;
jListTargetSampleAmnSemanticsRecFiles . addMouseListener ( new
ModelRegistrar_jListTargetSampleAmnSemanticsRecFiles_mouseAdapter ( this ) ) ;
jButtonUpdateSampleRegCard . setToolTipText (
" ) ;
jButtonUpdateSampleRegCard . setText ( " ) ;
jButtonUpdateSampleRegCard . addActionListener ( new
ModelRegistrar_jButtonUpdateSampleRegCard_actionAdapter ( this ) ) ;
jLabelRefinedModel . setText ( " ) ;
jTextFieldRefinedModel . setEditable ( false ) ;
jTextFieldRefinedModel . setText ( " ) ;
jButtonExploreExtension . setToolTipText (
" ) ;
jButtonExploreExtension . setText ( " ) ;
jButtonExploreExtension . addActionListener ( new
ModelRegistrar_jButtonExploreExtension_actionAdapter ( this ) ) ;
jButtonTranslate2AmnSampleSourceSpec . setText ( " ) ;
jButtonTranslate2AmnSampleSourceSpec . addActionListener ( new
ModelRegistrar_jButtonTranslate2AmnSampleSourceSpec_actionAdapter ( this ) ) ;
jButtonBrowseSchemaModule . setToolTipText (
" ) ;
jButtonBrowseSchemaModule . setActionCommand ( " ) ;
jButtonBrowseSchemaModule . setText ( " ) ;
jButtonBrowseSchemaModule . addActionListener ( new
ModelRegistrar_jButtonBrowseSchemaModule_actionAdapter ( this ) ) ;
jTabbedPaneActivities . add ( jPanelRegCard , " ) ;
jTabbedPaneActivities . add ( jPanelModelSyntax , " ) ;
jPanelRCButtons . add ( jButtonUpdateRegCard ) ;
jPanelRCButtons . add ( jButtonDeleteCard ) ;
jPanelModelSyntaxButtons . add ( jButtonBrowseModelSyntaxFile ) ;
jPanelModelSyntaxButtons . add ( jButtonDeleteModelSyntaxFile ) ;
jPanelModelSyntaxButtons . add ( jButtonExportModelSyntaxFile ) ;
jPanelModelSyntaxButtons . add ( jButtonUpdateModelSyntax ) ;
jPanelAmnSemanticsButtons . add ( jButtonBrowseAmnTranslatorFile ) ;
jPanelAmnSemanticsButtons . add ( jButtonDeleteAmnTranslatorFile ) ;
jPanelAmnSemanticsButtons . add ( jButtonExportAmnTranslatorFile ) ;
jPanelAmnSemanticsButtons . add ( jButtonUpdateAmnSemantics ) ;
jTabbedPaneActivities . add ( jPanelAmnSemantics , " ) ;
jPanelAmnSemantics . add ( jPanelAmnSemanticsButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . SOUTHWEST , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelAmnSemantics . add ( jSplitPaneAmnSemantics ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneVerbalAmnSemantics . getViewport ( ) . add (
jTextAreaVerbalAmnSemantics ) ;
jTabbedPaneActivities . add ( jPanelReferenceSchema ,
" ) ;
jPanelVODButtons . add ( jButtonCreateReferenceSchemaTemplate ) ;
jPanelVODButtons . add ( jButtonVODEdit ) ;
jPanelVODButtons . add ( jButtonBrowseSchemaModule ) ;
jPanelVODButtons . add ( jButtonVODUpdate ) ;
jPanelReferenceSchema . add ( jPanelVODButtons ,
new
GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jSplitPaneReferenceSchema . add ( jScrollPaneReferenceSchemaTemplate , JSplitPane . LEFT ) ;
jSplitPaneReferenceSchema . add ( jPanelReferenceSchemaEditor , JSplitPane . RIGHT ) ;
jScrollPaneReferenceSchemaTemplate . getViewport ( ) . add ( jTextAreaReferenceSchemaTemplate ) ;
jPanelReferenceSchema . add ( jSplitPaneReferenceSchema ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> ,
1.0
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jTabbedPaneActivities . add ( jPanelReferenceSchemaIntegration ,
" ) ;
jTabbedPaneActivities . add ( jPanelTranslator ,
" ) ;
jPanelTTMButtons . add ( jButtonGenerateTemplate ) ;
jPanelTTMButtons . add ( jButtonBrowseTranslator ) ;
jPanelTTMButtons . add ( jButtonDeleteTranslator ) ;
jPanelTTMButtons . add ( jButtonExportTranslator ) ;
jPanelTTMButtons . add ( jButtonUpdateTranslator ) ;
jScrollPaneVerbalRules . getViewport ( ) . add ( jTextAreaVerbalRules ) ;
jPanelTranslator . add ( jSplitPaneTranslator ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelTranslator . add ( jPanelTTMButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jTabbedPaneActivities . add ( jPanelSamples , " ) ;
jPanelReferenceSchemaIntegration . add ( jPanelReferenceSchemaIntegrationStub ,
new
GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSamples . add ( jSplitPaneSamples ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSampleButtons . add ( jButtonNewSample ) ;
jPanelSampleButtons . add ( jButtonDeleteSample ) ;
jPanelSampleButtons . add ( jButtonUpdateSampleRegCard ) ;
jPanelSamples . add ( jPanelSampleButtons , new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSampleSpecButtons . add ( jButtonBrowseSourceSampleSpec ) ;
jPanelSampleSpecButtons . add ( jButtonExportSourceSampleSpec ) ;
jPanelSampleSpecButtons . add ( jButtonTranslate2AmnSampleSourceSpec ) ;
jPanelSampleTargetSpecButtons . add ( jButtonBrowseSampleTargetSpec ) ;
jPanelSampleTargetSpecButtons . add ( jButtonTranslateSampleTargetSpec2Amn ) ;
jTabbedPaneSample . add ( jPanelSampleRegCard , " ) ;
jPanelSampleRegCard . add ( jLabelSampleTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSampleRegCard . add ( jTextFieldSampleTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSampleVerification . add ( jCheckBoxSampleVerification ) ;
jPanelSampleRegCard . add ( jPanelSampleRegCardButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSampleRegCard . add ( jPanelSourceSampleSpec ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSampleRegCard . add ( jPanelSampleTargetSpec ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSampleRegCard . add ( jPanelSampleVerification ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelModelSyntax . add ( jPanelModelSyntaxButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jSplitPaneModelSyntax . add ( jScrollPaneModelSyntaxFiles , JSplitPane . LEFT ) ;
jScrollPaneModelSyntaxFiles . getViewport ( ) . add ( jListModelSyntaxFiles ) ;
jSplitPaneModelSyntax . add ( jScrollPaneModelSyntax , JSplitPane . RIGHT ) ;
jScrollPaneModelSyntax . getViewport ( ) . add ( jTextAreaModelSyntax ) ;
jPanelModelSyntax . add ( jSplitPaneModelSyntax ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jSplitPaneAmnSemantics . add ( jScrollPaneVerbalAmnSemantics , JSplitPane . TOP ) ;
jSplitPaneAmnSemantics . add ( jSplitPaneTranslator2Amn , JSplitPane . BOTTOM ) ;
jSplitPaneTranslator2Amn . add ( jScrollPaneTranslator2AmnFiles , JSplitPane . LEFT ) ;
jScrollPaneTranslator2AmnFiles . getViewport ( ) . add (
jListTranslator2AmnFiles ) ;
jSplitPaneTranslator2Amn . add ( jScrollPaneTranslator2Amn , JSplitPane . RIGHT ) ;
jScrollPaneTranslator2Amn . getViewport ( ) . add ( jTextAreaTranslator2Amn ) ;
jSplitPaneTranslator . add ( jScrollPaneVerbalRules , JSplitPane . TOP ) ;
jSplitPaneTranslator . add ( jSplitPaneTranslator2TM , JSplitPane . BOTTOM ) ;
jSplitPaneTranslator2TM . add ( jScrollPaneTranslator2TMFiles , JSplitPane . LEFT ) ;
jScrollPaneTranslator2TMFiles . getViewport ( ) . add ( jListTranslator2TMFiles ) ;
jSplitPaneTranslator2TM . add ( jScrollPaneTranslator2CM , JSplitPane . RIGHT ) ;
jScrollPaneTranslator2CM . getViewport ( ) . add ( jTextAreaTranslator2TM ) ;
jPanelSourceSampleSpec . add ( jPanelSampleSpecButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSourceSampleSpec . add ( jScrollPaneSampleSpec ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneSampleSpec . getViewport ( ) . add ( jTextAreaSampleSpec ) ;
jSplitPaneSamples . add ( jTabbedPaneSample , JSplitPane . RIGHT ) ;
jSplitPaneSamples . add ( jScrollPaneExistingSamples , JSplitPane . LEFT ) ;
jScrollPaneExistingSamples . getViewport ( ) . add ( jListExistingSamples ) ;
jPanelSampleTargetSpec . add ( jPanelSampleTargetSpecButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSampleTargetSpec . add ( jScrollPaneSampleTargetSpec ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneSampleTargetSpec . getViewport ( ) . add ( jTextAreaSampleTargetSpec ) ;
jTabbedPaneSample . add ( jPanelSourceSampleAmnSemantics , " ) ;
jSplitPaneSourceSampleAmnSemantics . add ( jPanelSourceSampleAmnSemanticsNonRec , JSplitPane . TOP ) ;
jPanelSampleAmnSemanticsNonRecButtons . add (
jButtonSourceSampleAmnSemanticsNonRecBrowse ) ;
jPanelSampleAmnSemanticsNonRecButtons . add (
jButtonSourceSampleAmnSemanticsNonRecDelete ) ;
jSplitPaneSourceSampleAmnSemantics . add ( jPanelSourceSampleAmnSemanticsRec , JSplitPane . BOTTOM ) ;
jPanelSourceSampleAmnSemantics . add ( jSplitPaneSourceSampleAmnSemantics ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> ,
1.0
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jSplitPaneSampleAmnSemanticsNonRec . add (
jScrollPaneSourceSampleAmnSemanticsNonRecFiles , JSplitPane . LEFT ) ;
jScrollPaneSourceSampleAmnSemanticsNonRecFiles . getViewport ( ) . add (
jListSourceSampleAmnSemanticsNonRecFiles ) ;
jSplitPaneSampleAmnSemanticsNonRec . add (
jScrollPaneSampleAmnSemanticsNonRec , JSplitPane . RIGHT ) ;
jScrollPaneSampleAmnSemanticsNonRec . getViewport ( ) . add (
jTextAreaSourceSampleAmnSemanticsNonRec ) ;
jPanelSourceSampleAmnSemanticsNonRec . add ( jSplitPaneSampleAmnSemanticsNonRec , new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSourceSampleAmnSemanticsNonRec . add (
jPanelSampleAmnSemanticsNonRecButtons , new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSourceSampleAmnSemanticsRec . add ( jSplitPaneSourceSampleAmnSemanticsRec , new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSourceSampleAmnSemanticsRec . add ( jPanelSampleAmnSemanticsRecButtons , new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSampleAmnSemanticsRecButtons . add ( jButtonSourceSampleAmnSemanticsRecBrowse ) ;
jPanelSampleAmnSemanticsRecButtons . add (
jButtonSourceSampleAmnSemanticsRecExport ) ;
jPanelSampleAmnSemanticsRecButtons . add ( jButtonSourceSampleAmnSemanticsRecDelete ) ;
jSplitPaneSourceSampleAmnSemanticsRec . add (
jScrollPaneSourceSampleAmnSemanticsRecFiles , JSplitPane . LEFT ) ;
jScrollPaneSourceSampleAmnSemanticsRecFiles . getViewport ( ) . add (
jListSourceSampleAmnSemanticsRecFiles ) ;
jSplitPaneSourceSampleAmnSemanticsRec . add ( jScrollPaneSampleAmnSemanticsRec , JSplitPane . RIGHT ) ;
jScrollPaneSampleAmnSemanticsRec . getViewport ( ) . add (
jTextAreaSourceSampleAmnSemanticsRec ) ;
jTabbedPaneSample . add ( jPanelTargetSampleAmnSemantics ,
" ) ;
jSplitPaneTargetSampleAmnSemantics . add (
jPanelTargetSampleAmnSemanticsNonRec , JSplitPane . TOP ) ;
jSplitPaneTargetSampleAmnSemantics . add ( jPanelTargetSampleAmnSemanticsRec , JSplitPane . BOTTOM ) ;
jPanelTargetSampleAmnSemanticsRecButtons . add (
jButtonTargetSampleAmnSemanticsRecBrowse ) ;
jPanelTargetSampleAmnSemanticsRecButtons . add (
jButtonTargetSampleAmnSemanticsRecExport ) ;
jPanelTargetSampleAmnSemanticsRecButtons . add (
jButtonTargetSampleAmnSemanticsRecDelete ) ;
jPanelTargetSampleAmnSemantics . add ( jSplitPaneTargetSampleAmnSemantics ,
new GridBagConstraints ( <num> , <num> , <num> , <num> ,
1.0 , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelTargetSampleAmnSemanticsNonRec . add (
jSplitPaneTargetSampleAmnSemanticsNonRec , new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jSplitPaneTargetSampleAmnSemanticsNonRec . add (
jScrollPaneTargetSampleAmnSemanticsNonRecFiles , JSplitPane . LEFT ) ;
jScrollPaneTargetSampleAmnSemanticsNonRecFiles . getViewport ( ) . add (
jListTargetSampleAmnSemanticsNonRecFiles ) ;
jSplitPaneTargetSampleAmnSemanticsNonRec . add (
jScrollPaneTargetSampleAmnSemanticsNonRec , JSplitPane . RIGHT ) ;
jSplitPaneTargetSampleAmnSemanticsRec . add (
jScrollPaneTargetSampleAmnSemanticsRecFiles , JSplitPane . LEFT ) ;
jScrollPaneTargetSampleAmnSemanticsRecFiles . getViewport ( ) . add (
jListTargetSampleAmnSemanticsRecFiles ) ;
jSplitPaneTargetSampleAmnSemanticsRec . add (
jScrollPaneTargetSampleAmnSemanticsRec , JSplitPane . RIGHT ) ;
jScrollPaneTargetSampleAmnSemanticsRec . getViewport ( ) . add (
jTextAreaTargetSampleAmnSemanticsRec ) ;
jPanelTargetSampleAmnSemanticsRec . add (
jSplitPaneTargetSampleAmnSemanticsRec , new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelTargetSampleAmnSemanticsRec . add (
jPanelTargetSampleAmnSemanticsRecButtons , new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneTargetSampleAmnSemanticsNonRec . getViewport ( ) . add (
jTextAreaTargetSampleAmnSemanticsNonRec ) ;
jTabbedPaneSample . add ( jPanelRefinementProof , " ) ;
jPanelRefinementProof . add ( jPanelRefinementProofButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRefinementProofButtons . add ( jButtonRefinementProofBrowse ) ;
jPanelRefinementProof . add ( jScrollPaneRefinementProof ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneRefinementProof . getViewport ( ) . add ( jTextAreaRefinementProof ) ;
jPanelSyntax . add ( jLabelSyntaxDocTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSyntax . add ( jLabelSyntaxDate ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSyntax . add ( jLabelSyntaxLink ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSyntax . add ( jTextFieldSyntaxDocTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSyntax . add ( jTextFieldSyntaxLink ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSyntax . add ( jButtonBrowseSyntaxLink ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jLabelSemanticsDocTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jTextFieldSemanticsDocTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jLabelSemanticsDate ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jLabelSemanticsLink ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jTextFieldSemanticsLink ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jButtonBrowseSemantics ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSyntax . add ( jFormattedTextFieldSyntaxDate ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . WEST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jFormattedTextFieldSemanticsDate ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . WEST , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jTextFieldShortTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jTextFieldFullTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jLabelShortTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jLabelFullTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jPanelSyntax ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jPanelSemantics ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jPanelRCButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jLabelRefinedModel ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jTextFieldRefinedModel ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelRegCard . add ( jButtonExploreExtension ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
this . getContentPane ( ) . add ( jTabbedPaneActivities ,
java . awt . BorderLayout . CENTER ) ;
jPanelReferenceSchemaEditor . setLayout ( borderLayoutSchemaEditor ) ;
jPanelReferenceSchemaIntegrationStub . setLayout ( borderLayoutSchemaIntegration ) ;
for ( int i = <num> ; i <= <num> ; i ++ ) {
jTabbedPaneActivities . setEnabledAt ( i , false ) ;
}
for ( int i = <num> ; i <= <num> ; i ++ ) {
jTabbedPaneSample . setEnabledAt ( i , false ) ;
}
setDividersLocations ( ) ;
jListExistingSamples . setCellRenderer ( new SampleRegDefCellRenderer ( ) ) ;
jListExistingSamples . setModel ( new DefaultListModel ( ) ) ;
}
JTabbedPane jTabbedPaneActivities = new JTabbedPane ( ) ;
JPanel jPanelRegCard = new JPanel ( ) ;
GridBagLayout gridBagLayoutRC = new GridBagLayout ( ) ;
JPanel jPanelModelSyntax = new JPanel ( ) ;
GridBagLayout gridBagLayoutMS = new GridBagLayout ( ) ;
JLabel jLabelShortTitle = new JLabel ( ) ;
JTextField jTextFieldShortTitle = new JTextField ( ) ;
JLabel jLabelFullTitle = new JLabel ( ) ;
JTextField jTextFieldFullTitle = new JTextField ( ) ;
JPanel jPanelSyntax = new JPanel ( ) ;
GridBagLayout gridBagLayoutRCS = new GridBagLayout ( ) ;
JLabel jLabelSyntaxDocTitle = new JLabel ( ) ;
JLabel jLabelSyntaxDate = new JLabel ( ) ;
JLabel jLabelSyntaxLink = new JLabel ( ) ;
JTextField jTextFieldSyntaxDocTitle = new JTextField ( ) ;
JTextField jTextFieldSyntaxLink = new JTextField ( ) ;
JButton jButtonBrowseSyntaxLink = new JButton ( ) ;
JPanel jPanelSemantics = new JPanel ( ) ;
GridBagLayout gridBagLayoutRCSem = new GridBagLayout ( ) ;
JLabel jLabelSemanticsDocTitle = new JLabel ( ) ;
JTextField jTextFieldSemanticsDocTitle = new JTextField ( ) ;
JLabel jLabelSemanticsDate = new JLabel ( ) ;
JLabel jLabelSemanticsLink = new JLabel ( ) ;
JTextField jTextFieldSemanticsLink = new JTextField ( ) ;
JButton jButtonBrowseSemantics = new JButton ( ) ;
JPanel jPanelRCButtons = new JPanel ( ) ;
JButton jButtonUpdateRegCard = new JButton ( ) ;
FlowLayout flowLayoutRCB = new FlowLayout ( ) ;
JButton jButtonDeleteCard = new JButton ( ) ;
TitledBorder titledBorder3 = new TitledBorder ( " ) ;
JPanel jPanelModelSyntaxButtons = new JPanel ( ) ;
JButton jButtonBrowseModelSyntaxFile = new JButton ( ) ;
JButton jButtonUpdateModelSyntax = new JButton ( ) ;
JPanel jPanelAmnSemantics = new JPanel ( ) ;
GridBagLayout gridBagLayoutAMNS = new GridBagLayout ( ) ;
JPanel jPanelAmnSemanticsButtons = new JPanel ( ) ;
JButton jButtonUpdateAmnSemantics = new JButton ( ) ;
JButton jButtonBrowseAmnTranslatorFile = new JButton ( ) ;
JSplitPane jSplitPaneAmnSemantics = new JSplitPane ( ) ;
JScrollPane jScrollPaneVerbalAmnSemantics = new JScrollPane ( ) ;
JTextArea jTextAreaVerbalAmnSemantics = new JTextArea ( ) ;
JPanel jPanelReferenceSchema = new JPanel ( ) ;
GridBagLayout gridBagLayoutVOD = new GridBagLayout ( ) ;
JScrollPane jScrollPaneReferenceSchemaTemplate = new JScrollPane ( ) ;
JPanel jPanelVODButtons = new JPanel ( ) ;
JButton jButtonCreateReferenceSchemaTemplate = new JButton ( ) ;
JTextArea jTextAreaReferenceSchemaTemplate = new JTextArea ( ) ;
JButton jButtonVODUpdate = new JButton ( ) ;
JButton jButtonVODEdit = new JButton ( ) ;
JSplitPane jSplitPaneReferenceSchema = new JSplitPane ( ) ;
JPanel jPanelReferenceSchemaEditor = new JPanel ( ) ;
JPanel jPanelReferenceSchemaIntegration = new JPanel ( ) ;
GridBagLayout gridBagLayoutOI = new GridBagLayout ( ) ;
JPanel jPanelReferenceSchemaIntegrationStub = new JPanel ( ) ;
JPanel jPanelTranslator = new JPanel ( ) ;
GridBagLayout gridBagLayoutTr = new GridBagLayout ( ) ;
JSplitPane jSplitPaneTranslator = new JSplitPane ( ) ;
JPanel jPanelTTMButtons = new JPanel ( ) ;
JButton jButtonBrowseTranslator = new JButton ( ) ;
JButton jButtonGenerateTemplate = new JButton ( ) ;
JButton jButtonExportTranslator = new JButton ( ) ;
JButton jButtonUpdateTranslator = new JButton ( ) ;
JScrollPane jScrollPaneVerbalRules = new JScrollPane ( ) ;
JTextArea jTextAreaVerbalRules = new JTextArea ( ) ;
JPanel jPanelSamples = new JPanel ( ) ;
GridBagLayout gridBagLayoutSam = new GridBagLayout ( ) ;
JSplitPane jSplitPaneSamples = new JSplitPane ( ) ;
JTabbedPane jTabbedPaneSample = new JTabbedPane ( ) ;
JPanel jPanelSampleRegCard = new JPanel ( ) ;
GridBagLayout gridBagLayoutSRC = new GridBagLayout ( ) ;
JPanel jPanelSampleButtons = new JPanel ( ) ;
JButton jButtonNewSample = new JButton ( ) ;
JButton jButtonDeleteSample = new JButton ( ) ;
JLabel jLabelSampleTitle = new JLabel ( ) ;
JTextField jTextFieldSampleTitle = new JTextField ( ) ;
JPanel jPanelSourceSampleSpec = new JPanel ( ) ;
GridBagLayout gridBagLayoutSS = new GridBagLayout ( ) ;
JPanel jPanelSampleSpecButtons = new JPanel ( ) ;
JButton jButtonExportSourceSampleSpec = new JButton ( ) ;
JButton jButtonBrowseSourceSampleSpec = new JButton ( ) ;
JPanel jPanelSampleTargetSpec = new JPanel ( ) ;
GridBagLayout gridBagLayoutSCS = new GridBagLayout ( ) ;
JPanel jPanelSampleTargetSpecButtons = new JPanel ( ) ;
JButton jButtonBrowseSampleTargetSpec = new JButton ( ) ;
JCheckBox jCheckBoxSampleVerification = new JCheckBox ( ) ;
JPanel jPanelSampleVerification = new JPanel ( ) ;
JPanel jPanelSampleRegCardButtons = new JPanel ( ) ;
JButton jButtonTranslateSampleTargetSpec2Amn = new JButton ( ) ;
JSplitPane jSplitPaneModelSyntax = new JSplitPane ( ) ;
JScrollPane jScrollPaneModelSyntaxFiles = new JScrollPane ( ) ;
JScrollPane jScrollPaneModelSyntax = new JScrollPane ( ) ;
JTextArea jTextAreaModelSyntax = new JTextArea ( ) ;
TextFileJList jListModelSyntaxFiles = new TextFileJList ( jTextAreaModelSyntax ) ;
JSplitPane jSplitPaneTranslator2Amn = new JSplitPane ( ) ;
JScrollPane jScrollPaneTranslator2AmnFiles = new JScrollPane ( ) ;
JScrollPane jScrollPaneTranslator2Amn = new JScrollPane ( ) ;
JTextArea jTextAreaTranslator2Amn = new JTextArea ( ) ;
TextFileJList jListTranslator2AmnFiles = new TextFileJList ( jTextAreaTranslator2Amn ) ;
JSplitPane jSplitPaneTranslator2TM = new JSplitPane ( ) ;
JScrollPane jScrollPaneTranslator2TMFiles = new JScrollPane ( ) ;
JScrollPane jScrollPaneTranslator2CM = new JScrollPane ( ) ;
JTextArea jTextAreaTranslator2TM = new JTextArea ( ) ;
TextFileJList jListTranslator2TMFiles = new TextFileJList ( jTextAreaTranslator2TM ) ;
JScrollPane jScrollPaneSampleSpec = new JScrollPane ( ) ;
FileJTextArea jTextAreaSampleSpec = new FileJTextArea ( ) ;
JScrollPane jScrollPaneExistingSamples = new JScrollPane ( ) ;
JList jListExistingSamples = new JList ( ) ;
JScrollPane jScrollPaneSampleTargetSpec = new JScrollPane ( ) ;
FileJTextArea jTextAreaSampleTargetSpec = new FileJTextArea ( ) ;
JPanel jPanelSourceSampleAmnSemantics = new JPanel ( ) ;
GridBagLayout gridBagLayoutSAMNS = new GridBagLayout ( ) ;
JSplitPane jSplitPaneSourceSampleAmnSemantics = new JSplitPane ( ) ;
JPanel jPanelSourceSampleAmnSemanticsNonRec = new JPanel ( ) ;
JPanel jPanelSourceSampleAmnSemanticsRec = new JPanel ( ) ;
GridBagLayout gridBagLayoutSAMNSNR = new GridBagLayout ( ) ;
JSplitPane jSplitPaneSampleAmnSemanticsNonRec = new JSplitPane ( ) ;
JPanel jPanelSampleAmnSemanticsNonRecButtons = new JPanel ( ) ;
JButton jButtonSourceSampleAmnSemanticsNonRecBrowse = new JButton ( ) ;
JScrollPane jScrollPaneSourceSampleAmnSemanticsNonRecFiles = new JScrollPane ( ) ;
JScrollPane jScrollPaneSampleAmnSemanticsNonRec = new JScrollPane ( ) ;
JTextArea jTextAreaSourceSampleAmnSemanticsNonRec = new JTextArea ( ) ;
TextFileJList jListSourceSampleAmnSemanticsNonRecFiles = new TextFileJList ( jTextAreaSourceSampleAmnSemanticsNonRec ) ;
GridBagLayout gridBagLayoutSAMNSR = new GridBagLayout ( ) ;
JSplitPane jSplitPaneSourceSampleAmnSemanticsRec = new JSplitPane ( ) ;
JPanel jPanelSampleAmnSemanticsRecButtons = new JPanel ( ) ;
JScrollPane jScrollPaneSourceSampleAmnSemanticsRecFiles = new JScrollPane ( ) ;
JScrollPane jScrollPaneSampleAmnSemanticsRec = new JScrollPane ( ) ;
JTextArea jTextAreaSourceSampleAmnSemanticsRec = new JTextArea ( ) ;
TextFileJList jListSourceSampleAmnSemanticsRecFiles = new TextFileJList ( jTextAreaSourceSampleAmnSemanticsRec ) ;
JButton jButtonSourceSampleAmnSemanticsRecDelete = new JButton ( ) ;
JButton jButtonSourceSampleAmnSemanticsRecExport = new JButton ( ) ;
JButton jButtonSourceSampleAmnSemanticsRecBrowse = new JButton ( ) ;
JButton jButtonSourceSampleAmnSemanticsNonRecDelete = new JButton ( ) ;
JPanel jPanelTargetSampleAmnSemantics = new JPanel ( ) ;
JSplitPane jSplitPaneTargetSampleAmnSemantics = new JSplitPane ( ) ;
JPanel jPanelTargetSampleAmnSemanticsNonRec = new JPanel ( ) ;
JPanel jPanelTargetSampleAmnSemanticsRec = new JPanel ( ) ;
GridBagLayout gridBagLayoutCSAMNS = new GridBagLayout ( ) ;
GridBagLayout gridBagLayoutCSAMNSNR = new GridBagLayout ( ) ;
JSplitPane jSplitPaneTargetSampleAmnSemanticsNonRec = new JSplitPane ( ) ;
JScrollPane jScrollPaneTargetSampleAmnSemanticsNonRecFiles = new JScrollPane ( ) ;
JScrollPane jScrollPaneTargetSampleAmnSemanticsNonRec = new JScrollPane ( ) ;
JTextArea jTextAreaTargetSampleAmnSemanticsNonRec = new JTextArea ( ) ;
TextFileJList jListTargetSampleAmnSemanticsNonRecFiles = new TextFileJList ( jTextAreaTargetSampleAmnSemanticsNonRec ) ;
GridBagLayout gridBagLayoutCSAMNSR = new GridBagLayout ( ) ;
JSplitPane jSplitPaneTargetSampleAmnSemanticsRec = new JSplitPane ( ) ;
JPanel jPanelTargetSampleAmnSemanticsRecButtons = new JPanel ( ) ;
JButton jButtonTargetSampleAmnSemanticsRecDelete = new JButton ( ) ;
JButton jButtonTargetSampleAmnSemanticsRecExport = new JButton ( ) ;
JButton jButtonTargetSampleAmnSemanticsRecBrowse = new JButton ( ) ;
JScrollPane jScrollPaneTargetSampleAmnSemanticsRecFiles = new JScrollPane ( ) ;
JScrollPane jScrollPaneTargetSampleAmnSemanticsRec = new JScrollPane ( ) ;
JTextArea jTextAreaTargetSampleAmnSemanticsRec = new JTextArea ( ) ;
TextFileJList jListTargetSampleAmnSemanticsRecFiles = new TextFileJList ( jTextAreaTargetSampleAmnSemanticsRec ) ;
JPanel jPanelRefinementProof = new JPanel ( ) ;
GridBagLayout gridBagLayoutSRP = new GridBagLayout ( ) ;
JScrollPane jScrollPaneRefinementProof = new JScrollPane ( ) ;
JPanel jPanelRefinementProofButtons = new JPanel ( ) ;
JButton jButtonRefinementProofBrowse = new JButton ( ) ;
FileJTextArea jTextAreaRefinementProof = new FileJTextArea ( ) ;
JTextField jFormattedTextFieldSyntaxDate = new JFormattedTextField ( DateHelper . createMaskFormatter ( " ) ) ;
JTextField jFormattedTextFieldSemanticsDate = new JFormattedTextField ( DateHelper . createMaskFormatter ( " ) ) ;
JButton jButtonDeleteModelSyntaxFile = new JButton ( ) ;
JButton jButtonDeleteAmnTranslatorFile = new JButton ( ) ;
JButton jButtonDeleteTranslator = new JButton ( ) ;
JButton jButtonExportModelSyntaxFile = new JButton ( ) ;
JButton jButtonExportAmnTranslatorFile = new JButton ( ) ;
JButton jButtonUpdateSampleRegCard = new JButton ( ) ;
JLabel jLabelRefinedModel = new JLabel ( ) ;
JTextField jTextFieldRefinedModel = new JTextField ( ) ;
JButton jButtonExploreExtension = new JButton ( ) ;
JButton jButtonTranslate2AmnSampleSourceSpec = new JButton ( ) ;
Border border1 = BorderFactory . createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) ;
Border border2 = new TitledBorder ( border1 , " ) ;
JButton jButtonBrowseSchemaModule = new JButton ( ) ;
BorderLayout borderLayoutMR = new BorderLayout ( ) ;
BorderLayout borderLayoutSchemaEditor = new BorderLayout ( ) ;
BorderLayout borderLayoutSchemaIntegration = new BorderLayout ( ) ;
public void this_windowClosing ( WindowEvent e ) {
try {
if ( StringHelper . isNullEmptyOrBlank ( model . get_name ( ) ) )
removeModel ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonBrowseSyntaxLink_actionPerformed ( ActionEvent e ) {
BrowserControl . displayURL ( jTextFieldSyntaxLink . getText ( ) ) ;
}
public void jButtonBrowseSemantics_actionPerformed ( ActionEvent e ) {
BrowserControl . displayURL ( jTextFieldSemanticsLink . getText ( ) ) ;
}
public void jButtonExploreExtension_actionPerformed ( ActionEvent e ) {
try {
exploreExtension ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonUpdateRegCard_actionPerformed ( ActionEvent e ) {
try {
updateModelRegCard ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonDeleteCard_actionPerformed ( ActionEvent e ) {
try {
removeModel ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonBrowseModelSyntaxFile_actionPerformed ( ActionEvent e ) {
try {
jListModelSyntaxFiles . addFile ( " , " ) ;
} catch ( FileNotFoundException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonDeleteModelSyntaxFile_actionPerformed ( ActionEvent e ) {
jListModelSyntaxFiles . removeSelectedFile ( ) ;
}
public void jButtonExportModelSyntaxFile_actionPerformed ( ActionEvent e ) {
try {
jListModelSyntaxFiles . exportSelectedFile ( " , " ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonUpdateModelSyntax_actionPerformed ( ActionEvent e ) {
try {
updateAbstractSyntax ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
ex . printStackTrace ( ) ;
}
}
public void jListModelSyntaxFiles_mouseClicked ( MouseEvent e ) {
jListModelSyntaxFiles . updateLastSelectedContent ( ) ;
}
public void jButtonBrowseAmnTranslatorFile_actionPerformed ( ActionEvent e ) {
try {
jListTranslator2AmnFiles . addFile ( " , " ) ;
} catch ( FileNotFoundException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonDeleteAmnTranslatorFile_actionPerformed ( ActionEvent e ) {
jListTranslator2AmnFiles . removeSelectedFile ( ) ;
}
public void jButtonExportAmnTranslatorFile_actionPerformed ( ActionEvent e ) {
try {
jListTranslator2AmnFiles . exportSelectedFile ( " , " ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonUpdateAmnSemantics_actionPerformed ( ActionEvent e ) {
try {
updateAmnSemantics ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
ex . printStackTrace ( ) ;
}
}
public void jListTranslator2AmnFiles_mousePressed ( MouseEvent e ) {
jListTranslator2AmnFiles . updateLastSelectedContent ( ) ;
}
public void jButtonCreateReferenceSchemaTemplate_actionPerformed ( ActionEvent e ) {
try {
createReferenceSchemaTemplate ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( SdfDefinitionException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( SDF2RSException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( ReferenceSchemaModelException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( RecognitionException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonVODEdit_actionPerformed ( ActionEvent e ) {
try {
editReferenceSchema ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonBrowseSchemaModule_actionPerformed ( ActionEvent e ) {
try {
browseReferenceSchema ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonVODUpdate_actionPerformed ( ActionEvent e ) {
try {
updateReferenceSchema ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonGenerateTemplate_actionPerformed ( ActionEvent e ) {
try {
generateTranslatorToTargetModelTemplate ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( TranslatorTemplateConstructionException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( SdfDefinitionException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( RecognitionException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jListTranslator2CMFiles_mouseClicked ( MouseEvent e ) {
jListTranslator2TMFiles . updateLastSelectedContent ( ) ;
}
public void jButtonBrowseTranslator_actionPerformed ( ActionEvent e ) {
try {
jListTranslator2TMFiles . addFile ( " , " ) ;
} catch ( FileNotFoundException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonDeleteTranslator_actionPerformed ( ActionEvent e ) {
jListTranslator2TMFiles . removeSelectedFile ( ) ;
}
public void jButtonExportTranslator_actionPerformed ( ActionEvent e ) {
try {
jListTranslator2TMFiles . exportSelectedFile ( " , " ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonUpdateTranslator_actionPerformed ( ActionEvent e ) {
try {
updateTranslatorToTargetModel ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonNewSample_actionPerformed ( ActionEvent e ) {
try {
this . registerNewSample ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonDeleteSample_actionPerformed ( ActionEvent e ) {
try {
this . removeSelectedSample ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jListExistingSamples_mouseClicked ( MouseEvent e ) {
try {
openSelectedSample ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jListSampleAmnSemanticsNonRecFiles_mouseClicked ( MouseEvent e ) {
jListSourceSampleAmnSemanticsNonRecFiles . updateLastSelectedContent ( ) ;
}
public void jListSampleAmnSemanticsRecFiles_mouseClicked ( MouseEvent e ) {
jListSourceSampleAmnSemanticsRecFiles . updateLastSelectedContent ( ) ;
}
public void jListTargetSampleAmnSemanticsNonRecFiles_mouseClicked ( MouseEvent e ) {
jListTargetSampleAmnSemanticsNonRecFiles . updateLastSelectedContent ( ) ;
}
public void jListTargetSampleAmnSemanticsRecFiles_mouseClicked ( MouseEvent e ) {
jListTargetSampleAmnSemanticsRecFiles . updateLastSelectedContent ( ) ;
}
public void jButtonUpdateSampleRegCard_actionPerformed ( ActionEvent e ) {
try {
updateSampleCard ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonBrowseSampleSpec_actionPerformed ( ActionEvent e ) {
try {
jTextAreaSampleSpec . importTextFromFile ( " , " ) ;
} catch ( FileNotFoundException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonExportSampleSpec_actionPerformed ( ActionEvent e ) {
try {
jTextAreaSampleSpec . exportTextToFile ( " , " ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonTranslate2AmnSampleSourceSpec_actionPerformed ( ActionEvent e ) {
try {
translateSampleSourceSpec2Amn ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonBrowseSampleTargetSpec_actionPerformed ( ActionEvent e ) {
try {
jTextAreaSampleTargetSpec . importTextFromFile ( " , " ) ;
} catch ( FileNotFoundException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonTranslateSampleTargetSpec2Amn_actionPerformed ( ActionEvent e ) {
try {
translateSampleTargetSpec2Amn ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jCheckBoxSampleVerification_mouseClicked ( MouseEvent e ) {
if ( jTextAreaRefinementProof . getText ( ) . trim ( ) . compareTo ( " ) == <num> ||
jListSourceSampleAmnSemanticsRecFiles . getModel ( ) . getSize ( ) == <num> &&
jListTargetSampleAmnSemanticsRecFiles . getModel ( ) . getSize ( ) == <num> ) {
JOptionPane . showMessageDialog ( null , " ) ;
jCheckBoxSampleVerification . setSelected ( false ) ;
}
}
public void jButtonSampleAmnSemanticsNonRecBrowse_actionPerformed ( ActionEvent e ) {
try {
TextFile file ;
file = jListSourceSampleAmnSemanticsNonRecFiles . addFile ( " , " ) ;
jListSourceSampleAmnSemanticsRecFiles . addFile ( file ) ;
} catch ( FileNotFoundException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonSampleAmnSemanticsNonRecDelete_actionPerformed ( ActionEvent e ) {
jListSourceSampleAmnSemanticsNonRecFiles . removeSelectedFile ( ) ;
}
public void jButtonSampleAmnSemanticsRecBrowse_actionPerformed ( ActionEvent e ) {
try {
jListSourceSampleAmnSemanticsRecFiles . addFile ( " , " ) ;
} catch ( FileNotFoundException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonSampleAmnSemanticsRecExport_actionPerformed ( ActionEvent e ) {
try {
jListSourceSampleAmnSemanticsRecFiles . exportSelectedFile ( " ,
" ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonSampleAmnSemanticsRecDelete_actionPerformed ( ActionEvent e ) {
jListSourceSampleAmnSemanticsRecFiles . removeSelectedFile ( ) ;
}
public void jButtonTargetSampleAmnSemanticsRecBrowse_actionPerformed ( ActionEvent e ) {
try {
jListTargetSampleAmnSemanticsRecFiles . addFile ( " ,
" ) ;
} catch ( FileNotFoundException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonTargetSampleAmnSemanticsRecExport_actionPerformed ( ActionEvent e ) {
try {
jListTargetSampleAmnSemanticsRecFiles . exportSelectedFile ( " ,
" ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jButtonTargetSampleAmnSemanticsRecDelete_actionPerformed ( ActionEvent e ) {
jListTargetSampleAmnSemanticsRecFiles . removeSelectedFile ( ) ;
}
public void jButtonRefinementProofBrowse_actionPerformed ( ActionEvent e ) {
try {
jTextAreaRefinementProof . importTextFromFile ( " , " ) ;
} catch ( FileNotFoundException ex ) {
logger . info ( ex . toString ( ) ) ;
} catch ( IOException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
private void setDividersLocations ( ) {
jSplitPaneModelSyntax . setDividerLocation ( <num> ) ;
jSplitPaneAmnSemantics . setDividerLocation ( <num> ) ;
jSplitPaneReferenceSchema . setDividerLocation ( <num> ) ;
jSplitPaneTranslator . setDividerLocation ( <num> ) ;
jSplitPaneSamples . setDividerLocation ( <num> ) ;
jSplitPaneTranslator2Amn . setDividerLocation ( <num> ) ;
jSplitPaneTranslator2TM . setDividerLocation ( <num> ) ;
jSplitPaneSourceSampleAmnSemantics . setDividerLocation ( <num> ) ;
jSplitPaneSampleAmnSemanticsNonRec . setDividerLocation ( <num> ) ;
jSplitPaneSourceSampleAmnSemanticsRec . setDividerLocation ( <num> ) ;
jSplitPaneTargetSampleAmnSemantics . setDividerLocation ( <num> ) ;
jSplitPaneTargetSampleAmnSemanticsNonRec . setDividerLocation ( <num> ) ;
jSplitPaneTargetSampleAmnSemanticsRec . setDividerLocation ( <num> ) ;
}
private Logger logger ;
private DB db ;
private ModelRegDef model ;
private SampleRegDef sample ;
private SchemaEditorGui schemaEditor = null ;
private SchemaMappingGui schemaMapping = null ;
private void createNewModel ( ) throws SQLException {
model = db . <unk> ( ) ;
model . <unk> ( ModelKindChooserDialog . showModelKindChooserDialog ( ) ) ;
setModelKindDependableElements ( ) ;
}
private void openModel ( ) throws SQLException {
setModelKindDependableElements ( ) ;
jTextFieldShortTitle . setText ( model . get_name ( ) ) ;
jTextFieldFullTitle . setText ( model . <unk> ( ) ) ;
jTextFieldSyntaxDocTitle . setText ( model . <unk> ( ) ) ;
jTextFieldSyntaxLink . setText ( model . <unk> ( ) ) ;
jTextFieldSemanticsDocTitle . setText ( model . <unk> ( ) ) ;
jTextFieldSemanticsLink . setText ( model . <unk> ( ) ) ;
if ( model . get_syntDocDate ( ) != null ) {
( ( JFormattedTextField ) jFormattedTextFieldSyntaxDate ) . setValue (
DateHelper . convertDateIntoFormattedText ( model . get_syntDocDate ( ) ) ) ;
logger . info ( DateHelper . convertDateIntoFormattedText ( model . get_syntDocDate ( ) ) ) ;
}
if ( model . get_semDocDate ( ) != null ) {
( ( JFormattedTextField ) jFormattedTextFieldSemanticsDate ) . setValue (
DateHelper . convertDateIntoFormattedText ( model . get_semDocDate ( ) ) ) ;
logger . info ( DateHelper . convertDateIntoFormattedText ( model . get_syntDocDate ( ) ) ) ;
}
showRefinedExtensionName ( ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
jListModelSyntaxFiles . fillFromFileContainerSet ( model . get_abstrSyntax ( ) ) ;
if ( model . get_abstrSyntax ( ) . size ( ) != <num> ) {
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
}
jTextAreaVerbalAmnSemantics . setText ( model . get_verbAmnSem ( ) ) ;
jListTranslator2AmnFiles . fillFromFileContainerSet ( model . get_transToAmn ( ) ) ;
jTextAreaReferenceSchemaTemplate . setText ( model . get_refSchTmpl ( ) ) ;
if ( model . get_refSchema ( ) != null ) {
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
showReferenceSchemaEditor ( ) ;
}
jTextAreaVerbalRules . setText ( model . <unk> ( ) ) ;
jListTranslator2TMFiles . fillFromFileContainerSet ( model . get_transTargetModel ( ) ) ;
showExistingSamples ( ) ;
}
public void setModelKindDependableElements ( ) throws SQLException {
if ( model . get_target ( ) ) {
this . setTitle ( " ) ;
jLabelRefinedModel . setText ( " ) ;
jButtonExploreExtension . setToolTipText ( " ) ;
this . jButtonTranslateSampleTargetSpec2Amn . setEnabled ( false ) ;
} else {
this . setTitle ( " ) ;
jLabelRefinedModel . setText ( " ) ;
jButtonExploreExtension . setToolTipText ( " ) ;
this . jButtonTranslate2AmnSampleSourceSpec . setEnabled ( false ) ;
}
}
public void showRefinedExtensionName ( ) throws SQLException {
if ( model . get_refinedExtension ( ) != null ) {
jTextFieldRefinedModel . setText ( model . get_refinedExtension ( ) . get_name ( ) ) ;
showReferenceSchemaIntegration ( ) ;
}
}
private void updateModelRegCard ( ) throws SQLException {
int year ;
int month ;
int day ;
Date date ;
if ( jTextFieldShortTitle . getText ( ) . trim ( ) . compareTo ( " ) != <num> ) {
if ( model == null ) createNewModel ( ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
} else {
JOptionPane . showMessageDialog ( null , " ) ;
return ;
}
model . set_name ( jTextFieldShortTitle . getText ( ) ) ;
model . <unk> ( jTextFieldFullTitle . getText ( ) ) ;
model . <unk> ( jTextFieldSyntaxDocTitle . getText ( ) ) ;
model . <unk> ( jTextFieldSyntaxLink . getText ( ) ) ;
model . <unk> ( jTextFieldSemanticsDocTitle . getText ( ) ) ;
model . <unk> ( jTextFieldSemanticsLink . getText ( ) ) ;
date = null ;
try {
date = DateHelper . convertFormattedStringIntoDate ( jFormattedTextFieldSyntaxDate . getText ( ) ) ;
} catch ( Exception ex ) {
logger . info ( ex . toString ( ) ) ;
JOptionPane . showMessageDialog ( null , " ) ;
}
if ( date != null ) {
model . <unk> ( date ) ;
( ( JFormattedTextField ) jFormattedTextFieldSyntaxDate ) . setValue ( jFormattedTextFieldSyntaxDate . getText ( ) ) ;
}
date = null ;
try {
date = DateHelper . convertFormattedStringIntoDate ( jFormattedTextFieldSemanticsDate . getText ( ) ) ;
} catch ( Exception ex ) {
logger . info ( ex . toString ( ) ) ;
JOptionPane . showMessageDialog ( null , " ) ;
}
if ( date != null ) {
model . <unk> ( date ) ;
( ( JFormattedTextField ) jFormattedTextFieldSemanticsDate ) . setValue ( jFormattedTextFieldSemanticsDate . getText ( ) ) ;
}
}
private void removeModel ( ) throws SQLException {
int answer = JOptionPane . showConfirmDialog (
null ,
" + jTextFieldShortTitle . getText ( ) + " ,
" ,
JOptionPane . YES_NO_OPTION ) ;
if ( answer == <num> ) {
RepositoryCleaner . delete ( model ) ;
this . dispose ( ) ;
}
}
private void exploreExtension ( ) throws SQLException {
ExtensionExplorer explorer ;
if ( model . get_target ( ) )
logger . info ( " ) ;
else
logger . info ( " ) ;
explorer = new ExtensionExplorer ( this , model ) ;
}
private void updateAbstractSyntax ( ) throws SQLException {
jListModelSyntaxFiles . loadFilesToRepository ( db , model . get_abstrSyntax ( ) ) ;
if ( model . get_abstrSyntax ( ) . size ( ) != <num> ) {
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
}
}
private void updateAmnSemantics ( ) throws SQLException {
model . set_verbAmnSem ( jTextAreaVerbalAmnSemantics . getText ( ) ) ;
jListTranslator2AmnFiles . loadFilesToRepository ( db , model . get_transToAmn ( ) ) ;
}
private void createReferenceSchemaTemplate ( ) throws SQLException , SdfDefinitionException ,
SDF2RSException , ReferenceSchemaModelException ,
RecognitionException , IOException {
Module module = null ;
module = createSdfForModelSyntax ( ) ;
FormattingWriter writer = new DefaultFormattingWriter ( new StringWriter ( ) , <num> , " , " ) ;
SDF2RS sdf2so = new SDF2RS ( module , writer ) ;
sdf2so . generateSchema ( ) ;
jTextAreaReferenceSchemaTemplate . setText ( writer . toString ( ) ) ;
}
private Module createSdfForModelSyntax ( ) throws IOException ,
SdfDefinitionException , RecognitionException {
SdfCreator sdfCreator = new SdfCreator ( ) ;
Module module = null ;
Set < String > terminals = null ;
for ( int i = <num> ; i < jListModelSyntaxFiles . getModel ( ) . getSize ( ) ; i ++ ) {
TextFile file = ( TextFile ) jListModelSyntaxFiles . getModel ( ) . getElementAt ( i ) ;
Reader reader ;
reader = new StringReader ( file . getContent ( ) ) ;
terminals = StringChooserDialog . showStringChooserDialog ( " , ( new SdfCreator ( ) ) . getSortNames ( reader ) ) ;
reader . close ( ) ;
reader = new StringReader ( file . getContent ( ) ) ;
module = sdfCreator . processSdf ( reader , terminals ) ;
reader . close ( ) ;
}
return module ;
}
private void editReferenceSchema ( ) throws SQLException {
StringReader reader = new StringReader ( jTextAreaReferenceSchemaTemplate . getText ( ) ) ;
ModuleDef module ;
if ( model . get_refSchema ( ) != null ) {
}
module = ( new SynthesisLoader ( ) ) . loadFile ( db , reader , false ) ;
model . set_refSchema ( module ) ;
showReferenceSchemaEditor ( ) ;
showReferenceSchemaIntegration ( ) ;
}
private void browseReferenceSchema ( ) throws SQLException {
SchemaDef unifierSchemaDef = null ;
ModuleDef module = null ;
Set schemas ;
schemas = db . get_schema ( new Query ( new Like ( SchemaDef . _name , " ) ) ) ;
for ( Object obj : schemas ) {
unifierSchemaDef = ( SchemaDef ) obj ;
}
if ( unifierSchemaDef == null )
logger . info ( " ) ;
else {
module = ( ModuleDef ) ElementChooserDialog . showElementChooserDialog ( " , unifierSchemaDef . get_modules ( ) ) ;
if ( module != null )
model . set_refSchema ( module ) ;
}
showReferenceSchemaEditor ( ) ;
showReferenceSchemaIntegration ( ) ;
}
private void showReferenceSchemaEditor ( ) throws SQLException {
SchemaEditorGui gui = null ;
ModuleDef refSchema = null ;
refSchema = model . get_refSchema ( ) ;
if ( refSchema != null ) {
closeReferenceSchemaEditor ( ) ;
gui = new SchemaEditorGui ( ) ;
schemaEditor = gui ;
jPanelReferenceSchemaEditor . add ( " , gui ) ;
gui . start ( refSchema ) ;
validate ( ) ;
repaint ( ) ;
}
}
private void closeReferenceSchemaEditor ( ) {
if ( schemaEditor != null ) {
schemaEditor . end ( ) ;
jPanelReferenceSchemaEditor . remove ( schemaEditor ) ;
}
logger . info ( " ) ;
}
private void updateReferenceSchema ( ) throws SQLException {
model . set_refSchTmpl ( jTextAreaReferenceSchemaTemplate . getText ( ) ) ;
if ( model . get_refSchema ( ) != null ) {
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
jTabbedPaneActivities . setEnabledAt ( <num> , true ) ;
}
}
private void showReferenceSchemaIntegration ( ) throws SQLException {
SchemaMappingGui gui = null ;
ModuleDef modelRefSchema = null , extRefSchema = null ;
ExtensionRegDef extension = null ;
extension = model . get_refinedExtension ( ) ;
if ( extension == null ) return ;
modelRefSchema = model . get_refSchema ( ) ;
extRefSchema = extension . get_refSchema ( ) ;
if ( modelRefSchema != null && extRefSchema != null ) {
closeReferenceSchemaIntegration ( ) ;
gui = new SchemaMappingGui ( ) ;
schemaMapping = gui ;
jPanelReferenceSchemaIntegrationStub . add ( " , gui ) ;
if ( model . get_target ( ) )
gui . start ( extRefSchema , modelRefSchema ) ;
else
gui . start ( modelRefSchema , extRefSchema ) ;
validate ( ) ;
repaint ( ) ;
}
}
private void closeReferenceSchemaIntegration ( ) {
if ( schemaMapping != null ) {
schemaMapping . end ( ) ;
jPanelReferenceSchemaEditor . remove ( schemaMapping ) ;
}
logger . info ( " ) ;
}
private void generateTranslatorToTargetModelTemplate ( ) throws SQLException ,
SdfDefinitionException , TranslatorTemplateConstructionException ,
RecognitionException , IOException {
Module source = null , target = null ;
ModuleDef sourceSchema = null , targetSchema = null ;
Set < Similarity > sims ;
FormattingWriter signaturesWriter , equationsWriter ;
TranslatorTemplateConstructor constructor ;
TextFile signatures , equations ;
DefaultListModel listModel ;
if ( model . get_target ( ) ) {
target = this . createSdfForModelSyntax ( ) ;
targetSchema = model . get_refSchema ( ) ;
if ( model . get_refinedExtension ( ) == null )
logger . info ( " ) ;
else {
source = SdfForModelSyntaxCreator . createSdf ( model . get_refinedExtension ( ) ) ;
sourceSchema = model . get_refinedExtension ( ) . get_refSchema ( ) ;
}
} else {
source = this . createSdfForModelSyntax ( ) ;
sourceSchema = model . get_refSchema ( ) ;
if ( model . get_refinedExtension ( ) == null )
logger . info ( " ) ;
else {
target = SdfForModelSyntaxCreator . createSdf ( model . get_refinedExtension ( ) ) ;
targetSchema = model . get_refinedExtension ( ) . get_refSchema ( ) ;
}
}
sims = ( new SimilarityCreator ( sourceSchema , targetSchema ) ) . createSimilarities ( ) ;
signaturesWriter = new DefaultFormattingWriter ( new StringWriter ( ) , <num> , " , " ) ;
equationsWriter = new DefaultFormattingWriter ( new StringWriter ( ) , <num> , " , " ) ;
constructor = new TranslatorTemplateConstructor ( source , target , sims , signaturesWriter , equationsWriter ) ;
constructor . writeTranslatorTemplate ( ) ;
signaturesWriter . flush ( ) ;
equationsWriter . flush ( ) ;
signatures = new TextFile ( model . get_name ( ) + " , signaturesWriter . toString ( ) ) ;
equations = new TextFile ( model . get_name ( ) + " , equationsWriter . toString ( ) ) ;
listModel = ( DefaultListModel ) jListTranslator2TMFiles . getModel ( ) ;
listModel . addElement ( signatures ) ;
listModel . addElement ( equations ) ;
}
private void updateTranslatorToTargetModel ( ) throws SQLException {
model . <unk> ( jTextAreaVerbalRules . getText ( ) ) ;
jListTranslator2TMFiles . loadFilesToRepository ( db , model . get_transTargetModel ( ) ) ;
}
private void clearSampleCard ( ) {
jTextFieldSampleTitle . setText ( " ) ;
jTextAreaSampleSpec . setText ( " ) ;
jTextAreaSampleTargetSpec . setText ( " ) ;
jCheckBoxSampleVerification . setSelected ( false ) ;
( ( DefaultListModel ) jListSourceSampleAmnSemanticsNonRecFiles . getModel ( ) ) . removeAllElements ( ) ;
jTextAreaSourceSampleAmnSemanticsNonRec . setText ( " ) ;
( ( DefaultListModel ) jListSourceSampleAmnSemanticsRecFiles . getModel ( ) ) . removeAllElements ( ) ;
jTextAreaSourceSampleAmnSemanticsRec . setText ( " ) ;
( ( DefaultListModel ) jListTargetSampleAmnSemanticsNonRecFiles . getModel ( ) ) . removeAllElements ( ) ;
jTextAreaTargetSampleAmnSemanticsNonRec . setText ( " ) ;
( ( DefaultListModel ) jListTargetSampleAmnSemanticsRecFiles . getModel ( ) ) . removeAllElements ( ) ;
jTextAreaTargetSampleAmnSemanticsRec . setText ( " ) ;
jTextAreaRefinementProof . setText ( " ) ;
for ( int i = <num> ; i <= <num> ; i ++ ) {
jTabbedPaneSample . setEnabledAt ( i , false ) ;
}
}
private void showExistingSamples ( ) throws SQLException {
for ( Object s : model . get_samples ( ) ) {
SampleRegDef sample = ( SampleRegDef ) s ;
( ( DefaultListModel ) jListExistingSamples . getModel ( ) ) . addElement ( sample ) ;
}
}
private void removeSelectedSample ( ) throws SQLException {
if ( ! jListExistingSamples . isSelectionEmpty ( ) ) {
SampleRegDef selection = ( SampleRegDef ) jListExistingSamples . getSelectedValue ( ) ;
( ( DefaultListModel ) jListExistingSamples . getModel ( ) ) . remove ( jListExistingSamples . getSelectedIndex ( ) ) ;
clearSampleCard ( ) ;
RepositoryCleaner . delete ( selection ) ;
sample = null ;
}
}
private void registerNewSample ( ) throws SQLException {
SampleRegDef newSample ;
clearSampleCard ( ) ;
jListExistingSamples . clearSelection ( ) ;
newSample = db . <unk> ( ) ;
newSample . set_name ( " ) ;
model . get_samples ( ) . add ( newSample ) ;
( ( DefaultListModel ) jListExistingSamples . getModel ( ) ) . addElement ( newSample ) ;
jTextFieldSampleTitle . setText ( " ) ;
sample = newSample ;
}
private void openSelectedSample ( ) throws SQLException {
if ( jListExistingSamples . isSelectionEmpty ( ) ) return ;
SampleRegDef selected = ( SampleRegDef ) jListExistingSamples . getSelectedValue ( ) ;
sample = selected ;
clearSampleCard ( ) ;
jTextFieldSampleTitle . setText ( selected . get_name ( ) ) ;
jTextAreaSampleSpec . setText ( selected . <unk> ( ) ) ;
jTextAreaSampleTargetSpec . setText ( selected . get_targetSpec ( ) ) ;
jCheckBoxSampleVerification . setSelected ( selected . <unk> ( ) ) ;
jListSourceSampleAmnSemanticsNonRecFiles . fillFromFileContainerSet ( selected . get_amnSpec ( ) ) ;
jListSourceSampleAmnSemanticsRecFiles . fillFromFileContainerSet ( selected . get_recAmnSpec ( ) ) ;
jListTargetSampleAmnSemanticsNonRecFiles . fillFromFileContainerSet ( selected . get_targetAmnSpec ( ) ) ;
jListTargetSampleAmnSemanticsRecFiles . fillFromFileContainerSet ( selected . get_recTargetAmnSpec ( ) ) ;
jTextAreaRefinementProof . setText ( selected . <unk> ( ) ) ;
enableSampleTabs ( ) ;
}
private void enableSampleTabs ( ) {
if ( jTextAreaSampleSpec . getText ( ) . trim ( ) . compareTo ( " ) != <num> )
jTabbedPaneSample . setEnabledAt ( <num> , true ) ;
if ( jTextAreaSampleTargetSpec . getText ( ) . trim ( ) . compareTo ( " ) != <num> )
jTabbedPaneSample . setEnabledAt ( <num> , true ) ;
if ( jListSourceSampleAmnSemanticsRecFiles . getModel ( ) . getSize ( ) != <num> &&
jListTargetSampleAmnSemanticsRecFiles . getModel ( ) . getSize ( ) != <num> ) {
jTabbedPaneSample . setEnabledAt ( <num> , true ) ;
}
}
private void updateSampleCard ( ) throws SQLException {
if ( sample == null ) return ;
sample . set_name ( jTextFieldSampleTitle . getText ( ) ) ;
sample . <unk> ( jTextAreaSampleSpec . getText ( ) ) ;
sample . <unk> ( jTextAreaSampleTargetSpec . getText ( ) ) ;
sample . <unk> ( jCheckBoxSampleVerification . isSelected ( ) ) ;
jListSourceSampleAmnSemanticsNonRecFiles . loadFilesToRepository ( db , sample . get_amnSpec ( ) ) ;
jListSourceSampleAmnSemanticsRecFiles . loadFilesToRepository ( db , sample . get_recAmnSpec ( ) ) ;
jListTargetSampleAmnSemanticsNonRecFiles . loadFilesToRepository ( db , sample . get_targetAmnSpec ( ) ) ;
jListTargetSampleAmnSemanticsRecFiles . loadFilesToRepository ( db , sample . get_recTargetAmnSpec ( ) ) ;
sample . <unk> ( jTextAreaRefinementProof . getText ( ) ) ;
enableSampleTabs ( ) ;
logger . info ( " ) ;
}
private void translateSampleSourceSpec2Amn ( ) throws SQLException , IOException {
StringReader reader = null ;
Set < TextFile > files = null ;
if ( model . get_target ( ) ) {
reader = new StringReader ( sample . get_targetSpec ( ) ) ;
files = translateSampleSpec2Amn ( reader ) ;
if ( files . size ( ) != <num> ) {
logger . info ( " ) ;
jListSourceSampleAmnSemanticsNonRecFiles . fillFromTextFileSet ( files ) ;
jListSourceSampleAmnSemanticsRecFiles . fillFromTextFileSet ( files ) ;
} else
logger . info ( " ) ;
}
}
private void translateSampleTargetSpec2Amn ( ) throws SQLException , IOException {
StringReader reader = null ;
Set < TextFile > files = null ;
if ( ! model . get_target ( ) ) {
reader = new StringReader ( sample . get_targetSpec ( ) ) ;
files = translateSampleSpec2Amn ( reader ) ;
if ( files . size ( ) != <num> ) {
logger . info ( " ) ;
jListTargetSampleAmnSemanticsNonRecFiles . fillFromTextFileSet ( files ) ;
jListTargetSampleAmnSemanticsRecFiles . fillFromTextFileSet ( files ) ;
} else
logger . info ( " ) ;
}
}
private Set < TextFile > translateSampleSpec2Amn ( Reader reader ) throws SQLException , IOException {
ModuleDef module = null ;
Set < TextFile > result = null ;
module = ( new SynthesisLoader ( ) ) . loadFile ( db , reader , false ) ;
if ( module != null ) {
logger . info ( " + module . get_name ( ) + " ) ;
} else {
logger . info ( " ) ;
return null ;
}
Set types = module . get_containedTypes ( ) ;
TypeDef theType = null ;
if ( types . size ( ) == <num> ) {
logger . info ( " ) ;
} else if ( types . size ( ) == <num> ) {
theType = ( TypeDef ) types . iterator ( ) . next ( ) ;
} else {
theType = ( TypeDef ) ElementChooserDialog . showElementChooserDialog ( " , types ) ;
}
if ( theType == null ) {
logger . info ( " ) ;
Module2BTranslator translator = new Module2BTranslator ( ) ;
translator . translate ( module ) ;
translator . <unk> ( ) ;
translator . <unk> ( ) ;
result = translator . getResultedMachines ( ) ;
} else
if ( theType instanceof ADTDef ) {
Module2BTranslator t = new Module2BTranslator ( ) ;
t . translate ( ( ADTDef ) theType ) ;
result = t . getResultedMachines ( ) ;
} else {
logger . info ( " + theType . get_name ( ) + " ) ;
}
RepositoryCleaner . delete ( module ) ;
return result ;
}
}
class ModelRegistrar_jButtonBrowseSchemaModule_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonBrowseSchemaModule_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonBrowseSchemaModule_actionPerformed ( e ) ;
}
}
class ModelRegistrar_this_windowAdapter extends WindowAdapter {
private ModelRegistrar adaptee ;
ModelRegistrar_this_windowAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void windowClosing ( WindowEvent e ) {
adaptee . this_windowClosing ( e ) ;
}
}
class ModelRegistrar_jButtonTranslate2AmnSampleSourceSpec_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonTranslate2AmnSampleSourceSpec_actionAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonTranslate2AmnSampleSourceSpec_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonExploreExtension_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonExploreExtension_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonExploreExtension_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonRefinementProofBrowse_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonRefinementProofBrowse_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonRefinementProofBrowse_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonTargetSampleAmnSemanticsRecDelete_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonTargetSampleAmnSemanticsRecDelete_actionAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonTargetSampleAmnSemanticsRecDelete_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonTargetSampleAmnSemanticsRecExport_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonTargetSampleAmnSemanticsRecExport_actionAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonTargetSampleAmnSemanticsRecExport_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonTargetSampleAmnSemanticsRecBrowse_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonTargetSampleAmnSemanticsRecBrowse_actionAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonTargetSampleAmnSemanticsRecBrowse_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonSampleAmnSemanticsRecDelete_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonSampleAmnSemanticsRecDelete_actionAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonSampleAmnSemanticsRecDelete_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonSampleAmnSemanticsRecExport_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonSampleAmnSemanticsRecExport_actionAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonSampleAmnSemanticsRecExport_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonSampleAmnSemanticsRecBrowse_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonSampleAmnSemanticsRecBrowse_actionAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonSampleAmnSemanticsRecBrowse_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonSampleAmnSemanticsNonRecDelete_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonSampleAmnSemanticsNonRecDelete_actionAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonSampleAmnSemanticsNonRecDelete_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonSampleAmnSemanticsNonRecBrowse_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonSampleAmnSemanticsNonRecBrowse_actionAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonSampleAmnSemanticsNonRecBrowse_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonUpdateSampleRegCard_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonUpdateSampleRegCard_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonUpdateSampleRegCard_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jCheckBoxSampleVerification_mouseAdapter extends
MouseAdapter {
private ModelRegistrar adaptee ;
ModelRegistrar_jCheckBoxSampleVerification_mouseAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void mouseClicked ( MouseEvent e ) {
adaptee . jCheckBoxSampleVerification_mouseClicked ( e ) ;
}
}
class ModelRegistrar_jButtonTranslateSampleTargetSpec2Amn_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonTranslateSampleTargetSpec2Amn_actionAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonTranslateSampleTargetSpec2Amn_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonBrowseSampleTargetSpec_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonBrowseSampleTargetSpec_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonBrowseSampleTargetSpec_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonExportSampleSpec_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonExportSampleSpec_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonExportSampleSpec_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonBrowseSampleSpec_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonBrowseSampleSpec_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonBrowseSampleSpec_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jListTargetSampleAmnSemanticsNonRecFiles_mouseAdapter extends
MouseAdapter {
private ModelRegistrar adaptee ;
ModelRegistrar_jListTargetSampleAmnSemanticsNonRecFiles_mouseAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void mouseClicked ( MouseEvent e ) {
adaptee . jListTargetSampleAmnSemanticsNonRecFiles_mouseClicked ( e ) ;
}
}
class ModelRegistrar_jListTargetSampleAmnSemanticsRecFiles_mouseAdapter extends
MouseAdapter {
private ModelRegistrar adaptee ;
ModelRegistrar_jListTargetSampleAmnSemanticsRecFiles_mouseAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void mouseClicked ( MouseEvent e ) {
adaptee . jListTargetSampleAmnSemanticsRecFiles_mouseClicked ( e ) ;
}
}
class ModelRegistrar_jListSampleAmnSemanticsNonRecFiles_mouseAdapter extends
MouseAdapter {
private ModelRegistrar adaptee ;
ModelRegistrar_jListSampleAmnSemanticsNonRecFiles_mouseAdapter (
ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void mouseClicked ( MouseEvent e ) {
adaptee . jListSampleAmnSemanticsNonRecFiles_mouseClicked ( e ) ;
}
}
class ModelRegistrar_jListSampleAmnSemanticsRecFiles_mouseAdapter extends
MouseAdapter {
private ModelRegistrar adaptee ;
ModelRegistrar_jListSampleAmnSemanticsRecFiles_mouseAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void mouseClicked ( MouseEvent e ) {
adaptee . jListSampleAmnSemanticsRecFiles_mouseClicked ( e ) ;
}
}
class ModelRegistrar_jListExistingSamples_mouseAdapter extends MouseAdapter {
private ModelRegistrar adaptee ;
ModelRegistrar_jListExistingSamples_mouseAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void mouseClicked ( MouseEvent e ) {
adaptee . jListExistingSamples_mouseClicked ( e ) ;
}
}
class ModelRegistrar_jButtonDeleteSample_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonDeleteSample_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonDeleteSample_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonNewSample_actionAdapter implements ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonNewSample_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonNewSample_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jListTranslator2CMFiles_mouseAdapter extends MouseAdapter {
private ModelRegistrar adaptee ;
ModelRegistrar_jListTranslator2CMFiles_mouseAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void mouseClicked ( MouseEvent e ) {
adaptee . jListTranslator2CMFiles_mouseClicked ( e ) ;
}
}
class ModelRegistrar_jButtonUpdateTranslator_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonUpdateTranslator_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonUpdateTranslator_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonExportTranslator_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonExportTranslator_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonExportTranslator_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonDeleteTranslator_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonDeleteTranslator_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonDeleteTranslator_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonGenerateTemplate_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonGenerateTemplate_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonGenerateTemplate_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonBrowseTranslator_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonBrowseTranslator_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonBrowseTranslator_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonExportAmnTranslatorFile_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonExportAmnTranslatorFile_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonExportAmnTranslatorFile_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonExportModelSyntaxFile_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonExportModelSyntaxFile_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonExportModelSyntaxFile_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jListTranslator2AmnFiles_mouseAdapter extends MouseAdapter {
private ModelRegistrar adaptee ;
ModelRegistrar_jListTranslator2AmnFiles_mouseAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void mousePressed ( MouseEvent e ) {
adaptee . jListTranslator2AmnFiles_mousePressed ( e ) ;
}
}
class ModelRegistrar_jButtonVODUpdate_actionAdapter implements ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonVODUpdate_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonVODUpdate_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonVODEdit_actionAdapter implements ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonVODEdit_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonVODEdit_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonCreateReferenceSchemaTemplate_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonCreateReferenceSchemaTemplate_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonCreateReferenceSchemaTemplate_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonUpdateAmnSemantics_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonUpdateAmnSemantics_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonUpdateAmnSemantics_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonDeleteAmnTranslatorFile_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonDeleteAmnTranslatorFile_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonDeleteAmnTranslatorFile_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonBrowseAmnTranslatorFile_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonBrowseAmnTranslatorFile_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonBrowseAmnTranslatorFile_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jListModelSyntaxFiles_mouseAdapter extends MouseAdapter {
private ModelRegistrar adaptee ;
ModelRegistrar_jListModelSyntaxFiles_mouseAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void mouseClicked ( MouseEvent e ) {
adaptee . jListModelSyntaxFiles_mouseClicked ( e ) ;
}
}
class ModelRegistrar_jButtonUpdateModelSyntax_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonUpdateModelSyntax_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonUpdateModelSyntax_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonDeleteModelSyntaxFile_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonDeleteModelSyntaxFile_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonDeleteModelSyntaxFile_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonBrowseModelSyntaxFile_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonBrowseModelSyntaxFile_actionAdapter ( ModelRegistrar
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonBrowseModelSyntaxFile_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonDeleteCard_actionAdapter implements ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonDeleteCard_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonDeleteCard_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonUpdateRegCard_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonUpdateRegCard_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonUpdateRegCard_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonBrowseSemantics_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonBrowseSemantics_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonBrowseSemantics_actionPerformed ( e ) ;
}
}
class ModelRegistrar_jButtonBrowseSyntaxLink_actionAdapter implements
ActionListener {
private ModelRegistrar adaptee ;
ModelRegistrar_jButtonBrowseSyntaxLink_actionAdapter ( ModelRegistrar adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonBrowseSyntaxLink_actionPerformed ( e ) ;
}
}
package unifier . util ;
import javax . swing . JDialog ;
import java . awt . GridBagLayout ;
import javax . swing . JScrollPane ;
import java . awt . * ;
import javax . swing . JButton ;
import javax . swing . JPanel ;
import javax . swing . JList ;
import java . util . Set ;
import meta . ElementDef ;
import javax . swing . DefaultListModel ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import javax . swing . ListSelectionModel ;
public class ElementChooserDialog extends JDialog {
private ElementChooserDialog ( ) {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
}
private void jbInit ( ) throws Exception {
this . setModal ( true ) ;
this . setTitle ( " ) ;
this . getContentPane ( ) . setLayout ( gridBagLayoutECD ) ;
jButtonOK . setToolTipText ( " ) ;
jButtonOK . addActionListener ( new
ElementChooserDialog_jButtonOK_actionAdapter ( this ) ) ;
jListElements . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ;
jScrollPaneElements . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jButtonCancel . setToolTipText ( " ) ;
jButtonCancel . setText ( " ) ;
jButtonCancel . addActionListener ( new
ElementChooserDialog_jButtonCancel_actionAdapter ( this ) ) ;
this . getContentPane ( ) . add ( jScrollPaneElements ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneElements . getViewport ( ) . add ( jListElements ) ;
jButtonOK . setText ( " ) ;
jPanelButtons . setLayout ( flowLayoutButtons ) ;
this . getContentPane ( ) . add ( jPanelButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelButtons . add ( jButtonOK ) ;
jPanelButtons . add ( jButtonCancel ) ;
jListElements . setModel ( new DefaultListModel ( ) ) ;
jListElements . setCellRenderer ( new ElementDefCellRenderer ( ) ) ;
}
GridBagLayout gridBagLayoutECD = new GridBagLayout ( ) ;
JScrollPane jScrollPaneElements = new JScrollPane ( ) ;
JPanel jPanelButtons = new JPanel ( ) ;
FlowLayout flowLayoutButtons = new FlowLayout ( ) ;
JButton jButtonOK = new JButton ( ) ;
JList jListElements = new JList ( ) ;
JButton jButtonCancel = new JButton ( ) ;
private ElementChooserDialog ( Set elements ) {
this ( ) ;
if ( elements . size ( ) == <num> ) this . dispose ( ) ;
for ( Object elm : elements ) {
if ( elm instanceof ElementDef ) ( ( DefaultListModel ) jListElements . getModel ( ) ) . addElement ( elm ) ;
}
jListElements . setSelectedIndex ( <num> ) ;
}
public static ElementDef showElementChooserDialog ( String title , Set elements ) {
ElementChooserDialog dialog = new ElementChooserDialog ( elements ) ;
dialog . setTitle ( title ) ;
dialog . pack ( ) ;
dialog . validate ( ) ;
dialog . setVisible ( true ) ;
return dialog . getSelected ( ) ;
}
private ElementDef selected ;
private ElementDef getSelected ( ) {
return selected ;
}
public void jButtonOK_actionPerformed ( ActionEvent e ) {
if ( ! jListElements . isSelectionEmpty ( ) ) {
selected = ( ElementDef ) jListElements . getSelectedValue ( ) ;
this . dispose ( ) ;
}
}
public void jButtonCancel_actionPerformed ( ActionEvent e ) {
selected = null ;
this . dispose ( ) ;
}
}
class ElementChooserDialog_jButtonCancel_actionAdapter implements
ActionListener {
private ElementChooserDialog adaptee ;
ElementChooserDialog_jButtonCancel_actionAdapter ( ElementChooserDialog
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonCancel_actionPerformed ( e ) ;
}
}
class ElementChooserDialog_jButtonOK_actionAdapter implements ActionListener {
private ElementChooserDialog adaptee ;
ElementChooserDialog_jButtonOK_actionAdapter ( ElementChooserDialog adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonOK_actionPerformed ( e ) ;
}
}
package unifier . util ;
import javax . swing . JTextArea ;
import javax . swing . filechooser . FileFilter ;
import javax . swing . DefaultListModel ;
import java . io . File ;
import java . io . BufferedReader ;
import javax . swing . JFileChooser ;
import java . io . FileReader ;
import java . io . FileNotFoundException ;
import java . io . IOException ;
import java . io . FileWriter ;
import java . io . Writer ;
public class FileJTextArea extends JTextArea {
public void importTextFromFile ( String extension , String description ) throws FileNotFoundException , IOException {
FileFilter ff ;
JFileChooser chooser = new JFileChooser ( ) ;
int retValue ;
ff = new ExtensionChoosableFileFilter ( extension , description ) ;
chooser . setCurrentDirectory ( new File ( " ) ) ;
chooser . addChoosableFileFilter ( ff ) ;
chooser . setFileFilter ( ff ) ;
retValue = chooser . showOpenDialog ( this ) ;
if ( retValue == JFileChooser . APPROVE_OPTION ) {
File theFile = chooser . getSelectedFile ( ) ;
if ( theFile != null && ! theFile . isDirectory ( ) ) {
BufferedReader reader = new BufferedReader ( new FileReader ( theFile ) ) ;
String line ;
String content ;
line = reader . readLine ( ) ;
content = line ;
line = reader . readLine ( ) ;
while ( line != null ) {
content += " + line ;
line = reader . readLine ( ) ;
}
this . setText ( content ) ;
}
}
}
public void exportTextToFile ( String extension , String description ) throws IOException {
FileFilter ff ;
JFileChooser chooser = new JFileChooser ( ) ;
int retValue ;
ff = new ExtensionChoosableFileFilter ( extension , description ) ;
chooser . setCurrentDirectory ( new File ( " ) ) ;
chooser . addChoosableFileFilter ( ff ) ;
chooser . setFileFilter ( ff ) ;
retValue = chooser . showSaveDialog ( this ) ;
if ( retValue == JFileChooser . APPROVE_OPTION ) {
File theFile = chooser . getSelectedFile ( ) ;
if ( theFile != null && ! theFile . isDirectory ( ) ) {
Writer writer = new FileWriter ( theFile ) ;
writer . write ( this . getText ( ) ) ;
writer . flush ( ) ;
writer . close ( ) ;
}
}
}
}
package unifier . asfsdf ;
public abstract class Named {
protected String name = " ;
public String getName ( ) {
return name ;
}
public abstract Named setName ( String name ) ;
}
package unifier ;
public class SDF2RSException extends Exception {
public SDF2RSException ( String message ) {
super ( message ) ;
}
}
package unifier ;
public class TranslatorTemplateConstructionException extends Exception {
public TranslatorTemplateConstructionException ( String message ) {
super ( message ) ;
}
}
package unifier . util ;
import java . awt . event . ActionEvent ;
import javax . swing . DefaultListModel ;
import javax . swing . JPanel ;
import meta . ElementDef ;
import java . awt . Insets ;
import java . util . Set ;
import java . awt . event . ActionListener ;
import javax . swing . JButton ;
import java . awt . Dimension ;
import java . awt . GridBagConstraints ;
import javax . swing . JList ;
import java . awt . FlowLayout ;
import javax . swing . ListSelectionModel ;
import javax . swing . JScrollPane ;
import java . awt . GridBagLayout ;
import javax . swing . DefaultListCellRenderer ;
import javax . swing . JDialog ;
import java . util . HashSet ;
import java . awt . event . WindowEvent ;
import java . awt . event . WindowAdapter ;
public class ChooserDialog < E > extends JDialog {
private ChooserDialog ( ) {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
}
private void jbInit ( ) throws Exception {
this . setModal ( true ) ;
this . setTitle ( " ) ;
this . getContentPane ( ) . setLayout ( gridBagLayoutECD ) ;
jButtonOK . setToolTipText ( " ) ;
jButtonOK . addActionListener ( new
ChooserDialog_jButtonOK_actionAdapter ( this ) ) ;
jListElements . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ;
jScrollPaneElements . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jButtonCancel . setToolTipText ( " ) ;
jButtonCancel . setText ( " ) ;
jButtonCancel . addActionListener ( new
ChooserDialog_jButtonCancel_actionAdapter ( this ) ) ;
this . getContentPane ( ) . add ( jScrollPaneElements ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneElements . getViewport ( ) . add ( jListElements ) ;
jButtonOK . setText ( " ) ;
jPanelButtons . setLayout ( flowLayoutButtons ) ;
this . getContentPane ( ) . add ( jPanelButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelButtons . add ( jButtonOK ) ;
jPanelButtons . add ( jButtonCancel ) ;
jListElements . setModel ( new DefaultListModel ( ) ) ;
}
GridBagLayout gridBagLayoutECD = new GridBagLayout ( ) ;
JScrollPane jScrollPaneElements = new JScrollPane ( ) ;
JPanel jPanelButtons = new JPanel ( ) ;
FlowLayout flowLayoutButtons = new FlowLayout ( ) ;
JButton jButtonOK = new JButton ( ) ;
JList jListElements = new JList ( ) ;
JButton jButtonCancel = new JButton ( ) ;
private ChooserDialog (
String title ,
String okTooltip ,
String cancelTooltip ,
int selectionMode ,
Set < E > elements ,
DefaultListCellRenderer renderer ) {
this ( ) ;
this . setTitle ( title ) ;
jButtonOK . setToolTipText ( okTooltip ) ;
jButtonCancel . setToolTipText ( cancelTooltip ) ;
jListElements . setSelectionMode ( selectionMode ) ;
jListElements . setCellRenderer ( renderer ) ;
if ( elements . size ( ) == <num> ) this . dispose ( ) ;
for ( Object elm : elements ) {
( ( DefaultListModel ) jListElements . getModel ( ) ) . addElement ( elm ) ;
}
jListElements . setSelectedIndex ( <num> ) ;
}
public static < E > Set < E > showChooserDialog (
String title ,
String okTooltip ,
String cancelTooltip ,
int selectionMode ,
Set < E > elements ,
DefaultListCellRenderer renderer
) {
ChooserDialog dialog = new ChooserDialog < E > ( title , okTooltip , cancelTooltip , selectionMode , elements , renderer ) ;
dialog . setTitle ( title ) ;
dialog . pack ( ) ;
dialog . validate ( ) ;
dialog . setVisible ( true ) ;
return dialog . getSelected ( ) ;
}
private Set < E > selected = new HashSet < E > ( ) ;
private Set < E > getSelected ( ) {
return selected ;
}
public void jButtonOK_actionPerformed ( ActionEvent e ) {
if ( ! jListElements . isSelectionEmpty ( ) ) {
E [ ] arr ;
arr = ( E [ ] ) jListElements . getSelectedValues ( ) ;
selected . clear ( ) ;
for ( int i = <num> ; i <= ( arr . length  <num> ) ; i ++ ) selected . add ( arr [ i ] ) ;
this . dispose ( ) ;
}
}
public void jButtonCancel_actionPerformed ( ActionEvent e ) {
selected . clear ( ) ;
this . dispose ( ) ;
}
}
class ChooserDialog_jButtonCancel_actionAdapter implements
ActionListener {
private ChooserDialog adaptee ;
ChooserDialog_jButtonCancel_actionAdapter ( ChooserDialog adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonCancel_actionPerformed ( e ) ;
}
}
class ChooserDialog_jButtonOK_actionAdapter implements ActionListener {
private ChooserDialog adaptee ;
ChooserDialog_jButtonOK_actionAdapter ( ChooserDialog adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonOK_actionPerformed ( e ) ;
}
}
package unifier . util ;
import javax . swing . DefaultListCellRenderer ;
import javax . swing . JList ;
import meta . ModelRegDef ;
import java . awt . Component ;
import java . sql . SQLException ;
import meta . TypeDef ;
import meta . ElementDef ;
public class ElementDefCellRenderer extends DefaultListCellRenderer {
public Component getListCellRendererComponent (
JList list ,
Object value ,
int index ,
boolean iss ,
boolean chf )
{
if ( value instanceof ElementDef ) {
ElementDef elm = ( ElementDef ) value ;
String elmName = " ;
try {
elmName = elm . get_name ( ) ;
} catch ( SQLException ex ) {
}
super . getListCellRendererComponent ( list , elmName , index , iss , chf ) ;
}
else {
super . getListCellRendererComponent ( list , value , index , iss , chf ) ;
}
return this ;
}
}
package unifier . rsm ;
import unifier . util . FormattingWriter ;
public abstract class Element {
protected String name = " ;
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
public abstract void specification ( FormattingWriter writer ) ;
}
package unifier ;
import javax . swing . JFrame ;
import javax . swing . JScrollPane ;
import java . awt . * ;
import javax . swing . JTextArea ;
public class LogFrame extends JFrame {
public LogFrame ( ) {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
}
private void jbInit ( ) throws Exception {
this . setTitle ( " ) ;
this . getContentPane ( ) . setLayout ( gridBagLayout1 ) ;
jTextAreaLog . setEditable ( false ) ;
this . getContentPane ( ) . add ( jScrollPaneLog ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneLog . getViewport ( ) . add ( jTextAreaLog ) ;
jTextAreaLog . setText ( " ) ;
jScrollPaneLog . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
}
JScrollPane jScrollPaneLog = new JScrollPane ( ) ;
GridBagLayout gridBagLayout1 = new GridBagLayout ( ) ;
JTextArea jTextAreaLog = new JTextArea ( ) ;
public JTextArea getLogTextArea ( ) {
return jTextAreaLog ;
}
public void <unk> ( String s ) {
jTextAreaLog . append ( s ) ;
}
}
package unifier . similarity ;
public class Association extends Element {
private String domain = " ;
private String range = " ;
private int maxCard = <num> ;
public Association ( String domain , String range , int maxCard ) {
this . domain = domain ;
this . range = range ;
this . maxCard = maxCard ;
}
public boolean isAssociation ( ) {
return true ;
}
public String getDomain ( ) {
return domain ;
}
public String getRange ( ) {
return range ;
}
public int getMaxCard ( ) {
return maxCard ;
}
public String toString ( ) {
return getName ( ) + " + domain + " + range + " ;
}
}
package unifier . asfsdf ;
import java . util . Map ;
public abstract class Sort extends Named {
public abstract boolean isTerminal ( ) ;
public abstract boolean isListSort ( ) throws SdfDefinitionException ;
public abstract boolean isEnumerationSort ( ) throws SdfDefinitionException ;
public abstract boolean isAlternativeSort ( ) throws SdfDefinitionException ;
public abstract boolean isDeclarationSort ( ) throws SdfDefinitionException ;
public abstract String toTerm ( ) throws SdfDefinitionException ;
public abstract Map < Variable , Integer > getVariableInstances ( ) throws SdfDefinitionException ;
public String getSignatureName ( ) {
return " + name ;
}
}
package unifier . rsm ;
import java . util . Set ;
import unifier . util . StringHelper ;
import java . util . Map ;
import java . util . HashMap ;
import unifier . util . FormattingWriter ;
import java . util . HashSet ;
public class ADT extends Type {
private Map < String , Attribute > attributes = new HashMap < String , Attribute > ( ) ;
private Set < ADT > supertypes = new HashSet < ADT > ( ) ;
public void addAttribute ( Attribute attribute ) throws ReferenceSchemaModelException {
if ( StringHelper . isNullEmptyOrBlank ( attribute . getName ( ) ) ) {
throw new ReferenceSchemaModelException ( " ) ;
} else {
attributes . put ( attribute . getName ( ) , attribute ) ;
}
}
public Set < String > getTypesNames ( ) {
return attributes . keySet ( ) ;
}
public Attribute getAttribute ( String attributeName ) {
return attributes . get ( attributeName ) ;
}
public void addSupertype ( ADT supertype ) {
supertypes . add ( supertype ) ;
}
public Set < ADT > <unk> ( ) {
Set < ADT > result = new HashSet < ADT > ( ) ;
result . addAll ( supertypes ) ;
return result ;
}
public void specification ( FormattingWriter writer ) {
writer . write ( " ) ; writer . write ( getName ( ) ) ; writer . write ( " ) ;
writer . write ( " ) ; writer . ln ( + <num> ) ;
if ( supertypes . size ( ) > <num> ) {
writer . write ( " ) ;
int i = <num> ;
for ( ADT sup : supertypes ) {
writer . write ( sup . getName ( ) ) ;
if ( i < supertypes . size ( )  <num> ) writer . write ( " ) ;
i ++ ;
}
writer . write ( " ) ;
writer . ln ( ) ; writer . ln ( ) ;
}
for ( String attName : attributes . keySet ( ) ) {
attributes . get ( attName ) . specification ( writer ) ;
writer . ln ( ) ;
}
writer . ln (  <num> ) ;
writer . write ( " ) ;
}
public boolean isADT ( ) {
return true ;
}
}
package unifier . similarity ;
public class Similarity {
private Element of ;
private Element to ;
public Similarity ( Element of , Element to ) {
this . of = of ;
this . to = to ;
}
public Element getOf ( ) {
return of ;
}
public Element getTo ( ) {
return to ;
}
public String toString ( ) {
return of + " + to ;
}
}
package unifier . util ;
import javax . swing . DefaultListCellRenderer ;
import javax . swing . JList ;
import meta . ModelRegDef ;
import java . awt . Component ;
import java . sql . SQLException ;
public class ModelRegDefCellRenderer extends DefaultListCellRenderer {
public Component getListCellRendererComponent (
JList list ,
Object value ,
int index ,
boolean iss ,
boolean chf )
{
if ( value instanceof ModelRegDef ) {
ModelRegDef model = ( ModelRegDef ) value ;
String modelName = " ;
try {
modelName = model . get_name ( ) ;
} catch ( SQLException ex ) {
}
super . getListCellRendererComponent ( list , modelName , index , iss , chf ) ;
}
else {
super . getListCellRendererComponent ( list , value , index , iss , chf ) ;
}
return this ;
}
}
package unifier . rsm ;
import unifier . util . FormattingWriter ;
public abstract class Class extends Element {
}
package unifier . asfsdf ;
import java . util . List ;
import unifier . util . StringHelper ;
import java . util . ArrayList ;
import java . util . Map ;
import unifier . TranslatorTemplateConstructionException ;
public class Signature extends Named {
private List < Declaration > params = new ArrayList < Declaration > ( ) ;
private Declaration returnSort ;
public Signature setName ( String name ) {
this . name = name ;
return this ;
}
public List < Declaration > getParams ( ) {
return params ;
}
public Signature addParam ( Declaration decl ) {
params . add ( decl ) ;
return this ;
}
public Declaration getReturnSort ( ) {
return returnSort ;
}
public Signature setReturnSort ( Declaration sort ) {
returnSort = sort ;
return this ;
}
}
package unifier . util ;
import javax . swing . JList ;
import javax . swing . DefaultListModel ;
import java . util . Set ;
import javax . swing . filechooser . FileFilter ;
import java . io . File ;
import java . io . BufferedReader ;
import javax . swing . JFileChooser ;
import meta . FileContainerDef ;
import java . io . FileReader ;
import java . io . FileNotFoundException ;
import java . io . IOException ;
import java . sql . SQLException ;
import meta . DB ;
import meta . Def ;
import java . io . Writer ;
import java . io . FileWriter ;
import javax . swing . text . JTextComponent ;
public class TextFileJList extends JList {
public TextFileJList ( ) {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
}
private JTextComponent textComponent ;
public TextFileJList ( JTextComponent textComponent ) {
super ( ) ;
this . setModel ( new DefaultListModel ( ) ) ;
this . setCellRenderer ( new TextFileCellRenderer ( ) ) ;
this . textComponent = textComponent ;
}
TextFile lastSelection ;
public void updateLastSelectedContent ( ) {
if ( textComponent == null || this . isSelectionEmpty ( ) ) return ;
if ( lastSelection != null ) lastSelection . setContent ( textComponent . getText ( ) ) ;
lastSelection = ( ( TextFile ) this . getSelectedValue ( ) ) ;
textComponent . setText ( lastSelection . getContent ( ) ) ;
}
public TextFile addFile ( String extension , String description ) throws
FileNotFoundException , IOException {
FileFilter ff ;
JFileChooser chooser = new JFileChooser ( ) ;
int retValue ;
TextFile textFile = new TextFile ( " , " ) ;
ff = new ExtensionChoosableFileFilter ( extension , description ) ;
chooser . setCurrentDirectory ( new File ( " ) ) ;
chooser . addChoosableFileFilter ( ff ) ;
chooser . setFileFilter ( ff ) ;
retValue = chooser . showOpenDialog ( this ) ;
if ( retValue == JFileChooser . APPROVE_OPTION ) {
File theFile = chooser . getSelectedFile ( ) ;
if ( theFile != null && ! theFile . isDirectory ( ) ) {
BufferedReader reader = new BufferedReader ( new FileReader ( theFile ) ) ;
String line ;
String content ;
textFile . setName ( theFile . getName ( ) ) ;
line = reader . readLine ( ) ;
content = line ;
line = reader . readLine ( ) ;
while ( line != null ) {
content += " + line ;
line = reader . readLine ( ) ;
}
textFile . setContent ( content ) ;
( ( DefaultListModel ) this . getModel ( ) ) . addElement ( textFile ) ;
}
}
return textFile ;
}
public void addFile ( TextFile file ) {
( ( DefaultListModel ) this . getModel ( ) ) . addElement ( file ) ;
}
public void exportSelectedFile ( String extension , String description ) throws
IOException {
if ( this . isSelectionEmpty ( ) ) return ;
TextFile selection = ( ( TextFile ) this . getSelectedValue ( ) ) ;
FileFilter ff ;
JFileChooser chooser = new JFileChooser ( ) ;
int retValue ;
selection . setContent ( textComponent . getText ( ) ) ;
ff = new ExtensionChoosableFileFilter ( extension , description ) ;
chooser . setCurrentDirectory ( new File ( " ) ) ;
chooser . addChoosableFileFilter ( ff ) ;
chooser . setFileFilter ( ff ) ;
retValue = chooser . showSaveDialog ( this ) ;
if ( retValue == JFileChooser . APPROVE_OPTION ) {
File theFile = chooser . getSelectedFile ( ) ;
if ( theFile != null && ! theFile . isDirectory ( ) ) {
Writer writer = new FileWriter ( theFile ) ;
writer . write ( selection . getContent ( ) ) ;
writer . flush ( ) ;
writer . close ( ) ;
}
}
}
public void removeSelectedFile ( ) {
if ( ! this . isSelectionEmpty ( ) ) {
TextFile selection = ( ( TextFile ) this . getSelectedValue ( ) ) ;
( ( DefaultListModel ) this . getModel ( ) ) . remove ( this . getSelectedIndex ( ) ) ;
if ( textComponent != null ) {
textComponent . setText ( " ) ;
}
}
}
public void fillFromFileContainerSet ( Set < FileContainerDef > files ) throws SQLException {
for ( Object fc : files ) {
if ( fc instanceof FileContainerDef ) {
FileContainerDef fileCont = ( FileContainerDef ) fc ;
TextFile textFile = new TextFile ( fileCont . get_name ( ) , fileCont . get_file ( ) ) ;
( ( DefaultListModel ) this . getModel ( ) ) . addElement ( textFile ) ;
}
}
}
public void fillFromTextFileSet ( Set < TextFile > files ) throws SQLException {
for ( TextFile f : files ) {
( ( DefaultListModel ) this . getModel ( ) ) . addElement ( f ) ;
}
}
public void loadFilesToRepository ( DB db , Set set ) throws SQLException {
DefaultListModel model = ( DefaultListModel ) this . getModel ( ) ;
for ( Object fc : set ) {
if ( fc instanceof Def ) {
( ( Def ) fc ) . delete ( ) ;
}
}
for ( int i = <num> ; i < model . getSize ( ) ; i ++ ) {
FileContainerDef fc = db . <unk> ( ) ;
fc . set_name ( ( ( TextFile ) model . get ( i ) ) . getName ( ) ) ;
fc . <unk> ( ( ( TextFile ) model . get ( i ) ) . getContent ( ) ) ;
set . add ( fc ) ;
}
}
private void jbInit ( ) throws Exception {
}
}
package unifier . asfsdf ;
import java . util . List ;
import java . util . ArrayList ;
import java . util . Set ;
public class Enumeration extends AbstractSortDef {
private List < String > elements = new ArrayList < String > ( ) ;
public List < String > getElements ( ) {
return elements ;
}
public Enumeration addElement ( String elm ) {
elements . add ( elm ) ;
return this ;
}
public Enumeration addElements ( Set < String > elms ) {
elements . addAll ( elms ) ;
return this ;
}
public boolean isAlternative ( ) {
return false ;
}
public boolean isDeclaration ( ) {
return false ;
}
public boolean isEnumeration ( ) {
return true ;
}
public boolean isList ( ) {
return false ;
}
}
package unifier . util ;
import java . util . regex . Pattern ;
import java . util . regex . Matcher ;
public class StringHelper {
public static String <unk> ( String s ) {
if ( s == null ) return s ;
String result = s ;
int length = result . length ( ) ;
if ( length != <num> ) {
result = result . substring ( <num> , length  <num> ) ;
}
return result ;
}
public static boolean isNullEmptyOrBlank ( String s ) {
if ( s == null || s . trim ( ) . compareTo ( " ) == <num> ) {
return true ;
} else {
return false ;
}
}
public static String toQuotation ( String s ) {
if ( s == null ) return s ;
if ( s . charAt ( <num> ) == \"' && s . charAt ( s . length ( )  <num> ) == \"' ) {
return s ;
} else {
return " + s + " ;
}
}
public static String getLastComponentOfPath ( String path ) {
if ( isNullEmptyOrBlank ( path ) ) return path ;
int length = path . length ( ) ;
for ( int i = length  <num> ; i >= <num> ; i  ) {
if ( path . charAt ( i ) == /' ) {
return path . substring ( i + <num> , length ) ;
}
}
return path ;
}
public static boolean isIdentifier ( String s ) {
boolean result = false ;
Pattern p = Pattern . compile ( " ) ;
Matcher m = p . matcher ( s ) ;
result = m . matches ( ) ;
return result ;
}
}
package unifier . rsm ;
import java . util . Set ;
import java . util . HashSet ;
import unifier . util . FormattingWriter ;
public class Attribute extends Element {
private Type type = null ;
private Set < AssociationMetaclass > categories = new HashSet < AssociationMetaclass > ( ) ;
public Attribute ( ) {
}
public Attribute ( String name , Type type , AssociationMetaclass category ) {
this . name = name ;
this . type = type ;
this . addCategory ( category ) ;
}
public Type getType ( ) {
return type ;
}
public void setType ( Type type ) {
this . type = type ;
}
public Set < AssociationMetaclass > getCategories ( ) {
Set < AssociationMetaclass > result = new HashSet < AssociationMetaclass > ( ) ;
result . addAll ( categories ) ;
return result ;
}
public void addCategory ( AssociationMetaclass metaclass ) {
categories . add ( metaclass ) ;
}
public void specification ( FormattingWriter writer ) {
writer . write ( getName ( ) + " + type . getDesignator ( ) + " ) ;
if ( categories . size ( ) > <num> ) {
writer . ln ( + <num> ) ;
writer . write ( " ) ;
writer . ln ( + <num> ) ;
writer . write ( " ) ;
int i = <num> ;
for ( AssociationMetaclass am : categories ) {
writer . write ( am . getName ( ) ) ;
if ( i < categories . size ( )  <num> ) writer . write ( " ) ;
}
writer . write ( " ) ;
writer . ln (  <num> ) ;
writer . write ( " ) ;
writer . ln (  <num> ) ;
}
}
}
package unifier . similarity ;
import meta . ModuleDef ;
import java . util . Set ;
import java . util . HashSet ;
import java . util . logging . Logger ;
import meta . TypeDef ;
import java . sql . SQLException ;
import meta . ADTDef ;
import meta . RelevanceDef ;
import meta . ElementDef ;
import meta . AttributeDef ;
import meta . FrameDef ;
import meta . CollectionDef ;
public class SimilarityCreator {
public SimilarityCreator ( ModuleDef source , ModuleDef target ) {
this . source = source ;
this . target = target ;
}
private ModuleDef source ;
private ModuleDef target ;
private Logger logger = Logger . getLogger ( " ) ;
private Set < Similarity > sims = new HashSet < Similarity > ( ) ;
public Set < Similarity > createSimilarities ( ) throws SQLException {
sims . clear ( ) ;
if ( source == null || target == null ) {
logger . info ( " ) ;
return sims ;
}
for ( Object t : source . get_containedTypes ( ) ) {
if ( ! ( t instanceof ADTDef ) ) continue ;
createAdtSimilarities ( ( ADTDef ) t ) ;
}
return sims ;
}
private void createAdtSimilarities ( ADTDef adt ) throws SQLException {
for ( Object r : adt . get_relevances ( ) ) {
RelevanceDef relev = ( RelevanceDef ) r ;
ElementDef elm = null ;
Similarity sim = null ;
elm = relev . get_relevant ( ) ;
if ( relev . get_rejected ( ) ) continue ;
if ( relev . get_relevantFor ( ) != adt ) {
logger . info ( " + adt . get_name ( ) ) ;
continue ;
}
if ( ! elm . is_adt ( ) ) {
logger . info ( " + adt . get_name ( ) ) ;
continue ;
}
if ( ! typeIsInModule ( ( ADTDef ) elm , target ) ) {
logger . info ( " + elm . get_name ( ) + " + target . get_name ( ) ) ;
continue ;
}
sim = new Similarity ( new Element ( adt . get_name ( ) ) , new Element ( elm . get_name ( ) ) ) ;
sims . add ( sim ) ;
for ( Object a : adt . get_attributes ( ) ) {
if ( ! ( a instanceof AttributeDef ) ) continue ;
createAttributeSimilarities ( ( AttributeDef ) a ) ;
}
}
}
private void createAttributeSimilarities ( AttributeDef attr ) throws SQLException {
int card = <num> ;
if ( attr . get_attributeOf ( ) == null || attr . get_type ( ) == null ) {
logger . info ( " + attr . get_name ( ) + " ) ;
return ;
}
if ( ! attr . isNull_cardinality ( ) ) card = attr . get_cardinality ( ) ;
for ( Object r : attr . get_relevances ( ) ) {
RelevanceDef relev = ( RelevanceDef ) r ;
ElementDef elm = null ;
AttributeDef relAttr = null ;
int relAttrCard = <num> ;
Similarity sim = null ;
Association of = null ;
Association to = null ;
TypeDef attrType = null , relAttrType = null ;
elm = relev . get_relevant ( ) ;
if ( attr . get_type ( ) . is_set ( ) )
attrType = ( ( CollectionDef ) attr . get_type ( ) ) . get_ofType ( ) ;
else
attrType = attr . get_type ( ) ;
if ( relev . get_rejected ( ) ) continue ;
if ( relev . get_relevantFor ( ) != attr ) {
logger . info ( " + attr . get_name ( ) ) ;
continue ;
}
if ( ! elm . is_attribute ( ) ) {
logger . info ( " + attr . get_name ( ) ) ;
continue ;
}
relAttr = ( AttributeDef ) elm ;
if ( relAttr . get_type ( ) . is_set ( ) )
relAttrType = ( ( CollectionDef ) relAttr . get_type ( ) ) . get_ofType ( ) ;
else
relAttrType = relAttr . get_type ( ) ;
if ( ! typeIsInModule ( relAttrType , target ) ) {
logger . info ( " + elm . get_name ( ) + " + target . get_name ( ) ) ;
continue ;
}
if ( relAttr . get_attributeOf ( ) == null || relAttr . get_type ( ) == null ) {
logger . info ( " + relAttr . get_name ( ) + " ) ;
continue ;
}
if ( ! relAttr . isNull_cardinality ( ) ) relAttrCard = relAttr . get_cardinality ( ) ;
of = new Association ( attr . get_attributeOf ( ) . get_name ( ) , attrType . get_name ( ) , card ) ;
to = new Association ( relAttr . get_attributeOf ( ) . get_name ( ) , relAttrType . get_name ( ) , relAttrCard ) ;
sim = new Similarity ( of , to ) ;
sims . add ( sim ) ;
}
}
private boolean typeIsInModule ( TypeDef type , ModuleDef module ) throws SQLException {
boolean result = false ;
logger . info ( " + type . get_name ( ) + " + module . get_name ( ) ) ;
if ( type . <unk> ( ) == module )
result = true ;
else
for ( Object obj : module . get_imports ( ) ) {
FrameDef frame = ( FrameDef ) obj ;
if ( ! result && frame . is_module ( ) )
result = typeIsInModule ( type , ( ModuleDef ) frame ) ;
}
return result ;
}
}
package unifier . util ;
import java . util . Date ;
import java . util . Calendar ;
import javax . swing . text . MaskFormatter ;
import java . util . GregorianCalendar ;
public class DateHelper {
public static MaskFormatter createMaskFormatter ( String s ) {
MaskFormatter formatter = null ;
try {
formatter = new MaskFormatter ( s ) ;
} catch ( java . text . ParseException exc ) {
}
return formatter ;
}
public static Date convertFormattedStringIntoDate ( String s ) throws
IncorrectDateException {
int year ;
int month ;
int day ;
GregorianCalendar calendar = new GregorianCalendar ( ) ;
if ( s . length ( ) != <num> ) {
System . out . println ( s . length ( ) ) ;
throw new IncorrectDateException ( ) ;
}
year = ( new Integer ( s . substring ( <num> , <num> ) ) ) . intValue ( ) ;
if ( year < <num> || year > <num> ) {
throw new IncorrectDateException ( ) ;
}
month = ( new Integer ( s . substring ( <num> , <num> ) ) ) . intValue ( ) ;
if ( month < <num> || month > <num> ) {
throw new IncorrectDateException ( ) ;
}
day = ( new Integer ( s . substring ( <num> , <num> ) ) ) . intValue ( ) ;
if ( day < <num> || day > <num> ) {
throw new IncorrectDateException ( ) ;
}
calendar . set ( year , month  <num> , day ) ;
return calendar . getTime ( ) ;
}
public static String convertDateIntoFormattedText ( Date date ) {
GregorianCalendar calendar = new GregorianCalendar ( ) ;
String result = " ;
calendar . setTime ( date ) ;
if ( calendar . get ( Calendar . DAY_OF_MONTH ) >= <num> ) {
result += new Integer ( calendar . get ( Calendar . DAY_OF_MONTH ) ) . toString ( ) ;
} else {
result += " +
new Integer ( calendar . get ( Calendar . DAY_OF_MONTH ) ) . toString ( ) ;
}
result += " ;
if ( calendar . get ( Calendar . MONTH ) >= <num> ) {
result += new Integer ( calendar . get ( Calendar . DAY_OF_MONTH ) + <num> ) .
toString ( ) ;
} else {
result += " +
new Integer ( calendar . get ( Calendar . MONTH ) + <num> ) . toString ( ) ;
}
result += " ;
result += new Integer ( calendar . get ( Calendar . YEAR ) ) . toString ( ) ;
return result ;
}
}
class IncorrectDateException extends Exception {
public String toString ( ) {
return " ;
}
}
package unifier . asfsdf ;
import java . util . HashSet ;
import java . util . Set ;
import java . util . Map ;
import java . util . HashMap ;
public class Module extends Named {
private Set < String > startSymbols = new HashSet < String > ( ) ;
private Map < String , Sort > sorts = new HashMap < String , Sort > ( ) ;
private Set < String > imports = new HashSet < String > ( ) ;
private Map < String , Signature > signatures = new HashMap < String , Signature > ( ) ;
private Set < Variable > domainSortVariables = new HashSet < Variable > ( ) ;
private Set < Variable > rangeSortVariables = new HashSet < Variable > ( ) ;
private Set < Equation > equations = new HashSet < Equation > ( ) ;
public Module setName ( String name ) {
this . name = name ;
return this ;
}
public Set < String > getStartSymbols ( ) {
return startSymbols ;
}
public Module addStartSymbol ( String s ) {
startSymbols . add ( s ) ;
return this ;
}
public Set < String > getImports ( ) {
return imports ;
}
public Module addImport ( String s ) {
imports . add ( s ) ;
return this ;
}
public boolean <unk> ( String name ) {
return sorts . containsKey ( name ) ;
}
public Set < String > getSortNames ( ) {
return sorts . keySet ( ) ;
}
public Sort getSort ( String name ) throws SdfDefinitionException {
return sorts . get ( name ) ;
}
public Module addSort ( Sort sort ) throws SdfDefinitionException {
if ( sort . getName ( ) . trim ( ) . compareTo ( " ) == <num> ) {
throw new SdfDefinitionException ( " ) ;
} else {
sorts . put ( sort . getName ( ) , sort ) ;
}
return this ;
}
public Set < Variable > getDomainSortVariables ( ) {
return domainSortVariables ;
}
public Module addDomainSortVariable ( Variable var ) {
domainSortVariables . add ( var ) ;
return this ;
}
public Set < Variable > getRangeSortVariables ( ) {
return rangeSortVariables ;
}
public Module addRangeSortVariable ( Variable var ) {
rangeSortVariables . add ( var ) ;
return this ;
}
public Set < Equation > getEquations ( ) {
return equations ;
}
public Module addEquation ( Equation eq ) {
equations . add ( eq ) ;
return this ;
}
public Signature getSignature ( String sigName ) {
return signatures . get ( sigName ) ;
}
public Module addSignature ( Signature sig ) throws SdfDefinitionException {
if ( sig . getName ( ) . trim ( ) . compareTo ( " ) == <num> ) {
throw new SdfDefinitionException ( " ) ;
} else {
signatures . put ( sig . getName ( ) , sig ) ;
}
return this ;
}
public Module removeSignature ( Signature sig ) throws SdfDefinitionException {
if ( sig . getName ( ) . trim ( ) . compareTo ( " ) == <num> ) {
throw new SdfDefinitionException ( " ) ;
} else {
signatures . remove ( sig . getName ( ) ) ;
}
return this ;
}
public Set < String > getSignatureNames ( ) {
return signatures . keySet ( ) ;
}
public String getSeparatorOfListSort ( String domain , String range ) throws SdfDefinitionException {
String result = " ;
Sort domainSort ;
domainSort = this . getSort ( domain ) ;
if ( ! domainSort . isTerminal ( ) && ( ( Nonterminal ) domainSort ) . getDefinition ( ) . isDeclaration ( ) ) {
Declaration decl = ( Declaration ) ( ( Nonterminal ) domainSort ) . getDefinition ( ) ;
for ( DeclarationElement elm : decl . getElements ( ) ) {
if ( elm . isList ( ) && elm . isSimple ( ) && elm . getNameIfSimple ( ) . compareTo ( range ) == <num> ) {
return ( ( List ) elm ) . getSeparator ( ) ;
} else
if ( elm . isSortName ( ) ) {
String sortName = elm . getNameIfSimple ( ) ;
Sort sort = this . getSort ( sortName ) ;
if ( sort . isListSort ( ) ) {
Declaration listDecl = ( Declaration ) ( ( Nonterminal ) sort ) . getDefinition ( ) ;
List listElm = ( List ) listDecl . getElements ( ) . iterator ( ) . next ( ) ;
if ( listElm . isSimple ( ) && listElm . getNameIfSimple ( ) . compareTo ( range ) == <num> )
return listElm . getSeparator ( ) ;
}
}
}
}
return result ;
}
}
package unifier . asfsdf ;
public abstract class DerivedSort extends DeclarationElement {
protected AbstractSortDef originalSort ;
public AbstractSortDef getOriginalSort ( ) {
return originalSort ;
}
public abstract DerivedSort setOriginalSort ( AbstractSortDef sort ) ;
public boolean isSortName ( ) {
return false ;
}
public boolean isLiteral ( ) {
return false ;
}
public boolean isDerivedSort ( ) {
return true ;
}
public abstract boolean isOptional ( ) ;
public abstract boolean isList ( ) ;
public boolean originalSortIsDeclaration ( ) {
if ( originalSort . isDeclaration ( ) ) return true ;
else return false ;
}
}
package unifier . asfsdf ;
import unifier . util . StringHelper ;
public class Literal extends DeclarationElement {
private String value = " ;
public boolean isSortName ( ) {
return false ;
}
public boolean isLiteral ( ) {
return true ;
}
public boolean isDerivedSort ( ) {
return false ;
}
public Literal ( ) { }
public Literal ( String value ) {
this . value = value ;
}
public String getValue ( ) {
return StringHelper . toQuotation ( value ) ;
}
public Literal setValue ( String value ) {
this . value = value ;
return this ;
}
public String getVariableName ( ) throws SdfDefinitionException {
return value ;
}
public boolean isSimple ( ) {
return true ;
}
public String getNameIfSimple ( ) {
return value ;
}
public boolean isList ( ) {
return false ;
}
public boolean isOptionalLiteral ( ) {
return false ;
}
public boolean isOptional ( ) {
return false ;
}
}
package unifier . util ;
import java . io . File ;
import java . io . FileWriter ;
import java . io . IOException ;
public class TextFile {
public TextFile ( String name , String content ) {
this . name = name ;
this . content = content ;
}
private String name ;
private String content ;
public String getName ( ) {
return name ;
}
public String getContent ( ) {
return content ;
}
public void setName ( String name ) {
this . name = name ;
}
public void setContent ( String content ) {
this . content = content ;
}
public void save ( String path ) throws IOException {
FileWriter writer = new FileWriter ( new File ( path + name ) ) ;
writer . write ( content ) ;
writer . close ( ) ;
}
}
package unifier . asfsdf ;
import java . util . Set ;
import java . util . HashSet ;
public class Equation {
private String tag = " ;
private Set < Condition > conditions = new HashSet < Condition > ( ) ;
private String definedFunctionName = " ;
private String params = " ;
private String body = " ;
public Equation ( ) { }
public Equation ( String tag , String definedFunctionName ) {
this . tag = tag ;
this . definedFunctionName = definedFunctionName ;
}
public String getTag ( ) {
return tag ;
}
public Equation setTag ( String tag ) {
this . tag = tag ;
return this ;
}
public String getDefinedFunctionName ( ) {
return definedFunctionName ;
}
public Equation setDefinedFunctionName ( String definedFunctionName ) {
this . definedFunctionName = definedFunctionName ;
return this ;
}
public String getParams ( ) {
return params ;
}
public Equation setParams ( String params ) {
this . params = params ;
return this ;
}
public String getBody ( ) {
return body ;
}
public Equation setBody ( String body ) {
this . body = body ;
return this ;
}
public Set < Condition > getConditions ( ) {
return conditions ;
}
public Equation addCondition ( Condition cond ) {
conditions . add ( cond ) ;
return this ;
}
}
package sql . translator ;
import org . antlr . runtime . ANTLRStringStream ;
import org . antlr . runtime . CommonTokenStream ;
import org . antlr . runtime . RecognitionException ;
import org . antlr . runtime . tree . Tree ;
import org . antlr . stringtemplate . StringTemplateGroup ;
import org . antlr . stringtemplate . language . AngleBracketTemplateLexer ;
import queryprogram . mds . Module ;
import queryprogram . mds . Schema ;
import java . io . * ;
import java . net . URL ;
import sql . parser . CaseInsentitiveANTLRStringStream ;
import sql . translator . SqlAstToSyfsTranslator ;
import sql . SqlLexer ;
import sql . SqlParser ;
public class SqlToSyfsTranslator {
protected Resolver resolver ;
protected StringTemplateGroup stg ;
public SqlToSyfsTranslator ( Resolver resolver ) {
this . resolver = resolver ;
this . stg = loadSyfsGroup ( ) ;
}
public SqlToSyfsTranslator ( Schema schema , Module [ ] defaultModules ) {
this ( new Resolver ( schema , defaultModules ) ) ;
}
protected StringTemplateGroup loadSyfsGroup ( ) {
ClassLoader loader = ClassLoader . getSystemClassLoader ( ) ;
Reader syfsGroupReader = new InputStreamReader ( loader . getResourceAsStream ( " ) ) ;
return new StringTemplateGroup ( syfsGroupReader , AngleBracketTemplateLexer . class ) ;
}
public void translate ( String sql , Writer syfsWriter ) throws RecognitionException , IOException {
ANTLRStringStream stream = new CaseInsentitiveANTLRStringStream ( sql ) ;
CommonTokenStream tokenStream = new CommonTokenStream ( new SqlLexer ( stream ) ) ;
SqlParser parser = new SqlParser ( tokenStream ) ;
Tree tree = ( Tree ) parser . select ( ) . getTree ( ) ;
SqlAstToSyfsTranslator tran = new SqlAstToSyfsTranslator ( resolver , tree , stg , syfsWriter ) ;
tran . writeQuery ( ) ;
}
public String translate ( String sql ) throws IOException , RecognitionException {
StringWriter syfsWriter = new StringWriter ( ) ;
translate ( sql , syfsWriter ) ;
return syfsWriter . toString ( ) ;
}
}
package unifier ;
import javax . swing . border . TitledBorder ;
import javax . swing . JPanel ;
import java . awt . Insets ;
import javax . swing . JButton ;
import java . awt . Dimension ;
import java . awt . GridBagConstraints ;
import javax . swing . JTextArea ;
import java . awt . FlowLayout ;
import javax . swing . JScrollPane ;
import javax . swing . JTextField ;
import javax . swing . JTabbedPane ;
import java . awt . GridBagLayout ;
import javax . swing . JLabel ;
import javax . swing . JList ;
import java . awt . * ;
import javax . swing . BorderFactory ;
import javax . swing . JFrame ;
import meta . * ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import java . util . logging . Logger ;
import db . * ;
import java . util . Set ;
import java . util . Vector ;
import javax . swing . ListModel ;
import javax . swing . DefaultListCellRenderer ;
import java . sql . * ;
import javax . swing . DefaultListModel ;
import javax . swing . ListSelectionModel ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseAdapter ;
import unifier . util . ModelRegDefCellRenderer ;
import java . awt . event . KeyEvent ;
public class ModelExplorer extends CenteredFrame {
public ModelExplorer ( DB adb ) {
try {
jbInit ( ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
center ( ) ;
logger = Logger . getLogger ( " ) ;
db = adb ;
}
private void jbInit ( ) throws Exception {
this . setDefaultCloseOperation ( HIDE_ON_CLOSE ) ;
this . setTitle ( " ) ;
this . getContentPane ( ) . setLayout ( gridBagLayoutMR ) ;
jPanelSearchCriteria . setLayout ( gridBagLayoutSC ) ;
jPanelSearchResults . setLayout ( gridBagLayoutMS ) ;
jLabelShortTitle . setText ( " ) ;
jTextFieldShortTitle . setText ( " ) ;
jLabelFullTitle . setText ( " ) ;
jTextFieldFullTitle . setText ( " ) ;
jPanelSearchCriteria . setBorder ( null ) ;
jPanelSearchCriteria . setToolTipText ( " ) ;
jPanelSyntax . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) , " ) ) ;
jPanelSyntax . setToolTipText ( " ) ;
jPanelSyntax . setLayout ( gridBagLayoutRCS ) ;
jLabelSyntaxDocTitle . setText ( " ) ;
jLabelSyntaxLink . setText ( " ) ;
jTextFieldSyntaxDocTitle . setText ( " ) ;
jTextFieldSyntaxLink . setText ( " ) ;
jPanelSemantics . setLayout ( gridBagLayoutRCSem ) ;
jPanelSemantics . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white , new Color ( <num> , <num> , <num> ) ) ,
" ) ) ;
jLabelSemanticsDocTitle . setText ( " ) ;
jTextFieldSemanticsDocTitle . setText ( " ) ;
jLabelSemanticsLink . setText ( " ) ;
jTextFieldSemanticsLink . setText ( " ) ;
jButtonSearchModel . setText ( " ) ;
jButtonSearchModel . setMnemonic ( KeyEvent . VK_S ) ;
jButtonSearchModel . addActionListener ( new
ModelExplorer_jButtonSearchModel_actionAdapter ( this ) ) ;
jPanelSCButtons . setLayout ( flowLayoutSCB ) ;
jPanelSCButtons . setBorder ( BorderFactory . createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) ) ;
jButtonOpenModel . setText ( " ) ;
jButtonOpenModel . setMnemonic ( KeyEvent . VK_O ) ;
jButtonOpenModel . addActionListener ( new
ModelExplorer_jButtonOpenModel_actionAdapter ( this ) ) ;
jTabbedPaneActivities . setMinimumSize ( new Dimension ( <num> , <num> ) ) ;
jTabbedPaneActivities . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jPanelLegend . setBorder ( new TitledBorder ( BorderFactory .
createEtchedBorder ( Color . white ,
new Color ( <num> , <num> , <num> ) ) , " ) ) ;
jPanelLegend . setLayout ( gridBagLayout1 ) ;
jLabelMask1 . setFont ( new java . awt . Font ( " , Font . BOLD , <num> ) ) ;
jLabelMask1 . setText ( " ) ;
jLabelMask1Note . setText ( " ) ;
jLabelMask2 . setFont ( new java . awt . Font ( " , Font . BOLD , <num> ) ) ;
jLabelMask2 . setText ( " ) ;
jLabelMask2Note . setText ( " ) ;
jListSearchResults . setCellRenderer ( null ) ;
jListSearchResults . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ;
jTabbedPaneActivities . add ( jPanelSearchCriteria , " ) ;
jTabbedPaneActivities . add ( jPanelSearchResults , " ) ;
jPanelSemantics . add ( jLabelSemanticsDocTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jTextFieldSemanticsDocTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jLabelSemanticsLink ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSemantics . add ( jTextFieldSemanticsLink ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSCButtons . add ( jButtonSearchModel ) ;
jPanelSearchResults . add ( jPanelModelSyntaxButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelModelSyntaxButtons . add ( jButtonOpenModel ) ;
jPanelSearchResults . add ( jScrollPaneSearchResults ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jScrollPaneSearchResults . getViewport ( ) . add ( jListSearchResults ) ;
this . getContentPane ( ) . add ( jTabbedPaneActivities ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelLegend . add ( jLabelMask2 ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelLegend . add ( jLabelMask1Note ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . WEST ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelLegend . add ( jLabelMask1 ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelLegend . add ( jLabelMask2Note ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . WEST ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSearchCriteria . add ( jTextFieldFullTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSearchCriteria . add ( jLabelShortTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSearchCriteria . add ( jLabelFullTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST , GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSearchCriteria . add ( jPanelSyntax ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSearchCriteria . add ( jPanelSemantics ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSearchCriteria . add ( jPanelSCButtons ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSearchCriteria . add ( jTextFieldShortTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSyntax . add ( jLabelSyntaxDocTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSyntax . add ( jLabelSyntaxLink ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . EAST ,
GridBagConstraints . NONE ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSyntax . add ( jTextFieldSyntaxDocTitle ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSyntax . add ( jTextFieldSyntaxLink ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER ,
GridBagConstraints . HORIZONTAL ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jPanelSearchCriteria . add ( jPanelLegend ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
jListSearchResults . setCellRenderer ( new ModelRegDefCellRenderer ( ) ) ;
}
GridBagLayout gridBagLayoutMR = new GridBagLayout ( ) ;
JTabbedPane jTabbedPaneActivities = new JTabbedPane ( ) ;
JPanel jPanelSearchCriteria = new JPanel ( ) ;
GridBagLayout gridBagLayoutSC = new GridBagLayout ( ) ;
JPanel jPanelSearchResults = new JPanel ( ) ;
GridBagLayout gridBagLayoutMS = new GridBagLayout ( ) ;
JLabel jLabelShortTitle = new JLabel ( ) ;
JTextField jTextFieldShortTitle = new JTextField ( ) ;
JLabel jLabelFullTitle = new JLabel ( ) ;
JTextField jTextFieldFullTitle = new JTextField ( ) ;
JPanel jPanelSyntax = new JPanel ( ) ;
GridBagLayout gridBagLayoutRCS = new GridBagLayout ( ) ;
JLabel jLabelSyntaxDocTitle = new JLabel ( ) ;
JLabel jLabelSyntaxLink = new JLabel ( ) ;
JTextField jTextFieldSyntaxDocTitle = new JTextField ( ) ;
JTextField jTextFieldSyntaxLink = new JTextField ( ) ;
JPanel jPanelSemantics = new JPanel ( ) ;
GridBagLayout gridBagLayoutRCSem = new GridBagLayout ( ) ;
JLabel jLabelSemanticsDocTitle = new JLabel ( ) ;
JTextField jTextFieldSemanticsDocTitle = new JTextField ( ) ;
JLabel jLabelSemanticsLink = new JLabel ( ) ;
JTextField jTextFieldSemanticsLink = new JTextField ( ) ;
JPanel jPanelSCButtons = new JPanel ( ) ;
JButton jButtonSearchModel = new JButton ( ) ;
FlowLayout flowLayoutSCB = new FlowLayout ( ) ;
JPanel jPanelModelSyntaxButtons = new JPanel ( ) ;
JScrollPane jScrollPaneSearchResults = new JScrollPane ( ) ;
JButton jButtonOpenModel = new JButton ( ) ;
JList jListSearchResults = new JList ( ) ;
JPanel jPanelLegend = new JPanel ( ) ;
JLabel jLabelMask1 = new JLabel ( ) ;
GridBagLayout gridBagLayout1 = new GridBagLayout ( ) ;
JLabel jLabelMask1Note = new JLabel ( ) ;
JLabel jLabelMask2 = new JLabel ( ) ;
JLabel jLabelMask2Note = new JLabel ( ) ;
public void jButtonSearchModel_actionPerformed ( ActionEvent e ) {
searchForModel ( ) ;
}
public void jButtonOpenModel_actionPerformed ( ActionEvent e ) {
try {
openModel ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
private Logger logger ;
private DB db ;
private void searchForModel ( ) {
Set result ;
Condition cond = null ;
cond = new Like ( ModelRegDef . _name , " ) ;
if ( jTextFieldShortTitle . getText ( ) . trim ( ) . compareTo ( " ) != <num> ) {
cond = new And ( cond , new Like ( ModelRegDef . _name , jTextFieldShortTitle . getText ( ) . trim ( ) ) ) ;
}
if ( jTextFieldFullTitle . getText ( ) . trim ( ) . compareTo ( " ) != <num> ) {
cond = new And ( cond , new Like ( ModelRegDef . <unk> , jTextFieldFullTitle . getText ( ) . trim ( ) ) ) ;
}
if ( jTextFieldSyntaxDocTitle . getText ( ) . trim ( ) . compareTo ( " ) != <num> ) {
cond = new And ( cond , new Like ( ModelRegDef . <unk> , jTextFieldSyntaxDocTitle . getText ( ) . trim ( ) ) ) ;
}
if ( jTextFieldSyntaxLink . getText ( ) . trim ( ) . compareTo ( " ) != <num> ) {
cond = new And ( cond , new Like ( ModelRegDef . <unk> , jTextFieldSyntaxLink . getText ( ) . trim ( ) ) ) ;
}
if ( jTextFieldSemanticsDocTitle . getText ( ) . trim ( ) . compareTo ( " ) != <num> ) {
cond = new And ( cond , new Like ( ModelRegDef . <unk> , jTextFieldSemanticsDocTitle . getText ( ) . trim ( ) ) ) ;
}
if ( jTextFieldSemanticsLink . getText ( ) . trim ( ) . compareTo ( " ) != <num> ) {
cond = new And ( cond , new Like ( ModelRegDef . <unk> , jTextFieldSemanticsLink . getText ( ) . trim ( ) ) ) ;
}
result = db . <unk> ( new Query ( cond ) ) ;
DefaultListModel listModel = new DefaultListModel ( ) ;
for ( Object m : result ) {
ModelRegDef model = ( ModelRegDef ) m ;
listModel . addElement ( model ) ;
}
jListSearchResults . setModel ( listModel ) ;
jListSearchResults . clearSelection ( ) ;
jTabbedPaneActivities . setSelectedIndex ( <num> ) ;
}
private void openModel ( ) throws SQLException {
if ( ( ( ModelRegDef ) jListSearchResults . getSelectedValue ( ) ) . get_name ( ) == null ) return ;
if ( ! jListSearchResults . isSelectionEmpty ( ) ) {
ModelRegistrar registrar ;
logger . info ( " ) ;
registrar = new ModelRegistrar ( ( ModelRegDef ) jListSearchResults . getSelectedValue ( ) ) ;
jListSearchResults . clearSelection ( ) ;
}
}
}
class ModelExplorer_jButtonSearchModel_actionAdapter implements ActionListener {
private ModelExplorer adaptee ;
ModelExplorer_jButtonSearchModel_actionAdapter ( ModelExplorer adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonSearchModel_actionPerformed ( e ) ;
}
}
class ModelExplorer_jButtonOpenModel_actionAdapter implements ActionListener {
private ModelExplorer adaptee ;
ModelExplorer_jButtonOpenModel_actionAdapter ( ModelExplorer adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jButtonOpenModel_actionPerformed ( e ) ;
}
}
package unifier . util ;
import java . util . logging . Handler ;
import java . util . logging . LogRecord ;
import javax . swing . JTextArea ;
public class JTextAreaHandler extends Handler {
public JTextAreaHandler ( JTextArea area ) {
textArea = area ;
}
private JTextArea textArea ;
public void close ( ) throws SecurityException {
}
public void flush ( ) {
}
public void publish ( LogRecord record ) {
String recordString ;
recordString = record . getLoggerName ( ) + " + record . getMessage ( ) + " ;
textArea . append ( recordString ) ;
System . out . print ( recordString ) ;
}
}
package unifier ;
import javax . swing . JFrame ;
import java . util . * ;
import java . awt . SystemColor ;
import java . awt . GridBagLayout ;
import javax . swing . JMenuBar ;
import javax . swing . JMenu ;
import javax . swing . JMenuItem ;
import java . awt . event . ActionEvent ;
import java . awt . event . ActionListener ;
import java . io . * ;
import javax . swing . JOptionPane ;
import meta . DB ;
import java . sql . SQLException ;
import java . awt . event . WindowEvent ;
import java . awt . event . WindowAdapter ;
import javax . swing . JPanel ;
import java . awt . * ;
import java . util . logging . Logger ;
import java . util . logging . Handler ;
import javax . swing . UIManager ;
import javax . swing . SwingUtilities ;
import unifier . util . JTextAreaHandler ;
import java . awt . event . KeyEvent ;
public class ModelManager extends CenteredFrame {
public ModelManager ( ) {
modelRegistryConnection = " ;
logFrame = new LogFrame ( ) ;
logFrame . pack ( ) ;
logFrame . validate ( ) ;
logger = Logger . getLogger ( " ) ;
handler = new JTextAreaHandler ( logFrame . getLogTextArea ( ) ) ;
logger . addHandler ( handler ) ;
try {
jbInit ( ) ;
closeRegistryDependentMenuActions ( ) ;
UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ;
SwingUtilities . <unk> ( this ) ;
} catch ( Exception ex ) {
logger . info ( " ) ;
}
center ( ) ;
}
private void jbInit ( ) throws Exception {
this . getContentPane ( ) . setBackground ( SystemColor . control ) ;
this . setDefaultCloseOperation ( <unk> ) ;
this . setJMenuBar ( jMenuBarMR ) ;
this . setTitle ( " ) ;
this . addWindowListener ( new ModelManager_this_windowAdapter ( this ) ) ;
this . getContentPane ( ) . setLayout ( gridBagLayoutMM ) ;
jMenuFile . setMnemonic ( KeyEvent . VK_F ) ;
jMenuFile . setText ( " ) ;
jMenuItemOpenModelRegistry . setText ( " ) ;
jMenuItemOpenModelRegistry . addActionListener ( new
ModelManager_jMenuItemOpenModelRegistry_actionAdapter ( this ) ) ;
jMenuItemCloseModelRegistry . setText ( " ) ;
jMenuItemCloseModelRegistry . addActionListener ( new
ModelManager_jMenuItemCloseModelRegistry_actionAdapter ( this ) ) ;
jMenuView . setText ( " ) ;
jMenuItemLog . setText ( " ) ;
jMenuItemLog . addActionListener ( new
ModelManager_jMenuItemLog_actionAdapter ( this ) ) ;
jMenuItemNewModel . setText ( " ) ;
jMenuItemNewModel . addActionListener ( new
ModelManager_jMenuItemNewModel_actionAdapter ( this ) ) ;
jMenuSearch . setText ( " ) ;
jMenuSearch . setMnemonic ( KeyEvent . VK_S ) ;
jMenuItemFindModel . setText ( " ) ;
jMenuItemFindModel . addActionListener ( new
ModelManager_jMenuItemFindModel_actionAdapter ( this ) ) ;
jMenuItemExploreExtensions . setText ( " ) ;
jMenuItemExploreExtensions . addActionListener ( new
ModelManager_jMenuItemExploreExtensions_actionAdapter ( this ) ) ;
jPanelModelManager . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
jMenuItemNewExtension . setText ( " ) ;
jMenuItemNewExtension . addActionListener ( new
ModelManager_jMenuItemNewExtension_actionAdapter ( this ) ) ;
jMenuBarMR . add ( jMenuFile ) ;
jMenuBarMR . add ( jMenuSearch ) ;
jMenuBarMR . add ( jMenuView ) ;
jMenuFile . add ( jMenuItemOpenModelRegistry ) ;
jMenuFile . add ( jMenuItemCloseModelRegistry ) ;
jMenuFile . add ( jMenuItemNewModel ) ;
jMenuFile . add ( jMenuItemNewExtension ) ;
jMenuView . add ( jMenuItemLog ) ;
jMenuSearch . add ( jMenuItemFindModel ) ;
jMenuSearch . add ( jMenuItemExploreExtensions ) ;
this . getContentPane ( ) . add ( jPanelModelManager ,
new GridBagConstraints ( <num> , <num> , <num> , <num> , <num> , <num>
, GridBagConstraints . CENTER , GridBagConstraints . BOTH ,
new Insets ( <num> , <num> , <num> , <num> ) , <num> , <num> ) ) ;
}
private GridBagLayout gridBagLayoutMM = new GridBagLayout ( ) ;
private JMenuBar jMenuBarMR = new JMenuBar ( ) ;
private JMenu jMenuFile = new JMenu ( ) ;
private JMenuItem jMenuItemOpenModelRegistry = new JMenuItem ( ) ;
private JMenuItem jMenuItemCloseModelRegistry = new JMenuItem ( ) ;
private JMenu jMenuView = new JMenu ( ) ;
private JMenuItem jMenuItemLog = new JMenuItem ( ) ;
private JMenuItem jMenuItemNewModel = new JMenuItem ( ) ;
private JMenu jMenuSearch = new JMenu ( ) ;
private JMenuItem jMenuItemFindModel = new JMenuItem ( ) ;
private JMenuItem jMenuItemExploreExtensions = new JMenuItem ( ) ;
private JPanel jPanelModelManager = new JPanel ( ) ;
private JMenuItem jMenuItemNewExtension = new JMenuItem ( ) ;
public void jMenuItemOpenModelRegistry_actionPerformed ( ActionEvent e ) {
openModelRegistry ( ) ;
}
public void jMenuItemCloseModelRegistry_actionPerformed ( ActionEvent e ) {
closeConnectionToModelRegistry ( ) ;
}
public void jMenuItemLog_actionPerformed ( ActionEvent e ) {
logFrame . setVisible ( true ) ;
}
public void jMenuItemNewModel_actionPerformed ( ActionEvent e ) {
try {
registerNewModel ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jMenuItemNewExtension_actionPerformed ( ActionEvent e ) {
try {
registerNewExtension ( ) ;
} catch ( SQLException ex ) {
logger . info ( ex . toString ( ) ) ;
}
}
public void jMenuItemFindModel_actionPerformed ( ActionEvent e ) {
searchForModel ( ) ;
}
public void jMenuItemExploreExtensions_actionPerformed ( ActionEvent e ) {
exploreExtensions ( ) ;
}
public void this_windowClosing ( WindowEvent e ) {
closeConnectionToModelRegistry ( ) ;
System . exit ( <num> ) ;
}
private void closeRegistryDependentMenuActions ( ) {
jMenuItemCloseModelRegistry . setEnabled ( false ) ;
jMenuItemOpenModelRegistry . setEnabled ( true ) ;
jMenuItemNewModel . setEnabled ( false ) ;
jMenuItemNewExtension . setEnabled ( false ) ;
jMenuSearch . setEnabled ( false ) ;
}
private void openRegistryDependentMenuActions ( ) {
jMenuItemCloseModelRegistry . setEnabled ( true ) ;
jMenuItemOpenModelRegistry . setEnabled ( false ) ;
jMenuItemNewModel . setEnabled ( true ) ;
jMenuItemNewExtension . setEnabled ( true ) ;
jMenuSearch . setEnabled ( true ) ;
}
static DB db ;
private Logger logger ;
private Handler handler ;
private LogFrame logFrame ;
private String modelRegistryConnection ;
private void openModelRegistry ( ) {
try {
LineNumberReader initFile = new LineNumberReader ( new FileReader (
" ) ) ;
modelRegistryConnection = initFile . readLine ( ) ;
initFile . close ( ) ;
}
catch ( IOException ex ) {
logger . info ( " ) ;
logger . info ( ex . toString ( ) ) ;
}
String connection = ( String ) JOptionPane . showInputDialog (
null , " ,
" , JOptionPane . PLAIN_MESSAGE , null ,
null , modelRegistryConnection ) ;
if ( ( connection != null ) && ( connection . length ( ) > <num> ) ) {
modelRegistryConnection = connection ;
logger . info ( " + connection ) ;
establishConnectionToModelRegistry ( ) ;
if ( db != null ) {
openRegistryDependentMenuActions ( ) ;
}
}
try {
FileWriter initFile = new FileWriter ( " ) ;
initFile . write ( modelRegistryConnection ) ;
initFile . close ( ) ;
} catch ( IOException ex ) {
logger . info ( " ) ;
}
}
private void establishConnectionToModelRegistry ( ) {
try {
db = DB . open ( modelRegistryConnection ) ;
} catch ( SQLException ex ) {
logger . info ( " + modelRegistryConnection ) ;
logger . info ( ex . toString ( ) ) ;
}
}
private void closeConnectionToModelRegistry ( ) {
if ( db != null && db . getConnection ( ) != null ) {
try {
db . commit ( ) ;
logger . info ( " ) ;
db . close ( ) ;
logger . info ( " ) ;
} catch ( SQLException ex ) {
logger . info ( " + modelRegistryConnection ) ;
logger . info ( ex . toString ( ) ) ;
}
}
System . out . println ( " ) ;
closeRegistryDependentMenuActions ( ) ;
}
private void registerNewModel ( ) throws SQLException {
ModelRegistrar registrar ;
logger . info ( " ) ;
registrar = new ModelRegistrar ( db ) ;
}
private void searchForModel ( ) {
ModelExplorer explorer ;
logger . info ( " ) ;
explorer = new ModelExplorer ( db ) ;
}
private void exploreExtensions ( ) {
ExtensionExplorer explorer ;
logger . info ( " ) ;
explorer = new ExtensionExplorer ( db ) ;
explorer . pack ( ) ;
explorer . validate ( ) ;
explorer . setVisible ( true ) ;
}
private void registerNewExtension ( ) throws SQLException {
ExtensionRegistrar registrar ;
logger . info ( " ) ;
registrar = new ExtensionRegistrar ( db ) ;
registrar . pack ( ) ;
registrar . validate ( ) ;
registrar . setVisible ( true ) ;
}
}
class ModelManager_this_windowAdapter extends WindowAdapter {
private ModelManager adaptee ;
ModelManager_this_windowAdapter ( ModelManager adaptee ) {
this . adaptee = adaptee ;
}
public void windowClosing ( WindowEvent e ) {
adaptee . this_windowClosing ( e ) ;
}
}
class ModelManager_jMenuItemNewExtension_actionAdapter implements
ActionListener {
private ModelManager adaptee ;
ModelManager_jMenuItemNewExtension_actionAdapter ( ModelManager adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jMenuItemNewExtension_actionPerformed ( e ) ;
}
}
class ModelManager_jMenuItemExploreExtensions_actionAdapter implements
ActionListener {
private ModelManager adaptee ;
ModelManager_jMenuItemExploreExtensions_actionAdapter ( ModelManager adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jMenuItemExploreExtensions_actionPerformed ( e ) ;
}
}
class ModelManager_jMenuItemFindModel_actionAdapter implements ActionListener {
private ModelManager adaptee ;
ModelManager_jMenuItemFindModel_actionAdapter ( ModelManager adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jMenuItemFindModel_actionPerformed ( e ) ;
}
}
class ModelManager_jMenuItemNewModel_actionAdapter implements ActionListener {
private ModelManager adaptee ;
ModelManager_jMenuItemNewModel_actionAdapter ( ModelManager adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jMenuItemNewModel_actionPerformed ( e ) ;
}
}
class ModelManager_jMenuItemLog_actionAdapter implements ActionListener {
private ModelManager adaptee ;
ModelManager_jMenuItemLog_actionAdapter ( ModelManager adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jMenuItemLog_actionPerformed ( e ) ;
}
}
class ModelManager_jMenuItemCloseModelRegistry_actionAdapter implements
ActionListener {
private ModelManager adaptee ;
ModelManager_jMenuItemCloseModelRegistry_actionAdapter ( ModelManager
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jMenuItemCloseModelRegistry_actionPerformed ( e ) ;
}
}
class ModelManager_jMenuItemOpenModelRegistry_actionAdapter implements
ActionListener {
private ModelManager adaptee ;
ModelManager_jMenuItemOpenModelRegistry_actionAdapter ( ModelManager
adaptee ) {
this . adaptee = adaptee ;
}
public void actionPerformed ( ActionEvent e ) {
adaptee . jMenuItemOpenModelRegistry_actionPerformed ( e ) ;
}
}
package unifier . rsm ;
public abstract class BuiltInType extends Type {
}
package unifier . rsm ;
public class ReferenceSchemaModelException extends Exception {
public ReferenceSchemaModelException ( String message ) {
super ( message ) ;
}
}
package unifier . asfsdf ;
public class List extends DerivedSort {
public static final String EMPTY_SEPARATOR = " ;
private String separator = " ;
private ListMultiplicity multiplicity = ListMultiplicity . AT_LEAST_ZERO_TIME ;
public boolean isList ( ) {
return true ;
}
public boolean isOptional ( ) {
return false ;
}
public List ( ) { }
public List ( String sort ) {
originalSort = new Declaration ( new SortName ( sort ) ) ;
}
public List ( AbstractSortDef sort ) {
originalSort = sort ;
}
public List ( String sort , String separator ) {
originalSort = new Declaration ( new SortName ( sort ) ) ;
this . separator = separator ;
}
public List setOriginalSort ( AbstractSortDef sort ) {
originalSort = sort ;
return this ;
}
public String getSeparator ( ) {
return separator ;
}
public List setSeparator ( String separator ) {
this . separator = separator ;
return this ;
}
public String getSeparatorVerbalForm ( ) {
if ( separator . compareTo ( " ) == <num> )
return " ;
else if ( separator . compareTo ( " ) == <num> )
return " ;
else
return " ;
}
public boolean separatorIsEmpty ( ) {
return ( separator . compareTo ( EMPTY_SEPARATOR ) == <num> ) ;
}
public ListMultiplicity getMultiplicity ( ) {
return multiplicity ;
}
public String getMultiplicityToString ( ) {
return multiplicity . toString ( ) ;
}
public List setMultiplicity ( ListMultiplicity multiplicity ) {
this . multiplicity = multiplicity ;
return this ;
}
public boolean isSimple ( ) {
if ( this . originalSort . isDeclaration ( ) && ( ( Declaration ) this . originalSort ) . consistsOfOneSortName ( ) )
return true ;
else return false ;
}
public String getNameIfSimple ( ) throws SdfDefinitionException {
if ( this . isSimple ( ) ) {
return ( ( Declaration ) this . originalSort ) . getElements ( ) . iterator ( ) . next ( ) . getNameIfSimple ( ) ;
} else {
throw new SdfDefinitionException ( " ) ;
}
}
public String getSignatureNameIfSimple ( ) throws SdfDefinitionException {
if ( this . isSimple ( ) ) {
return " + getVariableName ( ) ;
} else {
throw new SdfDefinitionException ( " ) ;
}
}
public String getVariableName ( ) throws SdfDefinitionException {
String result = " ;
if ( this . isSimple ( ) ) {
result = result + ( ( Declaration ) originalSort ) . getVariableName ( ) ;
if ( ! separatorIsEmpty ( ) ) result = result + " + this . getSeparatorVerbalForm ( ) ;
result = result + " + this . multiplicity . getVerbalForm ( ) ;
result = result + " ;
} else
throw new SdfDefinitionException ( " ) ;
return result ;
}
public boolean isOptionalLiteral ( ) {
return false ;
}
}
package unifier . similarity ;
import java . util . Set ;
import java . util . HashSet ;
public class TestSimilarityCreator {
public static Set < Similarity > createSimilarities ( ) {
Set < Similarity > sims = new HashSet < Similarity > ( ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " , <num> ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " , <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " , <num> ) , new Association ( " , " ,  <num> ) ) ) ;
sims . add ( new Similarity ( new Element ( " ) , new Element ( " ) ) ) ;
sims . add ( new Similarity ( new Association ( " , " ,  <num> ) , new Association ( " , " ,  <num> ) ) ) ;
return sims ;
}
}
package unifier . asfsdf ;
public class SortName extends DeclarationElement {
private String value = " ;
public SortName ( String value ) {
this . value = value ;
}
public boolean isSortName ( ) {
return true ;
}
public boolean isLiteral ( ) {
return false ;
}
public boolean isDerivedSort ( ) {
return false ;
}
public SortName setValue ( String value ) {
this . value = value ;
return this ;
}
public String getValue ( ) {
return value ;
}
public String getVariableName ( ) {
return value ;
}
public boolean isSimple ( ) {
return true ;
}
public String getNameIfSimple ( ) {
return value ;
}
public boolean isList ( ) {
return false ;
}
public boolean isOptionalLiteral ( ) {
return false ;
}
public boolean isOptional ( ) {
return false ;
}
}
package unifier . util ;
import java . io . * ;
public class DefaultFormattingWriter extends FormattingWriter {
protected int indent = <num> ;
protected String tab = " ;
protected String ln = " ;
protected static String outputPath = " ;
public static DefaultFormattingWriter createSystemOutWriter ( ) {
return new DefaultFormattingWriter ( new OutputStreamWriter ( System . out ) ) ;
}
public static DefaultFormattingWriter createFileWriter ( String path ) throws IOException {
return new DefaultFormattingWriter ( new FileWriter ( path ) ) ;
}
public static DefaultFormattingWriter <unk> ( ) {
return new DefaultFormattingWriter ( new StringWriter ( ) ) ;
}
public DefaultFormattingWriter ( Writer writer ) {
super ( writer ) ;
}
public DefaultFormattingWriter ( Writer writer , int indent ) {
super ( writer ) ;
this . indent = indent ;
}
public DefaultFormattingWriter ( Writer writer , int indent , String tab , String ln ) {
super ( writer ) ;
this . indent = indent ;
this . tab = tab ;
this . ln = ln ;
}
public DefaultFormattingWriter ( FormattingWriter fw , int indent , String tab , String ln ) {
super ( fw . writer ) ;
this . indent = indent ;
this . tab = tab ;
this . ln = ln ;
}
public void ln ( int i ) {
indent += i ;
write ( ln ) ;
indent ( ) ;
}
public void indent ( ) {
for ( int i = <num> ; i < indent ; i ++ ) write ( tab ) ;
}
public int changeIndent ( int i ) {
return ( indent += i ) ;
}
}
package unifier . sdfparser ;
import org . antlr . runtime . * ;
import java . util . Stack ;
import java . util . List ;
import java . util . ArrayList ;
import org . antlr . runtime . tree . * ;
public class SdfParser extends Parser {
public static final String [ ] tokenNames = new String [ ] {
" , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , " , "
} ;
public static final int STAR = <num> ;
public static final int LETTER = <num> ;
public static final int LBRACE = <num> ;
public static final int ATTRIBUTE = <num> ;
public static final int CONTEXTFREE = <num> ;
public static final int SEPARATOR = <num> ;
public static final int ID = <num> ;
public static final int MARKEDSYMBOL = <num> ;
public static final int EOF =  <num> ;
public static final int SORTS = <num> ;
public static final int LPAREN = <num> ;
public static final int LBRACKET = <num> ;
public static final int SYNTAX = <num> ;
public static final int MULTIPLICITY = <num> ;
public static final int RPAREN = <num> ;
public static final int SLASH = <num> ;
public static final int GREATER = <num> ;
public static final int EXPORTS = <num> ;
public static final int COMMA = <num> ;
public static final int LEFT = <num> ;
public static final int ORIGIN = <num> ;
public static final int PRODUCTION = <num> ;
public static final int DEFINITION = <num> ;
public static final int IMP = <num> ;
public static final int PLUS = <num> ;
public static final int DIGIT = <num> ;
public static final int RBRACKET = <num> ;
public static final int COMPOUNDSYMBOL = <num> ;
public static final int STARTSYMBOLS = <num> ;
public static final int SMALLLETTER = <num> ;
public static final int RBRACE = <num> ;
public static final int CAPITALLETTER = <num> ;
public static final int WHITESPACE = <num> ;
public static final int SORT = <num> ;
public static final int UNDERSCORE = <num> ;
public static final int RIGHT = <num> ;
public static final int MINUS = <num> ;
public static final int MODULE = <num> ;
public static final int LIST = <num> ;
public static final int MODULENAME = <num> ;
public static final int PARAMETERIZEDSYMBOL = <num> ;
public static final int GROUP = <num> ;
public static final int PRIORITY = <num> ;
public static final int QUESTION = <num> ;
public static final int SL_COMMENT = <num> ;
public static final int BOLD_IMP = <num> ;
public static final int LDOUBLEBRACKET = <num> ;
public static final int HIDDENS = <num> ;
public static final int RDOUBLEBRACKET = <num> ;
public static final int IMPORTS = <num> ;
public static final int PRIORITIES = <num> ;
public static final int STRING = <num> ;
public SdfParser ( TokenStream input ) {
super ( input ) ;
}
protected TreeAdaptor adaptor = new <unk> ( ) ;
public void <unk> ( TreeAdaptor adaptor ) {
this . adaptor = adaptor ;
}
public TreeAdaptor <unk> ( ) {
return adaptor ;
}
public String [ ] <unk> ( ) { return tokenNames ; }
public String getGrammarFileName ( ) { return " ; }
public static class module_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final module_return module ( ) throws RecognitionException {
module_return retval = new module_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token MODULE1 = null ;
Token EOF5 = null ;
moduleName_return moduleName2 = null ;
impSection_return impSection3 = null ;
section_return section4 = null ;
CommonTree MODULE1_tree = null ;
CommonTree EOF5_tree = null ;
try {
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
MODULE1 = ( Token ) input . LT ( <num> ) ;
match ( input , MODULE , FOLLOW_MODULE_in_module256 ) ;
MODULE1_tree = ( CommonTree ) adaptor . create ( MODULE1 ) ;
root_0 = ( CommonTree ) adaptor . becomeRoot ( MODULE1_tree , root_0 ) ;
pushFollow ( FOLLOW_moduleName_in_module259 ) ;
moduleName2 = moduleName ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , moduleName2 . getTree ( ) ) ;
loop1 :
do {
int alt1 = <num> ;
int LA1_0 = input . LA ( <num> ) ;
if ( ( LA1_0 == IMPORTS ) ) {
alt1 = <num> ;
}
switch ( alt1 ) {
case <num> :
{
pushFollow ( FOLLOW_impSection_in_module261 ) ;
impSection3 = impSection ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , impSection3 . getTree ( ) ) ;
}
break ;
default :
break loop1 ;
}
} while ( true ) ;
loop2 :
do {
int alt2 = <num> ;
int LA2_0 = input . LA ( <num> ) ;
if ( ( ( LA2_0 >= EXPORTS && LA2_0 <= HIDDENS ) ) ) {
alt2 = <num> ;
}
switch ( alt2 ) {
case <num> :
{
pushFollow ( FOLLOW_section_in_module264 ) ;
section4 = section ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , section4 . getTree ( ) ) ;
}
break ;
default :
break loop2 ;
}
} while ( true ) ;
EOF5 = ( Token ) input . LT ( <num> ) ;
match ( input , EOF , FOLLOW_EOF_in_module267 ) ;
EOF5_tree = ( CommonTree ) adaptor . create ( EOF5 ) ;
adaptor . addChild ( root_0 , EOF5_tree ) ;
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class moduleName_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final moduleName_return moduleName ( ) throws RecognitionException {
moduleName_return retval = new moduleName_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
moduleId_return mid = null ;
RewriteRuleSubtreeStream stream_moduleId = new RewriteRuleSubtreeStream ( adaptor , " ) ;
try {
{
pushFollow ( FOLLOW_moduleId_in_moduleName280 ) ;
mid = moduleId ( ) ;
_fsp  ;
stream_moduleId . add ( mid . getTree ( ) ) ;
retval . tree = root_0 ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
RewriteRuleSubtreeStream stream_mid = new RewriteRuleSubtreeStream ( adaptor , " , mid != null ? mid . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
{
CommonTree root_1 = ( CommonTree ) adaptor . nil ( ) ;
root_1 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( MODULENAME , " ) , root_1 ) ;
adaptor . addChild ( root_1 , stream_mid . next ( ) ) ;
adaptor . addChild ( root_0 , root_1 ) ;
}
}
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class moduleId_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final moduleId_return moduleId ( ) throws RecognitionException {
moduleId_return retval = new moduleId_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token SLASH7 = null ;
moduleWord_return moduleWord6 = null ;
moduleWord_return moduleWord8 = null ;
CommonTree <unk> = null ;
try {
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
pushFollow ( FOLLOW_moduleWord_in_moduleId302 ) ;
moduleWord6 = moduleWord ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , moduleWord6 . getTree ( ) ) ;
loop3 :
do {
int alt3 = <num> ;
int LA3_0 = input . LA ( <num> ) ;
if ( ( LA3_0 == SLASH ) ) {
alt3 = <num> ;
}
switch ( alt3 ) {
case <num> :
{
SLASH7 = ( Token ) input . LT ( <num> ) ;
match ( input , SLASH , FOLLOW_SLASH_in_moduleId305 ) ;
pushFollow ( FOLLOW_moduleWord_in_moduleId308 ) ;
moduleWord8 = moduleWord ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , moduleWord8 . getTree ( ) ) ;
}
break ;
default :
break loop3 ;
}
} while ( true ) ;
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class moduleWord_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final moduleWord_return moduleWord ( ) throws RecognitionException {
moduleWord_return retval = new moduleWord_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token ID9 = null ;
CommonTree ID9_tree = null ;
try {
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
ID9 = ( Token ) input . LT ( <num> ) ;
match ( input , ID , FOLLOW_ID_in_moduleWord321 ) ;
ID9_tree = ( CommonTree ) adaptor . create ( ID9 ) ;
adaptor . addChild ( root_0 , ID9_tree ) ;
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class impSection_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final impSection_return impSection ( ) throws RecognitionException {
impSection_return retval = new impSection_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token IMPORTS10 = null ;
imports_return imports11 = null ;
CommonTree IMPORTS10_tree = null ;
try {
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
IMPORTS10 = ( Token ) input . LT ( <num> ) ;
match ( input , IMPORTS , FOLLOW_IMPORTS_in_impSection333 ) ;
IMPORTS10_tree = ( CommonTree ) adaptor . create ( IMPORTS10 ) ;
root_0 = ( CommonTree ) adaptor . becomeRoot ( IMPORTS10_tree , root_0 ) ;
loop4 :
do {
int alt4 = <num> ;
int LA4_0 = input . LA ( <num> ) ;
if ( ( LA4_0 == ID ) ) {
alt4 = <num> ;
}
switch ( alt4 ) {
case <num> :
{
pushFollow ( FOLLOW_imports_in_impSection336 ) ;
imports11 = imports ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , imports11 . getTree ( ) ) ;
}
break ;
default :
break loop4 ;
}
} while ( true ) ;
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class imports_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final imports_return imports ( ) throws RecognitionException {
imports_return retval = new imports_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
moduleName_return moduleName12 = null ;
try {
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
pushFollow ( FOLLOW_moduleName_in_imports348 ) ;
moduleName12 = moduleName ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , moduleName12 . getTree ( ) ) ;
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class section_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final section_return section ( ) throws RecognitionException {
section_return retval = new section_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token EXPORTS13 = null ;
Token HIDDENS14 = null ;
sdfGrammar_return sdfGrammar15 = null ;
CommonTree EXPORTS13_tree = null ;
CommonTree HIDDENS14_tree = null ;
try {
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
int alt5 = <num> ;
int LA5_0 = input . LA ( <num> ) ;
if ( ( LA5_0 == EXPORTS ) ) {
alt5 = <num> ;
}
else if ( ( LA5_0 == HIDDENS ) ) {
alt5 = <num> ;
}
else {
NoViableAltException nvae =
new NoViableAltException ( " , <num> , <num> , input ) ;
throw nvae ;
}
switch ( alt5 ) {
case <num> :
{
EXPORTS13 = ( Token ) input . LT ( <num> ) ;
match ( input , EXPORTS , FOLLOW_EXPORTS_in_section362 ) ;
EXPORTS13_tree = ( CommonTree ) adaptor . create ( EXPORTS13 ) ;
root_0 = ( CommonTree ) adaptor . becomeRoot ( EXPORTS13_tree , root_0 ) ;
}
break ;
case <num> :
{
HIDDENS14 = ( Token ) input . LT ( <num> ) ;
match ( input , HIDDENS , FOLLOW_HIDDENS_in_section367 ) ;
HIDDENS14_tree = ( CommonTree ) adaptor . create ( HIDDENS14 ) ;
root_0 = ( CommonTree ) adaptor . becomeRoot ( HIDDENS14_tree , root_0 ) ;
}
break ;
}
int cnt6 = <num> ;
loop6 :
do {
int alt6 = <num> ;
int LA6_0 = input . LA ( <num> ) ;
if ( ( LA6_0 == CONTEXTFREE || LA6_0 == SORTS ) ) {
alt6 = <num> ;
}
switch ( alt6 ) {
case <num> :
{
pushFollow ( FOLLOW_sdfGrammar_in_section371 ) ;
sdfGrammar15 = sdfGrammar ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , sdfGrammar15 . getTree ( ) ) ;
}
break ;
default :
if ( cnt6 >= <num> ) break loop6 ;
EarlyExitException eee =
new EarlyExitException ( <num> , input ) ;
throw eee ;
}
cnt6 ++ ;
} while ( true ) ;
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class sdfGrammar_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final sdfGrammar_return sdfGrammar ( ) throws RecognitionException {
sdfGrammar_return retval = new sdfGrammar_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token CONTEXTFREE16 = null ;
Token SYNTAX17 = null ;
Token PRIORITIES19 = null ;
Token STARTSYMBOLS21 = null ;
Token SORTS23 = null ;
production_return production18 = null ;
priority_return priority20 = null ;
symbol_return symbol22 = null ;
symbol_return symbol24 = null ;
CommonTree <unk> = null ;
CommonTree SYNTAX17_tree = null ;
CommonTree PRIORITIES19_tree = null ;
CommonTree STARTSYMBOLS21_tree = null ;
CommonTree SORTS23_tree = null ;
try {
int alt12 = <num> ;
int LA12_0 = input . LA ( <num> ) ;
if ( ( LA12_0 == CONTEXTFREE ) ) {
alt12 = <num> ;
}
else if ( ( LA12_0 == SORTS ) ) {
alt12 = <num> ;
}
else {
NoViableAltException nvae =
new NoViableAltException ( " , <num> , <num> , input ) ;
throw nvae ;
}
switch ( alt12 ) {
case <num> :
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
CONTEXTFREE16 = ( Token ) input . LT ( <num> ) ;
match ( input , CONTEXTFREE , FOLLOW_CONTEXTFREE_in_sdfGrammar383 ) ;
int alt10 = <num> ;
switch ( input . LA ( <num> ) ) {
case SYNTAX :
{
alt10 = <num> ;
}
break ;
case PRIORITIES :
{
alt10 = <num> ;
}
break ;
case STARTSYMBOLS :
{
alt10 = <num> ;
}
break ;
default :
NoViableAltException nvae =
new NoViableAltException ( " , <num> , <num> , input ) ;
throw nvae ;
}
switch ( alt10 ) {
case <num> :
{
SYNTAX17 = ( Token ) input . LT ( <num> ) ;
match ( input , SYNTAX , FOLLOW_SYNTAX_in_sdfGrammar387 ) ;
SYNTAX17_tree = ( CommonTree ) adaptor . create ( SYNTAX17 ) ;
root_0 = ( CommonTree ) adaptor . becomeRoot ( SYNTAX17_tree , root_0 ) ;
loop7 :
do {
int alt7 = <num> ;
int LA7_0 = input . LA ( <num> ) ;
if ( ( LA7_0 == ID || ( LA7_0 >= STRING && LA7_0 <= LPAREN ) || LA7_0 == LBRACE || LA7_0 == IMP ) ) {
alt7 = <num> ;
}
switch ( alt7 ) {
case <num> :
{
pushFollow ( FOLLOW_production_in_sdfGrammar390 ) ;
production18 = production ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , production18 . getTree ( ) ) ;
}
break ;
default :
break loop7 ;
}
} while ( true ) ;
}
break ;
case <num> :
{
PRIORITIES19 = ( Token ) input . LT ( <num> ) ;
match ( input , PRIORITIES , FOLLOW_PRIORITIES_in_sdfGrammar395 ) ;
PRIORITIES19_tree = ( CommonTree ) adaptor . create ( PRIORITIES19 ) ;
root_0 = ( CommonTree ) adaptor . becomeRoot ( PRIORITIES19_tree , root_0 ) ;
loop8 :
do {
int alt8 = <num> ;
int LA8_0 = input . LA ( <num> ) ;
if ( ( LA8_0 == ID || ( LA8_0 >= STRING && LA8_0 <= LPAREN ) || LA8_0 == LBRACE || LA8_0 == IMP ) ) {
alt8 = <num> ;
}
switch ( alt8 ) {
case <num> :
{
pushFollow ( FOLLOW_priority_in_sdfGrammar398 ) ;
priority20 = priority ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , priority20 . getTree ( ) ) ;
}
break ;
default :
break loop8 ;
}
} while ( true ) ;
}
break ;
case <num> :
{
STARTSYMBOLS21 = ( Token ) input . LT ( <num> ) ;
match ( input , STARTSYMBOLS , FOLLOW_STARTSYMBOLS_in_sdfGrammar403 ) ;
STARTSYMBOLS21_tree = ( CommonTree ) adaptor . create ( STARTSYMBOLS21 ) ;
root_0 = ( CommonTree ) adaptor . becomeRoot ( STARTSYMBOLS21_tree , root_0 ) ;
loop9 :
do {
int alt9 = <num> ;
int LA9_0 = input . LA ( <num> ) ;
if ( ( LA9_0 == ID || ( LA9_0 >= STRING && LA9_0 <= LPAREN ) || LA9_0 == LBRACE ) ) {
alt9 = <num> ;
}
switch ( alt9 ) {
case <num> :
{
pushFollow ( FOLLOW_symbol_in_sdfGrammar406 ) ;
symbol22 = symbol ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , symbol22 . getTree ( ) ) ;
}
break ;
default :
break loop9 ;
}
} while ( true ) ;
}
break ;
}
}
break ;
case <num> :
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
SORTS23 = ( Token ) input . LT ( <num> ) ;
match ( input , SORTS , FOLLOW_SORTS_in_sdfGrammar413 ) ;
SORTS23_tree = ( CommonTree ) adaptor . create ( SORTS23 ) ;
root_0 = ( CommonTree ) adaptor . becomeRoot ( SORTS23_tree , root_0 ) ;
loop11 :
do {
int alt11 = <num> ;
int LA11_0 = input . LA ( <num> ) ;
if ( ( LA11_0 == ID || ( LA11_0 >= STRING && LA11_0 <= LPAREN ) || LA11_0 == LBRACE ) ) {
alt11 = <num> ;
}
switch ( alt11 ) {
case <num> :
{
pushFollow ( FOLLOW_symbol_in_sdfGrammar416 ) ;
symbol24 = symbol ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , symbol24 . getTree ( ) ) ;
}
break ;
default :
break loop11 ;
}
} while ( true ) ;
}
break ;
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class priority_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final priority_return priority ( ) throws RecognitionException {
priority_return retval = new priority_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token GREATER26 = null ;
group_return group25 = null ;
group_return group27 = null ;
CommonTree <unk> = null ;
RewriteRuleTokenStream stream_GREATER = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleSubtreeStream stream_group = new RewriteRuleSubtreeStream ( adaptor , " ) ;
try {
{
pushFollow ( FOLLOW_group_in_priority429 ) ;
group25 = group ( ) ;
_fsp  ;
stream_group . add ( group25 . getTree ( ) ) ;
loop13 :
do {
int alt13 = <num> ;
int LA13_0 = input . LA ( <num> ) ;
if ( ( LA13_0 == GREATER ) ) {
alt13 = <num> ;
}
switch ( alt13 ) {
case <num> :
{
GREATER26 = ( Token ) input . LT ( <num> ) ;
match ( input , GREATER , FOLLOW_GREATER_in_priority432 ) ;
stream_GREATER . add ( GREATER26 ) ;
pushFollow ( FOLLOW_group_in_priority434 ) ;
group27 = group ( ) ;
_fsp  ;
stream_group . add ( group27 . getTree ( ) ) ;
}
break ;
default :
break loop13 ;
}
} while ( true ) ;
retval . tree = root_0 ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
{
CommonTree root_1 = ( CommonTree ) adaptor . nil ( ) ;
root_1 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( PRIORITY , " ) , root_1 ) ;
if ( ! ( stream_group . hasNext ( ) ) ) {
throw new RewriteEarlyExitException ( ) ;
}
while ( stream_group . hasNext ( ) ) {
adaptor . addChild ( root_1 , stream_group . next ( ) ) ;
}
stream_group . reset ( ) ;
adaptor . addChild ( root_0 , root_1 ) ;
}
}
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class group_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final group_return group ( ) throws RecognitionException {
group_return retval = new group_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
production_return production28 = null ;
RewriteRuleSubtreeStream stream_production = new RewriteRuleSubtreeStream ( adaptor , " ) ;
try {
{
pushFollow ( FOLLOW_production_in_group458 ) ;
production28 = production ( ) ;
_fsp  ;
stream_production . add ( production28 . getTree ( ) ) ;
retval . tree = root_0 ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
{
CommonTree root_1 = ( CommonTree ) adaptor . nil ( ) ;
root_1 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( GROUP , " ) , root_1 ) ;
adaptor . addChild ( root_1 , stream_production . next ( ) ) ;
adaptor . addChild ( root_0 , root_1 ) ;
}
}
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class symbol_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final symbol_return symbol ( ) throws RecognitionException {
symbol_return retval = new symbol_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
markedSymbol_return markedSymbol29 = null ;
list_return list30 = null ;
try {
int alt14 = <num> ;
int LA14_0 = input . LA ( <num> ) ;
if ( ( LA14_0 == ID || ( LA14_0 >= STRING && LA14_0 <= LPAREN ) ) ) {
alt14 = <num> ;
}
else if ( ( LA14_0 == LBRACE ) ) {
alt14 = <num> ;
}
else {
NoViableAltException nvae =
new NoViableAltException ( " , <num> , <num> , input ) ;
throw nvae ;
}
switch ( alt14 ) {
case <num> :
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
pushFollow ( FOLLOW_markedSymbol_in_symbol478 ) ;
markedSymbol29 = markedSymbol ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , markedSymbol29 . getTree ( ) ) ;
}
break ;
case <num> :
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
pushFollow ( FOLLOW_list_in_symbol483 ) ;
list30 = list ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , list30 . getTree ( ) ) ;
}
break ;
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class markedSymbol_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final markedSymbol_return markedSymbol ( ) throws RecognitionException {
markedSymbol_return retval = new markedSymbol_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token s = null ;
nonMarkedSymbol_return a = null ;
CommonTree s_tree = null ;
RewriteRuleTokenStream stream_PLUS = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_QUESTION = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleSubtreeStream stream_nonMarkedSymbol = new RewriteRuleSubtreeStream ( adaptor , " ) ;
try {
{
pushFollow ( FOLLOW_nonMarkedSymbol_in_markedSymbol496 ) ;
a = nonMarkedSymbol ( ) ;
_fsp  ;
stream_nonMarkedSymbol . add ( a . getTree ( ) ) ;
int alt16 = <num> ;
int LA16_0 = input . LA ( <num> ) ;
if ( ( ( LA16_0 >= STAR && LA16_0 <= QUESTION ) ) ) {
alt16 = <num> ;
}
else if ( ( LA16_0 == EOF || ( LA16_0 >= EXPORTS && LA16_0 <= CONTEXTFREE ) || LA16_0 == SORTS || ( LA16_0 >= ID && LA16_0 <= GREATER ) || ( LA16_0 >= STRING && LA16_0 <= RPAREN ) || ( LA16_0 >= COMMA && LA16_0 <= LBRACE ) || LA16_0 == IMP ) ) {
alt16 = <num> ;
}
else {
NoViableAltException nvae =
new NoViableAltException ( " , <num> , <num> , input ) ;
throw nvae ;
}
switch ( alt16 ) {
case <num> :
{
int alt15 = <num> ;
switch ( input . LA ( <num> ) ) {
case STAR :
{
alt15 = <num> ;
}
break ;
case PLUS :
{
alt15 = <num> ;
}
break ;
case QUESTION :
{
alt15 = <num> ;
}
break ;
default :
NoViableAltException nvae =
new NoViableAltException ( " , <num> , <num> , input ) ;
throw nvae ;
}
switch ( alt15 ) {
case <num> :
{
s = ( Token ) input . LT ( <num> ) ;
match ( input , STAR , FOLLOW_STAR_in_markedSymbol506 ) ;
stream_STAR . add ( s ) ;
}
break ;
case <num> :
{
s = ( Token ) input . LT ( <num> ) ;
match ( input , PLUS , FOLLOW_PLUS_in_markedSymbol512 ) ;
stream_PLUS . add ( s ) ;
}
break ;
case <num> :
{
s = ( Token ) input . LT ( <num> ) ;
match ( input , QUESTION , FOLLOW_QUESTION_in_markedSymbol518 ) ;
stream_QUESTION . add ( s ) ;
}
break ;
}
retval . tree = root_0 ;
RewriteRuleTokenStream stream_s = new RewriteRuleTokenStream ( adaptor , " , s ) ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
RewriteRuleSubtreeStream stream_a = new RewriteRuleSubtreeStream ( adaptor , " , a != null ? a . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
{
CommonTree root_1 = ( CommonTree ) adaptor . nil ( ) ;
root_1 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( MARKEDSYMBOL , " ) , root_1 ) ;
adaptor . addChild ( root_1 , stream_a . next ( ) ) ;
adaptor . addChild ( root_1 , stream_s . next ( ) ) ;
adaptor . addChild ( root_0 , root_1 ) ;
}
}
}
break ;
case <num> :
{
retval . tree = root_0 ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
adaptor . addChild ( root_0 , stream_nonMarkedSymbol . next ( ) ) ;
}
}
break ;
}
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class nonMarkedSymbol_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final nonMarkedSymbol_return nonMarkedSymbol ( ) throws RecognitionException {
nonMarkedSymbol_return retval = new nonMarkedSymbol_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token STRING32 = null ;
Token LPAREN33 = null ;
Token RPAREN35 = null ;
parameterizedSort_return parameterizedSort31 = null ;
symbol_return symbol34 = null ;
CommonTree STRING32_tree = null ;
CommonTree <unk> = null ;
CommonTree <unk> = null ;
RewriteRuleTokenStream stream_RPAREN = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_LPAREN = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleSubtreeStream stream_symbol = new RewriteRuleSubtreeStream ( adaptor , " ) ;
try {
int alt18 = <num> ;
switch ( input . LA ( <num> ) ) {
case ID :
{
alt18 = <num> ;
}
break ;
case STRING :
{
alt18 = <num> ;
}
break ;
case LPAREN :
{
alt18 = <num> ;
}
break ;
default :
NoViableAltException nvae =
new NoViableAltException ( " , <num> , <num> , input ) ;
throw nvae ;
}
switch ( alt18 ) {
case <num> :
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
pushFollow ( FOLLOW_parameterizedSort_in_nonMarkedSymbol559 ) ;
parameterizedSort31 = parameterizedSort ( ) ;
_fsp  ;
adaptor . addChild ( root_0 , parameterizedSort31 . getTree ( ) ) ;
}
break ;
case <num> :
{
root_0 = ( CommonTree ) adaptor . nil ( ) ;
STRING32 = ( Token ) input . LT ( <num> ) ;
match ( input , STRING , FOLLOW_STRING_in_nonMarkedSymbol565 ) ;
STRING32_tree = ( CommonTree ) adaptor . create ( STRING32 ) ;
root_0 = ( CommonTree ) adaptor . becomeRoot ( STRING32_tree , root_0 ) ;
}
break ;
case <num> :
{
LPAREN33 = ( Token ) input . LT ( <num> ) ;
match ( input , LPAREN , FOLLOW_LPAREN_in_nonMarkedSymbol575 ) ;
stream_LPAREN . add ( LPAREN33 ) ;
loop17 :
do {
int alt17 = <num> ;
int LA17_0 = input . LA ( <num> ) ;
if ( ( LA17_0 == ID || ( LA17_0 >= STRING && LA17_0 <= LPAREN ) || LA17_0 == LBRACE ) ) {
alt17 = <num> ;
}
switch ( alt17 ) {
case <num> :
{
pushFollow ( FOLLOW_symbol_in_nonMarkedSymbol577 ) ;
symbol34 = symbol ( ) ;
_fsp  ;
stream_symbol . add ( symbol34 . getTree ( ) ) ;
}
break ;
default :
break loop17 ;
}
} while ( true ) ;
RPAREN35 = ( Token ) input . LT ( <num> ) ;
match ( input , RPAREN , FOLLOW_RPAREN_in_nonMarkedSymbol580 ) ;
stream_RPAREN . add ( RPAREN35 ) ;
retval . tree = root_0 ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
{
CommonTree root_1 = ( CommonTree ) adaptor . nil ( ) ;
root_1 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( COMPOUNDSYMBOL , " ) , root_1 ) ;
while ( stream_symbol . hasNext ( ) ) {
adaptor . addChild ( root_1 , stream_symbol . next ( ) ) ;
}
stream_symbol . reset ( ) ;
adaptor . addChild ( root_0 , root_1 ) ;
}
}
}
break ;
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class parameterizedSort_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final parameterizedSort_return parameterizedSort ( ) throws RecognitionException {
parameterizedSort_return retval = new parameterizedSort_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token LDOUBLEBRACKET37 = null ;
Token COMMA39 = null ;
Token RDOUBLEBRACKET41 = null ;
sort_return sort36 = null ;
symbol_return symbol38 = null ;
symbol_return symbol40 = null ;
CommonTree <unk> = null ;
CommonTree <unk> = null ;
CommonTree <unk> = null ;
RewriteRuleTokenStream stream_LDOUBLEBRACKET = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_RDOUBLEBRACKET = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_COMMA = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleSubtreeStream stream_sort = new RewriteRuleSubtreeStream ( adaptor , " ) ;
RewriteRuleSubtreeStream stream_symbol = new RewriteRuleSubtreeStream ( adaptor , " ) ;
try {
{
pushFollow ( FOLLOW_sort_in_parameterizedSort602 ) ;
sort36 = sort ( ) ;
_fsp  ;
stream_sort . add ( sort36 . getTree ( ) ) ;
int alt20 = <num> ;
int LA20_0 = input . LA ( <num> ) ;
if ( ( LA20_0 == LDOUBLEBRACKET ) ) {
alt20 = <num> ;
}
else if ( ( LA20_0 == EOF || ( LA20_0 >= EXPORTS && LA20_0 <= CONTEXTFREE ) || LA20_0 == SORTS || ( LA20_0 >= ID && LA20_0 <= RPAREN ) || ( LA20_0 >= COMMA && LA20_0 <= LBRACE ) || LA20_0 == IMP ) ) {
alt20 = <num> ;
}
else {
NoViableAltException nvae =
new NoViableAltException ( " , <num> , <num> , input ) ;
throw nvae ;
}
switch ( alt20 ) {
case <num> :
{
LDOUBLEBRACKET37 = ( Token ) input . LT ( <num> ) ;
match ( input , LDOUBLEBRACKET , FOLLOW_LDOUBLEBRACKET_in_parameterizedSort609 ) ;
stream_LDOUBLEBRACKET . add ( LDOUBLEBRACKET37 ) ;
pushFollow ( FOLLOW_symbol_in_parameterizedSort611 ) ;
symbol38 = symbol ( ) ;
_fsp  ;
stream_symbol . add ( symbol38 . getTree ( ) ) ;
loop19 :
do {
int alt19 = <num> ;
int LA19_0 = input . LA ( <num> ) ;
if ( ( LA19_0 == COMMA ) ) {
alt19 = <num> ;
}
switch ( alt19 ) {
case <num> :
{
COMMA39 = ( Token ) input . LT ( <num> ) ;
match ( input , COMMA , FOLLOW_COMMA_in_parameterizedSort614 ) ;
stream_COMMA . add ( COMMA39 ) ;
pushFollow ( FOLLOW_symbol_in_parameterizedSort616 ) ;
symbol40 = symbol ( ) ;
_fsp  ;
stream_symbol . add ( symbol40 . getTree ( ) ) ;
}
break ;
default :
break loop19 ;
}
} while ( true ) ;
RDOUBLEBRACKET41 = ( Token ) input . LT ( <num> ) ;
match ( input , RDOUBLEBRACKET , FOLLOW_RDOUBLEBRACKET_in_parameterizedSort621 ) ;
stream_RDOUBLEBRACKET . add ( RDOUBLEBRACKET41 ) ;
retval . tree = root_0 ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
{
CommonTree root_1 = ( CommonTree ) adaptor . nil ( ) ;
root_1 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( PARAMETERIZEDSYMBOL , " ) , root_1 ) ;
adaptor . addChild ( root_1 , stream_sort . next ( ) ) ;
if ( ! ( stream_symbol . hasNext ( ) ) ) {
throw new RewriteEarlyExitException ( ) ;
}
while ( stream_symbol . hasNext ( ) ) {
adaptor . addChild ( root_1 , stream_symbol . next ( ) ) ;
}
stream_symbol . reset ( ) ;
adaptor . addChild ( root_0 , root_1 ) ;
}
}
}
break ;
case <num> :
{
retval . tree = root_0 ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
adaptor . addChild ( root_0 , stream_sort . next ( ) ) ;
}
}
break ;
}
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class sort_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final sort_return sort ( ) throws RecognitionException {
sort_return retval = new sort_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token id = null ;
CommonTree id_tree = null ;
RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream ( adaptor , " ) ;
try {
{
id = ( Token ) input . LT ( <num> ) ;
match ( input , ID , FOLLOW_ID_in_sort659 ) ;
stream_ID . add ( id ) ;
retval . tree = root_0 ;
RewriteRuleTokenStream stream_id = new RewriteRuleTokenStream ( adaptor , " , id ) ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
{
CommonTree root_1 = ( CommonTree ) adaptor . nil ( ) ;
root_1 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( SORT , " ) , root_1 ) ;
adaptor . addChild ( root_1 , stream_id . next ( ) ) ;
adaptor . addChild ( root_0 , root_1 ) ;
}
}
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class list_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final list_return list ( ) throws RecognitionException {
list_return retval = new list_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token s = null ;
Token m = null ;
Token LBRACE42 = null ;
Token RBRACE43 = null ;
symbol_return o = null ;
CommonTree s_tree = null ;
CommonTree <unk> = null ;
CommonTree <unk> = null ;
CommonTree <unk> = null ;
RewriteRuleTokenStream stream_PLUS = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_STAR = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_RBRACE = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_LBRACE = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_STRING = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleSubtreeStream stream_symbol = new RewriteRuleSubtreeStream ( adaptor , " ) ;
try {
{
LBRACE42 = ( Token ) input . LT ( <num> ) ;
match ( input , LBRACE , FOLLOW_LBRACE_in_list680 ) ;
stream_LBRACE . add ( LBRACE42 ) ;
pushFollow ( FOLLOW_symbol_in_list684 ) ;
o = symbol ( ) ;
_fsp  ;
stream_symbol . add ( o . getTree ( ) ) ;
s = ( Token ) input . LT ( <num> ) ;
match ( input , STRING , FOLLOW_STRING_in_list688 ) ;
stream_STRING . add ( s ) ;
RBRACE43 = ( Token ) input . LT ( <num> ) ;
match ( input , RBRACE , FOLLOW_RBRACE_in_list690 ) ;
stream_RBRACE . add ( RBRACE43 ) ;
int alt21 = <num> ;
int LA21_0 = input . LA ( <num> ) ;
if ( ( LA21_0 == PLUS ) ) {
alt21 = <num> ;
}
else if ( ( LA21_0 == STAR ) ) {
alt21 = <num> ;
}
else {
NoViableAltException nvae =
new NoViableAltException ( " , <num> , <num> , input ) ;
throw nvae ;
}
switch ( alt21 ) {
case <num> :
{
m = ( Token ) input . LT ( <num> ) ;
match ( input , PLUS , FOLLOW_PLUS_in_list695 ) ;
stream_PLUS . add ( m ) ;
}
break ;
case <num> :
{
m = ( Token ) input . LT ( <num> ) ;
match ( input , STAR , FOLLOW_STAR_in_list701 ) ;
stream_STAR . add ( m ) ;
}
break ;
}
retval . tree = root_0 ;
RewriteRuleTokenStream stream_s = new RewriteRuleTokenStream ( adaptor , " , s ) ;
RewriteRuleTokenStream stream_m = new RewriteRuleTokenStream ( adaptor , " , m ) ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
RewriteRuleSubtreeStream stream_o = new RewriteRuleSubtreeStream ( adaptor , " , o != null ? o . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
{
CommonTree root_1 = ( CommonTree ) adaptor . nil ( ) ;
root_1 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( LIST , " ) , root_1 ) ;
{
CommonTree root_2 = ( CommonTree ) adaptor . nil ( ) ;
root_2 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( ORIGIN , " ) , root_2 ) ;
adaptor . addChild ( root_2 , stream_o . next ( ) ) ;
adaptor . addChild ( root_1 , root_2 ) ;
}
{
CommonTree root_2 = ( CommonTree ) adaptor . nil ( ) ;
root_2 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( SEPARATOR , " ) , root_2 ) ;
adaptor . addChild ( root_2 , stream_s . next ( ) ) ;
adaptor . addChild ( root_1 , root_2 ) ;
}
{
CommonTree root_2 = ( CommonTree ) adaptor . nil ( ) ;
root_2 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( MULTIPLICITY , " ) , root_2 ) ;
adaptor . addChild ( root_2 , stream_m . next ( ) ) ;
adaptor . addChild ( root_1 , root_2 ) ;
}
adaptor . addChild ( root_0 , root_1 ) ;
}
}
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class attribute_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final attribute_return attribute ( ) throws RecognitionException {
attribute_return retval = new attribute_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token id = null ;
CommonTree id_tree = null ;
RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream ( adaptor , " ) ;
try {
{
id = ( Token ) input . LT ( <num> ) ;
match ( input , ID , FOLLOW_ID_in_attribute743 ) ;
stream_ID . add ( id ) ;
retval . tree = root_0 ;
RewriteRuleTokenStream stream_id = new RewriteRuleTokenStream ( adaptor , " , id ) ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
{
CommonTree root_1 = ( CommonTree ) adaptor . nil ( ) ;
root_1 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( ATTRIBUTE , " ) , root_1 ) ;
adaptor . addChild ( root_1 , stream_id . next ( ) ) ;
adaptor . addChild ( root_0 , root_1 ) ;
}
}
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static class production_return extends ParserRuleReturnScope {
CommonTree tree ;
public Object getTree ( ) { return tree ; }
} ;
public final production_return production ( ) throws RecognitionException {
production_return retval = new production_return ( ) ;
retval . start = input . LT ( <num> ) ;
CommonTree root_0 = null ;
Token IMP44 = null ;
Token LBRACE45 = null ;
Token RBRACE46 = null ;
List list_l = null ;
symbol_return r = null ;
attribute_return a = null ;
<unk> l = null ;
CommonTree <unk> = null ;
CommonTree <unk> = null ;
CommonTree <unk> = null ;
RewriteRuleTokenStream stream_IMP = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_RBRACE = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleTokenStream stream_LBRACE = new RewriteRuleTokenStream ( adaptor , " ) ;
RewriteRuleSubtreeStream stream_symbol = new RewriteRuleSubtreeStream ( adaptor , " ) ;
RewriteRuleSubtreeStream stream_attribute = new RewriteRuleSubtreeStream ( adaptor , " ) ;
try {
{
loop22 :
do {
int alt22 = <num> ;
int LA22_0 = input . LA ( <num> ) ;
if ( ( LA22_0 == ID || ( LA22_0 >= STRING && LA22_0 <= LPAREN ) || LA22_0 == LBRACE ) ) {
alt22 = <num> ;
}
switch ( alt22 ) {
case <num> :
{
pushFollow ( FOLLOW_symbol_in_production766 ) ;
l = symbol ( ) ;
_fsp  ;
stream_symbol . add ( l . getTree ( ) ) ;
if ( list_l == null ) list_l = new ArrayList ( ) ;
list_l . add ( l ) ;
}
break ;
default :
break loop22 ;
}
} while ( true ) ;
IMP44 = ( Token ) input . LT ( <num> ) ;
match ( input , IMP , FOLLOW_IMP_in_production769 ) ;
stream_IMP . add ( IMP44 ) ;
pushFollow ( FOLLOW_symbol_in_production773 ) ;
r = symbol ( ) ;
_fsp  ;
stream_symbol . add ( r . getTree ( ) ) ;
int alt23 = <num> ;
int LA23_0 = input . LA ( <num> ) ;
if ( ( LA23_0 == LBRACE ) ) {
int LA23_1 = input . LA ( <num> ) ;
if ( ( LA23_1 == ID ) ) {
int LA23_3 = input . LA ( <num> ) ;
if ( ( LA23_3 == RBRACE ) ) {
alt23 = <num> ;
}
}
}
switch ( alt23 ) {
case <num> :
{
LBRACE45 = ( Token ) input . LT ( <num> ) ;
match ( input , LBRACE , FOLLOW_LBRACE_in_production776 ) ;
stream_LBRACE . add ( LBRACE45 ) ;
pushFollow ( FOLLOW_attribute_in_production780 ) ;
a = attribute ( ) ;
_fsp  ;
stream_attribute . add ( a . getTree ( ) ) ;
RBRACE46 = ( Token ) input . LT ( <num> ) ;
match ( input , RBRACE , FOLLOW_RBRACE_in_production782 ) ;
stream_RBRACE . add ( RBRACE46 ) ;
}
break ;
}
retval . tree = root_0 ;
RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , " , retval != null ? retval . tree : null ) ;
RewriteRuleSubtreeStream stream_r = new RewriteRuleSubtreeStream ( adaptor , " , r != null ? r . tree : null ) ;
RewriteRuleSubtreeStream stream_l = new RewriteRuleSubtreeStream ( adaptor , " , list_l ) ;
root_0 = ( CommonTree ) adaptor . nil ( ) ;
{
{
CommonTree root_1 = ( CommonTree ) adaptor . nil ( ) ;
root_1 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( PRODUCTION , " ) , root_1 ) ;
{
CommonTree root_2 = ( CommonTree ) adaptor . nil ( ) ;
root_2 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( LEFT , " ) , root_2 ) ;
while ( stream_l . hasNext ( ) ) {
adaptor . addChild ( root_2 , ( ( ParserRuleReturnScope ) stream_l . next ( ) ) . getTree ( ) ) ;
}
stream_l . reset ( ) ;
adaptor . addChild ( root_1 , root_2 ) ;
}
{
CommonTree root_2 = ( CommonTree ) adaptor . nil ( ) ;
root_2 = ( CommonTree ) adaptor . becomeRoot ( adaptor . create ( RIGHT , " ) , root_2 ) ;
adaptor . addChild ( root_2 , stream_r . next ( ) ) ;
adaptor . addChild ( root_1 , root_2 ) ;
}
adaptor . addChild ( root_0 , root_1 ) ;
}
}
}
retval . stop = input . LT (  <num> ) ;
retval . tree = ( CommonTree ) adaptor . rulePostProcessing ( root_0 ) ;
adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ;
}
catch ( RecognitionException re ) {
reportError ( re ) ;
recover ( input , re ) ;
}
finally {
}
return retval ;
}
public static final BitSet FOLLOW_MODULE_in_module256 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_moduleName_in_module259 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_impSection_in_module261 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_section_in_module264 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_EOF_in_module267 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_moduleId_in_moduleName280 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_moduleWord_in_moduleId302 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_SLASH_in_moduleId305 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_moduleWord_in_moduleId308 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_ID_in_moduleWord321 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_IMPORTS_in_impSection333 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_imports_in_impSection336 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_moduleName_in_imports348 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_EXPORTS_in_section362 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_HIDDENS_in_section367 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_sdfGrammar_in_section371 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_CONTEXTFREE_in_sdfGrammar383 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_SYNTAX_in_sdfGrammar387 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_production_in_sdfGrammar390 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_PRIORITIES_in_sdfGrammar395 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_priority_in_sdfGrammar398 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_STARTSYMBOLS_in_sdfGrammar403 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_symbol_in_sdfGrammar406 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_SORTS_in_sdfGrammar413 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_symbol_in_sdfGrammar416 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_group_in_priority429 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_GREATER_in_priority432 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_group_in_priority434 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_production_in_group458 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_markedSymbol_in_symbol478 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_list_in_symbol483 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_nonMarkedSymbol_in_markedSymbol496 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_STAR_in_markedSymbol506 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_PLUS_in_markedSymbol512 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_QUESTION_in_markedSymbol518 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_parameterizedSort_in_nonMarkedSymbol559 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_STRING_in_nonMarkedSymbol565 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_LPAREN_in_nonMarkedSymbol575 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_symbol_in_nonMarkedSymbol577 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_RPAREN_in_nonMarkedSymbol580 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_sort_in_parameterizedSort602 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_LDOUBLEBRACKET_in_parameterizedSort609 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_symbol_in_parameterizedSort611 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_COMMA_in_parameterizedSort614 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_symbol_in_parameterizedSort616 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_RDOUBLEBRACKET_in_parameterizedSort621 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_ID_in_sort659 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_LBRACE_in_list680 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_symbol_in_list684 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_STRING_in_list688 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_RBRACE_in_list690 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_PLUS_in_list695 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_STAR_in_list701 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_ID_in_attribute743 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_symbol_in_production766 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_IMP_in_production769 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_symbol_in_production773 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_LBRACE_in_production776 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_attribute_in_production780 = new BitSet ( new long [ ] { <num> } ) ;
public static final BitSet FOLLOW_RBRACE_in_production782 = new BitSet ( new long [ ] { <num> } ) ;
package unifier . similarity ;
public class Element {
private String name = " ;
public Element ( ) { }
public boolean isAssociation ( ) {
return false ;
}
public Element ( String name ) {
this . name = name ;
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
public String toString ( ) {
return name ;
}
}
package unifier . util ;
import javax . swing . DefaultListCellRenderer ;
import javax . swing . JList ;
import meta . ModelRegDef ;
import java . awt . Component ;
import java . sql . SQLException ;
import meta . SampleRegDef ;
public class SampleRegDefCellRenderer extends DefaultListCellRenderer {
public Component getListCellRendererComponent (
JList list ,
Object value ,
int index ,
boolean iss ,
boolean chf )
{
if ( value instanceof SampleRegDef ) {
SampleRegDef sample = ( SampleRegDef ) value ;
String sampleName = " ;
try {
sampleName = sample . get_name ( ) ;
} catch ( SQLException ex ) {
}
super . getListCellRendererComponent ( list , sampleName , index , iss , chf ) ;
}
else {
super . getListCellRendererComponent ( list , value , index , iss , chf ) ;
}
return this ;
}
}
package unifier ;
import javax . swing . JFrame ;
import java . awt . Dimension ;
import java . awt . Toolkit ;
public class CenteredFrame extends JFrame {
protected void center ( ) {
Dimension screenSize ;
Dimension frameSize ;
pack ( ) ;
screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ;
frameSize = getSize ( ) ;
if ( frameSize . height > screenSize . height ) frameSize . height = screenSize . height ;
if ( frameSize . width > screenSize . width ) frameSize . width = screenSize . width ;
setSize ( frameSize ) ;
setLocation ( ( screenSize . width  frameSize . width ) / <num> , ( screenSize . height  frameSize . height ) / <num> ) ;
setVisible ( true ) ;
}
}
package com . roguecomma . bombapp ;
public final class Manifest {
public static final class permission {
public static final String C2D_MESSAGE = " ;
}
}
package com . roguecomma . bombapp ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . widget . Button ;
import com . viximo . android . * ;
import java . net . MalformedURLException ;
import java . net . URL ;
public class MainMenuActivity extends Activity {
private static final String TAG = MainMenuActivity . class . getName ( ) ;
private static User user ;
private static final String BOMBFIA = " ;
public static User getUser ( ) {
return user ;
}
private static void setUser ( User viximoUser ) {
user = viximoUser ;
}
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
Button layBombButton = ( Button ) findViewById ( R . id . layBombButton ) ;
layBombButton . setOnClickListener ( new LayBombButtonListener ( ) ) ;
Button addFriendsToBombfiaButton = ( Button ) findViewById ( R . id . addFriendsToBombfiaButton ) ;
addFriendsToBombfiaButton . setOnClickListener ( new AddFriendsToBombfiaListener ( ) ) ;
Button inviteFriendsButton = ( Button ) findViewById ( R . id . inviteFriendsButton ) ;
inviteFriendsButton . setOnClickListener ( new InviteFriendsButtonListener ( ) ) ;
Button moreGamesButton = ( Button ) findViewById ( R . id . moreGamesButton ) ;
moreGamesButton . setOnClickListener ( new MoreGamesButtonListener ( ) ) ;
Button messagesButton = ( Button ) findViewById ( R . id . messagesButton ) ;
messagesButton . setOnClickListener ( new MessagesButtonListener ( ) ) ;
Viximo . getUser ( new UserCallback ( ) ) ;
}
@Override
protected void onActivityResult ( int requestCode , int resultCode , Intent data ) {
super . onActivityResult ( requestCode , resultCode , data ) ;
if ( requestCode == <num> && resultCode == <num> ) {
final String userId = data . getStringExtra ( " ) ;
final String userName = data . getStringExtra ( " ) ;
AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ;
builder . setMessage ( " + userName + " )
. setCancelable ( false )
. setPositiveButton ( " , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int id ) {
UserFilter userFilter = new UserFilter ( ) ;
userFilter . addID ( userId ) ;
MessageData message = new MessageData ( getUser ( ) . getName ( ) + " , getBombIconURL ( ) , " ) { {
<unk> ( true ) ;
} } ;
Viximo . sendMessage ( userFilter , message , new Callback < Message [ ] > ( ) {
@Override
public void onSuccess ( Message [ ] messages ) {
if ( messages != null ) {
for ( Message bombMessage : messages ) {
Log . e ( TAG , " + bombMessage . <unk> ( ) ) ;
}
}
}
} ) ;
dialog . dismiss ( ) ;
}
} )
. setNegativeButton ( " , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int id ) {
dialog . cancel ( ) ;
}
} ) ;
AlertDialog alert = builder . create ( ) ;
alert . show ( ) ;
}
}
private URL getBombIconURL ( ) {
URL iconURL = null ;
try {
iconURL = new URL ( " ) ;
} catch ( MalformedURLException e ) {
Log . e ( TAG , " , e ) ;
}
return iconURL ;
}
private static class AddFriendsToBombfiaListener implements View . OnClickListener {
@Override
public void onClick ( View view ) {
FriendSelectorUI friendSelectorUI = new FriendSelectorUI ( <num> ) ;
friendSelectorUI . <unk> ( true ) ;
friendSelectorUI . setPrompt ( " ) ;
Viximo . getFriends ( friendSelectorUI , new Callback < User [ ] > ( ) {
@Override
public void onSuccess ( User [ ] users ) {
if ( users != null ) {
for ( User friend : users ) {
try {
Viximo . <unk> ( BOMBFIA , friend . getID ( ) , true , new Callback < User > ( ) {
@Override
public void onSuccess ( User user ) {
Log . e ( TAG , " + user . getName ( ) ) ;
}
} ) ;
} catch ( Exception e ) {
Log . e ( TAG , " , e ) ;
}
}
}
}
} ) ;
}
}
private static class InviteFriendsButtonListener implements View . OnClickListener {
@Override
public void onClick ( View view ) {
Viximo . <unk> ( " , new Callback < Invite > ( ) {
@Override
public void onSuccess ( Invite result ) {
Log . d ( TAG , " ) ;
}
} ) ;
}
}
private static class UserCallback extends Callback < com . viximo . android . User > {
@Override
public void onSuccess ( final com . viximo . android . User user ) {
if ( user == null ) {
Viximo . getUser ( new UserCallback ( ) ) ;
} else {
Log . i ( TAG , " + user . getName ( ) ) ;
setUser ( user ) ;
}
}
}
private static class MoreGamesButtonListener implements View . OnClickListener {
@Override
public void onClick ( View view ) {
Viximo . showInterface ( Viximo . UISection . <unk> ) ;
}
}
private static class MessagesButtonListener implements View . OnClickListener {
@Override
public void onClick ( View view ) {
Viximo . showInterface ( Viximo . UISection . <unk> ) ;
}
}
private class LayBombButtonListener implements View . OnClickListener {
@Override
public void onClick ( View view ) {
FriendSelectorUI ui = new FriendSelectorUI ( <num> ) ;
ui . <unk> ( BOMBFIA ) ;
ui . setPrompt ( " ) ;
Viximo . getFriends ( ui , new Callback < com . viximo . android . User [ ] > ( ) {
@Override
public void onSuccess ( com . viximo . android . User [ ] users ) {
if ( users != null ) {
String userID = users [ <num> ] . getID ( ) ;
for ( com . viximo . android . User user : users ) {
Log . d ( TAG , " + user . getName ( ) ) ;
}
Intent intent = new Intent ( MainMenuActivity . this , MapSelectionActivity . class ) ;
intent . putExtra ( " , userID ) ;
intent . putExtra ( " , users [ <num> ] . getName ( ) ) ;
startActivityForResult ( intent , <num> ) ;
}
}
} ) ;
}
}
}
package com . roguecomma . bombapp ;
public final class BuildConfig {
public final static boolean DEBUG = true ;
package com . roguecomma . bombapp ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . Button ;
import com . viximo . android . Viximo ;
public class SplashActivity extends Activity {
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
Viximo . initialize ( this , " , " , null ) ;
setContentView ( R . layout . splash ) ;
Button playButton = ( Button ) findViewById ( R . id . PlayButton ) ;
playButton . setOnClickListener ( new View . OnClickListener ( ) {
@Override
public void onClick ( View view ) {
Intent intent = new Intent ( SplashActivity . this , MainMenuActivity . class ) ;
startActivity ( intent ) ;
}
} ) ;
}
}
package com . viximo . android ;
public final class R {
public static final class attr {
}
public static final class layout {
public static int main = <num> ;
}
public static final class string {
public static int app_name = <num> ;
}
public static final class style {
public static int CoreDialog = <num> ;
public static int CoreDialogAnimation = <num> ;
}
}
package com . viximo . android ;
public final class Manifest {
public static final class permission {
public static final String C2D_MESSAGE = " ;
}
}
package com . viximo . android ;
public final class R {
public static final class attr {
}
public static final class drawable {
public static final int bomb_icon = <num> ;
public static final int custom_button = <num> ;
public static final int game_bg = <num> ;
public static final int loading_bg = <num> ;
public static final int sf = <num> ;
}
public static final class id {
public static final int PlayButton = <num> ;
public static final int RelativeLayout01 = <num> ;
public static final int addFriendsToBombfiaButton = <num> ;
public static final int inviteFriendsButton = <num> ;
public static final int layBombButton = <num> ;
public static final int mapsLayout = <num> ;
public static final int messagesButton = <num> ;
public static final int moreGamesButton = <num> ;
public static final int sf_map = <num> ;
}
public static final class layout {
public static final int main = <num> ;
public static final int maps = <num> ;
public static final int splash = <num> ;
}
public static final class string {
public static final int addFriendsToBombfiaButtonLabel = <num> ;
public static final int app_name = <num> ;
public static final int inviteFriendsButtonLabel = <num> ;
public static final int layBombButtonLabel = <num> ;
public static final int map_title = <num> ;
public static final int messagesButtonLabel = <num> ;
public static final int moreGamesButtonLabel = <num> ;
}
public static final class style {
public static final int CoreDialog = <num> ;
public static final int CoreDialogAnimation = <num> ;
}
}
package com . roguecomma . bombapp ;
import android . app . Activity ;
import android . content . Intent ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . ImageView ;
public class MapSelectionActivity extends Activity {
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . maps ) ;
ImageView imageView = ( ImageView ) findViewById ( R . id . sf_map ) ;
imageView . setOnClickListener ( new View . OnClickListener ( ) {
@Override
public void onClick ( View view ) {
Intent in = getIntent ( ) ;
setResult ( <num> , in ) ;
finish ( ) ;
}
} ) ;
}
}
package com . roguecomma . bombapp ;
public final class R {
public static final class attr {
}
public static final class drawable {
public static final int bomb_icon = <num> ;
public static final int custom_button = <num> ;
public static final int game_bg = <num> ;
public static final int loading_bg = <num> ;
public static final int sf = <num> ;
}
public static final class id {
public static final int PlayButton = <num> ;
public static final int RelativeLayout01 = <num> ;
public static final int addFriendsToBombfiaButton = <num> ;
public static final int inviteFriendsButton = <num> ;
public static final int layBombButton = <num> ;
public static final int mapsLayout = <num> ;
public static final int messagesButton = <num> ;
public static final int moreGamesButton = <num> ;
public static final int sf_map = <num> ;
}
public static final class layout {
public static final int main = <num> ;
public static final int maps = <num> ;
public static final int splash = <num> ;
}
public static final class string {
public static final int addFriendsToBombfiaButtonLabel = <num> ;
public static final int app_name = <num> ;
public static final int inviteFriendsButtonLabel = <num> ;
public static final int layBombButtonLabel = <num> ;
public static final int map_title = <num> ;
public static final int messagesButtonLabel = <num> ;
public static final int moreGamesButtonLabel = <num> ;
}
public static final class style {
public static final int CoreDialog = <num> ;
public static final int CoreDialogAnimation = <num> ;
}
}
package com . viximo . android ;
public final class BuildConfig {
public final static boolean DEBUG = true ;
package controllers ;
public class routes {
public static final controllers . ReverseAssets Assets = new controllers . ReverseAssets ( ) ;
public static final controllers . ReverseCollection Collection = new controllers . ReverseCollection ( ) ;
public static final controllers . ReverseLogin Login = new controllers . ReverseLogin ( ) ;
public static final controllers . ReverseApplication Application = new controllers . ReverseApplication ( ) ;
public static final controllers . ReverseUserImage UserImage = new controllers . ReverseUserImage ( ) ;
public static class javascript {
public static final controllers . javascript . ReverseAssets Assets = new controllers . javascript . ReverseAssets ( ) ;
public static final controllers . javascript . ReverseCollection Collection = new controllers . javascript . ReverseCollection ( ) ;
public static final controllers . javascript . ReverseLogin Login = new controllers . javascript . ReverseLogin ( ) ;
public static final controllers . javascript . ReverseApplication Application = new controllers . javascript . ReverseApplication ( ) ;
public static final controllers . javascript . ReverseUserImage UserImage = new controllers . javascript . ReverseUserImage ( ) ;
}
public static class ref {
public static final controllers . ref . ReverseAssets Assets = new controllers . ref . ReverseAssets ( ) ;
public static final controllers . ref . ReverseCollection Collection = new controllers . ref . ReverseCollection ( ) ;
public static final controllers . ref . ReverseLogin Login = new controllers . ref . ReverseLogin ( ) ;
public static final controllers . ref . ReverseApplication Application = new controllers . ref . ReverseApplication ( ) ;
public static final controllers . ref . ReverseUserImage UserImage = new controllers . ref . ReverseUserImage ( ) ;
}
}
package jms . mq . topic ;
import javax . jms . Destination ;
import javax . jms . JMSException ;
import jms . mq . MQConfig ;
import jms . mq . MQFacade ;
import com . ibm . mq . jms . MQMessageConsumer ;
import com . ibm . mq . jms . MQMessageProducer ;
import com . ibm . mq . jms . MQTopic ;
public class MQTopicFacade extends MQFacade {
private String topicName ;
public String getTopicName ( ) {
return topicName ;
}
public void setTopicName ( String topicName ) {
this . topicName = topicName ;
}
private MQTopic topic ;
public MQTopic getTopic ( ) {
return topic ;
}
public void setTopic ( MQTopic topic ) {
this . topic = topic ;
}
@Override
protected void initializeFacade ( ) throws Exception {
setTopicName ( " + MQConfig . getInstance ( ) . getTopicOrQueueName ( ) ) ;
final MQTopic topic = ( MQTopic ) getSession ( )
. createTopic ( getTopicName ( ) ) ;
if ( topic == null ) {
throw new Exception ( " ) ;
}
setTopic ( topic ) ;
try {
getConnectionBuilder ( ) . getMqConnection ( ) . start ( ) ;
} catch ( JMSException e ) {
throw new Exception ( " ) ;
}
}
@Override
protected Destination getJMSDestination ( ) {
return getTopic ( ) ;
}
@Override
public MQMessageConsumer getMQMessageConsumer ( ) {
return null ;
}
@Override
public MQMessageProducer getMQMessageProducer ( ) {
return null ;
}
}
package jms . mq ;
import java . util . LinkedList ;
import java . util . List ;
public class MQState {
public MQState ( ) {
sendingTimes = new LinkedList < Long > ( ) ;
receivingTimes = new LinkedList < Long > ( ) ;
}
private List < Long > sendingTimes = null ;
public void addSendingTime ( Long time ) {
this . sendingTimes . add ( time ) ;
}
public void addReceivingTime ( Long time ) {
this . receivingTimes . add ( time ) ;
}
private List < Long > receivingTimes = null ;
public List < Long > getSendingTimes ( ) {
return sendingTimes ;
}
public List < Long > getReceivingTimes ( ) {
return receivingTimes ;
}
}
package jms . mq . topic ;
import javax . jms . JMSException ;
import javax . jms . Session ;
import jms . mq . MQConnectionBuilder ;
import com . ibm . mq . jms . MQConnection ;
import com . ibm . mq . jms . MQConnectionFactory ;
import com . ibm . mq . jms . MQSession ;
import com . ibm . mq . jms . MQTopicConnectionFactory ;
public class MQTopicConnectionBuilder extends MQConnectionBuilder {
@Override
public MQConnectionFactory buildConnectionFactory ( String hostName ,
Integer port , Integer transportType , String queueManager ,
String chanel ) {
MQTopicConnectionFactory topicConnectionFactory = new MQTopicConnectionFactory ( ) ;
try {
topicConnectionFactory . setHostName ( hostName ) ;
topicConnectionFactory . setPort ( port ) ;
topicConnectionFactory . setTransportType ( transportType ) ;
topicConnectionFactory . setQueueManager ( queueManager ) ;
topicConnectionFactory . setChannel ( chanel ) ;
return topicConnectionFactory ;
} catch ( JMSException e ) {
return null ;
}
}
@Override
public MQConnection buildConnection ( ) {
try {
return ( MQConnection ) ( ( MQTopicConnectionFactory ) getConnectionFactory ( ) )
. <unk> ( ) ;
} catch ( JMSException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
@Override
public MQSession buildSession ( ) {
try {
return ( MQSession ) getMqConnection ( ) . createSession ( true ,
Session . AUTO_ACKNOWLEDGE ) ;
} catch ( JMSException e ) {
return null ;
}
}
}
package jms . mq ;
import com . ibm . mq . jms . MQConnection ;
import com . ibm . mq . jms . MQConnectionFactory ;
import com . ibm . mq . jms . MQSession ;
public abstract class MQConnectionBuilder {
private MQConnectionFactory connectionFactory = null ;
public MQConnectionFactory getConnectionFactory ( ) {
return connectionFactory ;
}
public void setConnectionFactory ( MQConnectionFactory connectionFactory ) {
this . connectionFactory = connectionFactory ;
}
private MQConnection mqConnection = null ;
public MQConnection getMqConnection ( ) {
return mqConnection ;
}
public void setMqConnection ( MQConnection mqConnection ) {
this . mqConnection = mqConnection ;
}
public void intialize ( String hostName , Integer port , Integer transportType ,
String queueManager , String chanel ) throws Exception {
MQConnectionFactory factory = buildConnectionFactory ( hostName , port ,
transportType , queueManager , chanel ) ;
if ( factory == null ) {
throw new Exception (
" ) ;
}
setConnectionFactory ( factory ) ;
MQConnection connection = buildConnection ( ) ;
if ( connection == null ) {
throw new Exception ( " ) ;
}
setMqConnection ( connection ) ;
}
public abstract MQConnectionFactory buildConnectionFactory ( String hostName ,
Integer port , Integer transportType , String queueManager ,
String chanel ) ;
public abstract MQConnection buildConnection ( ) ;
public abstract MQSession buildSession ( ) ;
}
package jms . mq . queue ;
import java . io . FileNotFoundException ;
import javax . jms . JMSException ;
import jms . mq . MQConfig ;
import jms . mq . MQConnectionBuilder ;
import jms . mq . MQFacade ;
import jms . mq . MQState ;
import jms . mq . MQUtils ;
import com . ibm . mq . jms . JMSC ;
import com . ibm . mq . jms . MQMessageConsumer ;
import com . ibm . mq . jms . MQMessageProducer ;
public class <unk> {
private static MQConfig config = null ;
private static MQConnectionBuilder builder = null ;
private static MQFacade facade = null ;
private static void initializeBuilder ( ) {
builder = new MQQueueConnectionBuilder ( ) ;
try {
builder . intialize ( config . getHostName ( ) , config . getHostPort ( ) ,
JMSC . MQJMS_TP_CLIENT_MQ_TCPIP ,
config . getQueueManagerName ( ) , config . getChannelName ( ) ) ;
} catch ( Exception e ) {
System . out . println ( e . getMessage ( ) ) ;
System . out . println ( " ) ;
System . exit ( <num> ) ;
}
}
private static void initializeFacade ( ) {
facade = new MQQueueFacade ( ) ;
facade . setConnectionBuilder ( builder ) ;
try {
facade . initialize ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
}
private static void sendMessages ( String content , MQState state )
throws JMSException {
final MQMessageProducer publisher = facade . getMQMessageProducer ( ) ;
System . out . println ( " ) ;
System . out . println ( ) ;
for ( int i = <num> ; i < MQConfig . getInstance ( ) . getMessagesSenderCount ( ) ; i ++ ) {
final long time1 = System . currentTimeMillis ( ) ;
facade . doSend ( publisher , facade . getJmsTextMessage ( content ) ) ;
final long time2 = System . currentTimeMillis ( ) ;
final String message = new StringBuilder ( )
. append ( " ) . append ( String . valueOf ( i ) )
. append ( " ) . append ( ( time2  time1 ) )
. append ( " ) . append ( " ) . toString ( ) ;
state . addSendingTime ( ( time2  time1 ) ) ;
System . out . println ( message ) ;
}
publisher . close ( ) ;
}
private static void receiveMessages ( MQState state ) throws JMSException {
final MQMessageConsumer subscriber = facade . getMQMessageConsumer ( ) ;
System . out . println ( " ) ;
System . out . println ( ) ;
for ( int i = <num> ; i < MQConfig . getInstance ( ) . getMessagesReceiverCount ( ) ; i ++ ) {
long time1 = System . currentTimeMillis ( ) ;
facade . doReceive ( subscriber ) ;
long time2 = System . currentTimeMillis ( ) ;
final String message = new StringBuilder ( )
. append ( " ) . append ( String . valueOf ( i ) )
. append ( " ) . append ( ( time2  time1 ) )
. append ( " ) . append ( " ) . toString ( ) ;
state . addReceivingTime ( time2  time1 ) ;
System . out . println ( message ) ;
}
subscriber . close ( ) ;
}
public static void runInSeparateThreads ( final String contentToSend , final MQState state ) throws InterruptedException {
final Thread sender = new Thread ( new Runnable ( ) {
@Override
public void run ( ) {
try {
sendMessages ( contentToSend , state ) ;
} catch ( JMSException e ) {
e . printStackTrace ( ) ;
}
}
} ) ;
sender . start ( ) ;
final Thread receiver = new Thread ( new Runnable ( ) {
@Override
public void run ( ) {
try {
receiveMessages ( state ) ;
} catch ( JMSException e ) {
e . printStackTrace ( ) ;
}
}
} ) ;
receiver . start ( ) ;
sender . join ( ) ;
receiver . join ( ) ;
}
public static void runInOneThread ( final String contentToSend , final MQState state ) {
try {
sendMessages ( contentToSend , state ) ;
System . out . println ( ) ;
receiveMessages ( state ) ;
} catch ( JMSException e ) {
e . printStackTrace ( ) ;
}
}
public static void main ( String [ ] args ) throws FileNotFoundException {
String contentToSend = " ;
if ( args . length == <num> ) {
config = MQConfig . getInstance ( ) ;
} else if ( args . length == <num> ) {
config = MQConfig . getInstance ( args [ <num> ] ) ;
} else if ( args . length == <num> ) {
config = MQConfig . getInstance ( args [ <num> ] ) ;
contentToSend = MQUtils . readContentFromFile ( args [ <num> ] ) ;
}
if ( contentToSend == null ) {
System . out
. println ( " ) ;
System . exit ( <num> ) ;
}
initializeBuilder ( ) ;
initializeFacade ( ) ;
final MQState state = new MQState ( ) ;
try {
if ( config . isSingleThreadMode ( ) ) {
runInOneThread ( contentToSend , state ) ;
} else {
runInSeparateThreads ( contentToSend , state ) ;
}
System . out . println ( ) ;
System . out . println ( " ) ;
MQUtils . printStatistics ( state ) ;
MQUtils . printMessageContent ( contentToSend ) ;
facade . doFinalize ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
}
package jms . mq . queue ;
import javax . jms . Destination ;
import javax . jms . JMSException ;
import jms . mq . MQConfig ;
import jms . mq . MQFacade ;
import com . ibm . mq . jms . MQMessageConsumer ;
import com . ibm . mq . jms . MQMessageProducer ;
import com . ibm . mq . jms . MQQueue ;
import com . ibm . mq . jms . MQQueueSession ;
public class MQQueueFacade extends MQFacade {
private String queueName ;
public String getQueueName ( ) {
return queueName ;
}
public void setQueueName ( String queueName ) {
this . queueName = queueName ;
}
private MQQueue queue ;
public MQQueue getQueue ( ) {
return queue ;
}
public void setQueue ( MQQueue queue ) {
this . queue = queue ;
}
@Override
protected void initializeFacade ( ) throws Exception {
setQueueName ( " + MQConfig . getInstance ( ) . getTopicOrQueueName ( ) ) ;
final MQQueue queue = ( MQQueue ) getSession ( )
. createQueue ( getQueueName ( ) ) ;
if ( queue == null ) {
throw new Exception ( " ) ;
}
setQueue ( queue ) ;
try {
getConnectionBuilder ( ) . getMqConnection ( ) . start ( ) ;
} catch ( JMSException e ) {
throw new Exception ( " ) ;
}
}
@Override
protected Destination getJMSDestination ( ) {
return getQueue ( ) ;
}
@Override
public MQMessageConsumer getMQMessageConsumer ( ) {
try {
return ( MQMessageConsumer ) ( ( MQQueueSession ) getSession ( ) )
. <unk> ( getQueue ( ) ) ;
} catch ( JMSException e ) {
return null ;
}
}
@Override
public MQMessageProducer getMQMessageProducer ( ) {
try {
return ( MQMessageProducer ) ( ( MQQueueSession ) getSession ( ) )
. <unk> ( getQueue ( ) ) ;
} catch ( JMSException e ) {
return null ;
}
}
}
package jms . mq . queue ;
import javax . jms . JMSException ;
import javax . jms . Session ;
import jms . mq . MQConnectionBuilder ;
import com . ibm . mq . jms . JMSC ;
import com . ibm . mq . jms . MQConnection ;
import com . ibm . mq . jms . MQConnectionFactory ;
import com . ibm . mq . jms . MQQueueConnection ;
import com . ibm . mq . jms . MQQueueConnectionFactory ;
import com . ibm . mq . jms . MQSession ;
public class MQQueueConnectionBuilder extends MQConnectionBuilder {
@Override
public MQConnectionFactory buildConnectionFactory ( String hostName ,
Integer port , Integer transportType , String queueManager ,
String chanel ) {
try {
MQQueueConnectionFactory factory = new MQQueueConnectionFactory ( ) ;
factory . setHostName ( hostName ) ;
factory . setPort ( port ) ;
factory . setQueueManager ( queueManager ) ;
factory . setChannel ( chanel ) ;
factory . setTransportType ( JMSC . MQJMS_TP_CLIENT_MQ_TCPIP ) ;
return factory ;
} catch ( JMSException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
@Override
public MQConnection buildConnection ( ) {
try {
return ( MQConnection ) ( ( MQQueueConnectionFactory ) getConnectionFactory ( ) )
. <unk> ( ) ;
} catch ( JMSException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
@Override
public MQSession buildSession ( ) {
try {
return ( MQSession ) ( ( MQQueueConnection ) getMqConnection ( ) )
. <unk> ( false , Session . AUTO_ACKNOWLEDGE ) ;
} catch ( JMSException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
}
package jms . mq . topic ;
import javax . jms . JMSException ;
import jms . mq . MQConfig ;
import jms . mq . MQConnectionBuilder ;
import jms . mq . MQFacade ;
import com . ibm . jms . JMSMessage ;
import com . ibm . mq . jms . JMSC ;
import com . ibm . mq . jms . MQMessageConsumer ;
import com . ibm . mq . jms . MQMessageProducer ;
public class <unk> {
private static final MQConfig config = MQConfig . getInstance ( ) ;
public static void main ( String [ ] args ) {
final MQConnectionBuilder builder = new MQTopicConnectionBuilder ( ) ;
try {
builder . intialize ( config . getHostName ( ) , config . getHostPort ( ) ,
JMSC . MQJMS_TP_CLIENT_MQ_TCPIP ,
config . getQueueManagerName ( ) , config . getChannelName ( ) ) ;
} catch ( Exception e ) {
System . out . println ( e . getMessage ( ) ) ;
System . out . println ( " ) ;
System . exit ( <num> ) ;
}
final MQFacade facade = new MQTopicFacade ( ) ;
facade . setConnectionBuilder ( builder ) ;
try {
facade . initialize ( ) ;
final MQMessageProducer publisher = facade . getMQMessageProducer ( ) ;
final MQMessageConsumer subscriber = facade . getMQMessageConsumer ( ) ;
final String key = " + System . currentTimeMillis ( ) % <num> ;
facade . doSend ( publisher , facade . getJmsTextMessage ( key ) ) ;
JMSMessage message = facade . doReceive ( subscriber ) ;
System . out . println ( " + message + " ) ;
publisher . close ( ) ;
subscriber . close ( ) ;
facade . doFinalize ( ) ;
} catch ( JMSException e ) {
e . printStackTrace ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
}
package jms . mq ;
import javax . jms . Destination ;
import javax . jms . JMSException ;
import com . ibm . jms . JMSMessage ;
import com . ibm . jms . JMSTextMessage ;
import com . ibm . mq . jms . MQMessageConsumer ;
import com . ibm . mq . jms . MQMessageProducer ;
import com . ibm . mq . jms . MQSession ;
public abstract class MQFacade {
MQConnectionBuilder connectionBuilder ;
public MQConnectionBuilder getConnectionBuilder ( ) {
return connectionBuilder ;
}
public void setConnectionBuilder ( MQConnectionBuilder connectionBuilder ) {
this . connectionBuilder = connectionBuilder ;
}
MQSession session ;
public MQSession getSession ( ) {
return session ;
}
public void setSession ( MQSession session ) {
this . session = session ;
}
public void initialize ( ) throws Exception {
final MQSession session = connectionBuilder . buildSession ( ) ;
if ( session == null ) {
throw new Exception ( " ) ;
}
setSession ( session ) ;
initializeFacade ( ) ;
getConnectionBuilder ( ) . getMqConnection ( ) . start ( ) ;
}
public abstract MQMessageConsumer getMQMessageConsumer ( ) ;
public abstract MQMessageProducer getMQMessageProducer ( ) ;
public JMSTextMessage getJmsTextMessage ( String content ) {
try {
return ( JMSTextMessage ) getSession ( ) . createTextMessage ( content ) ;
} catch ( JMSException e ) {
return null ;
}
}
public void doFinalize ( ) {
try {
getSession ( ) . close ( ) ;
getConnectionBuilder ( ) . getMqConnection ( ) . close ( ) ;
} catch ( JMSException e ) {
System . out
. println ( " ) ;
}
}
public void doSend ( MQMessageProducer producer , JMSMessage message )
throws JMSException {
producer . send ( message ) ;
}
public JMSMessage doReceive ( MQMessageConsumer subscriber )
throws JMSException {
return ( JMSMessage ) subscriber . receive ( ) ;
}
protected abstract void initializeFacade ( ) throws Exception ;
protected abstract Destination getJMSDestination ( ) ;
}
package jms . mq ;
import java . io . BufferedReader ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . io . IOException ;
import java . io . InputStreamReader ;
import java . util . Collections ;
import java . util . List ;
public class MQUtils {
private static Double calculateAverageForTimes ( List < Long > times ) {
Long sum = <num> ;
for ( Long time : times ) {
sum += time ;
}
return ( double ) sum / times . size ( ) ;
}
public static Double calculateAverageSendingTime ( MQState state ) {
return calculateAverageForTimes ( state . getSendingTimes ( ) ) ;
}
public static Double calculateAverageReceivingTime ( MQState state ) {
return calculateAverageForTimes ( state . getReceivingTimes ( ) ) ;
}
public static String readContentFromFile ( String fileName ) {
try {
final StringBuilder builder = new StringBuilder ( ) ;
final BufferedReader reader = new BufferedReader (
new InputStreamReader ( new FileInputStream ( fileName ) ) ) ;
String line = null ;
while ( ( line = reader . readLine ( ) ) != null )
builder . append ( line ) ;
return builder . toString ( ) ;
} catch ( FileNotFoundException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
return null ;
}
public static void printStatistics ( MQState state ) {
final String messge1 = new StringBuilder ( )
. append ( " )
. append ( state . getSendingTimes ( ) . size ( ) )
. append ( " )
. append ( MQUtils . calculateAverageSendingTime ( state ) )
. append ( " ) . toString ( ) ;
final String messge2 = new StringBuilder ( )
. append ( " )
. append ( state . getReceivingTimes ( ) . size ( ) )
. append ( " )
. append ( MQUtils . calculateAverageReceivingTime ( state ) )
. append ( " ) . toString ( ) ;
final String messge3 = new StringBuilder ( )
. append ( " )
. append ( Collections . max ( state . getSendingTimes ( ) ) )
. append ( " ) . toString ( ) ;
final String messge4 = new StringBuilder ( )
. append ( " )
. append ( Collections . min ( state . getSendingTimes ( ) ) )
. append ( " ) . toString ( ) ;
final String messge5 = new StringBuilder ( )
. append ( " )
. append ( Collections . max ( state . getReceivingTimes ( ) ) )
. append ( " ) . toString ( ) ;
final String messge6 = new StringBuilder ( )
. append ( " )
. append ( Collections . min ( state . getReceivingTimes ( ) ) )
. append ( " ) . toString ( ) ;
System . out . println ( messge1 ) ;
System . out . println ( messge2 ) ;
System . out . println ( messge3 ) ;
System . out . println ( messge4 ) ;
System . out . println ( messge5 ) ;
System . out . println ( messge6 ) ;
}
public static void printMessageContent ( String content ) {
System . out . println ( " ) ;
System . out . println ( content ) ;
System . out . println ( ) ;
}
}
package jms . mq ;
import java . io . FileInputStream ;
import java . io . IOException ;
import java . util . Properties ;
public class MQConfig {
public static final String CONFIG_FILE_NAME = " ;
public static final String CONFIG_HOST_NAME = " ;
public static final String CONFIG_HOST_PORT = " ;
public static final String CONFIG_QUEUE_MANAGER_NAME = " ;
public static final String CONFIG_CHANNEL_NAME = " ;
public static final String CONFIG_TOPIC_OR_QUEUE_NAME = " ;
public static final String CONFIG_SINGLE_THREAD_MODE = " ;
public static final String CONFIG_MESSAGES_COUNT_SENDER = " ;
public static final String CONFIG_MESSAGES_COUNT_RECEIVER = " ;
private Properties properties ;
private static MQConfig instance ;
private String hostName ;
private Integer hostPort ;
private String channelName ;
private String queueManagerName ;
private String topicOrQueueName ;
private Boolean singleThreadMode ;
private Integer messagesSenderCount ;
private Integer messagesReceiverCount ;
public String getHostName ( ) {
return hostName ;
}
public void setHostName ( String hostName ) {
this . hostName = hostName ;
}
public Integer getHostPort ( ) {
return hostPort ;
}
public void setHostPort ( Integer hostPort ) {
this . hostPort = hostPort ;
}
public String getChannelName ( ) {
return channelName ;
}
public void setChannelName ( String channelName ) {
this . channelName = channelName ;
}
public String getQueueManagerName ( ) {
return queueManagerName ;
}
public void setQueueManagerName ( String queueManagerName ) {
this . queueManagerName = queueManagerName ;
}
public String getTopicOrQueueName ( ) {
return topicOrQueueName ;
}
public void setTopicOrQueueName ( String topicOrQueueName ) {
this . topicOrQueueName = topicOrQueueName ;
}
public Integer getMessagesSenderCount ( ) {
return messagesSenderCount ;
}
public void setMessagesSenderCount ( Integer messagesSenderCount ) {
this . messagesSenderCount = messagesSenderCount ;
}
public Integer getMessagesReceiverCount ( ) {
return messagesReceiverCount ;
}
public void setMessagesReceiverCount ( Integer messagesReceiverCount ) {
this . messagesReceiverCount = messagesReceiverCount ;
}
public Boolean isSingleThreadMode ( ) {
return singleThreadMode ;
}
public void setSingleThreadMode ( Boolean singleThreadMode ) {
this . singleThreadMode = singleThreadMode ;
}
public static synchronized MQConfig getInstance ( ) {
if ( instance == null )
instance = new MQConfig ( ) ;
return instance ;
}
public static synchronized MQConfig getInstance ( String fileName ) {
if ( instance == null )
instance = new MQConfig ( fileName ) ;
return instance ;
}
public MQConfig ( ) {
this ( CONFIG_FILE_NAME ) ;
}
private MQConfig ( String fileName ) {
properties = new Properties ( ) ;
try {
properties . load ( new FileInputStream ( fileName ) ) ;
} catch ( IOException e ) {
System . out
. println ( "
+ CONFIG_FILE_NAME + " ) ;
e . printStackTrace ( ) ;
System . exit ( <num> ) ;
}
this . setHostName ( properties . getProperty ( CONFIG_HOST_NAME ) ) ;
this . setHostPort ( Integer . valueOf ( properties
. getProperty ( CONFIG_HOST_PORT ) ) ) ;
this . setChannelName ( properties . getProperty ( CONFIG_CHANNEL_NAME ) ) ;
this . setQueueManagerName ( properties
. getProperty ( CONFIG_QUEUE_MANAGER_NAME ) ) ;
this . setTopicOrQueueName ( properties
. getProperty ( CONFIG_TOPIC_OR_QUEUE_NAME ) ) ;
this . setMessagesReceiverCount ( Integer . valueOf ( properties
. getProperty ( CONFIG_MESSAGES_COUNT_RECEIVER ) ) ) ;
this . setMessagesSenderCount ( Integer . valueOf ( properties
. getProperty ( CONFIG_MESSAGES_COUNT_SENDER ) ) ) ;
this . setSingleThreadMode ( Boolean . valueOf ( properties
. getProperty ( CONFIG_SINGLE_THREAD_MODE ) ) ) ;
}
}
package org . llod . wals . csvtordf ;
import java . io . BufferedReader ;
import java . io . File ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . InputStreamReader ;
import java . io . Reader ;
import java . io . StringReader ;
import java . nio . charset . Charset ;
import java . text . NumberFormat ;
import java . util . HashMap ;
public class CsvReader {
private Reader inputStream = null ;
private String fileName = null ;
private UserSettings userSettings = new UserSettings ( ) ;
private Charset charset = null ;
private boolean useCustomRecordDelimiter = false ;
private DataBuffer dataBuffer = new DataBuffer ( ) ;
private ColumnBuffer columnBuffer = new ColumnBuffer ( ) ;
private RawRecordBuffer rawBuffer = new RawRecordBuffer ( ) ;
private boolean [ ] isQualified = null ;
private String rawRecord = " ;
private HeadersHolder headersHolder = new HeadersHolder ( ) ;
private boolean startedColumn = false ;
private boolean startedWithQualifier = false ;
private boolean hasMoreData = true ;
private char lastLetter = \0' ;
private boolean hasReadNextLine = false ;
private int columnsCount = <num> ;
private long currentRecord = <num> ;
private String [ ] values = new String [ StaticSettings . INITIAL_COLUMN_COUNT ] ;
private boolean initialized = false ;
private boolean closed = false ;
public static final int ESCAPE_MODE_DOUBLED = <num> ;
public static final int ESCAPE_MODE_BACKSLASH = <num> ;
public CsvReader ( String fileName , char delimiter , Charset charset )
throws FileNotFoundException {
if ( fileName == null ) {
throw new IllegalArgumentException (
" ) ;
}
if ( charset == null ) {
throw new IllegalArgumentException (
" ) ;
}
if ( ! new File ( fileName ) . exists ( ) ) {
throw new FileNotFoundException ( " + fileName
+ " ) ;
}
this . fileName = fileName ;
this . userSettings . Delimiter = delimiter ;
this . charset = charset ;
isQualified = new boolean [ values . length ] ;
}
public CsvReader ( String fileName , char delimiter )
throws FileNotFoundException {
this ( fileName , delimiter , Charset . forName ( " ) ) ;
}
public CsvReader ( String fileName ) throws FileNotFoundException {
this ( fileName , Letters . COMMA ) ;
}
public CsvReader ( Reader inputStream , char delimiter ) {
if ( inputStream == null ) {
throw new IllegalArgumentException (
" ) ;
}
this . inputStream = inputStream ;
this . userSettings . Delimiter = delimiter ;
initialized = true ;
isQualified = new boolean [ values . length ] ;
}
public CsvReader ( Reader inputStream ) {
this ( inputStream , Letters . COMMA ) ;
}
public CsvReader ( InputStream inputStream , char delimiter , Charset charset ) {
this ( new InputStreamReader ( inputStream , charset ) , delimiter ) ;
}
public CsvReader ( InputStream inputStream , Charset charset ) {
this ( new InputStreamReader ( inputStream , charset ) ) ;
}
public boolean <unk> ( ) {
return userSettings . CaptureRawRecord ;
}
public void <unk> ( boolean captureRawRecord ) {
userSettings . CaptureRawRecord = captureRawRecord ;
}
public String <unk> ( ) {
return rawRecord ;
}
public boolean <unk> ( ) {
return userSettings . TrimWhitespace ;
}
public void <unk> ( boolean trimWhitespace ) {
userSettings . TrimWhitespace = trimWhitespace ;
}
public char <unk> ( ) {
return userSettings . Delimiter ;
}
public void <unk> ( char delimiter ) {
userSettings . Delimiter = delimiter ;
}
public char <unk> ( ) {
return userSettings . RecordDelimiter ;
}
public void <unk> ( char recordDelimiter ) {
useCustomRecordDelimiter = true ;
userSettings . RecordDelimiter = recordDelimiter ;
}
public char <unk> ( ) {
return userSettings . TextQualifier ;
}
public void <unk> ( char textQualifier ) {
userSettings . TextQualifier = textQualifier ;
}
public boolean <unk> ( ) {
return userSettings . UseTextQualifier ;
}
public void <unk> ( boolean useTextQualifier ) {
userSettings . UseTextQualifier = useTextQualifier ;
}
public char getComment ( ) {
return userSettings . Comment ;
}
public void setComment ( char comment ) {
userSettings . Comment = comment ;
}
public boolean <unk> ( ) {
return userSettings . UseComments ;
}
public void <unk> ( boolean useComments ) {
userSettings . UseComments = useComments ;
}
public int <unk> ( ) {
return userSettings . EscapeMode ;
}
public void <unk> ( int escapeMode ) throws IllegalArgumentException {
if ( escapeMode != ESCAPE_MODE_DOUBLED
&& escapeMode != ESCAPE_MODE_BACKSLASH ) {
throw new IllegalArgumentException (
" ) ;
}
userSettings . EscapeMode = escapeMode ;
}
public boolean <unk> ( ) {
return userSettings . SkipEmptyRecords ;
}
public void <unk> ( boolean skipEmptyRecords ) {
userSettings . SkipEmptyRecords = skipEmptyRecords ;
}
public boolean <unk> ( ) {
return userSettings . SafetySwitch ;
}
public void <unk> ( boolean safetySwitch ) {
userSettings . SafetySwitch = safetySwitch ;
}
public int getColumnCount ( ) {
return columnsCount ;
}
public long <unk> ( ) {
return currentRecord  <num> ;
}
public int <unk> ( ) {
return headersHolder . Length ;
}
public String [ ] getHeaders ( ) throws IOException {
checkClosed ( ) ;
if ( headersHolder . Headers == null ) {
return null ;
} else {
String [ ] clone = new String [ headersHolder . Length ] ;
System . arraycopy ( headersHolder . Headers , <num> , clone , <num> ,
headersHolder . Length ) ;
return clone ;
}
}
public void setHeaders ( String [ ] headers ) {
headersHolder . Headers = headers ;
headersHolder . IndexByName . clear ( ) ;
if ( headers != null ) {
headersHolder . Length = headers . length ;
} else {
headersHolder . Length = <num> ;
}
for ( int i = <num> ; i < headersHolder . Length ; i ++ ) {
headersHolder . IndexByName . put ( headers [ i ] , new Integer ( i ) ) ;
}
}
public String [ ] getValues ( ) throws IOException {
checkClosed ( ) ;
String [ ] clone = new String [ columnsCount ] ;
System . arraycopy ( values , <num> , clone , <num> , columnsCount ) ;
return clone ;
}
public String get ( int columnIndex ) throws IOException {
checkClosed ( ) ;
if ( columnIndex >  <num> && columnIndex < columnsCount ) {
return values [ columnIndex ] ;
} else {
return " ;
}
}
public String get ( String headerName ) throws IOException {
checkClosed ( ) ;
return get ( getIndex ( headerName ) ) ;
}
public static CsvReader parse ( String data ) {
if ( data == null ) {
throw new IllegalArgumentException (
" ) ;
}
return new CsvReader ( new StringReader ( data ) ) ;
}
public boolean readRecord ( ) throws IOException {
checkClosed ( ) ;
columnsCount = <num> ;
rawBuffer . Position = <num> ;
dataBuffer . LineStart = dataBuffer . Position ;
hasReadNextLine = false ;
if ( hasMoreData ) {
do {
if ( dataBuffer . Position == dataBuffer . Count ) {
checkDataLength ( ) ;
} else {
startedWithQualifier = false ;
char currentLetter = dataBuffer . Buffer [ dataBuffer . Position ] ;
if ( userSettings . UseTextQualifier
&& currentLetter == userSettings . TextQualifier ) {
lastLetter = currentLetter ;
startedColumn = true ;
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
startedWithQualifier = true ;
boolean lastLetterWasQualifier = false ;
char escapeChar = userSettings . TextQualifier ;
if ( userSettings . EscapeMode == ESCAPE_MODE_BACKSLASH ) {
escapeChar = Letters . BACKSLASH ;
}
boolean eatingTrailingJunk = false ;
boolean lastLetterWasEscape = false ;
boolean readingComplexEscape = false ;
int escape = ComplexEscape . UNICODE ;
int escapeLength = <num> ;
char escapeValue = ( char ) <num> ;
dataBuffer . Position ++ ;
do {
if ( dataBuffer . Position == dataBuffer . Count ) {
checkDataLength ( ) ;
} else {
currentLetter = dataBuffer . Buffer [ dataBuffer . Position ] ;
if ( eatingTrailingJunk ) {
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
if ( currentLetter == userSettings . Delimiter ) {
endColumn ( ) ;
} else if ( ( ! useCustomRecordDelimiter && ( currentLetter == Letters . CR || currentLetter == Letters . LF ) )
|| ( useCustomRecordDelimiter && currentLetter == userSettings . RecordDelimiter ) ) {
endColumn ( ) ;
endRecord ( ) ;
}
} else if ( readingComplexEscape ) {
escapeLength ++ ;
switch ( escape ) {
case ComplexEscape . UNICODE :
escapeValue *= ( char ) <num> ;
escapeValue += hexToDec ( currentLetter ) ;
if ( escapeLength == <num> ) {
readingComplexEscape = false ;
}
break ;
case ComplexEscape . OCTAL :
escapeValue *= ( char ) <num> ;
escapeValue += ( char ) ( currentLetter  <num>  ) ;
if ( escapeLength == <num> ) {
readingComplexEscape = false ;
}
break ;
case ComplexEscape . DECIMAL :
escapeValue *= ( char ) <num> ;
escapeValue += ( char ) ( currentLetter  <num>  ) ;
if ( escapeLength == <num> ) {
readingComplexEscape = false ;
}
break ;
case ComplexEscape . HEX :
escapeValue *= ( char ) <num> ;
escapeValue += hexToDec ( currentLetter ) ;
if ( escapeLength == <num> ) {
readingComplexEscape = false ;
}
break ;
}
if ( ! readingComplexEscape ) {
appendLetter ( escapeValue ) ;
} else {
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
}
} else if ( currentLetter == userSettings . TextQualifier ) {
if ( lastLetterWasEscape ) {
lastLetterWasEscape = false ;
lastLetterWasQualifier = false ;
} else {
updateCurrentValue ( ) ;
if ( userSettings . EscapeMode == ESCAPE_MODE_DOUBLED ) {
lastLetterWasEscape = true ;
}
lastLetterWasQualifier = true ;
}
} else if ( userSettings . EscapeMode == ESCAPE_MODE_BACKSLASH
&& lastLetterWasEscape ) {
switch ( currentLetter ) {
case n' :
appendLetter ( Letters . LF ) ;
break ;
case r' :
appendLetter ( Letters . CR ) ;
break ;
case t' :
appendLetter ( Letters . TAB ) ;
break ;
case b' :
appendLetter ( Letters . BACKSPACE ) ;
break ;
case f' :
appendLetter ( Letters . FORM_FEED ) ;
break ;
case e' :
appendLetter ( Letters . ESCAPE ) ;
break ;
case v' :
appendLetter ( Letters . VERTICAL_TAB ) ;
break ;
case a' :
appendLetter ( Letters . ALERT ) ;
break ;
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
escape = ComplexEscape . OCTAL ;
readingComplexEscape = true ;
escapeLength = <num> ;
escapeValue = ( char ) ( currentLetter  <num>  ) ;
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
break ;
case u' :
case x' :
case o' :
case d' :
case U' :
case X' :
case O' :
case D' :
switch ( currentLetter ) {
case u' :
case U' :
escape = ComplexEscape . UNICODE ;
break ;
case x' :
case X' :
escape = ComplexEscape . HEX ;
break ;
case o' :
case O' :
escape = ComplexEscape . OCTAL ;
break ;
case d' :
case D' :
escape = ComplexEscape . DECIMAL ;
break ;
}
readingComplexEscape = true ;
escapeLength = <num> ;
escapeValue = ( char ) <num> ;
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
break ;
default :
break ;
}
lastLetterWasEscape = false ;
} else if ( currentLetter == escapeChar ) {
updateCurrentValue ( ) ;
lastLetterWasEscape = true ;
} else {
if ( lastLetterWasQualifier ) {
if ( currentLetter == userSettings . Delimiter ) {
endColumn ( ) ;
} else if ( ( ! useCustomRecordDelimiter && ( currentLetter == Letters . CR || currentLetter == Letters . LF ) )
|| ( useCustomRecordDelimiter && currentLetter == userSettings . RecordDelimiter ) ) {
endColumn ( ) ;
endRecord ( ) ;
} else {
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
eatingTrailingJunk = true ;
}
lastLetterWasQualifier = false ;
}
}
lastLetter = currentLetter ;
if ( startedColumn ) {
dataBuffer . Position ++ ;
if ( userSettings . SafetySwitch
&& dataBuffer . Position
dataBuffer . ColumnStart
+ columnBuffer . Position > <num> ) {
close ( ) ;
throw new IOException (
"
+ NumberFormat
. getIntegerInstance ( )
. format (
columnsCount )
+ "
+ NumberFormat
. getIntegerInstance ( )
. format (
currentRecord )
+ "
+ "
+ " ) ;
}
}
}
} while ( hasMoreData && startedColumn ) ;
} else if ( currentLetter == userSettings . Delimiter ) {
lastLetter = currentLetter ;
endColumn ( ) ;
} else if ( useCustomRecordDelimiter
&& currentLetter == userSettings . RecordDelimiter ) {
if ( startedColumn || columnsCount > 0
|| ! userSettings . SkipEmptyRecords ) {
endColumn ( ) ;
endRecord ( ) ;
} else {
dataBuffer . LineStart = dataBuffer . Position + <num> ;
}
lastLetter = currentLetter ;
} else if ( ! useCustomRecordDelimiter
&& ( currentLetter == Letters . CR || currentLetter == Letters . LF ) ) {
if ( startedColumn
|| columnsCount > 0
|| ( ! userSettings . SkipEmptyRecords && ( currentLetter == Letters . CR || lastLetter != Letters . CR ) ) ) {
endColumn ( ) ;
endRecord ( ) ;
} else {
dataBuffer . LineStart = dataBuffer . Position + <num> ;
}
lastLetter = currentLetter ;
} else if ( userSettings . UseComments && columnsCount == 0
&& currentLetter == userSettings . Comment ) {
lastLetter = currentLetter ;
skipLine ( ) ;
} else if ( userSettings . TrimWhitespace
&& ( currentLetter == Letters . SPACE || currentLetter == Letters . TAB ) ) {
startedColumn = true ;
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
} else {
startedColumn = true ;
dataBuffer . ColumnStart = dataBuffer . Position ;
boolean lastLetterWasBackslash = false ;
boolean readingComplexEscape = false ;
int escape = ComplexEscape . UNICODE ;
int escapeLength = <num> ;
char escapeValue = ( char ) <num> ;
boolean firstLoop = true ;
do {
if ( ! firstLoop
&& dataBuffer . Position == dataBuffer . Count ) {
checkDataLength ( ) ;
} else {
if ( ! firstLoop ) {
currentLetter = dataBuffer . Buffer [ dataBuffer . Position ] ;
}
if ( ! userSettings . UseTextQualifier
&& userSettings . EscapeMode == ESCAPE_MODE_BACKSLASH
&& currentLetter == Letters . BACKSLASH ) {
if ( lastLetterWasBackslash ) {
lastLetterWasBackslash = false ;
} else {
updateCurrentValue ( ) ;
lastLetterWasBackslash = true ;
}
} else if ( readingComplexEscape ) {
escapeLength ++ ;
switch ( escape ) {
case ComplexEscape . UNICODE :
escapeValue *= ( char ) <num> ;
escapeValue += hexToDec ( currentLetter ) ;
if ( escapeLength == <num> ) {
readingComplexEscape = false ;
}
break ;
case ComplexEscape . OCTAL :
escapeValue *= ( char ) <num> ;
escapeValue += ( char ) ( currentLetter  <num>  ) ;
if ( escapeLength == <num> ) {
readingComplexEscape = false ;
}
break ;
case ComplexEscape . DECIMAL :
escapeValue *= ( char ) <num> ;
escapeValue += ( char ) ( currentLetter  <num>  ) ;
if ( escapeLength == <num> ) {
readingComplexEscape = false ;
}
break ;
case ComplexEscape . HEX :
escapeValue *= ( char ) <num> ;
escapeValue += hexToDec ( currentLetter ) ;
if ( escapeLength == <num> ) {
readingComplexEscape = false ;
}
break ;
}
if ( ! readingComplexEscape ) {
appendLetter ( escapeValue ) ;
} else {
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
}
} else if ( userSettings . EscapeMode == ESCAPE_MODE_BACKSLASH
&& lastLetterWasBackslash ) {
switch ( currentLetter ) {
case n' :
appendLetter ( Letters . LF ) ;
break ;
case r' :
appendLetter ( Letters . CR ) ;
break ;
case t' :
appendLetter ( Letters . TAB ) ;
break ;
case b' :
appendLetter ( Letters . BACKSPACE ) ;
break ;
case f' :
appendLetter ( Letters . FORM_FEED ) ;
break ;
case e' :
appendLetter ( Letters . ESCAPE ) ;
break ;
case v' :
appendLetter ( Letters . VERTICAL_TAB ) ;
break ;
case a' :
appendLetter ( Letters . ALERT ) ;
break ;
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
case <num>  :
escape = ComplexEscape . OCTAL ;
readingComplexEscape = true ;
escapeLength = <num> ;
escapeValue = ( char ) ( currentLetter  <num>  ) ;
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
break ;
case u' :
case x' :
case o' :
case d' :
case U' :
case X' :
case O' :
case D' :
switch ( currentLetter ) {
case u' :
case U' :
escape = ComplexEscape . UNICODE ;
break ;
case x' :
case X' :
escape = ComplexEscape . HEX ;
break ;
case o' :
case O' :
escape = ComplexEscape . OCTAL ;
break ;
case d' :
case D' :
escape = ComplexEscape . DECIMAL ;
break ;
}
readingComplexEscape = true ;
escapeLength = <num> ;
escapeValue = ( char ) <num> ;
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
break ;
default :
break ;
}
lastLetterWasBackslash = false ;
} else {
if ( currentLetter == userSettings . Delimiter ) {
endColumn ( ) ;
} else if ( ( ! useCustomRecordDelimiter && ( currentLetter == Letters . CR || currentLetter == Letters . LF ) )
|| ( useCustomRecordDelimiter && currentLetter == userSettings . RecordDelimiter ) ) {
endColumn ( ) ;
endRecord ( ) ;
}
}
lastLetter = currentLetter ;
firstLoop = false ;
if ( startedColumn ) {
dataBuffer . Position ++ ;
if ( userSettings . SafetySwitch
&& dataBuffer . Position
dataBuffer . ColumnStart
+ columnBuffer . Position > <num> ) {
close ( ) ;
throw new IOException (
"
+ NumberFormat
. getIntegerInstance ( )
. format (
columnsCount )
+ "
+ NumberFormat
. getIntegerInstance ( )
. format (
currentRecord )
+ "
+ "
+ " ) ;
}
}
}
} while ( hasMoreData && startedColumn ) ;
}
if ( hasMoreData ) {
dataBuffer . Position ++ ;
}
}
} while ( hasMoreData && ! hasReadNextLine ) ;
if ( startedColumn || lastLetter == userSettings . Delimiter ) {
endColumn ( ) ;
endRecord ( ) ;
}
}
if ( userSettings . CaptureRawRecord ) {
if ( hasMoreData ) {
if ( rawBuffer . Position == <num> ) {
rawRecord = new String ( dataBuffer . Buffer ,
dataBuffer . LineStart , dataBuffer . Position
dataBuffer . LineStart  <num> ) ;
} else {
rawRecord = new String ( rawBuffer . Buffer , <num> ,
rawBuffer . Position )
+ new String ( dataBuffer . Buffer ,
dataBuffer . LineStart , dataBuffer . Position
dataBuffer . LineStart  <num> ) ;
}
} else {
rawRecord = new String ( rawBuffer . Buffer , <num> , rawBuffer . Position ) ;
}
} else {
rawRecord = " ;
}
return hasReadNextLine ;
}
private void checkDataLength ( ) throws IOException {
if ( ! initialized ) {
if ( fileName != null ) {
inputStream = new BufferedReader ( new InputStreamReader (
new FileInputStream ( fileName ) , charset ) ,
StaticSettings . MAX_FILE_BUFFER_SIZE ) ;
}
charset = null ;
initialized = true ;
}
updateCurrentValue ( ) ;
if ( userSettings . CaptureRawRecord && dataBuffer . Count > <num> ) {
if ( rawBuffer . Buffer . length  rawBuffer . Position < dataBuffer . Count
dataBuffer . LineStart ) {
int newLength = rawBuffer . Buffer . length
+ Math . max ( dataBuffer . Count  dataBuffer . LineStart ,
rawBuffer . Buffer . length ) ;
char [ ] holder = new char [ newLength ] ;
System . arraycopy ( rawBuffer . Buffer , <num> , holder , <num> ,
rawBuffer . Position ) ;
rawBuffer . Buffer = holder ;
}
System . arraycopy ( dataBuffer . Buffer , dataBuffer . LineStart ,
rawBuffer . Buffer , rawBuffer . Position , dataBuffer . Count
dataBuffer . LineStart ) ;
rawBuffer . Position += dataBuffer . Count  dataBuffer . LineStart ;
}
try {
dataBuffer . Count = inputStream . read ( dataBuffer . Buffer , <num> ,
dataBuffer . Buffer . length ) ;
} catch ( IOException ex ) {
close ( ) ;
throw ex ;
}
if ( dataBuffer . Count ==  <num> ) {
hasMoreData = false ;
}
dataBuffer . Position = <num> ;
dataBuffer . LineStart = <num> ;
dataBuffer . ColumnStart = <num> ;
}
public boolean readHeaders ( ) throws IOException {
boolean result = readRecord ( ) ;
headersHolder . Length = columnsCount ;
headersHolder . Headers = new String [ columnsCount ] ;
for ( int i = <num> ; i < headersHolder . Length ; i ++ ) {
String columnValue = get ( i ) ;
headersHolder . Headers [ i ] = columnValue ;
headersHolder . IndexByName . put ( columnValue , new Integer ( i ) ) ;
}
if ( result ) {
currentRecord  ;
}
columnsCount = <num> ;
return result ;
}
public String getHeader ( int columnIndex ) throws IOException {
checkClosed ( ) ;
if ( columnIndex >  <num> && columnIndex < headersHolder . Length ) {
return headersHolder . Headers [ columnIndex ] ;
} else {
return " ;
}
}
public boolean isQualified ( int columnIndex ) throws IOException {
checkClosed ( ) ;
if ( columnIndex < columnsCount && columnIndex >  <num> ) {
return isQualified [ columnIndex ] ;
} else {
return false ;
}
}
private void endColumn ( ) throws IOException {
String currentValue = " ;
if ( startedColumn ) {
if ( columnBuffer . Position == <num> ) {
if ( dataBuffer . ColumnStart < dataBuffer . Position ) {
int lastLetter = dataBuffer . Position  <num> ;
if ( userSettings . TrimWhitespace && ! startedWithQualifier ) {
while ( lastLetter >= dataBuffer . ColumnStart
&& ( dataBuffer . Buffer [ lastLetter ] == Letters . SPACE || dataBuffer . Buffer [ lastLetter ] == Letters . TAB ) ) {
lastLetter  ;
}
}
currentValue = new String ( dataBuffer . Buffer ,
dataBuffer . ColumnStart , lastLetter
dataBuffer . ColumnStart + <num> ) ;
}
} else {
updateCurrentValue ( ) ;
int lastLetter = columnBuffer . Position  <num> ;
if ( userSettings . TrimWhitespace && ! startedWithQualifier ) {
while ( lastLetter >= 0
&& ( columnBuffer . Buffer [ lastLetter ] == Letters . SPACE || columnBuffer . Buffer [ lastLetter ] == Letters . SPACE ) ) {
lastLetter  ;
}
}
currentValue = new String ( columnBuffer . Buffer , <num> ,
lastLetter + <num> ) ;
}
}
columnBuffer . Position = <num> ;
startedColumn = false ;
if ( columnsCount >= <num> && userSettings . SafetySwitch ) {
close ( ) ;
throw new IOException (
"
+ NumberFormat . getIntegerInstance ( ) . format (
currentRecord )
+ "
+ "
+ " ) ;
}
if ( columnsCount == values . length ) {
int newLength = values . length * <num> ;
String [ ] holder = new String [ newLength ] ;
System . arraycopy ( values , <num> , holder , <num> , values . length ) ;
values = holder ;
boolean [ ] qualifiedHolder = new boolean [ newLength ] ;
System . arraycopy ( isQualified , <num> , qualifiedHolder , <num> ,
isQualified . length ) ;
isQualified = qualifiedHolder ;
}
values [ columnsCount ] = currentValue ;
isQualified [ columnsCount ] = startedWithQualifier ;
currentValue = " ;
columnsCount ++ ;
}
private void appendLetter ( char letter ) {
if ( columnBuffer . Position == columnBuffer . Buffer . length ) {
int newLength = columnBuffer . Buffer . length * <num> ;
char [ ] holder = new char [ newLength ] ;
System . arraycopy ( columnBuffer . Buffer , <num> , holder , <num> ,
columnBuffer . Position ) ;
columnBuffer . Buffer = holder ;
}
columnBuffer . Buffer [ columnBuffer . Position ++ ] = letter ;
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
}
private void updateCurrentValue ( ) {
if ( startedColumn && dataBuffer . ColumnStart < dataBuffer . Position ) {
if ( columnBuffer . Buffer . length  columnBuffer . Position < dataBuffer . Position
dataBuffer . ColumnStart ) {
int newLength = columnBuffer . Buffer . length
+ Math . max (
dataBuffer . Position  dataBuffer . ColumnStart ,
columnBuffer . Buffer . length ) ;
char [ ] holder = new char [ newLength ] ;
System . arraycopy ( columnBuffer . Buffer , <num> , holder , <num> ,
columnBuffer . Position ) ;
columnBuffer . Buffer = holder ;
}
System . arraycopy ( dataBuffer . Buffer , dataBuffer . ColumnStart ,
columnBuffer . Buffer , columnBuffer . Position ,
dataBuffer . Position  dataBuffer . ColumnStart ) ;
columnBuffer . Position += dataBuffer . Position
dataBuffer . ColumnStart ;
}
dataBuffer . ColumnStart = dataBuffer . Position + <num> ;
}
private void endRecord ( ) throws IOException {
hasReadNextLine = true ;
currentRecord ++ ;
}
public int getIndex ( String headerName ) throws IOException {
checkClosed ( ) ;
Object indexValue = headersHolder . IndexByName . get ( headerName ) ;
if ( indexValue != null ) {
return ( ( Integer ) indexValue ) . intValue ( ) ;
} else {
return  <num> ;
}
}
public boolean <unk> ( ) throws IOException {
checkClosed ( ) ;
boolean recordRead = false ;
if ( hasMoreData ) {
recordRead = readRecord ( ) ;
if ( recordRead ) {
currentRecord  ;
}
}
return recordRead ;
}
public boolean skipLine ( ) throws IOException {
checkClosed ( ) ;
columnsCount = <num> ;
boolean skippedLine = false ;
if ( hasMoreData ) {
boolean foundEol = false ;
do {
if ( dataBuffer . Position == dataBuffer . Count ) {
checkDataLength ( ) ;
} else {
skippedLine = true ;
char currentLetter = dataBuffer . Buffer [ dataBuffer . Position ] ;
if ( currentLetter == Letters . CR
|| currentLetter == Letters . LF ) {
foundEol = true ;
}
lastLetter = currentLetter ;
if ( ! foundEol ) {
dataBuffer . Position ++ ;
}
}
} while ( hasMoreData && ! foundEol ) ;
columnBuffer . Position = <num> ;
dataBuffer . LineStart = dataBuffer . Position + <num> ;
}
rawBuffer . Position = <num> ;
rawRecord = " ;
return skippedLine ;
}
public void close ( ) {
if ( ! closed ) {
close ( true ) ;
closed = true ;
}
}
private void close ( boolean closing ) {
if ( ! closed ) {
if ( closing ) {
charset = null ;
headersHolder . Headers = null ;
headersHolder . IndexByName = null ;
dataBuffer . Buffer = null ;
columnBuffer . Buffer = null ;
rawBuffer . Buffer = null ;
}
try {
if ( initialized ) {
inputStream . close ( ) ;
}
} catch ( Exception e ) {
}
inputStream = null ;
closed = true ;
}
}
private void checkClosed ( ) throws IOException {
if ( closed ) {
throw new IOException (
" ) ;
}
}
protected void finalize ( ) {
close ( false ) ;
}
private class ComplexEscape {
private static final int UNICODE = <num> ;
private static final int OCTAL = <num> ;
private static final int DECIMAL = <num> ;
private static final int HEX = <num> ;
}
private static char hexToDec ( char hex ) {
char result ;
if ( hex >= a' ) {
result = ( char ) ( hex  a' + <num> ) ;
} else if ( hex >= A' ) {
result = ( char ) ( hex  A' + <num> ) ;
} else {
result = ( char ) ( hex  <num>  ) ;
}
return result ;
}
private class DataBuffer {
public char [ ] Buffer ;
public int Position ;
public int Count ;
public int ColumnStart ;
public int LineStart ;
public DataBuffer ( ) {
Buffer = new char [ StaticSettings . MAX_BUFFER_SIZE ] ;
Position = <num> ;
Count = <num> ;
ColumnStart = <num> ;
LineStart = <num> ;
}
}
private class ColumnBuffer {
public char [ ] Buffer ;
public int Position ;
public ColumnBuffer ( ) {
Buffer = new char [ StaticSettings . INITIAL_COLUMN_BUFFER_SIZE ] ;
Position = <num> ;
}
}
private class RawRecordBuffer {
public char [ ] Buffer ;
public int Position ;
public RawRecordBuffer ( ) {
Buffer = new char [ StaticSettings . INITIAL_COLUMN_BUFFER_SIZE
* StaticSettings . INITIAL_COLUMN_COUNT ] ;
Position = <num> ;
}
}
private class Letters {
public static final char LF = \n' ;
public static final char CR = \r' ;
public static final char QUOTE = "' ;
public static final char COMMA = ,' ;
public static final char SPACE =  ' ;
public static final char TAB = \t' ;
public static final char POUND = #' ;
public static final char BACKSLASH = \\' ;
public static final char NULL = \0' ;
public static final char BACKSPACE = \b' ;
public static final char FORM_FEED = \f' ;
public static final char ESCAPE = <unk> ;
public static final char VERTICAL_TAB = '
;
public static final char ALERT = <unk> ;
}
private class UserSettings {
public boolean CaseSensitive ;
public char TextQualifier ;
public boolean TrimWhitespace ;
public boolean UseTextQualifier ;
public char Delimiter ;
public char RecordDelimiter ;
public char Comment ;
public boolean UseComments ;
public int EscapeMode ;
public boolean SafetySwitch ;
public boolean SkipEmptyRecords ;
public boolean CaptureRawRecord ;
public UserSettings ( ) {
CaseSensitive = true ;
TextQualifier = Letters . QUOTE ;
TrimWhitespace = true ;
UseTextQualifier = true ;
Delimiter = Letters . COMMA ;
RecordDelimiter = Letters . NULL ;
Comment = Letters . POUND ;
UseComments = false ;
EscapeMode = CsvReader . ESCAPE_MODE_DOUBLED ;
SafetySwitch = true ;
SkipEmptyRecords = true ;
CaptureRawRecord = true ;
}
}
private class HeadersHolder {
public String [ ] Headers ;
public int Length ;
public HashMap IndexByName ;
public HeadersHolder ( ) {
Headers = null ;
Length = <num> ;
IndexByName = new HashMap ( ) ;
}
}
private class StaticSettings {
public static final int MAX_BUFFER_SIZE = <num> ;
public static final int MAX_FILE_BUFFER_SIZE = <num> * <num> ;
public static final int INITIAL_COLUMN_COUNT = <num> ;
public static final int INITIAL_COLUMN_BUFFER_SIZE = <num> ;
}
package org . llod . wals . csvtordf ;
import java . io . File ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . io . FileOutputStream ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . OutputStream ;
import java . nio . charset . Charset ;
import java . nio . charset . UnsupportedCharsetException ;
import java . util . ArrayList ;
import org . llod . wals . csvtordf . CsvReader ;
import com . hp . hpl . jena . rdf . model . Model ;
import com . hp . hpl . jena . rdf . model . ModelFactory ;
import com . hp . hpl . jena . rdf . model . Property ;
import com . hp . hpl . jena . rdf . model . Resource ;
import com . hp . hpl . jena . rdf . model . ResourceFactory ;
public class FeaturesToRDF {
private File featurefile ;
private String featureClassUri ;
private String featureNameProperty ;
public FeaturesToRDF ( File featurecsv , String URIprefix , String featureNameProperty ) throws FileNotFoundException {
if ( featurecsv . exists ( ) && ! featurecsv . isDirectory ( ) ) {
this . featurefile = featurecsv ;
}
else {
throw new FileNotFoundException ( ) ;
}
setFeatureClassUri ( URIprefix ) ;
setFeatureNameProperty ( featureNameProperty ) ;
}
public void setFeatureClassUri ( String uri ) {
if ( uri . endsWith ( " ) ) {
this . featureClassUri = uri ;
}
else {
this . featureClassUri = uri + " ;
}
}
public void setFeatureNameProperty ( String uri ) {
this . featureNameProperty = uri ;
}
private ArrayList < String [ ] > readCSV ( ) throws FileNotFoundException , UnsupportedCharsetException , IOException {
ArrayList < String [ ] > csvmap = new ArrayList < String [ ] > ( ) ;
InputStream input = new FileInputStream ( this . featurefile ) ;
Charset charset = Charset . forName ( " ) ;
CsvReader reader = new CsvReader ( input , " . charAt ( <num> ) , charset ) ;
reader . skipLine ( ) ;
while ( reader . readRecord ( ) ) {
String featureId = reader . getValues ( ) [ <num> ] ;
String featureName = reader . getValues ( ) [ <num> ] ;
String [ ] value = new String [ <num> ] ;
value [ <num> ] = featureId ;
value [ <num> ] = featureName ;
csvmap . add ( value ) ;
}
return csvmap ;
}
public Model getFeatureModel ( ) throws UnsupportedCharsetException , FileNotFoundException , IOException {
Model featureModel = ModelFactory . createDefaultModel ( ) ;
Property featureNameProperty = ResourceFactory . createProperty ( this . featureNameProperty ) ;
ArrayList < String [ ] > featureValues = this . readCSV ( ) ;
for ( int i = <num> ; i < featureValues . size ( ) ; i ++ ) {
String featureResourceUri = this . featureClassUri + featureValues . get ( i ) [ <num> ] ;
Resource featureResource = featureModel . createResource ( featureResourceUri ) ;
featureResource . addLiteral ( featureNameProperty , featureValues . get ( i ) [ <num> ] ) ;
}
return featureModel ;
}
public static void main ( String [ ] args ) {
String filename = " ;
try {
File featurefile = new File ( filename ) ;
FeaturesToRDF convert = new FeaturesToRDF ( featurefile , " , " ) ;
Model rdf = convert . getFeatureModel ( ) ;
OutputStream out = new FileOutputStream ( " ) ;
rdf . write ( out ) ;
} catch ( Exception fnf ) {
fnf . printStackTrace ( ) ;
}
}
}
package org . llod . wals . csvtordf ;
public class Datapoint {
private String featureId ;
private String valueId ;
private String walsCode ;
public Datapoint ( ) {
}
public Datapoint ( String walscode , String feature , String value ) {
this . setWalsCode ( walscode ) ;
this . setFeatureId ( feature ) ;
this . setValueId ( value ) ;
}
public void setWalsCode ( String walscode ) {
this . walsCode = walscode ;
}
public void setFeatureId ( String feature ) {
this . featureId = feature ;
}
public void setValueId ( String value ) {
this . valueId = value ;
}
public String getWalsCode ( ) {
return this . walsCode ;
}
public String getFeatureId ( ) {
return this . featureId ;
}
public String getValueId ( ) {
return this . valueId ;
}
}
package org . llod . wals . csvtordf ;
public class Language {
private String walsCode ;
private String languageName ;
private String latitude ;
private String longitude ;
private String genus ;
private String family ;
private String subFamily ;
private String isoCode ;
public Language ( ) {
}
public Language ( String walscode , String langname , String latitude ,
String longitude , String genus , String family , String subfamily ,
String isocode ) {
this . setWalsCode ( walscode ) ;
this . setLanguageName ( langname ) ;
this . setLatitude ( latitude ) ;
this . setLongitude ( longitude ) ;
this . setGenus ( genus ) ;
this . setFamily ( family ) ;
this . setSubFamily ( subfamily ) ;
this . setIsoCode ( isocode ) ;
}
public String getWalsCode ( ) {
return walsCode ;
}
public void setWalsCode ( String walsCode ) {
this . walsCode = walsCode ;
}
public String getLanguageName ( ) {
return languageName ;
}
public void setLanguageName ( String languageName ) {
this . languageName = languageName ;
}
public String getLatitude ( ) {
return latitude ;
}
public void setLatitude ( String latitude ) {
this . latitude = latitude ;
}
public String getLongitude ( ) {
return longitude ;
}
public void setLongitude ( String longitude ) {
this . longitude = longitude ;
}
public String getGenus ( ) {
return genus ;
}
public void setGenus ( String genus ) {
this . genus = genus ;
}
public String getFamily ( ) {
return family ;
}
public Boolean hasFamily ( ) {
return ! family . trim ( ) . isEmpty ( ) ;
}
public void setFamily ( String family ) {
this . family = family ;
}
public String getSubFamily ( ) {
return subFamily ;
}
public Boolean hasSubFamily ( ) {
return ! subFamily . trim ( ) . isEmpty ( ) ;
}
public void setSubFamily ( String subFamily ) {
this . subFamily = subFamily ;
}
public String getIsoCode ( ) {
return isoCode ;
}
public void setIsoCode ( String isoCode ) {
this . isoCode = isoCode ;
}
}
package org . llod . wals . csvtordf ;
public class WalsValue {
private String featureId ;
private String valueId ;
private String shortDescription ;
private String longDescription ;
public WalsValue ( String feature , String value , String shortDesc , String longDesc ) {
this . setFeatureId ( feature ) ;
this . setValueId ( value ) ;
this . setShortDescription ( shortDesc ) ;
this . setLongDescription ( longDesc ) ;
}
public WalsValue ( ) {
}
public void setFeatureId ( String featureId ) {
this . featureId = featureId ;
}
public void setValueId ( String valueId ) {
this . valueId = valueId ;
}
public void setShortDescription ( String shortdesc ) {
this . shortDescription = shortdesc ;
}
public void setLongDescription ( String longdesc ) {
this . longDescription = longdesc ;
}
public String getFeatureId ( ) {
return this . featureId ;
}
public String getValueId ( ) {
return this . valueId ;
}
public String <unk> ( ) {
return this . shortDescription ;
}
public String getLongDesc ( ) {
return this . longDescription ;
}
}
package org . llod . wals . csvtordf ;
import java . io . File ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . io . IOException ;
import java . io . InputStream ;
import java . nio . charset . Charset ;
public class VocabularyMapping {
private File mappingFile ;
private String familyClassUri ;
private String familyClassProperty ;
private String subFamilyClassUri ;
private String featureClassUri ;
private String featureNameProperty ;
private String languageClassUri ;
private String languageNameProperty ;
private String geoLatProperty ;
private String geoLongProperty ;
private String genusProperty ;
private String isoCodeProperty ;
private String valueDescriptionsProperty ;
public VocabularyMapping ( File mapping ) {
try {
this . setMappingFile ( mapping ) ;
} catch ( FileNotFoundException fnf ) {
System . out . println ( " + mapping . getAbsolutePath ( ) ) ;
return ;
}
try {
this . initializeMapping ( ) ;
} catch ( Exception e ) {
System . out . println ( " + mapping . getAbsolutePath ( ) + " ) ;
}
}
public void setMappingFile ( File mappingFile ) throws FileNotFoundException {
if ( mappingFile . exists ( ) && ! mappingFile . isDirectory ( ) ) {
this . mappingFile = mappingFile ;
}
else {
throw new FileNotFoundException ( ) ;
}
}
private void initializeMapping ( ) throws FileNotFoundException , IOException {
InputStream input = new FileInputStream ( this . mappingFile ) ;
Charset charset = Charset . forName ( " ) ;
CsvReader reader = new CsvReader ( input , " . charAt ( <num> ) , charset ) ;
reader . skipLine ( ) ;
while ( reader . readRecord ( ) ) {
String [ ] values = reader . getValues ( ) ;
if ( values [ <num> ] . equals ( " ) ) {
this . familyClassUri = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . familyClassProperty = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . subFamilyClassUri = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . featureClassUri = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . featureNameProperty = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . languageClassUri = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . languageNameProperty = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . geoLatProperty = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . geoLongProperty = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . genusProperty = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . isoCodeProperty = values [ <num> ] ;
}
else if ( values [ <num> ] . equals ( " ) ) {
this . valueDescriptionsProperty = values [ <num> ] ;
}
}
}
public String getFamilyClassUri ( ) {
return familyClassUri ;
}
public String getFamilyClassProperty ( ) {
return familyClassProperty ;
}
public String getSubFamilyClassUri ( ) {
return subFamilyClassUri ;
}
public String getFeatureClassUri ( ) {
return featureClassUri ;
}
public String <unk> ( ) {
return featureNameProperty ;
}
public String getLanguageClassUri ( ) {
return languageClassUri ;
}
public String getLanguageNameProperty ( ) {
return languageNameProperty ;
}
public String getGeoLatProperty ( ) {
return geoLatProperty ;
}
public String getGeoLongProperty ( ) {
return geoLongProperty ;
}
public String getGenusProperty ( ) {
return genusProperty ;
}
public String getIsoCodeProperty ( ) {
return isoCodeProperty ;
}
public String getValueDescriptionsProperty ( ) {
return valueDescriptionsProperty ;
}
public static void main ( String [ ] args ) {
File mappingFile = new File ( " ) ;
VocabularyMapping mapping = new VocabularyMapping ( mappingFile ) ;
System . out . println ( mapping . getFamilyClassProperty ( ) ) ;
System . out . println ( mapping . getGenusProperty ( ) ) ;
}
}
package org . llod . wals . csvtordf ;
import java . io . File ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . io . FileOutputStream ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . OutputStream ;
import java . net . URLEncoder ;
import java . nio . charset . Charset ;
import java . nio . charset . UnsupportedCharsetException ;
import java . util . ArrayList ;
import java . util . Collection ;
import java . util . HashMap ;
import java . util . Iterator ;
import com . hp . hpl . jena . rdf . model . Model ;
import com . hp . hpl . jena . rdf . model . ModelFactory ;
import com . hp . hpl . jena . rdf . model . Property ;
import com . hp . hpl . jena . rdf . model . Resource ;
import com . hp . hpl . jena . rdf . model . ResourceFactory ;
import com . hp . hpl . jena . vocabulary . RDF ;
import com . hp . hpl . jena . vocabulary . RDFS ;
public class LanguageDataToRDF {
private File languageFile ;
private File datapointFile ;
private File valueFile ;
private ArrayList < WalsValue > valueList ;
private ArrayList < Datapoint > <unk> ;
private ArrayList < Language > languageList ;
private VocabularyMapping mapping ;
public LanguageDataToRDF ( File languagesCsv , File datapointsCsv , File valuesCsv , File mappingFile ) throws FileNotFoundException {
try {
setLanguageFile ( languagesCsv ) ;
} catch ( FileNotFoundException fnf1 ) {
System . out . println ( " + languagesCsv . getAbsolutePath ( ) ) ;
}
try {
setDatapointFile ( datapointsCsv ) ;
} catch ( FileNotFoundException fnf1 ) {
System . out . println ( " + datapointsCsv . getAbsolutePath ( ) ) ;
}
try {
setValueFile ( valuesCsv ) ;
} catch ( FileNotFoundException fnf1 ) {
System . out . println ( " + valuesCsv . getAbsolutePath ( ) ) ;
}
this . mapping = new VocabularyMapping ( mappingFile ) ;
}
public ArrayList < WalsValue > <unk> ( ) {
HashMap < String , ArrayList < WalsValue >> valueMap = new HashMap < String , ArrayList < WalsValue >> ( ) ;
try {
valueMap = this . readValueCSV ( ) ;
} catch ( UnsupportedCharsetException e ) {
e . printStackTrace ( ) ;
} catch ( FileNotFoundException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
ArrayList < WalsValue > valueList = new ArrayList < WalsValue > ( ) ;
Collection < ArrayList < WalsValue >> values = valueMap . values ( ) ;
Iterator < ArrayList < WalsValue >> it = values . iterator ( ) ;
while ( it . hasNext ( ) ) {
valueList . addAll ( it . next ( ) ) ;
}
return valueList ;
}
public ArrayList < Datapoint > <unk> ( ) {
HashMap < String , ArrayList < Datapoint >> dataMap = new HashMap < String , ArrayList < Datapoint >> ( ) ;
try {
dataMap = this . readDatapointsCSV ( ) ;
} catch ( UnsupportedCharsetException e ) {
e . printStackTrace ( ) ;
} catch ( FileNotFoundException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
ArrayList < Datapoint > dataList = new ArrayList < Datapoint > ( ) ;
Collection < ArrayList < Datapoint >> data = dataMap . values ( ) ;
Iterator < ArrayList < Datapoint >> it = data . iterator ( ) ;
while ( it . hasNext ( ) ) {
dataList . addAll ( it . next ( ) ) ;
}
return dataList ;
}
public ArrayList < Language > <unk> ( ) {
ArrayList < Language > languageList = new ArrayList < Language > ( ) ;
try {
languageList = this . readLanguagesCSV ( ) ;
} catch ( UnsupportedCharsetException e ) {
e . printStackTrace ( ) ;
} catch ( FileNotFoundException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
return languageList ;
}
public void setLanguageFile ( File languagesCsv ) throws FileNotFoundException {
if ( languagesCsv . exists ( ) && ! languagesCsv . isDirectory ( ) ) {
this . languageFile = languagesCsv ;
}
else {
throw new FileNotFoundException ( ) ;
}
}
public void setDatapointFile ( File datapointsCsv ) throws FileNotFoundException {
if ( datapointsCsv . exists ( ) && ! datapointsCsv . isDirectory ( ) ) {
this . datapointFile = datapointsCsv ;
}
else {
throw new FileNotFoundException ( ) ;
}
}
public void setValueFile ( File valuesCsv ) throws FileNotFoundException {
if ( valuesCsv . exists ( ) && ! valuesCsv . isDirectory ( ) ) {
this . valueFile = valuesCsv ;
}
else {
throw new FileNotFoundException ( ) ;
}
}
private HashMap < String , ArrayList < WalsValue >> readValueCSV ( ) throws FileNotFoundException , UnsupportedCharsetException , IOException {
HashMap < String , ArrayList < WalsValue >> valueMap = new HashMap < String , ArrayList < WalsValue >> ( ) ;
InputStream input = new FileInputStream ( this . valueFile ) ;
Charset charset = Charset . forName ( " ) ;
CsvReader reader = new CsvReader ( input , " . charAt ( <num> ) , charset ) ;
reader . skipLine ( ) ;
ArrayList < WalsValue > valueList = new ArrayList < WalsValue > ( ) ;
String lastId = " ;
String featureId = " ;
while ( reader . readRecord ( ) ) {
String [ ] values = reader . getValues ( ) ;
featureId = values [ <num> ] ;
WalsValue value = new WalsValue ( ) ;
if ( values [ <num> ] . equals ( lastId ) || lastId . isEmpty ( ) ) {
value . setFeatureId ( values [ <num> ] ) ;
value . setValueId ( values [ <num> ] ) ;
value . setShortDescription ( values [ <num> ] ) ;
value . setLongDescription ( values [ <num> ] ) ;
valueList . add ( value ) ;
} else {
valueMap . put ( lastId , valueList ) ;
valueList = new ArrayList < WalsValue > ( ) ;
value . setFeatureId ( values [ <num> ] ) ;
value . setValueId ( values [ <num> ] ) ;
value . setShortDescription ( values [ <num> ] ) ;
value . setLongDescription ( values [ <num> ] ) ;
valueList . add ( value ) ;
}
lastId = values [ <num> ] ;
}
valueMap . put ( featureId , valueList ) ;
return valueMap ;
}
private ArrayList < Language > readLanguagesCSV ( ) throws FileNotFoundException , UnsupportedCharsetException , IOException {
ArrayList < Language > languageList = new ArrayList < Language > ( ) ;
InputStream input = new FileInputStream ( this . languageFile ) ;
Charset charset = Charset . forName ( " ) ;
CsvReader reader = new CsvReader ( input , " . charAt ( <num> ) , charset ) ;
reader . skipLine ( ) ;
while ( reader . readRecord ( ) ) {
String [ ] values = reader . getValues ( ) ;
Language language = new Language ( ) ;
language . setWalsCode ( values [ <num> ] ) ;
language . setLanguageName ( values [ <num> ] ) ;
language . setLatitude ( values [ <num> ] ) ;
language . setLongitude ( values [ <num> ] ) ;
language . setGenus ( values [ <num> ] ) ;
language . setFamily ( values [ <num> ] ) ;
language . setSubFamily ( values [ <num> ] ) ;
language . setIsoCode ( values [ <num> ] ) ;
languageList . add ( language ) ;
}
return languageList ;
}
private HashMap < String , ArrayList < Datapoint >> readDatapointsCSV ( ) throws FileNotFoundException , UnsupportedCharsetException , IOException {
HashMap < String , ArrayList < Datapoint >> datapoints = new HashMap < String , ArrayList < Datapoint >> ( ) ;
InputStream input = new FileInputStream ( this . datapointFile ) ;
Charset charset = Charset . forName ( " ) ;
CsvReader reader = new CsvReader ( input , " . charAt ( <num> ) , charset ) ;
reader . readHeaders ( ) ;
reader . skipLine ( ) ;
while ( reader . readRecord ( ) ) {
String [ ] values = reader . getValues ( ) ;
String walsCode = values [ <num> ] ;
ArrayList < Datapoint > languageData = new ArrayList < Datapoint > ( ) ;
for ( int i = <num> ; i < values . length ; i ++ ) {
Datapoint datapoint = new Datapoint ( ) ;
datapoint . setWalsCode ( values [ <num> ] ) ;
datapoint . setFeatureId ( reader . getHeader ( i ) ) ;
datapoint . setValueId ( values [ i ] ) ;
languageData . add ( datapoint ) ;
}
datapoints . put ( walsCode , languageData ) ;
}
return datapoints ;
}
public Model getLanguageModel ( ) throws UnsupportedCharsetException , FileNotFoundException , IOException {
Model languageModel = ModelFactory . createDefaultModel ( ) ;
Property languageNameProperty = ResourceFactory . createProperty ( this . mapping . getLanguageNameProperty ( ) ) ;
Property geoLat = ResourceFactory . createProperty ( this . mapping . getGeoLatProperty ( ) ) ;
Property geoLong = ResourceFactory . createProperty ( this . mapping . getGeoLongProperty ( ) ) ;
Property genus = ResourceFactory . createProperty ( this . mapping . getGenusProperty ( ) ) ;
Property partOf = ResourceFactory . createProperty ( this . mapping . getFamilyClassProperty ( ) ) ;
Property iso = ResourceFactory . createProperty ( this . mapping . getIsoCodeProperty ( ) ) ;
Property hasFeat = ResourceFactory . createProperty ( " ) ;
Property longDesc = ResourceFactory . createProperty ( this . mapping . getValueDescriptionsProperty ( ) ) ;
ArrayList < Language > languages = this . readLanguagesCSV ( ) ;
HashMap < String , ArrayList < Datapoint >> datapoints = this . readDatapointsCSV ( ) ;
HashMap < String , ArrayList < WalsValue >> values = this . readValueCSV ( ) ;
for ( Language language : languages ) {
String languageResourceUri = this . mapping . getLanguageClassUri ( ) + language . getWalsCode ( ) ;
Resource languageResource = languageModel . createResource ( languageResourceUri ) ;
languageResource . addLiteral ( languageNameProperty , language . getLanguageName ( ) ) ;
languageResource . addLiteral ( geoLat , language . getLatitude ( ) ) ;
languageResource . addLiteral ( geoLong , language . getLongitude ( ) ) ;
languageResource . addLiteral ( genus , language . getGenus ( ) ) ;
Resource familyResource = null ;
if ( language . hasFamily ( ) ) {
String family = URLEncoder . encode ( language . getFamily ( ) , " ) ;
familyResource = languageModel . createResource ( this . mapping . getFamilyClassUri ( ) + family ) ;
familyResource . addProperty ( RDF . type , " ) ;
languageResource . addProperty ( partOf , familyResource ) ;
}
if ( language . hasSubFamily ( ) ) {
String subfamily = URLEncoder . encode ( language . getSubFamily ( ) , " ) ;
Resource subFamilyResource = languageModel . createResource ( this . mapping . getSubFamilyClassUri ( ) + subfamily ) ;
subFamilyResource . addProperty ( RDF . type , " ) ;
if ( familyResource != null ) subFamilyResource . addProperty ( partOf , familyResource ) ;
languageResource . addProperty ( partOf , subFamilyResource ) ;
}
languageResource . addLiteral ( iso , language . getIsoCode ( ) ) ;
if ( datapoints . containsKey ( language . getWalsCode ( ) ) ) {
ArrayList < Datapoint > languageData = datapoints . get ( language . getWalsCode ( ) ) ;
for ( Datapoint datapoint : languageData ) {
ArrayList < WalsValue > languageDescriptions = values . get ( datapoint . getFeatureId ( ) ) ;
for ( WalsValue value : languageDescriptions ) {
if ( value . getValueId ( ) . equals ( datapoint . getValueId ( ) ) ) {
Resource featureResource = languageModel . createResource ( this . mapping . getFeatureClassUri ( ) + value . getFeatureId ( ) ) ;
languageResource . addProperty ( hasFeat , featureResource ) ;
languageResource . addLiteral ( longDesc , value . getLongDesc ( ) ) ;
}
}
}
}
}
return languageModel ;
}
public static void main ( String [ ] args ) {
try {
File langfile = new File ( args [ <num> ] ) ;
File datafile = new File ( args [ <num> ] ) ;
File valfile = new File ( args [ <num> ] ) ;
File mappingfile = new File ( args [ <num> ] ) ;
LanguageDataToRDF convert = new LanguageDataToRDF ( langfile , datafile , valfile , mappingfile ) ;
Model rdf = convert . getLanguageModel ( ) ;
OutputStream out = new FileOutputStream ( " ) ;
rdf . write ( out ) ;
} catch ( Exception fnf ) {
fnf . printStackTrace ( ) ;
}
}
}
package com . marakana . android . audioplayerdemo ;
import android . app . Service ;
import android . content . Intent ;
import android . os . IBinder ;
import android . util . Log ;
public class AudioPlayerService extends Service {
public static final String ACTION_PLAY_PAUSE = " ;
public static final String ACTION_STOP = " ;
private static final String TAG = " ;
private IAudioPlayerServiceImpl service ;
@Override
public void onCreate ( ) {
super . onCreate ( ) ;
Log . d ( TAG , " ) ;
this . service = new IAudioPlayerServiceImpl ( this ) ;
}
@Override
public int onStartCommand ( Intent intent , int flags , int startId ) {
Log . d ( TAG , " + intent + " + flags + " + startId + " ) ;
if ( ACTION_PLAY_PAUSE . equals ( intent . getAction ( ) ) ) {
if ( this . service . isPlaying ( ) ) {
this . service . pause ( ) ;
} else {
this . service . play ( ) ;
}
} else if ( ACTION_STOP . equals ( intent . getAction ( ) ) ) {
this . service . stop ( ) ;
}
return START_STICKY ;
}
@Override
public void onDestroy ( ) {
super . onDestroy ( ) ;
Log . d ( TAG , " ) ;
}
@Override
public IBinder onBind ( Intent intent ) {
Log . d ( TAG , " + intent + " ) ;
return this . service ;
}
}
package com . marakana . android . audioplayerdemo ;
import java . lang . ref . WeakReference ;
import android . app . Notification ;
import android . app . PendingIntent ;
import android . content . BroadcastReceiver ;
import android . content . ComponentName ;
import android . content . Context ;
import android . content . Intent ;
import android . content . IntentFilter ;
import android . content . res . AssetFileDescriptor ;
import android . media . AudioManager ;
import android . media . AudioManager . OnAudioFocusChangeListener ;
import android . media . MediaPlayer ;
import android . media . MediaPlayer . OnCompletionListener ;
import android . media . MediaPlayer . OnErrorListener ;
import android . media . MediaPlayer . OnPreparedListener ;
import android . os . PowerManager ;
import android . util . Log ;
public class IAudioPlayerServiceImpl extends IAudioPlayerService . Stub implements
OnPreparedListener , OnErrorListener , OnAudioFocusChangeListener , OnCompletionListener {
private static final String TAG = " ;
private final IntentFilter AUDIO_BECOMING_NOISY_INTENT_FILTER = new IntentFilter (
AudioManager . ACTION_AUDIO_BECOMING_NOISY ) ;
private final WeakReference < AudioPlayerService > audioPlayerService ;
private final Context context ;
private MediaPlayer mediaPlayer ;
private AudioManager audioManager ;
private NoisyAudioReceiver noisyAudioReceiver ;
private ComponentName remoteControlReceiverName ;
private boolean muted = false ;
public IAudioPlayerServiceImpl ( AudioPlayerService audioPlayerService ) {
this . context = audioPlayerService . getApplicationContext ( ) ;
this . audioPlayerService = new WeakReference < AudioPlayerService > ( audioPlayerService ) ;
this . audioManager = ( AudioManager ) context . getSystemService ( Context . AUDIO_SERVICE ) ;
this . noisyAudioReceiver = new NoisyAudioReceiver ( ) ;
this . remoteControlReceiverName = new ComponentName ( context , RemoteControlReceiver . class ) ;
}
public synchronized void play ( ) {
if ( this . mediaPlayer == null ) {
Log . d ( TAG , " ) ;
this . mediaPlayer = new MediaPlayer ( ) ;
this . mediaPlayer . setAudioStreamType ( AudioManager . STREAM_MUSIC ) ;
try {
AssetFileDescriptor afd = context . getResources ( ) . openRawResourceFd ( R . raw . <unk> ) ;
try {
this . mediaPlayer . setDataSource ( afd . getFileDescriptor ( ) ) ;
Log . d ( TAG , " ) ;
} finally {
afd . close ( ) ;
}
} catch ( Exception e ) {
Log . wtf ( TAG , " , e ) ;
this . stop ( ) ;
}
this . mediaPlayer . setWakeMode ( context , PowerManager . PARTIAL_WAKE_LOCK ) ;
this . mediaPlayer . setOnErrorListener ( this ) ;
this . mediaPlayer . setOnPreparedListener ( this ) ;
this . mediaPlayer . prepareAsync ( ) ;
Log . d ( TAG , " ) ;
} else if ( ! this . mediaPlayer . isPlaying ( ) ) {
Log . d ( TAG , " ) ;
this . mediaPlayer . start ( ) ;
} else {
Log . d ( TAG , " ) ;
this . mediaPlayer . setVolume ( <num> , <num> ) ;
}
}
public synchronized boolean pause ( ) {
if ( this . mediaPlayer != null && this . mediaPlayer . isPlaying ( ) ) {
Log . d ( TAG , " ) ;
this . mediaPlayer . pause ( ) ;
return true ;
} else {
Log . d ( TAG , " ) ;
return false ;
}
}
public synchronized void stop ( ) {
if ( this . mediaPlayer == null ) {
Log . d ( TAG , " ) ;
} else {
if ( this . mediaPlayer . isPlaying ( ) ) {
Log . d ( TAG , " ) ;
this . mediaPlayer . stop ( ) ;
}
Log . d ( TAG , " ) ;
this . mediaPlayer . release ( ) ;
this . mediaPlayer = null ;
Log . d ( TAG , " ) ;
this . audioManager . abandonAudioFocus ( this ) ;
Log . d ( TAG , " ) ;
context . unregisterReceiver ( this . noisyAudioReceiver ) ;
Log . d ( TAG , " ) ;
this . audioManager . <unk> ( this . remoteControlReceiverName ) ;
Log . d ( TAG , " ) ;
this . audioPlayerService . get ( ) . stopForeground ( true ) ;
this . audioPlayerService . get ( ) . stopSelf ( ) ;
}
}
public synchronized int duration ( ) {
return this . isStopped ( ) ? <num> : this . mediaPlayer . getDuration ( ) ;
}
public synchronized int position ( ) {
return this . isStopped ( ) ? <num> : this . mediaPlayer . getCurrentPosition ( ) ;
}
public synchronized int seek ( int position ) {
if ( this . isStopped ( ) ) {
return <num> ;
} else {
this . mediaPlayer . seekTo ( position ) ;
return this . mediaPlayer . getCurrentPosition ( ) ;
}
}
public synchronized boolean isPlaying ( ) {
return this . mediaPlayer != null && this . mediaPlayer . isPlaying ( ) ;
}
public synchronized boolean isPaused ( ) {
return this . mediaPlayer != null && ! this . mediaPlayer . isPlaying ( ) ;
}
public synchronized boolean isStopped ( ) {
return this . mediaPlayer == null ;
}
public synchronized void mute ( ) {
if ( this . mediaPlayer != null ) {
this . mediaPlayer . setVolume ( <num> , <num> ) ;
this . muted = true ;
}
}
public synchronized void unmute ( ) {
if ( this . mediaPlayer != null ) {
this . mediaPlayer . setVolume ( <num> , <num> ) ;
this . muted = false ;
}
}
public synchronized boolean isMuted ( ) {
return this . mediaPlayer != null && this . muted ;
}
public synchronized void onPrepared ( MediaPlayer mp ) {
Log . d ( TAG , " ) ;
if ( this . audioManager . requestAudioFocus ( this , AudioManager . STREAM_MUSIC ,
AudioManager . AUDIOFOCUS_GAIN ) == AudioManager . AUDIOFOCUS_REQUEST_GRANTED ) {
Log . d ( TAG , " ) ;
this . context . startService ( new Intent ( this . context , AudioPlayerService . class ) ) ;
PendingIntent pendingIntent = PendingIntent . getActivity ( context , <num> , new Intent ( context ,
AudioPlayerActivity . class ) , PendingIntent . FLAG_UPDATE_CURRENT ) ;
Notification notification = new Notification ( android . R . drawable . ic_media_play ,
context . getText ( R . string . <unk> ) ,
System . currentTimeMillis ( ) ) ;
notification . setLatestEventInfo ( context ,
context . getText ( R . string . <unk> ) ,
context . getText ( R . string . <unk> ) ,
pendingIntent ) ;
notification . flags |= Notification . FLAG_ONGOING_EVENT ;
this . audioPlayerService . get ( ) . startForeground ( <num> , notification ) ;
Log . d ( TAG , " ) ;
this . mediaPlayer . setOnCompletionListener ( this ) ;
this . mediaPlayer . start ( ) ;
Log . d ( TAG , " ) ;
context . registerReceiver ( this . noisyAudioReceiver , AUDIO_BECOMING_NOISY_INTENT_FILTER ) ;
Log . d ( TAG , " ) ;
this . audioManager . <unk> ( this . remoteControlReceiverName ) ;
this . muted = false ;
} else {
Log . w ( TAG , " ) ;
this . stop ( ) ;
}
}
public void onCompletion ( MediaPlayer mp ) {
Log . d ( TAG , " ) ;
this . stop ( ) ;
}
public boolean onError ( MediaPlayer mp , int what , int extra ) {
Log . e ( TAG ,
String . format ( " , what , extra ) ) ;
this . stop ( ) ;
return true ;
}
public synchronized void onAudioFocusChange ( int focusChange ) {
switch ( focusChange ) {
case AudioManager . AUDIOFOCUS_GAIN :
Log . d ( TAG , " ) ;
this . play ( ) ;
break ;
case AudioManager . AUDIOFOCUS_LOSS :
Log . d ( TAG , " ) ;
this . stop ( ) ;
break ;
case AudioManager . AUDIOFOCUS_LOSS_TRANSIENT :
Log . d ( TAG , " ) ;
this . pause ( ) ;
break ;
case AudioManager . AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK :
Log . d ( TAG , " ) ;
if ( this . mediaPlayer != null ) {
this . mediaPlayer . setVolume ( <num> , <num> ) ;
}
break ;
default :
Log . w ( TAG , " + focusChange + " ) ;
}
}
private class NoisyAudioReceiver extends BroadcastReceiver {
@Override
public void onReceive ( Context context , Intent intent ) {
if ( AudioManager . ACTION_AUDIO_BECOMING_NOISY . equals ( intent . getAction ( ) ) ) {
Log . d ( TAG , " ) ;
IAudioPlayerServiceImpl . this . pause ( ) ;
}
}
}
}
package com . marakana . android . audioplayerdemo ;
import android . content . BroadcastReceiver ;
import android . content . Context ;
import android . content . Intent ;
import android . util . Log ;
import android . view . KeyEvent ;
public class RemoteControlReceiver extends BroadcastReceiver {
private static final String TAG = " ;
@Override
public void onReceive ( Context context , Intent intent ) {
if ( Intent . ACTION_MEDIA_BUTTON . equals ( intent . getAction ( ) ) ) {
KeyEvent event = ( KeyEvent ) intent . getParcelableExtra ( Intent . EXTRA_KEY_EVENT ) ;
switch ( event . getKeyCode ( ) ) {
case KeyEvent . KEYCODE_MEDIA_PLAY_PAUSE :
Log . d ( TAG , " ) ;
context . startService ( new Intent ( AudioPlayerService . ACTION_PLAY_PAUSE ) ) ;
break ;
case KeyEvent . KEYCODE_MEDIA_STOP :
Log . d ( TAG , " ) ;
context . startService ( new Intent ( AudioPlayerService . ACTION_STOP ) ) ;
break ;
}
}
}
}
package com . marakana . android . audioplayerdemo ;
import android . app . Activity ;
import android . content . ComponentName ;
import android . content . Intent ;
import android . content . ServiceConnection ;
import android . os . Bundle ;
import android . os . Handler ;
import android . os . IBinder ;
import android . os . RemoteException ;
import android . util . Log ;
import android . view . View ;
import android . widget . ImageButton ;
import android . widget . SeekBar ;
import android . widget . SeekBar . OnSeekBarChangeListener ;
import android . widget . TextView ;
public class AudioPlayerActivity extends Activity implements ServiceConnection ,
OnSeekBarChangeListener , Runnable {
private static final String TAG = " ;
private static final int JUMP_OFFSET = <num> ;
private Handler handler ;
private IAudioPlayerService service ;
private TextView status ;
private SeekBar seekBar ;
private ImageButton goToBeginningButton ;
private ImageButton reverseButton ;
private ImageButton playButton ;
private ImageButton pauseButton ;
private ImageButton stopButton ;
private ImageButton fastForwardButton ;
private ImageButton goToEndButton ;
private ImageButton muteButton ;
private ImageButton unmuteButton ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
this . status = ( TextView ) super . findViewById ( R . id . status ) ;
this . seekBar = ( SeekBar ) super . findViewById ( R . id . seekBar ) ;
this . seekBar . setOnSeekBarChangeListener ( this ) ;
this . goToBeginningButton = ( ImageButton ) super . findViewById ( R . id . goToBeginningButton ) ;
this . reverseButton = ( ImageButton ) super . findViewById ( R . id . reverseButton ) ;
this . playButton = ( ImageButton ) super . findViewById ( R . id . playButton ) ;
this . pauseButton = ( ImageButton ) super . findViewById ( R . id . pauseButton ) ;
this . stopButton = ( ImageButton ) super . findViewById ( R . id . stopButton ) ;
this . fastForwardButton = ( ImageButton ) super . findViewById ( R . id . fastForwardButton ) ;
this . goToEndButton = ( ImageButton ) super . findViewById ( R . id . goToEndButton ) ;
this . muteButton = ( ImageButton ) super . findViewById ( R . id . muteButton ) ;
this . unmuteButton = ( ImageButton ) super . findViewById ( R . id . unmuteButton ) ;
this . handler = new Handler ( ) ;
this . toggleButtons ( false , false ) ;
Log . d ( TAG , " + savedInstanceState + " ) ;
}
private void toggleButtons ( boolean enablePlay , boolean enableOthers ) {
this . goToBeginningButton . setEnabled ( enableOthers ) ;
this . reverseButton . setEnabled ( enableOthers ) ;
this . playButton . setEnabled ( enablePlay ) ;
this . pauseButton . setEnabled ( enableOthers ) ;
this . stopButton . setEnabled ( enableOthers ) ;
this . fastForwardButton . setEnabled ( enableOthers ) ;
this . goToEndButton . setEnabled ( enableOthers ) ;
this . muteButton . setEnabled ( enableOthers ) ;
this . unmuteButton . setEnabled ( enableOthers ) ;
this . togglePlayPauseButtons ( false ) ;
this . toggleMuteUnmuteButtons ( false ) ;
}
@Override
protected void onStart ( ) {
super . onStart ( ) ;
Log . d ( TAG , " ) ;
if ( super . bindService ( new Intent ( this , AudioPlayerService . class ) , this , BIND_AUTO_CREATE ) ) {
Log . d ( TAG , " ) ;
} else {
Log . e ( TAG , " ) ;
}
}
@Override
protected void onStop ( ) {
super . onStop ( ) ;
Log . d ( TAG , " ) ;
this . unbindService ( this ) ;
}
public void onServiceConnected ( ComponentName name , IBinder service ) {
Log . d ( TAG , " + name ) ;
this . service = IAudioPlayerService . Stub . asInterface ( service ) ;
try {
this . toggleButtons ( true , ! this . service . isStopped ( ) ) ;
boolean playing = this . service . isPlaying ( ) ;
this . togglePlayPauseButtons ( playing ) ;
if ( playing ) {
this . handler . post ( this ) ;
}
} catch ( RemoteException e ) {
Log . wtf ( TAG , " , e ) ;
}
}
public void onServiceDisconnected ( ComponentName name ) {
Log . d ( TAG , " + name ) ;
this . service = null ;
this . toggleButtons ( false , false ) ;
}
public void <unk> ( View v ) throws RemoteException {
Log . d ( TAG , " ) ;
this . service . seek ( <num> ) ;
}
public void reverse ( View v ) throws RemoteException {
Log . d ( TAG , " ) ;
this . service . seek ( Math . max ( <num> , this . service . position ( )  JUMP_OFFSET ) ) ;
}
public void play ( View v ) throws RemoteException {
Log . d ( TAG , " ) ;
this . service . play ( ) ;
this . toggleButtons ( true , true ) ;
this . togglePlayPauseButtons ( true ) ;
this . handler . postDelayed ( this , <num> ) ;
}
public void pause ( View v ) throws RemoteException {
Log . d ( TAG , " ) ;
this . service . pause ( ) ;
this . togglePlayPauseButtons ( false ) ;
}
public void stop ( View v ) throws RemoteException {
Log . d ( TAG , " ) ;
this . service . stop ( ) ;
this . toggleButtons ( true , false ) ;
this . togglePlayPauseButtons ( false ) ;
this . handler . removeCallbacks ( this ) ;
this . seekBar . setEnabled ( false ) ;
this . seekBar . setProgress ( <num> ) ;
}
public void <unk> ( View v ) throws RemoteException {
Log . d ( TAG , " ) ;
this . service . seek ( Math . min ( this . service . duration ( ) , this . service . position ( ) + JUMP_OFFSET ) ) ;
}
public void <unk> ( View v ) throws RemoteException {
Log . d ( TAG , " ) ;
this . service . pause ( ) ;
this . service . seek ( this . service . duration ( ) ) ;
this . togglePlayPauseButtons ( false ) ;
}
public void mute ( View v ) throws RemoteException {
Log . d ( TAG , " ) ;
this . service . mute ( ) ;
this . toggleMuteUnmuteButtons ( true ) ;
}
public void unmute ( View v ) throws RemoteException {
Log . d ( TAG , " ) ;
this . service . unmute ( ) ;
this . toggleMuteUnmuteButtons ( false ) ;
}
private void togglePlayPauseButtons ( boolean playing ) {
this . pauseButton . setVisibility ( playing ? View . VISIBLE : View . GONE ) ;
this . playButton . setVisibility ( playing ? View . GONE : View . VISIBLE ) ;
}
private void toggleMuteUnmuteButtons ( boolean muted ) {
this . unmuteButton . setVisibility ( muted ? View . VISIBLE : View . GONE ) ;
this . muteButton . setVisibility ( muted ? View . GONE : View . VISIBLE ) ;
}
public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) {
}
private boolean wasPlayingBeforeSeeking = false ;
public void onStartTrackingTouch ( SeekBar seekBar ) {
try {
this . wasPlayingBeforeSeeking = this . service . isPlaying ( ) ;
if ( this . wasPlayingBeforeSeeking ) {
this . service . pause ( ) ;
}
this . handler . removeCallbacks ( this ) ;
} catch ( RemoteException e ) {
Log . wtf ( TAG , " , e ) ;
}
}
public void onStopTrackingTouch ( SeekBar seekBar ) {
try {
this . service . seek ( seekBar . getProgress ( ) ) ;
if ( this . wasPlayingBeforeSeeking ) {
this . service . play ( ) ;
}
this . handler . post ( this ) ;
} catch ( RemoteException e ) {
Log . wtf ( TAG , " , e ) ;
}
}
private static String formatAsTime ( int milliseconds ) {
int seconds = milliseconds / <num> ;
return String . format ( " , seconds / <num> , seconds % <num> ) ;
}
public void run ( ) {
try {
if ( this . service == null || this . service . isStopped ( ) ) {
this . seekBar . setProgress ( <num> ) ;
this . seekBar . setEnabled ( false ) ;
this . toggleButtons ( true , false ) ;
this . togglePlayPauseButtons ( false ) ;
this . status . setText ( R . string . <unk> ) ;
} else {
int position = this . service . position ( ) ;
this . status . setText ( formatAsTime ( position ) ) ;
this . seekBar . setMax ( this . service . duration ( ) ) ;
this . seekBar . setProgress ( position ) ;
this . seekBar . setEnabled ( true ) ;
if ( this . service . isPlaying ( ) ) {
this . handler . postDelayed ( this , <num> ) ;
}
}
} catch ( RemoteException e ) {
Log . wtf ( TAG , " , e ) ;
}
}
}
package com . google . android . mms ;
import java . io . IOException ;
import org . xmlpull . v1 . XmlPullParser ;
import org . xmlpull . v1 . XmlPullParserException ;
import com . shellware . CarHome . R ;
import android . content . Context ;
import android . content . res . XmlResourceParser ;
import android . util . Config ;
import android . util . Log ;
public class MmsConfig {
private static final String TAG = " ;
private static final boolean DEBUG = false ;
private static final boolean LOCAL_LOGV = DEBUG ? Config . LOGD : Config . LOGV ;
private static final String DEFAULT_HTTP_KEY_X_WAP_PROFILE = " ;
private static final String DEFAULT_USER_AGENT = " ;
private static final int MAX_IMAGE_HEIGHT = <num> ;
private static final int MAX_IMAGE_WIDTH = <num> ;
private static boolean mTransIdEnabled = false ;
private static int mMmsEnabled = <num> ;
private static int mMaxMessageSize = <num> * <num> ;
private static String mUserAgent = DEFAULT_USER_AGENT ;
private static String mUaProfTagName = DEFAULT_HTTP_KEY_X_WAP_PROFILE ;
private static String mUaProfUrl = null ;
private static String mHttpParams = null ;
private static String mHttpParamsLine1Key = null ;
private static String mEmailGateway = null ;
private static int mMaxImageHeight = MAX_IMAGE_HEIGHT ;
private static int mMaxImageWidth = MAX_IMAGE_WIDTH ;
private static int mRecipientLimit = Integer . MAX_VALUE ;
private static int mDefaultSMSMessagesPerThread = <num> ;
private static int mDefaultMMSMessagesPerThread = <num> ;
private static int mMinMessageCountPerThread = <num> ;
private static int mMaxMessageCountPerThread = <num> ;
private static int mHttpSocketTimeout = <num> * <num> ;
private static int mMinimumSlideElementDuration = <num> ;
private static boolean mNotifyWapMMSC = false ;
private static boolean mAllowAttachAudio = true ;
private static int mMaxSizeScaleForPendingMmsAllowed = <num> ;
private static boolean mAliasEnabled = false ;
private static int mAliasRuleMinChars = <num> ;
private static int mAliasRuleMaxChars = <num> ;
public static void init ( Context context ) {
if ( LOCAL_LOGV ) {
Log . v ( TAG , " ) ;
}
loadMmsSettings ( context ) ;
}
public static boolean getMmsEnabled ( ) {
return mMmsEnabled == <num> ? true : false ;
}
public static int <unk> ( ) {
return mMaxMessageSize ;
}
public static boolean <unk> ( ) {
return mTransIdEnabled ;
}
public static String getUserAgent ( ) {
return mUserAgent ;
}
public static String getUaProfTagName ( ) {
return mUaProfTagName ;
}
public static String getUaProfUrl ( ) {
return mUaProfUrl ;
}
public static String getHttpParams ( ) {
return mHttpParams ;
}
public static String getHttpParamsLine1Key ( ) {
return mHttpParamsLine1Key ;
}
public static String <unk> ( ) {
return mEmailGateway ;
}
public static int <unk> ( ) {
return mMaxImageHeight ;
}
public static int <unk> ( ) {
return mMaxImageWidth ;
}
public static int <unk> ( ) {
return mRecipientLimit ;
}
public static int <unk> ( ) {
return mDefaultSMSMessagesPerThread ;
}
public static int <unk> ( ) {
return mDefaultMMSMessagesPerThread ;
}
public static int <unk> ( ) {
return mMinMessageCountPerThread ;
}
public static int <unk> ( ) {
return mMaxMessageCountPerThread ;
}
public static int getHttpSocketTimeout ( ) {
return mHttpSocketTimeout ;
}
public static int <unk> ( ) {
return mMinimumSlideElementDuration ;
}
public static boolean <unk> ( ) {
return mNotifyWapMMSC ;
}
public static int <unk> ( ) {
return mMaxSizeScaleForPendingMmsAllowed ;
}
public static boolean <unk> ( ) {
return mAliasEnabled ;
}
public static int <unk> ( ) {
return mAliasRuleMinChars ;
}
public static int <unk> ( ) {
return mAliasRuleMaxChars ;
}
public static boolean <unk> ( ) {
return mAllowAttachAudio ;
}
public static final void beginDocument ( XmlPullParser parser , String firstElementName ) throws XmlPullParserException , IOException
{
int type ;
while ( ( type = parser . next ( ) ) != parser . START_TAG
&& type != parser . END_DOCUMENT ) {
;
}
if ( type != parser . START_TAG ) {
throw new XmlPullParserException ( " ) ;
}
if ( ! parser . getName ( ) . equals ( firstElementName ) ) {
throw new XmlPullParserException ( " + parser . getName ( ) +
" + firstElementName ) ;
}
}
public static final void nextElement ( XmlPullParser parser ) throws XmlPullParserException , IOException
{
int type ;
while ( ( type = parser . next ( ) ) != parser . START_TAG
&& type != parser . END_DOCUMENT ) {
;
}
}
private static void loadMmsSettings ( Context context ) {
XmlResourceParser parser = context . getResources ( ) . getXml ( R . xml . <unk> ) ;
try {
beginDocument ( parser , " ) ;
while ( true ) {
nextElement ( parser ) ;
String tag = parser . getName ( ) ;
if ( tag == null ) {
break ;
}
String name = parser . getAttributeName ( <num> ) ;
String value = parser . getAttributeValue ( <num> ) ;
String text = null ;
if ( parser . next ( ) == XmlPullParser . TEXT ) {
text = parser . getText ( ) ;
}
if ( DEBUG ) {
Log . v ( TAG , " + tag + " + value ) ;
}
if ( " . equalsIgnoreCase ( name ) ) {
if ( " . equals ( tag ) ) {
if ( " . equalsIgnoreCase ( value ) ) {
mMmsEnabled = " . equalsIgnoreCase ( text ) ? <num> : <num> ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mTransIdEnabled = " . equalsIgnoreCase ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mNotifyWapMMSC = " . equalsIgnoreCase ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mAliasEnabled = " . equalsIgnoreCase ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mAllowAttachAudio = " . equalsIgnoreCase ( text ) ;
}
} else if ( " . equals ( tag ) ) {
if ( " . equalsIgnoreCase ( value ) ) {
mMaxMessageSize = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mMaxImageHeight = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mMaxImageWidth = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mDefaultSMSMessagesPerThread = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mDefaultMMSMessagesPerThread = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mMinMessageCountPerThread = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mMaxMessageCountPerThread = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mRecipientLimit = Integer . parseInt ( text ) ;
if ( mRecipientLimit < <num> ) {
mRecipientLimit = Integer . MAX_VALUE ;
}
} else if ( " . equalsIgnoreCase ( value ) ) {
mHttpSocketTimeout = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mMinimumSlideElementDuration = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mMaxSizeScaleForPendingMmsAllowed = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mAliasRuleMinChars = Integer . parseInt ( text ) ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mAliasRuleMaxChars = Integer . parseInt ( text ) ;
}
} else if ( " . equals ( tag ) ) {
if ( " . equalsIgnoreCase ( value ) ) {
mUserAgent = text ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mUaProfTagName = text ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mUaProfUrl = text ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mHttpParams = text ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mHttpParamsLine1Key = text ;
} else if ( " . equalsIgnoreCase ( value ) ) {
mEmailGateway = text ;
}
}
}
}
} catch ( XmlPullParserException e ) {
Log . e ( TAG , " , e ) ;
} catch ( NumberFormatException e ) {
Log . e ( TAG , " , e ) ;
} catch ( IOException e ) {
Log . e ( TAG , " , e ) ;
} finally {
parser . close ( ) ;
}
String errorStr = null ;
if ( getMmsEnabled ( ) && mUaProfUrl == null ) {
errorStr = " ;
}
if ( errorStr != null ) {
String err =
String . format ( " ,
errorStr ) ;
Log . e ( TAG , err ) ;
throw new ContentRestrictionException ( err ) ;
}
}
}
package com . google . android . mms . pdu ;
import android . util . Log ;
import com . google . android . mms . InvalidHeaderValueException ;
public class SendReq extends MultimediaMessagePdu {
private static final String TAG = " ;
public SendReq ( ) {
super ( ) ;
try {
setMessageType ( PduHeaders . MESSAGE_TYPE_SEND_REQ ) ;
setMmsVersion ( PduHeaders . CURRENT_MMS_VERSION ) ;
setContentType ( " . getBytes ( ) ) ;
setTransactionId ( generateTransactionId ( ) ) ;
} catch ( InvalidHeaderValueException e ) {
Log . e ( TAG , " , e ) ;
throw new RuntimeException ( e ) ;
}
}
private byte [ ] generateTransactionId ( ) {
String transactionId = " + Long . toHexString ( System . currentTimeMillis ( ) ) ;
return transactionId . getBytes ( ) ;
}
public SendReq ( byte [ ] contentType ,
EncodedStringValue from ,
int mmsVersion ,
byte [ ] transactionId ) throws InvalidHeaderValueException {
super ( ) ;
setMessageType ( PduHeaders . MESSAGE_TYPE_SEND_REQ ) ;
setContentType ( contentType ) ;
setMmsVersion ( mmsVersion ) ;
setTransactionId ( transactionId ) ;
}
SendReq ( PduHeaders headers ) {
super ( headers ) ;
}
SendReq ( PduHeaders headers , PduBody body ) {
super ( headers , body ) ;
}
public EncodedStringValue [ ] getBcc ( ) {
return mPduHeaders . getEncodedStringValues ( PduHeaders . BCC ) ;
}
public void <unk> ( EncodedStringValue value ) {
mPduHeaders . appendEncodedStringValue ( value , PduHeaders . BCC ) ;
}
public void setBcc ( EncodedStringValue [ ] value ) {
mPduHeaders . setEncodedStringValues ( value , PduHeaders . BCC ) ;
}
public EncodedStringValue [ ] getCc ( ) {
return mPduHeaders . getEncodedStringValues ( PduHeaders . CC ) ;
}
public void <unk> ( EncodedStringValue value ) {
mPduHeaders . appendEncodedStringValue ( value , PduHeaders . CC ) ;
}
public void setCc ( EncodedStringValue [ ] value ) {
mPduHeaders . setEncodedStringValues ( value , PduHeaders . CC ) ;
}
public byte [ ] getContentType ( ) {
return mPduHeaders . getTextString ( PduHeaders . CONTENT_TYPE ) ;
}
public void setContentType ( byte [ ] value ) {
mPduHeaders . setTextString ( value , PduHeaders . CONTENT_TYPE ) ;
}
public int <unk> ( ) {
return mPduHeaders . getOctet ( PduHeaders . DELIVERY_REPORT ) ;
}
public void <unk> ( int value ) throws InvalidHeaderValueException {
mPduHeaders . setOctet ( value , PduHeaders . DELIVERY_REPORT ) ;
}
public long <unk> ( ) {
return mPduHeaders . getLongInteger ( PduHeaders . EXPIRY ) ;
}
public void <unk> ( long value ) {
mPduHeaders . setLongInteger ( value , PduHeaders . EXPIRY ) ;
}
public long <unk> ( ) {
return mPduHeaders . getLongInteger ( PduHeaders . MESSAGE_SIZE ) ;
}
public void <unk> ( long value ) {
mPduHeaders . setLongInteger ( value , PduHeaders . MESSAGE_SIZE ) ;
}
public byte [ ] <unk> ( ) {
return mPduHeaders . getTextString ( PduHeaders . MESSAGE_CLASS ) ;
}
public void <unk> ( byte [ ] value ) {
mPduHeaders . setTextString ( value , PduHeaders . MESSAGE_CLASS ) ;
}
public int <unk> ( ) {
return mPduHeaders . getOctet ( PduHeaders . READ_REPORT ) ;
}
public void <unk> ( int value ) throws InvalidHeaderValueException {
mPduHeaders . setOctet ( value , PduHeaders . READ_REPORT ) ;
}
public void setTo ( EncodedStringValue [ ] value ) {
mPduHeaders . setEncodedStringValues ( value , PduHeaders . TO ) ;
}
public byte [ ] getTransactionId ( ) {
return mPduHeaders . getTextString ( PduHeaders . TRANSACTION_ID ) ;
}
public void setTransactionId ( byte [ ] value ) {
mPduHeaders . setTextString ( value , PduHeaders . TRANSACTION_ID ) ;
}
package com . shellware . CarHome . media ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . List ;
import com . shellware . CarHome . CarHomeActivity ;
import com . shellware . CarHome . R ;
import com . shellware . CarHome . R . drawable ;
import com . shellware . CarHome . R . string ;
import com . shellware . CarHome . media . MusicRetriever . Item ;
import android . app . Notification ;
import android . app . NotificationManager ;
import android . app . PendingIntent ;
import android . app . Service ;
import android . content . Context ;
import android . content . Intent ;
import android . graphics . Bitmap ;
import android . media . AudioManager ;
import android . media . MediaPlayer ;
import android . media . MediaPlayer . OnCompletionListener ;
import android . media . MediaPlayer . OnErrorListener ;
import android . media . MediaPlayer . OnPreparedListener ;
import android . net . Uri ;
import android . net . wifi . WifiManager ;
import android . net . wifi . WifiManager . WifiLock ;
import android . os . IBinder ;
import android . os . PowerManager ;
import android . util . Log ;
import android . widget . Toast ;
public class MusicService extends Service implements OnCompletionListener , OnPreparedListener ,
OnErrorListener , MusicFocusable ,
PrepareMusicRetrieverTask . MusicRetrieverPreparedListener {
private NotificationManager mNotificationManager ;
private static MediaPlayer mPlayer = null ;
private AudioFocusHelper mAudioFocusHelper = null ;
public enum State {
Retrieving ,
Stopped ,
Preparing ,
Playing ,
Paused
} ;
public static State mState = State . Retrieving ;
private boolean mStartPlayingAfterRetrieve = false ;
private Uri mWhatToPlayAfterRetrieve = null ;
private enum PauseReason {
UserRequest ,
<unk> ,
} ;
private PauseReason <unk> = PauseReason . UserRequest ;
private enum AudioFocus {
NoFocusNoDuck ,
NoFocusCanDuck ,
Focused
}
private AudioFocus mAudioFocus = AudioFocus . NoFocusNoDuck ;
private static List < Item > mHistory = new ArrayList < Item > ( ) ;
private boolean mIsStreaming = false ;
private WifiLock mWifiLock ;
private final static String TAG = " ;
public static final String ACTION_PLAY = " ;
public static final String ACTION_PAUSE = " ;
public static final String ACTION_STOP = " ;
public static final String ACTION_SKIP = " ;
public static final String ACTION_REWIND = " ;
public static final String ACTION_URL = " ;
public final float DUCK_VOLUME = <num> ;
private final int NOTIFICATION_ID = <num> ;
private MusicRetriever mRetriever ;
private Notification mNotification = null ;
private void createMediaPlayerIfNeeded ( ) {
if ( mPlayer == null ) {
mPlayer = new MediaPlayer ( ) ;
mPlayer . setWakeMode ( getApplicationContext ( ) , PowerManager . PARTIAL_WAKE_LOCK ) ;
mPlayer . setOnPreparedListener ( this ) ;
mPlayer . setOnCompletionListener ( this ) ;
mPlayer . setOnErrorListener ( this ) ;
}
else
mPlayer . reset ( ) ;
}
@Override
public void onCreate ( ) {
Log . i ( TAG , " ) ;
mWifiLock = ( ( WifiManager ) getSystemService ( Context . WIFI_SERVICE ) )
. createWifiLock ( WifiManager . WIFI_MODE_FULL , " ) ;
mNotificationManager = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ;
mRetriever = new MusicRetriever ( getContentResolver ( ) ) ;
( new PrepareMusicRetrieverTask ( mRetriever , this ) ) . execute ( ) ;
if ( android . os . Build . VERSION . SDK_INT >= <num> )
mAudioFocusHelper = new AudioFocusHelper ( getApplicationContext ( ) , this ) ;
else
mAudioFocus = AudioFocus . Focused ;
}
@Override
public int onStartCommand ( Intent intent , int flags , int startId ) {
String action = intent . getAction ( ) ;
Log . d ( TAG , " + action ) ;
if ( action . equals ( ACTION_PLAY ) ) processPlayRequest ( ) ;
else if ( action . equals ( ACTION_PAUSE ) ) processPauseRequest ( ) ;
else if ( action . equals ( ACTION_SKIP ) ) processSkipRequest ( ) ;
else if ( action . equals ( ACTION_STOP ) ) processStopRequest ( ) ;
else if ( action . equals ( ACTION_REWIND ) ) processRewindRequest ( ) ;
else if ( action . equals ( ACTION_URL ) ) processAddRequest ( intent ) ;
return START_NOT_STICKY ;
}
void processPlayRequest ( ) {
if ( mState == State . Retrieving ) {
mWhatToPlayAfterRetrieve = null ;
mStartPlayingAfterRetrieve = true ;
return ;
}
tryToGetAudioFocus ( ) ;
if ( mState == State . Stopped ) {
playNextSong ( null ) ;
}
else if ( mState == State . Paused ) {
mState = State . Playing ;
setUpAsForeground ( getCurrentItem ( ) . getArtist ( ) + " + getCurrentItem ( ) . getTitle ( ) ) ;
configAndStartMediaPlayer ( ) ;
}
}
void processPauseRequest ( ) {
if ( mState == State . Retrieving ) {
mStartPlayingAfterRetrieve = false ;
return ;
}
if ( mState == State . Playing ) {
mState = State . Paused ;
mPlayer . pause ( ) ;
relaxResources ( false ) ;
giveUpAudioFocus ( ) ;
}
}
void processRewindRequest ( ) {
if ( mState == State . Playing || mState == State . Paused ) {
if ( mPlayer . getCurrentPosition ( ) > <num> ) {
mPlayer . seekTo ( <num> ) ;
} else {
try {
if ( mHistory . size ( ) == <num> ) return ;
mHistory . remove ( mHistory . size ( )  <num> ) ;
if ( mHistory . size ( ) == <num> ) return ;
createMediaPlayerIfNeeded ( ) ;
mState = State . Preparing ;
mPlayer . setAudioStreamType ( AudioManager . STREAM_MUSIC ) ;
mPlayer . setDataSource ( getApplicationContext ( ) , getCurrentItem ( ) . getURI ( ) ) ;
setUpAsForeground ( getCurrentItem ( ) . getArtist ( ) + " + getCurrentItem ( ) . getTitle ( ) ) ;
mPlayer . prepareAsync ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
}
}
void processSkipRequest ( ) {
if ( mState == State . Stopped || mState == State . Retrieving ) {
processPlayRequest ( ) ;
return ;
}
if ( mState == State . Playing || mState == State . Paused ) {
tryToGetAudioFocus ( ) ;
playNextSong ( null ) ;
}
}
void processStopRequest ( ) {
if ( mState == State . Playing || mState == State . Paused ) {
mState = State . Stopped ;
relaxResources ( true ) ;
giveUpAudioFocus ( ) ;
}
}
void relaxResources ( boolean releaseMediaPlayer ) {
stopForeground ( true ) ;
if ( releaseMediaPlayer && mPlayer != null ) {
mPlayer . reset ( ) ;
mPlayer . release ( ) ;
mPlayer = null ;
}
if ( mWifiLock . isHeld ( ) ) mWifiLock . release ( ) ;
}
void giveUpAudioFocus ( ) {
if ( mAudioFocus == AudioFocus . Focused && mAudioFocusHelper != null
&& mAudioFocusHelper . abandonFocus ( ) )
mAudioFocus = AudioFocus . NoFocusNoDuck ;
}
void configAndStartMediaPlayer ( ) {
if ( mAudioFocus == AudioFocus . NoFocusNoDuck ) {
if ( mPlayer . isPlaying ( ) ) mPlayer . pause ( ) ;
return ;
}
else if ( mAudioFocus == AudioFocus . NoFocusCanDuck )
mPlayer . setVolume ( DUCK_VOLUME , DUCK_VOLUME ) ;
else
mPlayer . setVolume ( <num> , <num> ) ;
if ( ! mPlayer . isPlaying ( ) ) mPlayer . start ( ) ;
}
void processAddRequest ( Intent intent ) {
if ( mState == State . Retrieving ) {
mWhatToPlayAfterRetrieve = intent . getData ( ) ;
mStartPlayingAfterRetrieve = true ;
}
else if ( mState == State . Playing || mState == State . Paused || mState == State . Stopped ) {
Log . i ( TAG , " + intent . getData ( ) . toString ( ) ) ;
tryToGetAudioFocus ( ) ;
playNextSong ( intent . getData ( ) . toString ( ) ) ;
}
}
void say ( String message ) {
Toast . makeText ( this , message , Toast . LENGTH_SHORT ) . show ( ) ;
}
void tryToGetAudioFocus ( ) {
if ( mAudioFocus != AudioFocus . Focused && mAudioFocusHelper != null
&& mAudioFocusHelper . requestFocus ( ) )
mAudioFocus = AudioFocus . Focused ;
}
void playNextSong ( String manualUrl ) {
mState = State . Stopped ;
relaxResources ( false ) ;
try {
if ( manualUrl != null ) {
createMediaPlayerIfNeeded ( ) ;
mPlayer . setAudioStreamType ( AudioManager . STREAM_MUSIC ) ;
mPlayer . setDataSource ( manualUrl ) ;
mIsStreaming = manualUrl . startsWith ( " ) || manualUrl . startsWith ( " ) ;
}
else {
mIsStreaming = false ;
MusicRetriever . Item item = mRetriever . getRandomItem ( ) ;
if ( item == null ) {
say ( " ) ;
return ;
}
mHistory . add ( item ) ;
createMediaPlayerIfNeeded ( ) ;
mPlayer . setAudioStreamType ( AudioManager . STREAM_MUSIC ) ;
mPlayer . setDataSource ( getApplicationContext ( ) , item . getURI ( ) ) ;
}
mState = State . Preparing ;
setUpAsForeground ( getCurrentItem ( ) . getArtist ( ) + " + getCurrentItem ( ) . getTitle ( ) ) ;
mPlayer . prepareAsync ( ) ;
if ( mIsStreaming ) mWifiLock . acquire ( ) ;
else if ( mWifiLock . isHeld ( ) ) mWifiLock . release ( ) ;
}
catch ( IOException ex ) {
Log . e ( " , " + ex . getMessage ( ) ) ;
ex . printStackTrace ( ) ;
}
}
public void onCompletion ( MediaPlayer player ) {
playNextSong ( null ) ;
}
public void onPrepared ( MediaPlayer player ) {
mState = State . Playing ;
updateNotification ( getCurrentItem ( ) . getArtist ( ) + " + getCurrentItem ( ) . getTitle ( ) ) ;
configAndStartMediaPlayer ( ) ;
}
void updateNotification ( String text ) {
PendingIntent pi = PendingIntent . getActivity ( getApplicationContext ( ) , <num> ,
new Intent ( getApplicationContext ( ) , CarHomeActivity . class ) ,
PendingIntent . FLAG_UPDATE_CURRENT ) ;
mNotification . setLatestEventInfo ( getApplicationContext ( ) , getString ( R . string . app_name ) , text , pi ) ;
mNotificationManager . notify ( NOTIFICATION_ID , mNotification ) ;
}
void setUpAsForeground ( String text ) {
PendingIntent pi = PendingIntent . getActivity ( getApplicationContext ( ) , <num> ,
new Intent ( getApplicationContext ( ) , CarHomeActivity . class ) ,
PendingIntent . FLAG_UPDATE_CURRENT ) ;
mNotification = new Notification ( ) ;
mNotification . tickerText = text ;
mNotification . icon = R . drawable . <unk> ;
mNotification . flags |= Notification . FLAG_ONGOING_EVENT ;
mNotification . setLatestEventInfo ( getApplicationContext ( ) , getString ( R . string . app_name ) , text , pi ) ;
startForeground ( NOTIFICATION_ID , mNotification ) ;
}
public boolean onError ( MediaPlayer mp , int what , int extra ) {
Toast . makeText ( getApplicationContext ( ) , " ,
Toast . LENGTH_SHORT ) . show ( ) ;
Log . e ( TAG , " + String . valueOf ( what ) + " + String . valueOf ( extra ) ) ;
mState = State . Stopped ;
relaxResources ( true ) ;
giveUpAudioFocus ( ) ;
return true ;
}
public void onGainedAudioFocus ( ) {
mAudioFocus = AudioFocus . Focused ;
if ( mState == State . Playing )
configAndStartMediaPlayer ( ) ;
}
public void onLostAudioFocus ( boolean canDuck ) {
mAudioFocus = canDuck ? AudioFocus . NoFocusCanDuck : AudioFocus . NoFocusNoDuck ;
if ( mPlayer != null && mPlayer . isPlaying ( ) )
configAndStartMediaPlayer ( ) ;
}
public void onMusicRetrieverPrepared ( ) {
mState = State . Stopped ;
if ( mStartPlayingAfterRetrieve ) {
tryToGetAudioFocus ( ) ;
playNextSong ( mWhatToPlayAfterRetrieve == null ?
null : mWhatToPlayAfterRetrieve . toString ( ) ) ;
}
}
@Override
public void onDestroy ( ) {
mState = State . Stopped ;
relaxResources ( true ) ;
giveUpAudioFocus ( ) ;
}
@Override
public IBinder onBind ( Intent arg0 ) {
return null ;
}
public static int getPosition ( ) {
return mState == State . Paused || mState == State . Playing ? mPlayer . getCurrentPosition ( ) : <num> ;
}
public static void setPosition ( int position ) {
if ( mState == State . Paused || mState == State . Playing ) {
mPlayer . seekTo ( position ) ;
}
}
public static List < Item > <unk> ( ) {
return mHistory ;
}
public static Item getCurrentItem ( ) {
return mHistory . get ( mHistory . size ( )  <num> ) ;
}
}
package com . google . android . mms . pdu ;
import android . net . Uri ;
import java . util . HashMap ;
import java . util . Map ;
public class PduPart {
public static final int <unk> = <num> ;
public static final int P_CHARSET = <num> ;
public static final int <unk> = <num> ;
public static final int P_TYPE = <num> ;
public static final int P_DEP_NAME = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int P_CT_MR_TYPE = <num> ;
public static final int P_DEP_START = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int P_NAME = <num> ;
public static final int P_FILENAME = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int P_PATH = <num> ;
public static final int P_CONTENT_TYPE = <num> ;
public static final int P_CONTENT_LOCATION = <num> ;
public static final int P_CONTENT_ID = <num> ;
public static final int <unk> = <num> ;
public static final int P_CONTENT_DISPOSITION = <num> ;
public static final int P_CONTENT_TRANSFER_ENCODING = <num> ;
public static final String <unk> =
" ;
public static final String <unk> = " ;
public static final String <unk> = " ;
public static final String <unk> = " ;
public static final String <unk> = " ;
public static final String <unk> = " ;
static final byte [ ] <unk> = " . getBytes ( ) ;
static final byte [ ] <unk> = " . getBytes ( ) ;
static final byte [ ] <unk> = " . getBytes ( ) ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
private Map < Integer , Object > mPartHeader = null ;
private Uri mUri = null ;
private byte [ ] mPartData = null ;
private static final String TAG = " ;
public PduPart ( ) {
mPartHeader = new HashMap < Integer , Object > ( ) ;
}
public void setData ( byte [ ] data ) {
if ( data == null ) {
return ;
}
mPartData = new byte [ data . length ] ;
System . arraycopy ( data , <num> , mPartData , <num> , data . length ) ;
}
public byte [ ] getData ( ) {
if ( mPartData == null ) {
return null ;
}
byte [ ] byteArray = new byte [ mPartData . length ] ;
System . arraycopy ( mPartData , <num> , byteArray , <num> , mPartData . length ) ;
return byteArray ;
}
public void <unk> ( Uri uri ) {
mUri = uri ;
}
public Uri getDataUri ( ) {
return mUri ;
}
public void setContentId ( byte [ ] contentId ) {
if ( ( contentId == null ) || ( contentId . length == <num> ) ) {
throw new IllegalArgumentException (
" ) ;
}
if ( ( contentId . length > <num> )
&& ( ( char ) contentId [ <num> ] == <' )
&& ( ( char ) contentId [ contentId . length  <num> ] == >' ) ) {
mPartHeader . put ( P_CONTENT_ID , contentId ) ;
return ;
}
byte [ ] buffer = new byte [ contentId . length + <num> ] ;
buffer [ <num> ] = ( byte ) ( <num> & <' ) ;
buffer [ buffer . length  <num> ] = ( byte ) ( <num> & >' ) ;
System . arraycopy ( contentId , <num> , buffer , <num> , contentId . length ) ;
mPartHeader . put ( P_CONTENT_ID , buffer ) ;
}
public byte [ ] getContentId ( ) {
return ( byte [ ] ) mPartHeader . get ( P_CONTENT_ID ) ;
}
public void setCharset ( int charset ) {
mPartHeader . put ( P_CHARSET , charset ) ;
}
public int getCharset ( ) {
Integer charset = ( Integer ) mPartHeader . get ( P_CHARSET ) ;
if ( charset == null ) {
return <num> ;
} else {
return charset . intValue ( ) ;
}
}
public void <unk> ( byte [ ] contentLocation ) {
if ( contentLocation == null ) {
throw new NullPointerException ( " ) ;
}
mPartHeader . put ( P_CONTENT_LOCATION , contentLocation ) ;
}
public byte [ ] getContentLocation ( ) {
return ( byte [ ] ) mPartHeader . get ( P_CONTENT_LOCATION ) ;
}
public void <unk> ( byte [ ] contentDisposition ) {
if ( contentDisposition == null ) {
throw new NullPointerException ( " ) ;
}
mPartHeader . put ( P_CONTENT_DISPOSITION , contentDisposition ) ;
}
public byte [ ] <unk> ( ) {
return ( byte [ ] ) mPartHeader . get ( P_CONTENT_DISPOSITION ) ;
}
public void setContentType ( byte [ ] contentType ) {
if ( contentType == null ) {
throw new NullPointerException ( " ) ;
}
mPartHeader . put ( P_CONTENT_TYPE , contentType ) ;
}
public byte [ ] getContentType ( ) {
return ( byte [ ] ) mPartHeader . get ( P_CONTENT_TYPE ) ;
}
public void <unk> ( byte [ ] contentTransferEncoding ) {
if ( contentTransferEncoding == null ) {
throw new NullPointerException ( " ) ;
}
mPartHeader . put ( P_CONTENT_TRANSFER_ENCODING , contentTransferEncoding ) ;
}
public byte [ ] <unk> ( ) {
return ( byte [ ] ) mPartHeader . get ( P_CONTENT_TRANSFER_ENCODING ) ;
}
public void setName ( byte [ ] name ) {
if ( null == name ) {
throw new NullPointerException ( " ) ;
}
mPartHeader . put ( P_NAME , name ) ;
}
public byte [ ] getName ( ) {
return ( byte [ ] ) mPartHeader . get ( P_NAME ) ;
}
public void setFilename ( byte [ ] fileName ) {
if ( null == fileName ) {
throw new NullPointerException ( " ) ;
}
mPartHeader . put ( P_FILENAME , fileName ) ;
}
public byte [ ] getFilename ( ) {
return ( byte [ ] ) mPartHeader . get ( P_FILENAME ) ;
}
public String <unk> ( ) {
byte [ ] location = ( byte [ ] ) mPartHeader . get ( P_NAME ) ;
if ( null == location ) {
location = ( byte [ ] ) mPartHeader . get ( P_FILENAME ) ;
if ( null == location ) {
location = ( byte [ ] ) mPartHeader . get ( P_CONTENT_LOCATION ) ;
}
}
if ( null == location ) {
byte [ ] contentId = ( byte [ ] ) mPartHeader . get ( P_CONTENT_ID ) ;
return " + new String ( contentId ) ;
} else {
return new String ( location ) ;
}
}
}
package com . google . android . mms . transaction ;
import org . apache . http . HttpEntity ;
import org . apache . http . HttpHost ;
import org . apache . http . HttpRequest ;
import org . apache . http . HttpResponse ;
import org . apache . http . StatusLine ;
import org . apache . http . client . methods . HttpGet ;
import org . apache . http . client . methods . HttpPost ;
import org . apache . http . conn . params . ConnRouteParams ;
import org . apache . http . params . HttpParams ;
import org . apache . http . params . HttpProtocolParams ;
import org . apache . http . params . HttpConnectionParams ;
import com . google . android . mms . LogTag ;
import com . google . android . mms . MmsConfig ;
import android . content . Context ;
import android . net . http . AndroidHttpClient ;
import android . telephony . TelephonyManager ;
import android . text . TextUtils ;
import android . util . Config ;
import android . util . Log ;
import java . io . DataInputStream ;
import java . io . IOException ;
import java . net . SocketException ;
import java . net . URI ;
import java . net . URISyntaxException ;
import java . util . Locale ;
public class HttpUtils {
private static final String TAG = LogTag . TRANSACTION ;
private static final boolean DEBUG = false ;
private static final boolean LOCAL_LOGV = DEBUG ? Config . LOGD : Config . LOGV ;
public static final int HTTP_POST_METHOD = <num> ;
public static final int HTTP_GET_METHOD = <num> ;
private static final String HDR_VALUE_ACCEPT_LANGUAGE ;
static {
HDR_VALUE_ACCEPT_LANGUAGE = getHttpAcceptLanguage ( ) ;
}
private static final String HDR_KEY_ACCEPT = " ;
private static final String HDR_KEY_ACCEPT_LANGUAGE = " ;
private static final String HDR_VALUE_ACCEPT =
" ;
private HttpUtils ( ) {
}
public static byte [ ] httpConnection ( Context context , long token ,
String url , byte [ ] pdu , int method , boolean isProxySet ,
String proxyHost , int proxyPort ) throws IOException {
if ( url == null ) {
throw new IllegalArgumentException ( " ) ;
}
if ( LOCAL_LOGV ) {
Log . v ( TAG , " ) ;
Log . v ( TAG , " + token ) ;
Log . v ( TAG , " + url ) ;
Log . v ( TAG , "
+ ( ( method == HTTP_POST_METHOD ) ? "
: ( ( method == HTTP_GET_METHOD ) ? " : " ) ) ) ;
Log . v ( TAG , " + isProxySet ) ;
Log . v ( TAG , " + proxyHost ) ;
Log . v ( TAG , " + proxyPort ) ;
}
AndroidHttpClient client = null ;
try {
URI hostUrl = new URI ( url ) ;
HttpHost target = new HttpHost (
hostUrl . getHost ( ) , hostUrl . getPort ( ) ,
HttpHost . <unk> ) ;
client = createHttpClient ( context ) ;
HttpRequest req = null ;
switch ( method ) {
case HTTP_POST_METHOD :
ProgressCallbackEntity entity = new ProgressCallbackEntity (
context , token , pdu ) ;
entity . setContentType ( " ) ;
HttpPost post = new HttpPost ( url ) ;
post . setEntity ( entity ) ;
req = post ;
break ;
case HTTP_GET_METHOD :
req = new HttpGet ( url ) ;
break ;
default :
Log . e ( TAG , " + method
+ " + HTTP_POST_METHOD
+ " + HTTP_GET_METHOD + " ) ;
return null ;
}
HttpParams params = client . getParams ( ) ;
if ( isProxySet ) {
ConnRouteParams . <unk> (
params , new HttpHost ( proxyHost , proxyPort ) ) ;
}
req . setParams ( params ) ;
req . addHeader ( HDR_KEY_ACCEPT , HDR_VALUE_ACCEPT ) ;
{
String xWapProfileTagName = MmsConfig . getUaProfTagName ( ) ;
String xWapProfileUrl = MmsConfig . getUaProfUrl ( ) ;
if ( xWapProfileUrl != null ) {
if ( Log . isLoggable ( LogTag . TRANSACTION , Log . VERBOSE ) ) {
Log . d ( LogTag . TRANSACTION ,
" + xWapProfileUrl ) ;
}
req . addHeader ( xWapProfileTagName , xWapProfileUrl ) ;
}
}
String extraHttpParams = MmsConfig . getHttpParams ( ) ;
if ( extraHttpParams != null ) {
String line1Number = ( ( TelephonyManager ) context
. getSystemService ( Context . TELEPHONY_SERVICE ) )
. getLine1Number ( ) ;
String line1Key = MmsConfig . getHttpParamsLine1Key ( ) ;
String paramList [ ] = extraHttpParams . split ( " ) ;
for ( String paramPair : paramList ) {
String splitPair [ ] = paramPair . split ( " , <num> ) ;
if ( splitPair . length == <num> ) {
String name = splitPair [ <num> ] . trim ( ) ;
String value = splitPair [ <num> ] . trim ( ) ;
if ( line1Key != null ) {
value = value . replace ( line1Key , line1Number ) ;
}
if ( ! TextUtils . isEmpty ( name ) && ! TextUtils . isEmpty ( value ) ) {
req . addHeader ( name , value ) ;
}
}
}
}
req . addHeader ( HDR_KEY_ACCEPT_LANGUAGE , HDR_VALUE_ACCEPT_LANGUAGE ) ;
HttpResponse response = client . execute ( target , req ) ;
StatusLine status = response . getStatusLine ( ) ;
if ( status . getStatusCode ( ) != <num> ) {
throw new IOException ( " + status . getReasonPhrase ( ) ) ;
}
HttpEntity entity = response . getEntity ( ) ;
byte [ ] body = null ;
if ( entity != null ) {
try {
if ( entity . getContentLength ( ) > <num> ) {
body = new byte [ ( int ) entity . getContentLength ( ) ] ;
DataInputStream dis = new DataInputStream ( entity . getContent ( ) ) ;
try {
dis . readFully ( body ) ;
} finally {
try {
dis . close ( ) ;
} catch ( IOException e ) {
Log . e ( TAG , " + e . getMessage ( ) ) ;
}
}
}
} finally {
if ( entity != null ) {
entity . consumeContent ( ) ;
}
}
}
return body ;
} catch ( URISyntaxException e ) {
handleHttpConnectionException ( e , url ) ;
} catch ( IllegalStateException e ) {
handleHttpConnectionException ( e , url ) ;
} catch ( IllegalArgumentException e ) {
handleHttpConnectionException ( e , url ) ;
} catch ( SocketException e ) {
handleHttpConnectionException ( e , url ) ;
} catch ( Exception e ) {
handleHttpConnectionException ( e , url ) ;
}
finally {
if ( client != null ) {
client . close ( ) ;
}
}
return null ;
}
private static void handleHttpConnectionException ( Exception exception , String url )
throws IOException {
Log . e ( TAG , " + url + " + exception . getMessage ( ) ) ;
IOException e = new IOException ( exception . getMessage ( ) ) ;
e . initCause ( exception ) ;
throw e ;
}
private static AndroidHttpClient createHttpClient ( Context context ) {
String userAgent = MmsConfig . getUserAgent ( ) ;
AndroidHttpClient client = AndroidHttpClient . newInstance ( userAgent , context ) ;
HttpParams params = client . getParams ( ) ;
HttpProtocolParams . setContentCharset ( params , " ) ;
int soTimeout = MmsConfig . getHttpSocketTimeout ( ) ;
if ( Log . isLoggable ( LogTag . TRANSACTION , Log . DEBUG ) ) {
Log . d ( TAG , " + soTimeout + "
+ " + userAgent ) ;
}
HttpConnectionParams . setSoTimeout ( params , soTimeout ) ;
return client ;
}
private static String getHttpAcceptLanguage ( ) {
Locale locale = Locale . getDefault ( ) ;
StringBuilder builder = new StringBuilder ( ) ;
addLocaleToHttpAcceptLanguage ( builder , locale ) ;
if ( ! locale . equals ( Locale . US ) ) {
if ( builder . length ( ) > <num> ) {
builder . append ( " ) ;
}
addLocaleToHttpAcceptLanguage ( builder , Locale . US ) ;
}
return builder . toString ( ) ;
}
private static void addLocaleToHttpAcceptLanguage (
StringBuilder builder , Locale locale ) {
String language = locale . getLanguage ( ) ;
if ( language != null ) {
builder . append ( language ) ;
String country = locale . getCountry ( ) ;
if ( country != null ) {
builder . append ( " ) ;
builder . append ( country ) ;
}
}
}
package com . google . android . mms ;
import java . util . ArrayList ;
import java . util . Collections ;
import java . util . List ;
import android . content . Context ;
import android . database . Cursor ;
import android . net . Uri ;
import android . provider . BaseColumns ;
import android . text . TextUtils ;
public class APNHelper {
static final String APN_TYPE_ALL = " ;
static final String <unk> = " ;
static final String APN_TYPE_MMS = " ;
static final String <unk> = " ;
static final String <unk> = " ;
static final String <unk> = " ;
public class APN {
public String MMSCenterUrl = " ;
public String MMSPort = " ;
public String MMSProxy = " ;
}
private Context context ;
public APNHelper ( final Context context ) {
this . context = context ;
}
public List < APN > getMMSApns ( ) {
final Cursor apnCursor = this . context . getContentResolver ( ) . query ( Uri . withAppendedPath ( Carriers . CONTENT_URI , " ) , null , null , null , null ) ;
if ( apnCursor == null ) {
return Collections . EMPTY_LIST ;
} else {
final List < APN > results = new ArrayList < APN > ( ) ;
while ( apnCursor . moveToNext ( ) ) {
final String type = apnCursor . getString ( apnCursor . getColumnIndex ( Carriers . TYPE ) ) ;
if ( ! TextUtils . isEmpty ( type ) && ( type . contains ( APN_TYPE_ALL ) || type . contains ( APN_TYPE_MMS ) ) ) {
final String mmsc = apnCursor . getString ( apnCursor . getColumnIndex ( Carriers . MMSC ) ) ;
final String mmsProxy = apnCursor . getString ( apnCursor . getColumnIndex ( Carriers . MMSPROXY ) ) ;
final String port = apnCursor . getString ( apnCursor . getColumnIndex ( Carriers . MMSPORT ) ) ;
final APN apn = new APN ( ) ;
apn . MMSCenterUrl = mmsc ;
apn . MMSProxy = mmsProxy ;
apn . MMSPort = port . trim ( ) . length ( ) > <num> ? port : " ;
results . add ( apn ) ;
}
}
apnCursor . close ( ) ;
return results ;
}
}
public static final class Carriers implements BaseColumns {
public static final Uri CONTENT_URI =
Uri . parse ( " ) ;
public static final String DEFAULT_SORT_ORDER = " ;
public static final String NAME = " ;
public static final String APN = " ;
public static final String <unk> = " ;
public static final String PORT = " ;
public static final String MMSPROXY = " ;
public static final String MMSPORT = " ;
public static final String SERVER = " ;
public static final String USER = " ;
public static final String PASSWORD = " ;
public static final String MMSC = " ;
public static final String <unk> = " ;
public static final String <unk> = " ;
public static final String NUMERIC = " ;
public static final String TYPE = " ;
public static final String CURRENT = " ;
}
package com . google . android . mms . pdu ;
import com . google . android . mms . InvalidHeaderValueException ;
public class MultimediaMessagePdu extends GenericPdu {
private PduBody mMessageBody ;
public MultimediaMessagePdu ( ) {
super ( ) ;
}
public MultimediaMessagePdu ( PduHeaders header , PduBody body ) {
super ( header ) ;
mMessageBody = body ;
}
MultimediaMessagePdu ( PduHeaders headers ) {
super ( headers ) ;
}
public PduBody getBody ( ) {
return mMessageBody ;
}
public void setBody ( PduBody body ) {
mMessageBody = body ;
}
public EncodedStringValue getSubject ( ) {
return mPduHeaders . getEncodedStringValue ( PduHeaders . SUBJECT ) ;
}
public void setSubject ( EncodedStringValue value ) {
mPduHeaders . setEncodedStringValue ( value , PduHeaders . SUBJECT ) ;
}
public EncodedStringValue [ ] getTo ( ) {
return mPduHeaders . getEncodedStringValues ( PduHeaders . TO ) ;
}
public void addTo ( EncodedStringValue value ) {
mPduHeaders . appendEncodedStringValue ( value , PduHeaders . TO ) ;
}
public int getPriority ( ) {
return mPduHeaders . getOctet ( PduHeaders . PRIORITY ) ;
}
public void setPriority ( int value ) throws InvalidHeaderValueException {
mPduHeaders . setOctet ( value , PduHeaders . PRIORITY ) ;
}
public long getDate ( ) {
return mPduHeaders . getLongInteger ( PduHeaders . DATE ) ;
}
public void setDate ( long value ) {
mPduHeaders . setLongInteger ( value , PduHeaders . DATE ) ;
}
package com . shellware . CarHome . helpers ;
import com . shellware . CarHome . CarHomeActivity ;
import android . content . BroadcastReceiver ;
import android . content . Context ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . content . SharedPreferences . Editor ;
import android . os . Bundle ;
import android . preference . PreferenceManager ;
import android . telephony . SmsMessage ;
import android . util . Log ;
public class <unk> extends BroadcastReceiver {
private static final String TAG = " ;
private static final String POKED_KEYPHRASE = " ;
private static final String SEE_KEYPHRASE = " ;
private static final String REBOOT_KEYPHRASE = " ;
@Override
public void onReceive ( Context ctx , Intent intent ) {
SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ;
if ( ! prefs . getBoolean ( " , true ) ) {
Log . d ( TAG , " ) ;
return ;
}
Bundle bundle = intent . getExtras ( ) ;
SmsMessage [ ] msgs = null ;
if ( bundle != null ) {
final long lastMessageTimestamp = prefs . getLong ( " , <num> ) ;
Object [ ] pdus = ( Object [ ] ) bundle . get ( " ) ;
msgs = new SmsMessage [ pdus . length ] ;
for ( int i = <num> ; i < msgs . length ; i ++ ) {
msgs [ i ] = SmsMessage . createFromPdu ( ( byte [ ] ) pdus [ i ] ) ;
final String msg = msgs [ i ] . getMessageBody ( ) ;
if ( msgs [ i ] . getMessageBody ( ) != null && msg . toUpperCase ( ) . contains ( POKED_KEYPHRASE ) &&
msgs [ i ] . getTimestampMillis ( ) > lastMessageTimestamp ) {
CarHomeActivity . whereAreYou ( msgs [ i ] . getOriginatingAddress ( ) ) ;
Editor edit = prefs . edit ( ) ;
edit . putLong ( " , msgs [ i ] . getTimestampMillis ( ) ) ;
edit . commit ( ) ;
Log . d ( TAG , " + msgs [ i ] . getTimestampMillis ( ) ) ;
abortBroadcast ( ) ;
} else {
if ( msgs [ i ] . getMessageBody ( ) != null && msg . toUpperCase ( ) . contains ( SEE_KEYPHRASE ) &&
msgs [ i ] . getTimestampMillis ( ) > lastMessageTimestamp ) {
CarHomeActivity . whatDoYouSee ( msgs [ i ] . getOriginatingAddress ( ) ) ;
Editor edit = prefs . edit ( ) ;
edit . putLong ( " , msgs [ i ] . getTimestampMillis ( ) ) ;
edit . commit ( ) ;
Log . d ( TAG , " + msgs [ i ] . getTimestampMillis ( ) ) ;
abortBroadcast ( ) ;
} else {
if ( msgs [ i ] . getMessageBody ( ) != null && msg . toUpperCase ( ) . contains ( REBOOT_KEYPHRASE ) &&
msgs [ i ] . getTimestampMillis ( ) > lastMessageTimestamp ) {
Editor edit = prefs . edit ( ) ;
edit . putLong ( " , msgs [ i ] . getTimestampMillis ( ) ) ;
edit . commit ( ) ;
Log . d ( TAG , " + msgs [ i ] . getTimestampMillis ( ) ) ;
CarHomeActivity . rebootWithSU ( ) ;
abortBroadcast ( ) ;
}
}
}
}
}
}
}
package com . google . android . mms . pdu ;
import com . google . android . mms . InvalidHeaderValueException ;
import java . util . ArrayList ;
import java . util . HashMap ;
public class PduHeaders {
public static final int BCC = <num> ;
public static final int CC = <num> ;
public static final int CONTENT_LOCATION = <num> ;
public static final int CONTENT_TYPE = <num> ;
public static final int DATE = <num> ;
public static final int DELIVERY_REPORT = <num> ;
public static final int DELIVERY_TIME = <num> ;
public static final int EXPIRY = <num> ;
public static final int FROM = <num> ;
public static final int MESSAGE_CLASS = <num> ;
public static final int MESSAGE_ID = <num> ;
public static final int MESSAGE_TYPE = <num> ;
public static final int MMS_VERSION = <num> ;
public static final int MESSAGE_SIZE = <num> ;
public static final int PRIORITY = <num> ;
public static final int <unk> = <num> ;
public static final int READ_REPORT = <num> ;
public static final int REPORT_ALLOWED = <num> ;
public static final int RESPONSE_STATUS = <num> ;
public static final int RESPONSE_TEXT = <num> ;
public static final int SENDER_VISIBILITY = <num> ;
public static final int STATUS = <num> ;
public static final int SUBJECT = <num> ;
public static final int TO = <num> ;
public static final int TRANSACTION_ID = <num> ;
public static final int RETRIEVE_STATUS = <num> ;
public static final int RETRIEVE_TEXT = <num> ;
public static final int READ_STATUS = <num> ;
public static final int REPLY_CHARGING = <num> ;
public static final int REPLY_CHARGING_DEADLINE = <num> ;
public static final int REPLY_CHARGING_ID = <num> ;
public static final int REPLY_CHARGING_SIZE = <num> ;
public static final int PREVIOUSLY_SENT_BY = <num> ;
public static final int PREVIOUSLY_SENT_DATE = <num> ;
public static final int STORE = <num> ;
public static final int MM_STATE = <num> ;
public static final int MM_FLAGS = <num> ;
public static final int STORE_STATUS = <num> ;
public static final int STORE_STATUS_TEXT = <num> ;
public static final int STORED = <num> ;
public static final int ATTRIBUTES = <num> ;
public static final int TOTALS = <num> ;
public static final int <unk> = <num> ;
public static final int QUOTAS = <num> ;
public static final int <unk> = <num> ;
public static final int MESSAGE_COUNT = <num> ;
public static final int CONTENT = <num> ;
public static final int START = <num> ;
public static final int <unk> = <num> ;
public static final int DISTRIBUTION_INDICATOR = <num> ;
public static final int <unk> = <num> ;
public static final int LIMIT = <num> ;
public static final int RECOMMENDED_RETRIEVAL_MODE = <num> ;
public static final int RECOMMENDED_RETRIEVAL_MODE_TEXT = <num> ;
public static final int STATUS_TEXT = <num> ;
public static final int APPLIC_ID = <num> ;
public static final int REPLY_APPLIC_ID = <num> ;
public static final int AUX_APPLIC_ID = <num> ;
public static final int CONTENT_CLASS = <num> ;
public static final int DRM_CONTENT = <num> ;
public static final int ADAPTATION_ALLOWED = <num> ;
public static final int REPLACE_ID = <num> ;
public static final int CANCEL_ID = <num> ;
public static final int CANCEL_STATUS = <num> ;
public static final int MESSAGE_TYPE_SEND_REQ = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int MESSAGE_TYPE_NOTIFYRESP_IND = <num> ;
public static final int <unk> = <num> ;
public static final int MESSAGE_TYPE_ACKNOWLEDGE_IND = <num> ;
public static final int <unk> = <num> ;
public static final int MESSAGE_TYPE_READ_REC_IND = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int MESSAGE_TYPE_CANCEL_CONF = <num> ;
public static final int VALUE_YES = <num> ;
public static final int VALUE_NO = <num> ;
public static final int <unk> = <num> ;
public static final int VALUE_RELATIVE_TOKEN = <num> ;
public static final int MMS_VERSION_1_3 = ( ( <num> << <num> ) | <num> ) ;
public static final int MMS_VERSION_1_2 = ( ( <num> << <num> ) | <num> ) ;
public static final int <unk> = ( ( <num> << <num> ) | <num> ) ;
public static final int MMS_VERSION_1_0 = ( ( <num> << <num> ) | <num> ) ;
public static final int CURRENT_MMS_VERSION = MMS_VERSION_1_2 ;
public static final int FROM_ADDRESS_PRESENT_TOKEN = <num> ;
public static final int FROM_INSERT_ADDRESS_TOKEN = <num> ;
public static final String <unk> = " ;
public static final String FROM_INSERT_ADDRESS_TOKEN_STR = " ;
public static final int STATUS_EXPIRED = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int STATUS_UNREACHABLE = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int MESSAGE_CLASS_PERSONAL = <num> ;
public static final int MESSAGE_CLASS_ADVERTISEMENT = <num> ;
public static final int MESSAGE_CLASS_INFORMATIONAL = <num> ;
public static final int MESSAGE_CLASS_AUTO = <num> ;
public static final String MESSAGE_CLASS_PERSONAL_STR = " ;
public static final String MESSAGE_CLASS_ADVERTISEMENT_STR = " ;
public static final String MESSAGE_CLASS_INFORMATIONAL_STR = " ;
public static final String MESSAGE_CLASS_AUTO_STR = " ;
public static final int PRIORITY_LOW = <num> ;
public static final int <unk> = <num> ;
public static final int PRIORITY_HIGH = <num> ;
public static final int RESPONSE_STATUS_OK = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int RESPONSE_STATUS_ERROR_UNSUPPORTED_MESSAGE = <num> ;
public static final int RESPONSE_STATUS_ERROR_TRANSIENT_FAILURE = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int RESPONSE_STATUS_ERROR_TRANSIENT_PARTIAL_SUCCESS = <num> ;
public static final int RESPONSE_STATUS_ERROR_PERMANENT_FAILURE = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int RESPONSE_STATUS_ERROR_PERMANENT_LACK_OF_PREPAID = <num> ;
public static final int RESPONSE_STATUS_ERROR_PERMANENT_END = <num> ;
public static final int RETRIEVE_STATUS_OK = <num> ;
public static final int RETRIEVE_STATUS_ERROR_TRANSIENT_FAILURE = <num> ;
public static final int <unk> = <num> ;
public static final int RETRIEVE_STATUS_ERROR_TRANSIENT_NETWORK_PROBLEM = <num> ;
public static final int RETRIEVE_STATUS_ERROR_PERMANENT_FAILURE = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int RETRIEVE_STATUS_ERROR_PERMANENT_CONTENT_UNSUPPORTED = <num> ;
public static final int RETRIEVE_STATUS_ERROR_END = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int READ_STATUS_READ = <num> ;
public static final int READ_STATUS__DELETED_WITHOUT_BEING_READ = <num> ;
public static final int CANCEL_STATUS_REQUEST_SUCCESSFULLY_RECEIVED = <num> ;
public static final int CANCEL_STATUS_REQUEST_CORRUPTED = <num> ;
public static final int REPLY_CHARGING_REQUESTED = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int REPLY_CHARGING_ACCEPTED_TEXT_ONLY = <num> ;
public static final int MM_STATE_DRAFT = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int MM_STATE_FORWARDED = <num> ;
public static final int RECOMMENDED_RETRIEVAL_MODE_MANUAL = <num> ;
public static final int CONTENT_CLASS_TEXT = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int CONTENT_CLASS_CONTENT_RICH = <num> ;
public static final int STORE_STATUS_SUCCESS = <num> ;
public static final int STORE_STATUS_ERROR_TRANSIENT_FAILURE = <num> ;
public static final int STORE_STATUS_ERROR_TRANSIENT_NETWORK_PROBLEM = <num> ;
public static final int STORE_STATUS_ERROR_PERMANENT_FAILURE = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int STORE_STATUS_ERROR_PERMANENT_MMBOX_FULL = <num> ;
public static final int STORE_STATUS_ERROR_END = <num> ;
private HashMap < Integer , Object > mHeaderMap = null ;
public PduHeaders ( ) {
mHeaderMap = new HashMap < Integer , Object > ( ) ;
}
protected int getOctet ( int field ) {
Integer octet = ( Integer ) mHeaderMap . get ( field ) ;
if ( null == octet ) {
return <num> ;
}
return octet ;
}
protected void setOctet ( int value , int field )
throws InvalidHeaderValueException {
switch ( field ) {
case REPORT_ALLOWED :
case ADAPTATION_ALLOWED :
case DELIVERY_REPORT :
case DRM_CONTENT :
case DISTRIBUTION_INDICATOR :
case QUOTAS :
case READ_REPORT :
case STORE :
case STORED :
case TOTALS :
case SENDER_VISIBILITY :
if ( ( VALUE_YES != value ) && ( VALUE_NO != value ) ) {
throw new InvalidHeaderValueException ( " ) ;
}
break ;
case READ_STATUS :
if ( ( READ_STATUS_READ != value ) &&
( READ_STATUS__DELETED_WITHOUT_BEING_READ != value ) ) {
throw new InvalidHeaderValueException ( " ) ;
}
break ;
case CANCEL_STATUS :
if ( ( CANCEL_STATUS_REQUEST_SUCCESSFULLY_RECEIVED != value ) &&
( CANCEL_STATUS_REQUEST_CORRUPTED != value ) ) {
throw new InvalidHeaderValueException ( " ) ;
}
break ;
case PRIORITY :
if ( ( value < PRIORITY_LOW ) || ( value > PRIORITY_HIGH ) ) {
throw new InvalidHeaderValueException ( " ) ;
}
break ;
case STATUS :
if ( ( value < STATUS_EXPIRED ) || ( value > STATUS_UNREACHABLE ) ) {
throw new InvalidHeaderValueException ( " ) ;
}
break ;
case REPLY_CHARGING :
if ( ( value < REPLY_CHARGING_REQUESTED )
|| ( value > REPLY_CHARGING_ACCEPTED_TEXT_ONLY ) ) {
throw new InvalidHeaderValueException ( " ) ;
}
break ;
case MM_STATE :
if ( ( value < MM_STATE_DRAFT ) || ( value > MM_STATE_FORWARDED ) ) {
throw new InvalidHeaderValueException ( " ) ;
}
break ;
case RECOMMENDED_RETRIEVAL_MODE :
if ( RECOMMENDED_RETRIEVAL_MODE_MANUAL != value ) {
throw new InvalidHeaderValueException ( " ) ;
}
break ;
case CONTENT_CLASS :
if ( ( value < CONTENT_CLASS_TEXT )
|| ( value > CONTENT_CLASS_CONTENT_RICH ) ) {
throw new InvalidHeaderValueException ( " ) ;
}
break ;
case RETRIEVE_STATUS :
if ( ( value > RETRIEVE_STATUS_ERROR_TRANSIENT_NETWORK_PROBLEM ) &&
( value < RETRIEVE_STATUS_ERROR_PERMANENT_FAILURE ) ) {
value = RETRIEVE_STATUS_ERROR_TRANSIENT_FAILURE ;
} else if ( ( value > RETRIEVE_STATUS_ERROR_PERMANENT_CONTENT_UNSUPPORTED ) &&
( value <= RETRIEVE_STATUS_ERROR_END ) ) {
value = RETRIEVE_STATUS_ERROR_PERMANENT_FAILURE ;
} else if ( ( value < RETRIEVE_STATUS_OK ) ||
( ( value > RETRIEVE_STATUS_OK ) &&
( value < RETRIEVE_STATUS_ERROR_TRANSIENT_FAILURE ) ) ||
( value > RETRIEVE_STATUS_ERROR_END ) ) {
value = RETRIEVE_STATUS_ERROR_PERMANENT_FAILURE ;
}
break ;
case STORE_STATUS :
if ( ( value > STORE_STATUS_ERROR_TRANSIENT_NETWORK_PROBLEM ) &&
( value < STORE_STATUS_ERROR_PERMANENT_FAILURE ) ) {
value = STORE_STATUS_ERROR_TRANSIENT_FAILURE ;
} else if ( ( value > STORE_STATUS_ERROR_PERMANENT_MMBOX_FULL ) &&
( value <= STORE_STATUS_ERROR_END ) ) {
value = STORE_STATUS_ERROR_PERMANENT_FAILURE ;
} else if ( ( value < STORE_STATUS_SUCCESS ) ||
( ( value > STORE_STATUS_SUCCESS ) &&
( value < STORE_STATUS_ERROR_TRANSIENT_FAILURE ) ) ||
( value > STORE_STATUS_ERROR_END ) ) {
value = STORE_STATUS_ERROR_PERMANENT_FAILURE ;
}
break ;
case RESPONSE_STATUS :
if ( ( value > RESPONSE_STATUS_ERROR_TRANSIENT_PARTIAL_SUCCESS ) &&
( value < RESPONSE_STATUS_ERROR_PERMANENT_FAILURE ) ) {
value = RESPONSE_STATUS_ERROR_TRANSIENT_FAILURE ;
} else if ( ( ( value > RESPONSE_STATUS_ERROR_PERMANENT_LACK_OF_PREPAID ) &&
( value <= RESPONSE_STATUS_ERROR_PERMANENT_END ) ) ||
( value < RESPONSE_STATUS_OK ) ||
( ( value > RESPONSE_STATUS_ERROR_UNSUPPORTED_MESSAGE ) &&
( value < RESPONSE_STATUS_ERROR_TRANSIENT_FAILURE ) ) ||
( value > RESPONSE_STATUS_ERROR_PERMANENT_END ) ) {
value = RESPONSE_STATUS_ERROR_PERMANENT_FAILURE ;
}
break ;
case MMS_VERSION :
if ( ( value < MMS_VERSION_1_0 ) || ( value > MMS_VERSION_1_3 ) ) {
value = CURRENT_MMS_VERSION ;
}
break ;
case MESSAGE_TYPE :
if ( ( value < MESSAGE_TYPE_SEND_REQ ) || ( value > MESSAGE_TYPE_CANCEL_CONF ) ) {
throw new InvalidHeaderValueException ( " ) ;
}
break ;
default :
throw new RuntimeException ( " ) ;
}
mHeaderMap . put ( field , value ) ;
}
protected byte [ ] getTextString ( int field ) {
return ( byte [ ] ) mHeaderMap . get ( field ) ;
}
protected void setTextString ( byte [ ] value , int field ) {
if ( null == value ) {
throw new NullPointerException ( ) ;
}
switch ( field ) {
case TRANSACTION_ID :
case REPLY_CHARGING_ID :
case AUX_APPLIC_ID :
case APPLIC_ID :
case REPLY_APPLIC_ID :
case MESSAGE_ID :
case REPLACE_ID :
case CANCEL_ID :
case CONTENT_LOCATION :
case MESSAGE_CLASS :
case CONTENT_TYPE :
break ;
default :
throw new RuntimeException ( " ) ;
}
mHeaderMap . put ( field , value ) ;
}
protected EncodedStringValue getEncodedStringValue ( int field ) {
return ( EncodedStringValue ) mHeaderMap . get ( field ) ;
}
protected EncodedStringValue [ ] getEncodedStringValues ( int field ) {
ArrayList < EncodedStringValue > list =
( ArrayList < EncodedStringValue > ) mHeaderMap . get ( field ) ;
if ( null == list ) {
return null ;
}
EncodedStringValue [ ] values = new EncodedStringValue [ list . size ( ) ] ;
return list . toArray ( values ) ;
}
protected void setEncodedStringValue ( EncodedStringValue value , int field ) {
if ( null == value ) {
throw new NullPointerException ( ) ;
}
switch ( field ) {
case SUBJECT :
case RECOMMENDED_RETRIEVAL_MODE_TEXT :
case RETRIEVE_TEXT :
case STATUS_TEXT :
case STORE_STATUS_TEXT :
case RESPONSE_TEXT :
case FROM :
case PREVIOUSLY_SENT_BY :
case MM_FLAGS :
break ;
default :
throw new RuntimeException ( " ) ;
}
mHeaderMap . put ( field , value ) ;
}
protected void setEncodedStringValues ( EncodedStringValue [ ] value , int field ) {
if ( null == value ) {
throw new NullPointerException ( ) ;
}
switch ( field ) {
case BCC :
case CC :
case TO :
break ;
default :
throw new RuntimeException ( " ) ;
}
ArrayList < EncodedStringValue > list = new ArrayList < EncodedStringValue > ( ) ;
for ( int i = <num> ; i < value . length ; i ++ ) {
list . add ( value [ i ] ) ;
}
mHeaderMap . put ( field , list ) ;
}
protected void appendEncodedStringValue ( EncodedStringValue value ,
int field ) {
if ( null == value ) {
throw new NullPointerException ( ) ;
}
switch ( field ) {
case BCC :
case CC :
case TO :
break ;
default :
throw new RuntimeException ( " ) ;
}
ArrayList < EncodedStringValue > list =
( ArrayList < EncodedStringValue > ) mHeaderMap . get ( field ) ;
if ( null == list ) {
list = new ArrayList < EncodedStringValue > ( ) ;
}
list . add ( value ) ;
mHeaderMap . put ( field , list ) ;
}
protected long getLongInteger ( int field ) {
Long longInteger = ( Long ) mHeaderMap . get ( field ) ;
if ( null == longInteger ) {
return  <num> ;
}
return longInteger . longValue ( ) ;
}
protected void setLongInteger ( long value , int field ) {
switch ( field ) {
case DATE :
case REPLY_CHARGING_SIZE :
case MESSAGE_SIZE :
case MESSAGE_COUNT :
case START :
case LIMIT :
case DELIVERY_TIME :
case EXPIRY :
case REPLY_CHARGING_DEADLINE :
case PREVIOUSLY_SENT_DATE :
break ;
default :
throw new RuntimeException ( " ) ;
}
mHeaderMap . put ( field , value ) ;
}
package com . google . android . mms . pdu ;
import java . util . HashMap ;
import java . util . Map ;
import java . util . Vector ;
public class PduBody {
private Vector < PduPart > mParts = null ;
private Map < String , PduPart > mPartMapByContentId = null ;
private Map < String , PduPart > mPartMapByContentLocation = null ;
private Map < String , PduPart > mPartMapByName = null ;
private Map < String , PduPart > mPartMapByFileName = null ;
public PduBody ( ) {
mParts = new Vector < PduPart > ( ) ;
mPartMapByContentId = new HashMap < String , PduPart > ( ) ;
mPartMapByContentLocation = new HashMap < String , PduPart > ( ) ;
mPartMapByName = new HashMap < String , PduPart > ( ) ;
mPartMapByFileName = new HashMap < String , PduPart > ( ) ;
}
private void putPartToMaps ( PduPart part ) {
byte [ ] contentId = part . getContentId ( ) ;
if ( null != contentId ) {
mPartMapByContentId . put ( new String ( contentId ) , part ) ;
}
byte [ ] contentLocation = part . getContentLocation ( ) ;
if ( null != contentLocation ) {
String clc = new String ( contentLocation ) ;
mPartMapByContentLocation . put ( clc , part ) ;
}
byte [ ] name = part . getName ( ) ;
if ( null != name ) {
String clc = new String ( name ) ;
mPartMapByName . put ( clc , part ) ;
}
byte [ ] fileName = part . getFilename ( ) ;
if ( null != fileName ) {
String clc = new String ( fileName ) ;
mPartMapByFileName . put ( clc , part ) ;
}
}
public boolean addPart ( PduPart part ) {
if ( null == part ) {
throw new NullPointerException ( ) ;
}
putPartToMaps ( part ) ;
return mParts . add ( part ) ;
}
public void addPart ( int index , PduPart part ) {
if ( null == part ) {
throw new NullPointerException ( ) ;
}
putPartToMaps ( part ) ;
mParts . add ( index , part ) ;
}
public PduPart <unk> ( int index ) {
return mParts . remove ( index ) ;
}
public void removeAll ( ) {
mParts . clear ( ) ;
}
public PduPart getPart ( int index ) {
return mParts . get ( index ) ;
}
public int <unk> ( PduPart part ) {
return mParts . indexOf ( part ) ;
}
public int getPartsNum ( ) {
return mParts . size ( ) ;
}
public PduPart <unk> ( String cid ) {
return mPartMapByContentId . get ( cid ) ;
}
public PduPart <unk> ( String contentLocation ) {
return mPartMapByContentLocation . get ( contentLocation ) ;
}
public PduPart <unk> ( String name ) {
return mPartMapByName . get ( name ) ;
}
public PduPart <unk> ( String filename ) {
return mPartMapByFileName . get ( filename ) ;
}
package com . google . android . mms . pdu ;
import com . google . android . mms . InvalidHeaderValueException ;
public class GenericPdu {
PduHeaders mPduHeaders = null ;
public GenericPdu ( ) {
mPduHeaders = new PduHeaders ( ) ;
}
GenericPdu ( PduHeaders headers ) {
mPduHeaders = headers ;
}
PduHeaders getPduHeaders ( ) {
return mPduHeaders ;
}
public int getMessageType ( ) {
return mPduHeaders . getOctet ( PduHeaders . MESSAGE_TYPE ) ;
}
public void setMessageType ( int value ) throws InvalidHeaderValueException {
mPduHeaders . setOctet ( value , PduHeaders . MESSAGE_TYPE ) ;
}
public int <unk> ( ) {
return mPduHeaders . getOctet ( PduHeaders . MMS_VERSION ) ;
}
public void setMmsVersion ( int value ) throws InvalidHeaderValueException {
mPduHeaders . setOctet ( value , PduHeaders . MMS_VERSION ) ;
}
package com . shellware . CarHome . helpers ;
import android . bluetooth . BluetoothAdapter ;
import android . content . Context ;
import com . gtosoft . libvoyager . android . ActivityHelper ;
import com . gtosoft . libvoyager . db . DashDB ;
import com . gtosoft . libvoyager . session . HybridSession ;
import com . gtosoft . libvoyager . session . OBD2Session ;
import com . gtosoft . libvoyager . util . EasyTime ;
import com . gtosoft . libvoyager . util . EventCallback ;
import com . gtosoft . libvoyager . util . GeneralStats ;
import com . gtosoft . libvoyager . util . OOBMessageTypes ;
public class OBDHelper {
private Context ctx ;
private GeneralStats mgStats = new GeneralStats ( ) ;
private DashDB ddb = null ;
private HybridSession hs ;
private ActivityHelper aHelper = null ;
private float voltage = <num> ;
private float iat = <num> ;
private float fuel = <num> ;
private float coolant = <num> ;
private float maf = <num> ;
private float wideband = <num> ;
private float egt = <num> ;
private String tire1Pres = " ;
public OBDHelper ( Context ctx ) {
this . ctx = ctx ;
aHelper = new ActivityHelper ( ctx ) ;
aHelper . <unk> ( chosenCallback ) ;
doBestAvailable ( ) ;
}
private boolean doBestAvailable ( ) {
if ( hs == null || hs . getEBT ( ) . isConnected ( ) != true ) {
connectToBestAvailable ( ) ;
} else {
return false ;
}
return true ;
}
private void connectToBestAvailable ( ) {
String lastmac = aHelper . <unk> ( ) ;
if ( lastmac . length ( ) == <num> ) {
setupSession ( lastmac ) ;
} else {
aHelper . startDiscovering ( ) ;
}
}
private EventCallback chosenCallback = new EventCallback ( ) {
@Override
public void <unk> ( String MAC ) {
setupSession ( MAC ) ;
}
} ;
private synchronized boolean setupSession ( String deviceMACAddress ) {
if ( hs != null ) {
hs . shutdown ( ) ;
}
if ( ddb == null ) {
ddb = new DashDB ( ctx ) ;
}
aHelper . <unk> ( deviceMACAddress ) ;
hs = new HybridSession ( BluetoothAdapter . getDefaultAdapter ( ) ,
deviceMACAddress , ddb , mLocalecbOOBMessageHandler ) ;
hs . <unk> ( mLocalDPNArrivedHandler ) ;
return true ;
}
private int mLastIOState = <num> ;
private void ioStateChanged ( int newState ) {
if ( newState == mLastIOState ) {
return ;
} else {
mLastIOState = newState ;
}
if ( newState == <num> ) {
detectSessionInBackground ( ) ;
} else {
}
}
public void shutdown ( ) {
try {
if ( aHelper != null ) aHelper . shutdown ( ) ;
if ( hs != null ) hs . shutdown ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
} ;
private void detectSessionInBackground ( ) {
new Thread ( ) {
public void run ( ) {
mgStats . incrementStat ( " ) ;
while ( hs . <unk> ( ) != true
&& hs . getEBT ( ) . isConnected ( ) == true ) {
mgStats . incrementStat ( " ) ;
if ( ! EasyTime . <unk> ( <num> ) )
break ;
}
}
} . start ( ) ;
}
private EventCallback mLocalDPNArrivedHandler = new EventCallback ( ) {
@Override
public void <unk> ( String DPN , final String sDecodedData , int <unk> ) {
if ( DPN . equals ( " ) ) voltage = getPrimaryDPNValue ( sDecodedData , voltage ) ;
if ( DPN . equals ( " ) ) iat = getPrimaryDPNValue ( sDecodedData , iat ) ;
if ( DPN . equals ( " ) ) coolant = getPrimaryDPNValue ( sDecodedData , coolant ) ;
if ( DPN . equals ( " ) ) maf = getPrimaryDPNValue ( sDecodedData , maf ) ;
if ( DPN . equals ( " ) ) fuel = getPrimaryDPNValue ( sDecodedData , fuel , <num> ) ;
if ( DPN . equals ( " ) ) wideband = getPrimaryDPNValue ( sDecodedData , wideband ) ;
if ( DPN . equals ( " ) ) egt = getPrimaryDPNValue ( sDecodedData , egt ) ;
if ( DPN . equals ( " ) ) tire1Pres = sDecodedData ;
}
} ;
private EventCallback mLocalecbOOBMessageHandler = new EventCallback ( ) {
@Override
public void <unk> ( String dataName , String dataValue ) {
if ( dataName . equals ( OOBMessageTypes . <unk> ) ) {
int newState = <num> ;
try {
newState = Integer . valueOf ( dataValue ) ;
ioStateChanged ( newState ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
if ( dataName . equals ( OOBMessageTypes . <unk> ) ) {
if ( dataValue . equals ( " ) ) {
aHelper . startDiscovering ( ) ;
}
}
if ( dataName . equals ( OOBMessageTypes . <unk> ) ) {
int newState = <num> ;
try {
newState = Integer . valueOf ( dataValue ) ;
} catch ( NumberFormatException e ) {
return ;
}
if ( hs != null && hs . getRoutineScan ( ) != null ) {
if ( newState >= OBD2Session . STATE_OBDCONNECTED ) {
hs . setRoutineScanDelay ( <num> ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
} else {
hs . getRoutineScan ( ) . <unk> ( ) ;
}
}
}
if ( dataName . equals ( OOBMessageTypes . <unk> ) ) {
if ( hs . isDetectionValid ( ) != true )
return ;
SetupSessionBasedOnCapabilities ( ) ;
}
}
} ;
private void SetupSessionBasedOnCapabilities ( ) {
if ( hs . isDetectionValid ( ) != true ) {
return ;
}
hs . <unk> ( HybridSession . <unk> ) ;
if ( hs . getRoutineScan ( ) == null ) return ;
hs . setRoutineScanDelay ( <num> ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
hs . getRoutineScan ( ) . addDPN ( " ) ;
}
private float getPrimaryDPNValue ( String decodedData , final float defaultValue ) {
return getPrimaryDPNValue ( decodedData , defaultValue , <num> ) ;
}
private float getPrimaryDPNValue ( String decodedData , final float defaultValue , final int maxVariance ) {
float Y = <num> ;
if ( decodedData . contains ( " ) ) {
try {
Y = Float . valueOf ( decodedData . split ( " ) [ <num> ] ) ;
} catch ( NumberFormatException e ) {
}
} else {
try {
Y = Float . valueOf ( decodedData ) ;
} catch ( NumberFormatException e ) {
}
}
if ( Y == <num> ) Y = defaultValue ;
if ( maxVariance != <num> && Math . abs ( Y  defaultValue ) > maxVariance ) Y = defaultValue ;
return Y ;
}
public HybridSession getHs ( ) {
return hs ;
}
public float getVoltage ( ) {
return voltage ;
}
public float getIat ( ) {
return ( float ) ( <num> * iat + <num> ) ;
}
public float getFuel ( ) {
return fuel ;
}
public float getCoolant ( ) {
return ( float ) ( <num> * coolant + <num> ) ;
}
public float getMaf ( ) {
return maf ;
}
public float getWideband ( ) {
return wideband ;
}
public float getEgt ( ) {
return ( float ) ( <num> * egt + <num> ) ;
}
public String <unk> ( ) {
return tire1Pres ;
}
}
package com . google . android . mms ;
public class ContentRestrictionException extends RuntimeException {
private static final long serialVersionUID = <num> ;
public ContentRestrictionException ( ) {
super ( ) ;
}
public ContentRestrictionException ( String msg ) {
super ( msg ) ;
}
public ContentRestrictionException ( Exception cause ) {
super ( cause ) ;
}
}
package com . google . android . mms ;
public class MmsException extends Exception {
private static final long serialVersionUID =  <num> ;
public MmsException ( ) {
super ( ) ;
}
public MmsException ( String message ) {
super ( message ) ;
}
public MmsException ( Throwable cause ) {
super ( cause ) ;
}
public MmsException ( String message , Throwable cause ) {
super ( message , cause ) ;
}
package com . shellware . CarHome . helpers ;
import android . bluetooth . BluetoothAdapter ;
import android . content . BroadcastReceiver ;
import android . content . Context ;
import android . content . Intent ;
import android . os . BatteryManager ;
import android . os . Handler ;
import android . view . Menu ;
import com . shellware . CarHome . R ;
import com . shellware . CarHome . media . MusicService ;
public class BatteryStatusReceiver extends BroadcastReceiver {
private Context ctx = null ;
private OBDHelper obd = null ;
private Menu myMenu = null ;
private boolean isCharging = false ;
public BatteryStatusReceiver ( Context ctx , OBDHelper obd , Menu myMenu ) {
this . ctx = ctx ;
this . obd = obd ;
this . myMenu = myMenu ;
}
@Override
public void onReceive ( Context arg0 , Intent arg1 ) {
if ( arg1 . getAction ( ) . equals ( Intent . ACTION_BATTERY_CHANGED ) ) {
final int status = arg1 . getIntExtra ( " , BatteryManager . <unk> ) ;
final BluetoothAdapter bt = BluetoothAdapter . getDefaultAdapter ( ) ;
if ( status == BatteryManager . BATTERY_STATUS_CHARGING ||
status == BatteryManager . BATTERY_STATUS_FULL ) {
isCharging = true ;
if ( bt != null && ! bt . isEnabled ( ) ) {
bt . enable ( ) ;
if ( obd != null ) {
obd . shutdown ( ) ;
obd = null ;
}
new Handler ( ) . postDelayed ( new Runnable ( ) {
public void run ( ) {
obd = new OBDHelper ( ctx ) ;
if ( MusicService . mState == MusicService . State . Paused )
ctx . startService ( new Intent ( MusicService . ACTION_PLAY ) ) ;
}
} , <num> ) ;
new Handler ( ) . post ( new Runnable ( ) {
public void run ( ) {
myMenu . getItem ( <num> ) . setIcon ( R . drawable . bluetooth_on ) ;
}
} ) ;
}
} else {
isCharging = false ;
if ( bt != null && bt . isEnabled ( ) ) {
new Handler ( ) . postDelayed ( new Runnable ( ) {
public void run ( ) {
if ( ! isCharging ) {
if ( obd != null ) {
obd . shutdown ( ) ;
obd = null ;
}
bt . disable ( ) ;
myMenu . getItem ( <num> ) . setIcon ( R . drawable . bluetooth_off ) ;
ctx . startService ( new Intent ( MusicService . ACTION_PAUSE ) ) ;
}
}
} , <num> ) ;
}
}
}
}
}
package com . google . android . mms . pdu ;
import android . content . ContentResolver ;
import android . content . Context ;
import java . io . ByteArrayOutputStream ;
import java . io . FileNotFoundException ;
import java . io . IOException ;
import java . io . InputStream ;
import java . util . Arrays ;
import java . util . HashMap ;
public class PduComposer {
static private final int PDU_PHONE_NUMBER_ADDRESS_TYPE = <num> ;
static private final int PDU_EMAIL_ADDRESS_TYPE = <num> ;
static private final int PDU_IPV4_ADDRESS_TYPE = <num> ;
static private final int PDU_IPV6_ADDRESS_TYPE = <num> ;
static private final int PDU_UNKNOWN_ADDRESS_TYPE = <num> ;
static final String REGEXP_PHONE_NUMBER_ADDRESS_TYPE = " ;
static final String REGEXP_EMAIL_ADDRESS_TYPE = " +
" ;
static final String REGEXP_IPV6_ADDRESS_TYPE =
" +
" +
" ;
static final String REGEXP_IPV4_ADDRESS_TYPE = " +
" ;
static final String STRING_PHONE_NUMBER_ADDRESS_TYPE = " ;
static final String STRING_IPV4_ADDRESS_TYPE = " ;
static final String STRING_IPV6_ADDRESS_TYPE = " ;
static private final int PDU_COMPOSE_SUCCESS = <num> ;
static private final int PDU_COMPOSE_CONTENT_ERROR = <num> ;
static private final int PDU_COMPOSE_FIELD_NOT_SET = <num> ;
static private final int PDU_COMPOSE_FIELD_NOT_SUPPORTED = <num> ;
static private final int QUOTED_STRING_FLAG = <num> ;
static private final int END_STRING_FLAG = <num> ;
static private final int LENGTH_QUOTE = <num> ;
static private final int TEXT_MAX = <num> ;
static private final int SHORT_INTEGER_MAX = <num> ;
static private final int LONG_INTEGER_LENGTH_MAX = <num> ;
static private final int PDU_COMPOSER_BLOCK_SIZE = <num> ;
protected ByteArrayOutputStream mMessage = null ;
private GenericPdu mPdu = null ;
protected int mPosition = <num> ;
private BufferStack mStack = null ;
private final ContentResolver mResolver ;
private PduHeaders mPduHeader = null ;
private static HashMap < String , Integer > mContentTypeMap = null ;
static {
mContentTypeMap = new HashMap < String , Integer > ( ) ;
int i ;
for ( i = <num> ; i < PduContentTypes . contentTypes . length ; i ++ ) {
mContentTypeMap . put ( PduContentTypes . contentTypes [ i ] , i ) ;
}
}
public PduComposer ( Context context , GenericPdu pdu ) {
mPdu = pdu ;
mResolver = context . getContentResolver ( ) ;
mPduHeader = pdu . getPduHeaders ( ) ;
mStack = new BufferStack ( ) ;
mMessage = new ByteArrayOutputStream ( ) ;
mPosition = <num> ;
}
public byte [ ] make ( ) {
int type = mPdu . getMessageType ( ) ;
switch ( type ) {
case PduHeaders . MESSAGE_TYPE_SEND_REQ :
if ( makeSendReqPdu ( ) != PDU_COMPOSE_SUCCESS ) {
return null ;
}
break ;
case PduHeaders . MESSAGE_TYPE_NOTIFYRESP_IND :
if ( makeNotifyResp ( ) != PDU_COMPOSE_SUCCESS ) {
return null ;
}
break ;
case PduHeaders . MESSAGE_TYPE_ACKNOWLEDGE_IND :
if ( makeAckInd ( ) != PDU_COMPOSE_SUCCESS ) {
return null ;
}
break ;
case PduHeaders . MESSAGE_TYPE_READ_REC_IND :
if ( makeReadRecInd ( ) != PDU_COMPOSE_SUCCESS ) {
return null ;
}
break ;
default :
return null ;
}
return mMessage . toByteArray ( ) ;
}
protected void arraycopy ( byte [ ] buf , int pos , int length ) {
mMessage . write ( buf , pos , length ) ;
mPosition = mPosition + length ;
}
protected void append ( int value ) {
mMessage . write ( value ) ;
mPosition ++ ;
}
protected void appendShortInteger ( int value ) {
append ( ( value | <num> ) & <num> ) ;
}
protected void appendOctet ( int number ) {
append ( number ) ;
}
protected void appendShortLength ( int value ) {
append ( value ) ;
}
protected void appendLongInteger ( long longInt ) {
int size ;
long temp = longInt ;
for ( size = <num> ; ( temp != <num> ) && ( size < LONG_INTEGER_LENGTH_MAX ) ; size ++ ) {
temp = ( temp >>> <num> ) ;
}
appendShortLength ( size ) ;
int i ;
int shift = ( size  <num> ) * <num> ;
for ( i = <num> ; i < size ; i ++ ) {
append ( ( int ) ( ( longInt >>> shift ) & <num> ) ) ;
shift = shift  <num> ;
}
}
protected void appendTextString ( byte [ ] text ) {
if ( ( ( text [ <num> ] ) & <num> ) > TEXT_MAX ) {
append ( TEXT_MAX ) ;
}
arraycopy ( text , <num> , text . length ) ;
append ( <num> ) ;
}
protected void appendTextString ( String str ) {
appendTextString ( str . getBytes ( ) ) ;
}
protected void appendEncodedString ( EncodedStringValue enStr ) {
assert ( enStr != null ) ;
int charset = enStr . getCharacterSet ( ) ;
byte [ ] textString = enStr . getTextString ( ) ;
if ( null == textString ) {
return ;
}
mStack . newbuf ( ) ;
PositionMarker start = mStack . mark ( ) ;
appendShortInteger ( charset ) ;
appendTextString ( textString ) ;
int len = start . getLength ( ) ;
mStack . pop ( ) ;
appendValueLength ( len ) ;
mStack . copy ( ) ;
}
protected void appendUintvarInteger ( long value ) {
int i ;
long max = SHORT_INTEGER_MAX ;
for ( i = <num> ; i < <num> ; i ++ ) {
if ( value < max ) {
break ;
}
max = ( max << <num> ) | <num> ;
}
while ( i > <num> ) {
long temp = value >>> ( i * <num> ) ;
temp = temp & <num> ;
append ( ( int ) ( ( temp | <num> ) & <num> ) ) ;
i  ;
}
append ( ( int ) ( value & <num> ) ) ;
}
protected void appendDateValue ( long date ) {
appendLongInteger ( date ) ;
}
protected void appendValueLength ( long value ) {
if ( value < LENGTH_QUOTE ) {
appendShortLength ( ( int ) value ) ;
return ;
}
append ( LENGTH_QUOTE ) ;
appendUintvarInteger ( value ) ;
}
protected void appendQuotedString ( byte [ ] text ) {
append ( QUOTED_STRING_FLAG ) ;
arraycopy ( text , <num> , text . length ) ;
append ( END_STRING_FLAG ) ;
}
protected void appendQuotedString ( String str ) {
appendQuotedString ( str . getBytes ( ) ) ;
}
private int appendHeader ( int field ) {
switch ( field ) {
case PduHeaders . MMS_VERSION :
appendOctet ( field ) ;
int version = mPduHeader . getOctet ( field ) ;
if ( <num> == version ) {
appendShortInteger ( PduHeaders . CURRENT_MMS_VERSION ) ;
} else {
appendShortInteger ( version ) ;
}
break ;
case PduHeaders . MESSAGE_ID :
case PduHeaders . TRANSACTION_ID :
byte [ ] textString = mPduHeader . getTextString ( field ) ;
if ( null == textString ) {
return PDU_COMPOSE_FIELD_NOT_SET ;
}
appendOctet ( field ) ;
appendTextString ( textString ) ;
break ;
case PduHeaders . TO :
case PduHeaders . BCC :
case PduHeaders . CC :
EncodedStringValue [ ] addr = mPduHeader . getEncodedStringValues ( field ) ;
if ( null == addr ) {
return PDU_COMPOSE_FIELD_NOT_SET ;
}
EncodedStringValue temp ;
for ( int i = <num> ; i < addr . length ; i ++ ) {
try {
int addressType = checkAddressType ( addr [ i ] . getString ( ) ) ;
temp = EncodedStringValue . copy ( addr [ i ] ) ;
if ( PDU_PHONE_NUMBER_ADDRESS_TYPE == addressType ) {
temp . appendTextString (
STRING_PHONE_NUMBER_ADDRESS_TYPE . getBytes ( ) ) ;
} else if ( PDU_IPV4_ADDRESS_TYPE == addressType ) {
temp . appendTextString ( STRING_IPV4_ADDRESS_TYPE . getBytes ( ) ) ;
} else if ( PDU_IPV6_ADDRESS_TYPE == addressType ) {
temp . appendTextString ( STRING_IPV6_ADDRESS_TYPE . getBytes ( ) ) ;
}
} catch ( NullPointerException e ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
appendOctet ( field ) ;
appendEncodedString ( temp ) ;
}
break ;
case PduHeaders . FROM :
appendOctet ( field ) ;
EncodedStringValue from = mPduHeader . getEncodedStringValue ( field ) ;
if ( ( from == null )
|| new String ( from . getTextString ( ) ) . equals (
PduHeaders . FROM_INSERT_ADDRESS_TOKEN_STR ) ) {
append ( <num> ) ;
append ( PduHeaders . FROM_INSERT_ADDRESS_TOKEN ) ;
} else {
mStack . newbuf ( ) ;
PositionMarker fstart = mStack . mark ( ) ;
append ( PduHeaders . FROM_ADDRESS_PRESENT_TOKEN ) ;
appendEncodedString ( from ) ;
int flen = fstart . getLength ( ) ;
mStack . pop ( ) ;
appendValueLength ( flen ) ;
mStack . copy ( ) ;
}
break ;
case PduHeaders . READ_STATUS :
case PduHeaders . STATUS :
case PduHeaders . REPORT_ALLOWED :
case PduHeaders . PRIORITY :
case PduHeaders . DELIVERY_REPORT :
case PduHeaders . READ_REPORT :
int octet = mPduHeader . getOctet ( field ) ;
if ( <num> == octet ) {
return PDU_COMPOSE_FIELD_NOT_SET ;
}
appendOctet ( field ) ;
appendOctet ( octet ) ;
break ;
case PduHeaders . DATE :
long date = mPduHeader . getLongInteger ( field ) ;
if (  <num> == date ) {
return PDU_COMPOSE_FIELD_NOT_SET ;
}
appendOctet ( field ) ;
appendDateValue ( date ) ;
break ;
case PduHeaders . SUBJECT :
EncodedStringValue enString =
mPduHeader . getEncodedStringValue ( field ) ;
if ( null == enString ) {
return PDU_COMPOSE_FIELD_NOT_SET ;
}
appendOctet ( field ) ;
appendEncodedString ( enString ) ;
break ;
case PduHeaders . MESSAGE_CLASS :
byte [ ] messageClass = mPduHeader . getTextString ( field ) ;
if ( null == messageClass ) {
return PDU_COMPOSE_FIELD_NOT_SET ;
}
appendOctet ( field ) ;
if ( Arrays . equals ( messageClass ,
PduHeaders . MESSAGE_CLASS_ADVERTISEMENT_STR . getBytes ( ) ) ) {
appendOctet ( PduHeaders . MESSAGE_CLASS_ADVERTISEMENT ) ;
} else if ( Arrays . equals ( messageClass ,
PduHeaders . MESSAGE_CLASS_AUTO_STR . getBytes ( ) ) ) {
appendOctet ( PduHeaders . MESSAGE_CLASS_AUTO ) ;
} else if ( Arrays . equals ( messageClass ,
PduHeaders . MESSAGE_CLASS_PERSONAL_STR . getBytes ( ) ) ) {
appendOctet ( PduHeaders . MESSAGE_CLASS_PERSONAL ) ;
} else if ( Arrays . equals ( messageClass ,
PduHeaders . MESSAGE_CLASS_INFORMATIONAL_STR . getBytes ( ) ) ) {
appendOctet ( PduHeaders . MESSAGE_CLASS_INFORMATIONAL ) ;
} else {
appendTextString ( messageClass ) ;
}
break ;
case PduHeaders . EXPIRY :
long expiry = mPduHeader . getLongInteger ( field ) ;
if (  <num> == expiry ) {
return PDU_COMPOSE_FIELD_NOT_SET ;
}
appendOctet ( field ) ;
mStack . newbuf ( ) ;
PositionMarker expiryStart = mStack . mark ( ) ;
append ( PduHeaders . VALUE_RELATIVE_TOKEN ) ;
appendLongInteger ( expiry ) ;
int expiryLength = expiryStart . getLength ( ) ;
mStack . pop ( ) ;
appendValueLength ( expiryLength ) ;
mStack . copy ( ) ;
break ;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED ;
}
return PDU_COMPOSE_SUCCESS ;
}
private int makeReadRecInd ( ) {
if ( mMessage == null ) {
mMessage = new ByteArrayOutputStream ( ) ;
mPosition = <num> ;
}
appendOctet ( PduHeaders . MESSAGE_TYPE ) ;
appendOctet ( PduHeaders . MESSAGE_TYPE_READ_REC_IND ) ;
if ( appendHeader ( PduHeaders . MMS_VERSION ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
if ( appendHeader ( PduHeaders . MESSAGE_ID ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
if ( appendHeader ( PduHeaders . TO ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
if ( appendHeader ( PduHeaders . FROM ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
appendHeader ( PduHeaders . DATE ) ;
if ( appendHeader ( PduHeaders . READ_STATUS ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
return PDU_COMPOSE_SUCCESS ;
}
private int makeNotifyResp ( ) {
if ( mMessage == null ) {
mMessage = new ByteArrayOutputStream ( ) ;
mPosition = <num> ;
}
appendOctet ( PduHeaders . MESSAGE_TYPE ) ;
appendOctet ( PduHeaders . MESSAGE_TYPE_NOTIFYRESP_IND ) ;
if ( appendHeader ( PduHeaders . TRANSACTION_ID ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
if ( appendHeader ( PduHeaders . MMS_VERSION ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
if ( appendHeader ( PduHeaders . STATUS ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
return PDU_COMPOSE_SUCCESS ;
}
private int makeAckInd ( ) {
if ( mMessage == null ) {
mMessage = new ByteArrayOutputStream ( ) ;
mPosition = <num> ;
}
appendOctet ( PduHeaders . MESSAGE_TYPE ) ;
appendOctet ( PduHeaders . MESSAGE_TYPE_ACKNOWLEDGE_IND ) ;
if ( appendHeader ( PduHeaders . TRANSACTION_ID ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
if ( appendHeader ( PduHeaders . MMS_VERSION ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
appendHeader ( PduHeaders . REPORT_ALLOWED ) ;
return PDU_COMPOSE_SUCCESS ;
}
private int makeSendReqPdu ( ) {
if ( mMessage == null ) {
mMessage = new ByteArrayOutputStream ( ) ;
mPosition = <num> ;
}
appendOctet ( PduHeaders . MESSAGE_TYPE ) ;
appendOctet ( PduHeaders . MESSAGE_TYPE_SEND_REQ ) ;
appendOctet ( PduHeaders . TRANSACTION_ID ) ;
byte [ ] trid = mPduHeader . getTextString ( PduHeaders . TRANSACTION_ID ) ;
if ( trid == null ) {
throw new IllegalArgumentException ( " ) ;
}
appendTextString ( trid ) ;
if ( appendHeader ( PduHeaders . MMS_VERSION ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
appendHeader ( PduHeaders . DATE ) ;
if ( appendHeader ( PduHeaders . FROM ) != PDU_COMPOSE_SUCCESS ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
boolean recipient = false ;
if ( appendHeader ( PduHeaders . TO ) != PDU_COMPOSE_CONTENT_ERROR ) {
recipient = true ;
}
if ( appendHeader ( PduHeaders . CC ) != PDU_COMPOSE_CONTENT_ERROR ) {
recipient = true ;
}
if ( appendHeader ( PduHeaders . BCC ) != PDU_COMPOSE_CONTENT_ERROR ) {
recipient = true ;
}
if ( false == recipient ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
appendHeader ( PduHeaders . SUBJECT ) ;
appendHeader ( PduHeaders . MESSAGE_CLASS ) ;
appendHeader ( PduHeaders . EXPIRY ) ;
appendHeader ( PduHeaders . PRIORITY ) ;
appendHeader ( PduHeaders . DELIVERY_REPORT ) ;
appendHeader ( PduHeaders . READ_REPORT ) ;
appendOctet ( PduHeaders . CONTENT_TYPE ) ;
makeMessageBody ( ) ;
return PDU_COMPOSE_SUCCESS ;
}
private int makeMessageBody ( ) {
mStack . newbuf ( ) ;
PositionMarker ctStart = mStack . mark ( ) ;
String contentType = new String (
mPduHeader . getTextString ( PduHeaders . CONTENT_TYPE ) ) ;
Integer contentTypeIdentifier = mContentTypeMap . get ( contentType ) ;
if ( contentTypeIdentifier == null ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
appendShortInteger ( contentTypeIdentifier . intValue ( ) ) ;
PduBody body = ( ( SendReq ) mPdu ) . getBody ( ) ;
if ( null == body ) {
appendUintvarInteger ( <num> ) ;
mStack . pop ( ) ;
mStack . copy ( ) ;
return PDU_COMPOSE_SUCCESS ;
}
PduPart part ;
try {
part = body . getPart ( <num> ) ;
byte [ ] start = part . getContentId ( ) ;
if ( start != null ) {
appendOctet ( PduPart . P_DEP_START ) ;
if ( ( <' == start [ <num> ] ) && ( >' == start [ start . length  <num> ] ) ) {
appendTextString ( start ) ;
} else {
appendTextString ( " + new String ( start ) + " ) ;
}
}
appendOctet ( PduPart . P_CT_MR_TYPE ) ;
appendTextString ( part . getContentType ( ) ) ;
}
catch ( ArrayIndexOutOfBoundsException e ) {
e . printStackTrace ( ) ;
}
int ctLength = ctStart . getLength ( ) ;
mStack . pop ( ) ;
appendValueLength ( ctLength ) ;
mStack . copy ( ) ;
int partNum = body . getPartsNum ( ) ;
appendUintvarInteger ( partNum ) ;
for ( int i = <num> ; i < partNum ; i ++ ) {
part = body . getPart ( i ) ;
mStack . newbuf ( ) ;
PositionMarker attachment = mStack . mark ( ) ;
mStack . newbuf ( ) ;
PositionMarker contentTypeBegin = mStack . mark ( ) ;
byte [ ] partContentType = part . getContentType ( ) ;
if ( partContentType == null ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
Integer partContentTypeIdentifier =
mContentTypeMap . get ( new String ( partContentType ) ) ;
if ( partContentTypeIdentifier == null ) {
appendTextString ( partContentType ) ;
} else {
appendShortInteger ( partContentTypeIdentifier . intValue ( ) ) ;
}
byte [ ] name = part . getName ( ) ;
if ( null == name ) {
name = part . getFilename ( ) ;
if ( null == name ) {
name = part . getContentLocation ( ) ;
if ( null == name ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
}
}
appendOctet ( PduPart . P_DEP_NAME ) ;
appendTextString ( name ) ;
int charset = part . getCharset ( ) ;
if ( charset != <num> ) {
appendOctet ( PduPart . P_CHARSET ) ;
appendShortInteger ( charset ) ;
}
int contentTypeLength = contentTypeBegin . getLength ( ) ;
mStack . pop ( ) ;
appendValueLength ( contentTypeLength ) ;
mStack . copy ( ) ;
byte [ ] contentId = part . getContentId ( ) ;
if ( null != contentId ) {
appendOctet ( PduPart . P_CONTENT_ID ) ;
if ( ( <' == contentId [ <num> ] ) && ( >' == contentId [ contentId . length  <num> ] ) ) {
appendQuotedString ( contentId ) ;
} else {
appendQuotedString ( " + new String ( contentId ) + " ) ;
}
}
byte [ ] contentLocation = part . getContentLocation ( ) ;
if ( null != contentLocation ) {
appendOctet ( PduPart . P_CONTENT_LOCATION ) ;
appendTextString ( contentLocation ) ;
}
int headerLength = attachment . getLength ( ) ;
int dataLength = <num> ;
byte [ ] partData = part . getData ( ) ;
if ( partData != null ) {
arraycopy ( partData , <num> , partData . length ) ;
dataLength = partData . length ;
} else {
InputStream cr ;
try {
byte [ ] buffer = new byte [ PDU_COMPOSER_BLOCK_SIZE ] ;
cr = mResolver . openInputStream ( part . getDataUri ( ) ) ;
int len = <num> ;
while ( ( len = cr . read ( buffer ) ) !=  <num> ) {
mMessage . write ( buffer , <num> , len ) ;
mPosition += len ;
dataLength += len ;
}
} catch ( FileNotFoundException e ) {
return PDU_COMPOSE_CONTENT_ERROR ;
} catch ( IOException e ) {
return PDU_COMPOSE_CONTENT_ERROR ;
} catch ( RuntimeException e ) {
return PDU_COMPOSE_CONTENT_ERROR ;
}
}
if ( dataLength != ( attachment . getLength ( )  headerLength ) ) {
throw new RuntimeException ( " ) ;
}
mStack . pop ( ) ;
appendUintvarInteger ( headerLength ) ;
appendUintvarInteger ( dataLength ) ;
mStack . copy ( ) ;
}
return PDU_COMPOSE_SUCCESS ;
}
static private class LengthRecordNode {
ByteArrayOutputStream currentMessage = null ;
public int currentPosition = <num> ;
public LengthRecordNode next = null ;
}
private class PositionMarker {
private int c_pos ;
private int currentStackSize ;
int getLength ( ) {
if ( currentStackSize != mStack . stackSize ) {
throw new RuntimeException ( " ) ;
}
return mPosition  c_pos ;
}
}
private class BufferStack {
private LengthRecordNode stack = null ;
private LengthRecordNode toCopy = null ;
int stackSize = <num> ;
void newbuf ( ) {
if ( toCopy != null ) {
throw new RuntimeException ( " ) ;
}
LengthRecordNode temp = new LengthRecordNode ( ) ;
temp . currentMessage = mMessage ;
temp . currentPosition = mPosition ;
temp . next = stack ;
stack = temp ;
stackSize = stackSize + <num> ;
mMessage = new ByteArrayOutputStream ( ) ;
mPosition = <num> ;
}
void pop ( ) {
ByteArrayOutputStream currentMessage = mMessage ;
int currentPosition = mPosition ;
mMessage = stack . currentMessage ;
mPosition = stack . currentPosition ;
toCopy = stack ;
stack = stack . next ;
stackSize = stackSize  <num> ;
toCopy . currentMessage = currentMessage ;
toCopy . currentPosition = currentPosition ;
}
void copy ( ) {
arraycopy ( toCopy . currentMessage . toByteArray ( ) , <num> ,
toCopy . currentPosition ) ;
toCopy = null ;
}
PositionMarker mark ( ) {
PositionMarker m = new PositionMarker ( ) ;
m . c_pos = mPosition ;
m . currentStackSize = stackSize ;
return m ;
}
}
protected static int checkAddressType ( String address ) {
if ( null == address ) {
return PDU_UNKNOWN_ADDRESS_TYPE ;
}
if ( address . matches ( REGEXP_IPV4_ADDRESS_TYPE ) ) {
return PDU_IPV4_ADDRESS_TYPE ;
} else if ( address . matches ( REGEXP_PHONE_NUMBER_ADDRESS_TYPE ) ) {
return PDU_PHONE_NUMBER_ADDRESS_TYPE ;
} else if ( address . matches ( REGEXP_EMAIL_ADDRESS_TYPE ) ) {
return PDU_EMAIL_ADDRESS_TYPE ;
} else if ( address . matches ( REGEXP_IPV6_ADDRESS_TYPE ) ) {
return PDU_IPV6_ADDRESS_TYPE ;
} else {
return PDU_UNKNOWN_ADDRESS_TYPE ;
}
}
package com . google . android . mms ;
public class InvalidHeaderValueException extends MmsException {
private static final long serialVersionUID =  <num> ;
public InvalidHeaderValueException ( ) {
super ( ) ;
}
public InvalidHeaderValueException ( String message ) {
super ( message ) ;
}
package com . google . android . mms . pdu ;
public class PduContentTypes {
static final String [ ] contentTypes = {
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
" ,
"
} ;
package com . shellware . CarHome ;
import java . io . ByteArrayOutputStream ;
import java . io . IOException ;
import java . io . PrintWriter ;
import java . io . StringWriter ;
import java . io . Writer ;
import java . util . Calendar ;
import java . util . List ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . app . UiModeManager ;
import android . bluetooth . BluetoothAdapter ;
import android . content . BroadcastReceiver ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . IntentFilter ;
import android . content . SharedPreferences ;
import android . content . res . Resources ;
import android . graphics . Bitmap ;
import android . graphics . Bitmap . CompressFormat ;
import android . graphics . BitmapFactory ;
import android . hardware . Camera ;
import android . hardware . Camera . CameraInfo ;
import android . hardware . Camera . PictureCallback ;
import android . hardware . Camera . PreviewCallback ;
import android . location . Location ;
import android . media . AudioManager ;
import android . media . Ringtone ;
import android . media . RingtoneManager ;
import android . net . ConnectivityManager ;
import android . net . NetworkInfo ;
import android . net . Uri ;
import android . net . wifi . WifiManager ;
import android . os . Bundle ;
import android . os . Handler ;
import android . preference . PreferenceManager ;
import android . telephony . SmsManager ;
import android . view . KeyEvent ;
import android . view . Menu ;
import android . view . MenuInflater ;
import android . view . MenuItem ;
import android . view . MotionEvent ;
import android . view . SurfaceHolder ;
import android . view . SurfaceView ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . view . View . OnTouchListener ;
import android . view . WindowManager ;
import android . widget . Button ;
import android . widget . ImageView ;
import android . widget . SeekBar ;
import android . widget . SeekBar . OnSeekBarChangeListener ;
import android . widget . TextView ;
import com . google . android . mms . APNHelper ;
import com . google . android . mms . APNHelper . APN ;
import com . google . android . mms . pdu . EncodedStringValue ;
import com . google . android . mms . pdu . PduBody ;
import com . google . android . mms . pdu . PduComposer ;
import com . google . android . mms . pdu . PduPart ;
import com . google . android . mms . pdu . SendReq ;
import com . google . android . mms . transaction . HttpUtils ;
import com . gtosoft . libvoyager . session . OBD2Session ;
import com . shellware . CarHome . helpers . BatteryStatusReceiver ;
import com . shellware . CarHome . helpers . MyLocation ;
import com . shellware . CarHome . helpers . MyLocation . LocationResult ;
import com . shellware . CarHome . helpers . OBDHelper ;
import com . shellware . CarHome . media . MusicService ;
import com . shellware . CarHome . media . RemoteControlReceiver ;
import com . shellware . CarHome . ui . GaugeNeedle ;
import com . shellware . CarHome . ui . ProgramsGallery ;
public class CarHomeActivity extends Activity implements OnClickListener {
private final static String TAG = " ;
private static final String FEATURE_ENABLE_MMS = " ;
private static boolean debugMode = false ;
private static final int APN_ALREADY_ACTIVE = <num> ;
private final static float KPI_TO_PSI_MULTIPLIER = <num> ;
private final static int ROUTINE_UPDATE_INTERVAL = <num> ;
private final static int TPMS_UPDATE_INTERVAL = <num> ;
private final static int MUSIC_UPDATE_INTERVAL = <num> ;
private final static int BRIGHTNESS_UPDATE_INTERVAL = <num> ;
private final static float BRIGHTNESS_MINIMUM = <num> ;
private final static float BRIGHTNESS_MAXIMUM = <num> ;
private static Context ctx = null ;
private SharedPreferences prefs ;
private Resources res ;
private Handler routineUpdateHandler = new Handler ( ) ;
private Handler tpmsUpdateHandler = new Handler ( ) ;
private Handler brightnessUpdateHandler = new Handler ( ) ;
private Handler musicUpdateHandler = new Handler ( ) ;
private AudioManager mAudioManager ;
private static Camera camera = null ;
private static ConnectivityActionReceiver connectivityActionReceiver ;
RemoteControlReceiver mMediaButtonReceiver ;
BatteryStatusReceiver mBatteryStatusReceiver ;
IntentFilter mediaFilter ;
private OBDHelper obd ;
private static SurfaceView mCameraView ;
private static SurfaceHolder mCameraHolder = null ;
private Menu myMenu = null ;
private GaugeNeedle waterNeedle ;
private GaugeNeedle voltageNeedle ;
private GaugeNeedle afrNeedle ;
private GaugeNeedle iatNeedle ;
private GaugeNeedle mafNeedle ;
private GaugeNeedle egtNeedle ;
private GaugeNeedle tpms1Needle ;
private GaugeNeedle tpms2Needle ;
private GaugeNeedle tpms3Needle ;
private GaugeNeedle tpms4Needle ;
private GaugeNeedle temp1Needle ;
private GaugeNeedle temp2Needle ;
private GaugeNeedle temp3Needle ;
private GaugeNeedle temp4Needle ;
private Button mPlayButton ;
private Button mStopButton ;
private Button mForwardButton ;
private Button mRewindButton ;
private Button mMuteButton ;
private SeekBar mPositionBar ;
private ImageView mArtworkImage ;
private ImageView mBackground ;
private ImageView mLowFuel ;
private ProgramsGallery gallery ;
private static TextView mMiscText ;
private boolean mMuted = false ;
private static String originator = " ;
private static boolean wifiEnabled = false ;
private static int activeCamera = <num> ;
private long lastFuelAlarm = <num> ;
private long lastSongId = <num> ;
private boolean tpmsUpdateRunning = false ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
ctx = this ;
setContentView ( R . layout . main ) ;
prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ;
res = getResources ( ) ;
mAudioManager = ( AudioManager ) getSystemService ( Context . AUDIO_SERVICE ) ;
mMediaButtonReceiver = new RemoteControlReceiver ( ) ;
mediaFilter = new IntentFilter ( Intent . ACTION_MEDIA_BUTTON ) ;
mediaFilter . setPriority ( Integer . MAX_VALUE ) ;
registerReceiver ( mMediaButtonReceiver , mediaFilter ) ;
mBackground = ( ImageView ) findViewById ( R . id . background ) ;
mBackground . setOnTouchListener ( new backgroundTouchListener ( ) ) ;
waterNeedle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
voltageNeedle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
afrNeedle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
iatNeedle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
mafNeedle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
egtNeedle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
tpms1Needle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
tpms2Needle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
tpms3Needle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
tpms4Needle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
temp1Needle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
temp2Needle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
temp3Needle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
temp4Needle = ( GaugeNeedle ) findViewById ( R . id . <unk> ) ;
waterNeedle . setPivotPoint ( <num> ) ;
waterNeedle . setMinValue ( <num> ) ;
waterNeedle . setMaxValue ( <num> ) ;
waterNeedle . setMinDegrees (  <num> ) ;
waterNeedle . setMaxDegrees ( <num> ) ;
voltageNeedle . setPivotPoint ( <num> ) ;
voltageNeedle . setMinValue ( <num> ) ;
voltageNeedle . setMaxValue ( <num> ) ;
voltageNeedle . setMinDegrees (  <num> ) ;
voltageNeedle . setMaxDegrees ( <num> ) ;
mafNeedle . setPivotPoint ( <num> ) ;
mafNeedle . setMinValue ( <num> ) ;
mafNeedle . setMaxValue ( <num> ) ;
mafNeedle . setMinDegrees (  <num> ) ;
mafNeedle . setMaxDegrees ( <num> ) ;
afrNeedle . setPivotPoint ( <num> ) ;
afrNeedle . setMinValue ( <num> ) ;
afrNeedle . setMaxValue ( <num> ) ;
afrNeedle . setMinDegrees (  <num> ) ;
afrNeedle . setMaxDegrees ( <num> ) ;
iatNeedle . setPivotPoint ( <num> ) ;
iatNeedle . setMinValue ( <num> ) ;
iatNeedle . setMaxValue ( <num> ) ;
iatNeedle . setMinDegrees (  <num> ) ;
iatNeedle . setMaxDegrees ( <num> ) ;
egtNeedle . setPivotPoint ( <num> ) ;
egtNeedle . setMinValue ( <num> ) ;
egtNeedle . setMaxValue ( <num> ) ;
egtNeedle . setMinDegrees (  <num> ) ;
egtNeedle . setMaxDegrees ( <num> ) ;
tpms1Needle . setPivotPoint ( <num> ) ;
tpms1Needle . setMinValue ( <num> ) ;
tpms1Needle . setMaxValue ( <num> ) ;
tpms1Needle . setMinDegrees (  <num> ) ;
tpms1Needle . setMaxDegrees ( <num> ) ;
tpms2Needle . setPivotPoint ( <num> ) ;
tpms2Needle . setMinValue ( <num> ) ;
tpms2Needle . setMaxValue ( <num> ) ;
tpms2Needle . setMinDegrees (  <num> ) ;
tpms2Needle . setMaxDegrees ( <num> ) ;
tpms3Needle . setPivotPoint ( <num> ) ;
tpms3Needle . setMinValue ( <num> ) ;
tpms3Needle . setMaxValue ( <num> ) ;
tpms3Needle . setMinDegrees (  <num> ) ;
tpms3Needle . setMaxDegrees ( <num> ) ;
tpms4Needle . setPivotPoint ( <num> ) ;
tpms4Needle . setMinValue ( <num> ) ;
tpms4Needle . setMaxValue ( <num> ) ;
tpms4Needle . setMinDegrees (  <num> ) ;
tpms4Needle . setMaxDegrees ( <num> ) ;
temp1Needle . setPivotPoint ( <num> ) ;
temp1Needle . setMinValue (  <num> ) ;
temp1Needle . setMaxValue ( <num> ) ;
temp1Needle . setMinDegrees (  <num> ) ;
temp1Needle . setMaxDegrees ( <num> ) ;
temp2Needle . setPivotPoint ( <num> ) ;
temp2Needle . setMinValue (  <num> ) ;
temp2Needle . setMaxValue ( <num> ) ;
temp2Needle . setMinDegrees (  <num> ) ;
temp2Needle . setMaxDegrees ( <num> ) ;
temp3Needle . setPivotPoint ( <num> ) ;
temp3Needle . setMinValue (  <num> ) ;
temp3Needle . setMaxValue ( <num> ) ;
temp3Needle . setMinDegrees (  <num> ) ;
temp3Needle . setMaxDegrees ( <num> ) ;
temp4Needle . setPivotPoint ( <num> ) ;
temp4Needle . setMinValue (  <num> ) ;
temp4Needle . setMaxValue ( <num> ) ;
temp4Needle . setMinDegrees (  <num> ) ;
temp4Needle . setMaxDegrees ( <num> ) ;
mPlayButton = ( Button ) findViewById ( R . id . <unk> ) ;
mPlayButton . setOnClickListener ( this ) ;
mStopButton = ( Button ) findViewById ( R . id . stopbutton ) ;
mStopButton . setOnClickListener ( this ) ;
mForwardButton = ( Button ) findViewById ( R . id . <unk> ) ;
mForwardButton . setOnClickListener ( this ) ;
mRewindButton = ( Button ) findViewById ( R . id . <unk> ) ;
mRewindButton . setOnClickListener ( this ) ;
mMuteButton = ( Button ) findViewById ( R . id . <unk> ) ;
mMuteButton . setOnClickListener ( this ) ;
mPositionBar = ( SeekBar ) findViewById ( R . id . position ) ;
mPositionBar . setMax ( <num> ) ;
mPositionBar . setProgress ( <num> ) ;
mPositionBar . setOnSeekBarChangeListener ( new OnSeekBarChangeListener ( ) {
public void onProgressChanged ( SeekBar arg0 , int position , boolean fromTouch ) {
if ( fromTouch ) MusicService . setPosition ( position ) ;
}
public void onStartTrackingTouch ( SeekBar arg0 ) {
}
public void onStopTrackingTouch ( SeekBar arg0 ) {
}
} ) ;
mArtworkImage = ( ImageView ) findViewById ( R . id . artwork ) ;
mCameraView = ( SurfaceView ) findViewById ( R . id . <unk> ) ;
mLowFuel = ( ImageView ) findViewById ( R . id . <unk> ) ;
gallery = ( ProgramsGallery ) findViewById ( R . id . gallery ) ;
mMiscText = ( TextView ) findViewById ( R . id . <unk> ) ;
}
private class backgroundTouchListener implements OnTouchListener {
public boolean onTouch ( View view , MotionEvent motionevent ) {
if ( motionevent . getAction ( ) == MotionEvent . ACTION_DOWN ) {
if ( gallery . getVisibility ( ) != View . VISIBLE ) {
gallery . showGallery ( ) ;
} else {
gallery . hideGallery ( ) ;
}
}
return true ;
}
}
@Override
public boolean dispatchKeyEvent ( KeyEvent event ) {
return super . dispatchKeyEvent ( event ) ;
}
@Override
public boolean onKeyDown ( int keyCode , KeyEvent event ) {
return super . onKeyDown ( keyCode , event ) ;
}
@Override
public void onResume ( ) {
super . onResume ( ) ;
if ( obd != null ) {
obd . shutdown ( ) ;
obd = null ;
}
new Handler ( ) . postDelayed ( new Runnable ( ) {
public void run ( ) {
obd = new OBDHelper ( ctx ) ;
}
} , <num> ) ;
routineUpdateHandler . post ( routineUpdate ) ;
tpmsUpdateHandler . postDelayed ( tpmsUpdate , TPMS_UPDATE_INTERVAL ) ;
brightnessUpdateHandler . post ( brightnessUpdate ) ;
musicUpdateHandler . post ( musicUpdate ) ;
}
@Override
public void onPause ( ) {
super . onPause ( ) ;
if ( obd != null ) {
obd . shutdown ( ) ;
obd = null ;
}
routineUpdateHandler . removeCallbacks ( routineUpdate ) ;
tpmsUpdateHandler . removeCallbacks ( tpmsUpdate ) ;
brightnessUpdateHandler . removeCallbacks ( brightnessUpdate ) ;
musicUpdateHandler . removeCallbacks ( musicUpdate ) ;
}
@Override
protected void onDestroy ( ) {
super . onDestroy ( ) ;
gallery . destroyGallery ( ) ;
UiModeManager manager = ( UiModeManager ) getSystemService ( Context . <unk> ) ;
manager . <unk> ( UiModeManager . <unk> ) ;
unregisterReceiver ( mMediaButtonReceiver ) ;
unregisterReceiver ( mBatteryStatusReceiver ) ;
}
public boolean onCreateOptionsMenu ( Menu menu ) {
MenuInflater inflater = getMenuInflater ( ) ;
inflater . inflate ( R . menu . menu , menu ) ;
return true ;
}
public void onClick ( View target ) {
if ( target == mPlayButton ) {
if ( MusicService . mState == MusicService . State . Paused ) {
startService ( new Intent ( MusicService . ACTION_PLAY ) ) ;
} else {
if ( MusicService . mState == MusicService . State . Playing ) {
startService ( new Intent ( MusicService . ACTION_PAUSE ) ) ;
} else {
startService ( new Intent ( MusicService . ACTION_SKIP ) ) ;
}
}
}
if ( target == mStopButton ) {
startService ( new Intent ( MusicService . ACTION_STOP ) ) ;
}
if ( target == mForwardButton ) {
startService ( new Intent ( MusicService . ACTION_SKIP ) ) ;
}
if ( target == mRewindButton ) {
startService ( new Intent ( MusicService . ACTION_REWIND ) ) ;
}
if ( target == mMuteButton ) {
mMuted = ! mMuted ;
mAudioManager . setStreamMute ( AudioManager . STREAM_MUSIC , mMuted ) ;
if ( mMuted ) {
mMuteButton . setBackgroundResource ( R . drawable . <unk> ) ;
} else {
mMuteButton . setBackgroundResource ( R . drawable . <unk> ) ;
}
}
}
@Override
public boolean onPrepareOptionsMenu ( Menu menu ) {
myMenu = menu ;
BluetoothAdapter bt = BluetoothAdapter . getDefaultAdapter ( ) ;
if ( bt != null && bt . isEnabled ( ) ) {
myMenu . getItem ( <num> ) . setIcon ( R . drawable . bluetooth_on ) ;
} else {
myMenu . getItem ( <num> ) . setIcon ( R . drawable . bluetooth_off ) ;
}
mBatteryStatusReceiver = new BatteryStatusReceiver ( this , obd , menu ) ;
registerReceiver ( mBatteryStatusReceiver , new IntentFilter ( Intent . ACTION_BATTERY_CHANGED ) ) ;
return super . onPrepareOptionsMenu ( menu ) ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
return true ;
case R . id . <unk> :
BluetoothAdapter bt = BluetoothAdapter . getDefaultAdapter ( ) ;
if ( bt != null && ! bt . isEnabled ( ) ) {
sleep ( <num> ) ;
bt . enable ( ) ;
if ( obd != null ) {
obd . shutdown ( ) ;
obd = null ;
}
new Handler ( ) . postDelayed ( new Runnable ( ) {
public void run ( ) {
obd = new OBDHelper ( ctx ) ;
}
} , <num> ) ;
item . setIcon ( R . drawable . bluetooth_on ) ;
} else {
if ( obd != null ) {
obd . shutdown ( ) ;
obd = null ;
}
if ( bt != null ) bt . disable ( ) ;
item . setIcon ( R . drawable . bluetooth_off ) ;
}
return true ;
case R . id . quitMenuItem :
System . exit ( <num> ) ;
return true ;
case R . id . <unk> :
if ( camera == null ) {
startCameraPreview ( Camera . CameraInfo . CAMERA_FACING_FRONT , false ) ;
} else {
stopCameraPreview ( ) ;
}
return true ;
case R . id . <unk> :
if ( obd != null && obd . getHs ( ) != null && obd . getHs ( ) . getOBDSession ( ) != null &&
obd . getHs ( ) . getOBDSession ( ) . getCurrentState ( ) == OBD2Session . STATE_OBDCONNECTED ) {
String cels = obd . getHs ( ) . <unk> ( ) . <unk> ( " ) ;
AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ;
builder
. setTitle ( " )
. setMessage ( cels + " + " )
. setIcon ( android . R . drawable . ic_dialog_info )
. setPositiveButton ( " , new DialogInterface . OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int which ) {
obd . getHs ( ) . getOBDSession ( ) . <unk> ( ) ;
}
} )
. setNegativeButton ( " , null )
. show ( ) ;
}
return true ;
case R . id . debugMenuItem :
item . setChecked ( ! item . isChecked ( ) ) ;
debugMode = item . isChecked ( ) ;
return false ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
private Runnable musicUpdate = new Runnable ( ) {
public void run ( ) {
if ( MusicService . getPosition ( ) != <num> ) {
mPositionBar . setMax ( MusicService . getCurrentItem ( ) . getDuration ( ) ) ;
mPositionBar . setProgress ( MusicService . getPosition ( ) ) ;
} else {
mPositionBar . setMax ( <num> ) ;
mPositionBar . setProgress ( <num> ) ;
}
if ( MusicService . mState == MusicService . State . Playing ) {
mPlayButton . setBackgroundResource ( R . drawable . <unk> ) ;
if ( lastSongId != MusicService . getCurrentItem ( ) . getId ( ) ) {
mArtworkImage . setImageBitmap ( MusicService . getCurrentItem ( ) . getAlbumArt ( ) ) ;
lastSongId = MusicService . getCurrentItem ( ) . getId ( ) ;
}
} else {
mPlayButton . setBackgroundResource ( R . drawable . <unk> ) ;
}
musicUpdateHandler . postDelayed ( this , MUSIC_UPDATE_INTERVAL ) ;
}
} ;
private Runnable routineUpdate = new Runnable ( ) {
public void run ( ) {
try {
if ( obd != null && obd . getHs ( ) != null &&
obd . getHs ( ) . isOBDReady ( ) && obd . getHs ( ) . getOBDSession ( ) != null &&
obd . getHs ( ) . getOBDSession ( ) . getCurrentState ( ) >= OBD2Session . STATE_OBDCONNECTED ) {
waterNeedle . setValue ( obd . getCoolant ( ) ) ;
voltageNeedle . setValue ( obd . getVoltage ( ) * <num> ) ;
mafNeedle . setValue ( obd . getMaf ( ) ) ;
afrNeedle . setValue ( <num>  ( obd . getWideband ( ) * <num> ) + <num> ) ;
iatNeedle . setValue ( obd . getIat ( ) ) ;
egtNeedle . setValue ( obd . getEgt ( ) ) ;
if ( obd . getFuel ( ) > <num> && obd . getFuel ( ) < <num> ) {
if ( mLowFuel . getVisibility ( ) == View . INVISIBLE ) {
mLowFuel . setVisibility ( View . VISIBLE ) ;
if ( lastFuelAlarm + <num> < System . currentTimeMillis ( ) ) {
Uri notification = RingtoneManager . getDefaultUri ( RingtoneManager . <unk> ) ;
Ringtone r = RingtoneManager . getRingtone ( getApplicationContext ( ) , notification ) ;
r . play ( ) ;
lastFuelAlarm = System . currentTimeMillis ( ) ;
}
} else {
mLowFuel . setVisibility ( View . INVISIBLE ) ;
}
} else {
if ( mLowFuel . getVisibility ( ) == View . VISIBLE ) mLowFuel . setVisibility ( View . INVISIBLE ) ;
}
} else {
waterNeedle . setValue ( <num> ) ;
voltageNeedle . setValue ( <num> ) ;
mafNeedle . setValue ( <num> ) ;
afrNeedle . setValue ( <num>  <num> + <num> ) ;
iatNeedle . setValue ( <num> ) ;
egtNeedle . setValue ( <num> ) ;
}
} catch ( Exception ex ) {
logger ( ex . getMessage ( ) + " + getStackTrace ( ex ) ) ;
} finally {
if ( ! tpmsUpdateRunning ) routineUpdateHandler . postDelayed ( this , ROUTINE_UPDATE_INTERVAL ) ;
}
}
} ;
private Runnable tpmsUpdate = new Runnable ( ) {
public void run ( ) {
tpmsUpdateRunning = true ;
routineUpdateHandler . removeCallbacks ( routineUpdate ) ;
try {
if ( obd != null && obd . getHs ( ) != null &&
obd . getHs ( ) . isOBDReady ( ) && obd . getHs ( ) . getOBDSession ( ) != null &&
obd . getHs ( ) . getOBDSession ( ) . getCurrentState ( ) >= OBD2Session . STATE_OBDCONNECTED ) {
Thread . sleep ( <num> ) ;
obd . getHs ( ) . getEBT ( ) . sendATCommand2 ( " ) ;
final String tpmsPresBuf = obd . getHs ( ) . getEBT ( ) . sendOBDCommand ( " ) ;
final String tpmsTempBuf = obd . getHs ( ) . getEBT ( ) . sendOBDCommand ( " ) ;
if ( debugMode ) {
obd . getHs ( ) . getEBT ( ) . sendATCommand2 ( " ) ;
obd . getHs ( ) . getEBT ( ) . sendATCommand2 ( " ) ;
final String c1 = obd . getHs ( ) . getEBT ( ) . sendOBDCommand ( " ) ;
final String c2 = obd . getHs ( ) . getEBT ( ) . sendOBDCommand ( " ) ;
logger ( " + c1 + " + c2 ) ;
}
obd . getHs ( ) . getEBT ( ) . sendATCommand2 ( " ) ;
if ( tpmsPresBuf != null && ! tpmsPresBuf . contains ( " ) ) {
try {
final String [ ] tpmsPres = tpmsPresBuf . split ( " ) ;
if ( tpmsPres . length > <num> ) {
final float tpmsPres4 = Integer . parseInt ( tpmsPres [ tpmsPres . length  <num> ] , <num> ) * <num> * KPI_TO_PSI_MULTIPLIER ;
final float tpmsPres3 = Integer . parseInt ( tpmsPres [ tpmsPres . length  <num> ] , <num> ) * <num> * KPI_TO_PSI_MULTIPLIER ;
final float tpmsPres2 = Integer . parseInt ( tpmsPres [ tpmsPres . length  <num> ] , <num> ) * <num> * KPI_TO_PSI_MULTIPLIER ;
final float tpmsPres1 = Integer . parseInt ( tpmsPres [ tpmsPres . length  <num> ] , <num> ) * <num> * KPI_TO_PSI_MULTIPLIER ;
tpms1Needle . setValue ( tpmsPres1 * <num> ) ;
tpms2Needle . setValue ( tpmsPres2 * <num> ) ;
tpms3Needle . setValue ( tpmsPres3 * <num> ) ;
tpms4Needle . setValue ( tpmsPres4 * <num> ) ;
}
} catch ( Exception ex ) {
tpms1Needle . setValue ( <num> ) ;
tpms2Needle . setValue ( <num> ) ;
tpms3Needle . setValue ( <num> ) ;
tpms4Needle . setValue ( <num> ) ;
}
}
if ( tpmsTempBuf != null && ! tpmsTempBuf . contains ( " ) ) {
try {
final String [ ] tpmsTemp = tpmsTempBuf . split ( " ) ;
if ( tpmsTemp . length > <num> ) {
final float tpmsTemp4 = ( float ) ( <num> * ( Integer . parseInt ( tpmsTemp [ tpmsTemp . length  <num> ] , <num> )  <num> ) + <num> ) ;
final float tpmsTemp3 = ( float ) ( <num> * ( Integer . parseInt ( tpmsTemp [ tpmsTemp . length  <num> ] , <num> )  <num> ) + <num> ) ;
final float tpmsTemp2 = ( float ) ( <num> * ( Integer . parseInt ( tpmsTemp [ tpmsTemp . length  <num> ] , <num> )  <num> ) + <num> ) ;
final float tpmsTemp1 = ( float ) ( <num> * ( Integer . parseInt ( tpmsTemp [ tpmsTemp . length  <num> ] , <num> )  <num> ) + <num> ) ;
temp1Needle . setValue ( tpmsTemp1 ) ;
temp2Needle . setValue ( tpmsTemp2 ) ;
temp3Needle . setValue ( tpmsTemp3 ) ;
temp4Needle . setValue ( tpmsTemp4 ) ;
}
} catch ( Exception ex ) {
temp1Needle . setValue ( <num> ) ;
temp2Needle . setValue ( <num> ) ;
temp3Needle . setValue ( <num> ) ;
temp4Needle . setValue ( <num> ) ;
}
}
} else {
tpms1Needle . setValue ( <num> ) ;
tpms2Needle . setValue ( <num> ) ;
tpms3Needle . setValue ( <num> ) ;
tpms4Needle . setValue ( <num> ) ;
temp1Needle . setValue ( <num> ) ;
temp2Needle . setValue ( <num> ) ;
temp3Needle . setValue ( <num> ) ;
temp4Needle . setValue ( <num> ) ;
}
} catch ( Exception ex ) {
logger ( ex . getMessage ( ) + " + getStackTrace ( ex ) ) ;
} finally {
routineUpdateHandler . postDelayed ( routineUpdate , ROUTINE_UPDATE_INTERVAL ) ;
tpmsUpdateRunning = false ;
tpmsUpdateHandler . postDelayed ( tpmsUpdate , TPMS_UPDATE_INTERVAL ) ;
}
}
} ;
public Runnable brightnessUpdate = new Runnable ( ) {
public void run ( ) {
Calendar cal = Calendar . getInstance ( ) ;
float brightness = <num> ;
if ( cal . get ( Calendar . MONTH ) >= Calendar . DECEMBER || cal . get ( Calendar . MONTH ) < Calendar . APRIL ) {
if ( cal . get ( Calendar . HOUR_OF_DAY ) > <num> || cal . get ( Calendar . HOUR_OF_DAY ) <= <num> ) brightness = BRIGHTNESS_MINIMUM ;
if ( cal . get ( Calendar . HOUR_OF_DAY ) <= <num> && cal . get ( Calendar . HOUR_OF_DAY ) > <num> ) brightness = BRIGHTNESS_MAXIMUM ;
}
if ( cal . get ( Calendar . MONTH ) >= Calendar . APRIL && cal . get ( Calendar . MONTH ) < Calendar . JULY ) {
if ( cal . get ( Calendar . HOUR_OF_DAY ) > <num> || cal . get ( Calendar . HOUR_OF_DAY ) <= <num> ) brightness = BRIGHTNESS_MINIMUM ;
if ( cal . get ( Calendar . HOUR_OF_DAY ) <= <num> && cal . get ( Calendar . HOUR_OF_DAY ) > <num> ) brightness = BRIGHTNESS_MAXIMUM ;
}
if ( cal . get ( Calendar . MONTH ) >= Calendar . JULY && cal . get ( Calendar . MONTH ) < Calendar . OCTOBER ) {
if ( cal . get ( Calendar . HOUR_OF_DAY ) > <num> || cal . get ( Calendar . HOUR_OF_DAY ) <= <num> ) brightness = BRIGHTNESS_MINIMUM ;
if ( cal . get ( Calendar . HOUR_OF_DAY ) <= <num> && cal . get ( Calendar . HOUR_OF_DAY ) > <num> ) brightness = BRIGHTNESS_MAXIMUM ;
}
if ( cal . get ( Calendar . MONTH ) >= Calendar . OCTOBER && cal . get ( Calendar . MONTH ) < Calendar . DECEMBER ) {
if ( cal . get ( Calendar . HOUR_OF_DAY ) > <num> || cal . get ( Calendar . HOUR_OF_DAY ) <= <num> ) brightness = BRIGHTNESS_MINIMUM ;
if ( cal . get ( Calendar . HOUR_OF_DAY ) <= <num> && cal . get ( Calendar . HOUR_OF_DAY ) > <num> ) brightness = BRIGHTNESS_MAXIMUM ;
}
WindowManager . LayoutParams lp = getWindow ( ) . getAttributes ( ) ;
lp . <unk> = brightness ;
getWindow ( ) . setAttributes ( lp ) ;
brightnessUpdateHandler . postDelayed ( brightnessUpdate , BRIGHTNESS_UPDATE_INTERVAL ) ;
}
} ;
public static void toggleCamera ( ) {
if ( camera == null ) {
startCameraPreview ( Camera . CameraInfo . CAMERA_FACING_FRONT , false ) ;
} else {
stopCameraPreview ( ) ;
}
}
private static void startCameraPreview ( int whichCamera , boolean withCallback ) {
try {
if ( ! withCallback ) mCameraView . setVisibility ( View . VISIBLE ) ;
activeCamera = whichCamera ;
if ( mCameraHolder == null ) {
mCameraHolder = mCameraView . getHolder ( ) ;
mCameraHolder . addCallback ( surfaceCallback ) ;
}
Camera . CameraInfo info = new Camera . CameraInfo ( ) ;
for ( int i = <num> ; i < Camera . getNumberOfCameras ( ) ; i ++ ) {
Camera . getCameraInfo ( i , info ) ;
if ( info . facing == whichCamera ) {
camera = Camera . open ( i ) ;
}
}
if ( camera == null ) {
camera = Camera . open ( ) ;
}
if ( withCallback ) camera . setPreviewCallback ( new CameraPreviewCallback ( ) ) ;
camera . setPreviewDisplay ( mCameraHolder ) ;
camera . startPreview ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
private static void stopCameraPreview ( ) {
if ( camera == null ) return ;
camera . stopPreview ( ) ;
camera . release ( ) ;
camera = null ;
mCameraHolder = null ;
mCameraView . setVisibility ( View . INVISIBLE ) ;
}
static SurfaceHolder . Callback surfaceCallback = new SurfaceHolder . Callback ( ) {
public void surfaceCreated ( SurfaceHolder holder ) {
}
public void surfaceChanged ( SurfaceHolder holder , int format ,
int width , int height ) {
logger ( " ) ;
}
public void surfaceDestroyed ( SurfaceHolder holder ) {
}
} ;
public static void whereAreYou ( final String origin ) {
locationResult . setDestination ( origin ) ;
MyLocation myLocation = new MyLocation ( ) ;
myLocation . getLocation ( ctx , locationResult ) ;
}
public static LocationResult locationResult = new LocationResult ( ) {
String destination = " ;
@Override
public void gotLocation ( final Location location ) {
if ( location == null ) return ;
final String text = " + location . getLatitude ( ) + " + location . getLongitude ( ) ;
SmsManager sm = SmsManager . getDefault ( ) ;
sm . sendTextMessage ( destination , null , text , null , null ) ;
}
public void setDestination ( final String destination ) {
this . destination = destination ;
}
} ;
public static void whatDoYouSee ( final String origin ) {
if ( connectivityActionReceiver == null ) {
originator = origin ;
stopCameraPreview ( ) ;
startCameraPreview ( Camera . CameraInfo . CAMERA_FACING_FRONT , true ) ;
Handler handler = new Handler ( ) ;
handler . postDelayed ( doItAgain , <num> ) ;
} else {
logger ( " ) ;
}
}
private static Runnable doItAgain = new Runnable ( ) {
public void run ( ) {
stopCameraPreview ( ) ;
startCameraPreview ( Camera . CameraInfo . <unk> , true ) ;
}
} ;
private static class CameraPreviewCallback implements PreviewCallback {
private long startTime ;
private boolean fired = false ;
public CameraPreviewCallback ( ) {
super ( ) ;
startTime = System . currentTimeMillis ( ) ;
fired = false ;
}
public void onPreviewFrame ( byte [ ] arg0 , Camera arg1 ) {
if ( ! fired && System . currentTimeMillis ( )  startTime >= <num> ) {
fired = true ;
logger ( " ) ;
camera . stopPreview ( ) ;
camera . takePicture ( null , null , new CameraPictureCallback ( ) ) ;
}
}
}
private static class CameraPictureCallback implements PictureCallback {
public void onPictureTaken ( byte [ ] data , Camera camera ) {
logger ( " ) ;
stopCameraPreview ( ) ;
WifiManager wifi = ( WifiManager ) ctx . getSystemService ( Context . WIFI_SERVICE ) ;
wifiEnabled = wifi . <unk> ( ) ;
wifi . setWifiEnabled ( false ) ;
logger ( " + wifiEnabled ) ;
final ConnectivityManager connMgr = ( ConnectivityManager ) ctx . getSystemService ( Context . CONNECTIVITY_SERVICE ) ;
final int result = connMgr . <unk> ( ConnectivityManager . TYPE_MOBILE , FEATURE_ENABLE_MMS ) ;
if ( result != APN_ALREADY_ACTIVE ) {
logger ( " ) ;
final IntentFilter filter = new IntentFilter ( ) ;
filter . addAction ( ConnectivityManager . CONNECTIVITY_ACTION ) ;
connectivityActionReceiver = new ConnectivityActionReceiver ( data , activeCamera == CameraInfo . CAMERA_FACING_FRONT ? <num> : <num> ) ;
ctx . registerReceiver ( connectivityActionReceiver , filter ) ;
return ;
}
SendMmsPicture worker = new SendMmsPicture ( data , activeCamera == CameraInfo . CAMERA_FACING_FRONT ? <num> : <num> ) ;
worker . start ( ) ;
}
}
private static class ConnectivityActionReceiver extends BroadcastReceiver {
private byte [ ] data ;
private int quality ;
public ConnectivityActionReceiver ( byte [ ] data , int quality ) {
super ( ) ;
this . data = data ;
this . quality = quality ;
}
@Override
public void onReceive ( Context context , Intent intent ) {
String action = intent . getAction ( ) ;
if ( ! action . equals ( ConnectivityManager . CONNECTIVITY_ACTION ) ) {
return ;
}
NetworkInfo mNetworkInfo = ( NetworkInfo ) intent . getParcelableExtra (
ConnectivityManager . EXTRA_NETWORK_INFO ) ;
if ( ( mNetworkInfo == null ) ||
( mNetworkInfo . getType ( ) != ConnectivityManager . <unk> ) ) {
return ;
}
if ( ! mNetworkInfo . isConnected ( ) ) {
return ;
} else {
logger ( " ) ;
SendMmsPicture worker = new SendMmsPicture ( data , quality ) ;
worker . start ( ) ;
}
}
}
public static class SendMmsPicture extends Thread {
private byte [ ] data ;
private int quality ;
public SendMmsPicture ( byte [ ] data , int quality ) {
super ( ) ;
this . data = data ;
this . quality = quality ;
}
public void run ( ) {
logger ( " ) ;
final SendReq sendRequest = new SendReq ( ) ;
final EncodedStringValue [ ] phoneNumbers = EncodedStringValue
. extract ( originator ) ;
if ( phoneNumbers != null && phoneNumbers . length > <num> ) {
sendRequest . addTo ( phoneNumbers [ <num> ] ) ;
}
final PduBody pduBody = new PduBody ( ) ;
final PduPart partPdu = new PduPart ( ) ;
partPdu . setContentId ( " . getBytes ( ) ) ;
partPdu . setName ( " . getBytes ( ) ) ;
partPdu . setContentType ( " . getBytes ( ) ) ;
Bitmap bm = BitmapFactory . decodeByteArray ( data , <num> , data . length ) ;
ByteArrayOutputStream baos = new ByteArrayOutputStream ( data . length ) ;
bm . compress ( CompressFormat . JPEG , quality , baos ) ;
partPdu . setData ( baos . toByteArray ( ) ) ;
pduBody . addPart ( partPdu ) ;
sendRequest . setBody ( pduBody ) ;
final PduComposer composer = new PduComposer ( ctx , sendRequest ) ;
final byte [ ] bytesToSend = composer . make ( ) ;
try {
APNHelper apnHelper = new APNHelper ( ctx ) ;
List < APN > apns = apnHelper . getMMSApns ( ) ;
for ( APN apn : apns ) {
HttpUtils . httpConnection ( ctx , <num> , apn . MMSCenterUrl ,
bytesToSend , HttpUtils . HTTP_POST_METHOD , true , apn . MMSProxy , Integer . parseInt ( apn . MMSPort ) ) ;
logger ( " ) ;
}
} catch ( IOException e ) {
e . printStackTrace ( ) ;
} finally {
if ( connectivityActionReceiver != null ) {
ctx . unregisterReceiver ( connectivityActionReceiver ) ;
connectivityActionReceiver = null ;
final ConnectivityManager connMgr = ( ConnectivityManager ) ctx . getSystemService ( Context . CONNECTIVITY_SERVICE ) ;
connMgr . <unk> ( ConnectivityManager . TYPE_MOBILE , FEATURE_ENABLE_MMS ) ;
logger ( " ) ;
WifiManager wifi = ( WifiManager ) ctx . getSystemService ( Context . WIFI_SERVICE ) ;
wifi . setWifiEnabled ( wifiEnabled ) ;
logger ( " + wifiEnabled ) ;
}
}
}
}
public static void rebootWithSU ( ) {
try {
Runtime . getRuntime ( ) . exec ( new String [ ] { " , " , " } ) ;
sleep ( <num> ) ;
Runtime . getRuntime ( ) . exec ( new String [ ] { " , " , " } ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
private static void sleep ( final int millis ) {
try {
Thread . sleep ( millis ) ;
} catch ( InterruptedException e ) {
}
}
private static String getStackTrace ( Exception ex ) {
final Writer result = new StringWriter ( ) ;
final PrintWriter printWriter = new PrintWriter ( result ) ;
ex . printStackTrace ( printWriter ) ;
return result . toString ( ) ;
}
private static void logger ( final String msg ) {
logger ( msg ) ;
if ( debugMode ) mMiscText . setText ( String . format ( " , msg , mMiscText . getText ( ) ) ) ;
}
package com . google . android . mms ;
import android . util . Log ;
public class LogTag {
public static final String TAG = " ;
public static final String TRANSACTION = " ;
public static final String APP = " ;
public static final String <unk> = " ;
private static String prettyArray ( String [ ] array ) {
if ( array . length == <num> ) {
return " ;
}
StringBuilder sb = new StringBuilder ( " ) ;
int len = array . length  <num> ;
for ( int i = <num> ; i < len ; i ++ ) {
sb . append ( array [ i ] ) ;
sb . append ( " ) ;
}
sb . append ( array [ len ] ) ;
sb . append ( " ) ;
return sb . toString ( ) ;
}
private static String logFormat ( String format , Object . . . args ) {
for ( int i = <num> ; i < args . length ; i ++ ) {
if ( args [ i ] instanceof String [ ] ) {
args [ i ] = prettyArray ( ( String [ ] ) args [ i ] ) ;
}
}
String s = String . format ( format , args ) ;
s = " + Thread . currentThread ( ) . getId ( ) + " + s ;
return s ;
}
public static void debug ( String format , Object . . . args ) {
Log . d ( TAG , logFormat ( format , args ) ) ;
}
public static void warn ( String format , Object . . . args ) {
Log . w ( TAG , logFormat ( format , args ) ) ;
}
public static void error ( String format , Object . . . args ) {
Log . e ( TAG , logFormat ( format , args ) ) ;
}
}
package com . google . android . mms . pdu ;
import java . io . UnsupportedEncodingException ;
import java . util . HashMap ;
public class CharacterSets {
public static final int ANY_CHARSET = <num> ;
public static final int US_ASCII = <num> ;
public static final int ISO_8859_1 = <num> ;
public static final int ISO_8859_2 = <num> ;
public static final int ISO_8859_3 = <num> ;
public static final int ISO_8859_4 = <num> ;
public static final int ISO_8859_5 = <num> ;
public static final int ISO_8859_6 = <num> ;
public static final int ISO_8859_7 = <num> ;
public static final int ISO_8859_8 = <num> ;
public static final int ISO_8859_9 = <num> ;
public static final int SHIFT_JIS = <num> ;
public static final int UTF_8 = <num> ;
public static final int BIG5 = <num> ;
public static final int UCS2 = <num> ;
public static final int UTF_16 = <num> ;
public static final int DEFAULT_CHARSET = UTF_8 ;
private static final int [ ] MIBENUM_NUMBERS = {
ANY_CHARSET ,
US_ASCII ,
ISO_8859_1 ,
ISO_8859_2 ,
ISO_8859_3 ,
ISO_8859_4 ,
ISO_8859_5 ,
ISO_8859_6 ,
ISO_8859_7 ,
ISO_8859_8 ,
ISO_8859_9 ,
SHIFT_JIS ,
UTF_8 ,
BIG5 ,
UCS2 ,
UTF_16 ,
} ;
public static final String MIMENAME_ANY_CHARSET = " ;
public static final String MIMENAME_US_ASCII = " ;
public static final String MIMENAME_ISO_8859_1 = " ;
public static final String MIMENAME_ISO_8859_2 = " ;
public static final String MIMENAME_ISO_8859_3 = " ;
public static final String MIMENAME_ISO_8859_4 = " ;
public static final String MIMENAME_ISO_8859_5 = " ;
public static final String MIMENAME_ISO_8859_6 = " ;
public static final String MIMENAME_ISO_8859_7 = " ;
public static final String MIMENAME_ISO_8859_8 = " ;
public static final String MIMENAME_ISO_8859_9 = " ;
public static final String MIMENAME_SHIFT_JIS = " ;
public static final String MIMENAME_UTF_8 = " ;
public static final String MIMENAME_BIG5 = " ;
public static final String MIMENAME_UCS2 = " ;
public static final String MIMENAME_UTF_16 = " ;
public static final String DEFAULT_CHARSET_NAME = MIMENAME_UTF_8 ;
private static final String [ ] MIME_NAMES = {
MIMENAME_ANY_CHARSET ,
MIMENAME_US_ASCII ,
MIMENAME_ISO_8859_1 ,
MIMENAME_ISO_8859_2 ,
MIMENAME_ISO_8859_3 ,
MIMENAME_ISO_8859_4 ,
MIMENAME_ISO_8859_5 ,
MIMENAME_ISO_8859_6 ,
MIMENAME_ISO_8859_7 ,
MIMENAME_ISO_8859_8 ,
MIMENAME_ISO_8859_9 ,
MIMENAME_SHIFT_JIS ,
MIMENAME_UTF_8 ,
MIMENAME_BIG5 ,
MIMENAME_UCS2 ,
MIMENAME_UTF_16 ,
} ;
private static final HashMap < Integer , String > MIBENUM_TO_NAME_MAP ;
private static final HashMap < String , Integer > NAME_TO_MIBENUM_MAP ;
static {
MIBENUM_TO_NAME_MAP = new HashMap < Integer , String > ( ) ;
NAME_TO_MIBENUM_MAP = new HashMap < String , Integer > ( ) ;
assert ( MIBENUM_NUMBERS . length == MIME_NAMES . length ) ;
int count = MIBENUM_NUMBERS . length  <num> ;
for ( int i = <num> ; i <= count ; i ++ ) {
MIBENUM_TO_NAME_MAP . put ( MIBENUM_NUMBERS [ i ] , MIME_NAMES [ i ] ) ;
NAME_TO_MIBENUM_MAP . put ( MIME_NAMES [ i ] , MIBENUM_NUMBERS [ i ] ) ;
}
}
private CharacterSets ( ) { }
public static String getMimeName ( int mibEnumValue )
throws UnsupportedEncodingException {
String name = MIBENUM_TO_NAME_MAP . get ( mibEnumValue ) ;
if ( name == null ) {
throw new UnsupportedEncodingException ( ) ;
}
return name ;
}
public static int <unk> ( String mimeName )
throws UnsupportedEncodingException {
if ( null == mimeName ) {
return  <num> ;
}
Integer mibEnumValue = NAME_TO_MIBENUM_MAP . get ( mimeName ) ;
if ( mibEnumValue == null ) {
throw new UnsupportedEncodingException ( ) ;
}
return mibEnumValue ;
}
package com . shellware . CarHome . media ;
import android . content . Context ;
import android . media . AudioManager ;
public class AudioFocusHelper implements AudioManager . OnAudioFocusChangeListener {
AudioManager mAM ;
MusicFocusable mFocusable ;
public AudioFocusHelper ( Context ctx , MusicFocusable focusable ) {
mAM = ( AudioManager ) ctx . getSystemService ( Context . AUDIO_SERVICE ) ;
mFocusable = focusable ;
}
public boolean requestFocus ( ) {
return AudioManager . AUDIOFOCUS_REQUEST_GRANTED ==
mAM . requestAudioFocus ( this , AudioManager . STREAM_MUSIC , AudioManager . AUDIOFOCUS_GAIN ) ;
}
public boolean abandonFocus ( ) {
return AudioManager . AUDIOFOCUS_REQUEST_GRANTED == mAM . abandonAudioFocus ( this ) ;
}
public void onAudioFocusChange ( int focusChange ) {
if ( mFocusable == null ) return ;
switch ( focusChange ) {
case AudioManager . AUDIOFOCUS_GAIN :
mFocusable . onGainedAudioFocus ( ) ;
break ;
case AudioManager . AUDIOFOCUS_LOSS :
case AudioManager . AUDIOFOCUS_LOSS_TRANSIENT :
mFocusable . onLostAudioFocus ( false ) ;
break ;
case AudioManager . AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK :
mFocusable . onLostAudioFocus ( true ) ;
break ;
default :
}
}
}
package com . shellware . CarHome . media ;
import android . content . BroadcastReceiver ;
import android . content . Context ;
import android . content . Intent ;
import android . util . Log ;
import android . view . KeyEvent ;
import android . widget . Toast ;
public class RemoteControlReceiver extends BroadcastReceiver {
@Override
public void onReceive ( Context context , Intent intent ) {
if ( intent . getAction ( ) . equals ( android . media . AudioManager . ACTION_AUDIO_BECOMING_NOISY ) ) {
Toast . makeText ( context , " , Toast . LENGTH_SHORT ) . show ( ) ;
context . startService ( new Intent ( MusicService . ACTION_PAUSE ) ) ;
} else {
if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_BUTTON ) ) {
KeyEvent keyEvent = ( KeyEvent ) intent . getExtras ( ) . get ( Intent . EXTRA_KEY_EVENT ) ;
if ( keyEvent . getAction ( ) != KeyEvent . ACTION_DOWN )
return ;
switch ( keyEvent . getKeyCode ( ) ) {
case KeyEvent . KEYCODE_HEADSETHOOK :
Toast . makeText ( context , " , Toast . LENGTH_SHORT ) . show ( ) ;
case KeyEvent . KEYCODE_MEDIA_PLAY_PAUSE :
Toast . makeText ( context , " , Toast . LENGTH_SHORT ) . show ( ) ;
break ;
case KeyEvent . KEYCODE_MEDIA_PLAY :
context . startService ( new Intent ( MusicService . ACTION_PLAY ) ) ;
break ;
case KeyEvent . KEYCODE_MEDIA_PAUSE :
context . startService ( new Intent ( MusicService . ACTION_PAUSE ) ) ;
break ;
case KeyEvent . KEYCODE_MEDIA_STOP :
context . startService ( new Intent ( MusicService . ACTION_PAUSE ) ) ;
break ;
case KeyEvent . KEYCODE_MEDIA_NEXT :
context . startService ( new Intent ( MusicService . ACTION_SKIP ) ) ;
break ;
case KeyEvent . KEYCODE_MEDIA_PREVIOUS :
context . startService ( new Intent ( MusicService . ACTION_REWIND ) ) ;
break ;
default :
Toast . makeText ( context , " + keyEvent . getKeyCode ( ) , Toast . LENGTH_SHORT ) . show ( ) ;
break ;
}
abortBroadcast ( ) ;
} else {
Log . d ( " , " ) ;
}
}
}
package com . shellware . CarHome . helpers ;
import java . util . Timer ;
import java . util . TimerTask ;
import android . content . Context ;
import android . location . Location ;
import android . location . LocationListener ;
import android . location . LocationManager ;
import android . os . Bundle ;
public class MyLocation {
Timer timer1 ;
LocationManager lm ;
LocationResult locationResult ;
boolean gps_enabled = false ;
boolean network_enabled = false ;
public boolean getLocation ( Context context , LocationResult result )
{
locationResult = result ;
if ( lm == null )
lm = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ;
try { gps_enabled = lm . isProviderEnabled ( LocationManager . GPS_PROVIDER ) ; } catch ( Exception ex ) { }
if ( ! gps_enabled && ! network_enabled )
return false ;
if ( gps_enabled )
lm . requestLocationUpdates ( LocationManager . GPS_PROVIDER , <num> , <num> , locationListenerGps ) ;
if ( network_enabled )
lm . requestLocationUpdates ( LocationManager . NETWORK_PROVIDER , <num> , <num> , locationListenerNetwork ) ;
timer1 = new Timer ( ) ;
timer1 . schedule ( new GetLastLocation ( ) , <num> ) ;
return true ;
}
LocationListener locationListenerGps = new LocationListener ( ) {
public void onLocationChanged ( Location location ) {
timer1 . cancel ( ) ;
locationResult . gotLocation ( location ) ;
lm . removeUpdates ( this ) ;
lm . removeUpdates ( locationListenerNetwork ) ;
}
public void onProviderDisabled ( String provider ) { }
public void onProviderEnabled ( String provider ) { }
public void onStatusChanged ( String provider , int status , Bundle extras ) { }
} ;
LocationListener locationListenerNetwork = new LocationListener ( ) {
public void onLocationChanged ( Location location ) {
timer1 . cancel ( ) ;
locationResult . gotLocation ( location ) ;
lm . removeUpdates ( this ) ;
lm . removeUpdates ( locationListenerGps ) ;
}
public void onProviderDisabled ( String provider ) { }
public void onProviderEnabled ( String provider ) { }
public void onStatusChanged ( String provider , int status , Bundle extras ) { }
} ;
class GetLastLocation extends TimerTask {
@Override
public void run ( ) {
lm . removeUpdates ( locationListenerGps ) ;
lm . removeUpdates ( locationListenerNetwork ) ;
Location net_loc = null , gps_loc = null ;
if ( gps_enabled )
gps_loc = lm . getLastKnownLocation ( LocationManager . GPS_PROVIDER ) ;
if ( network_enabled )
net_loc = lm . getLastKnownLocation ( LocationManager . NETWORK_PROVIDER ) ;
if ( gps_loc != null && net_loc != null ) {
if ( gps_loc . getTime ( ) > net_loc . getTime ( ) )
locationResult . gotLocation ( gps_loc ) ;
else
locationResult . gotLocation ( net_loc ) ;
return ;
}
if ( gps_loc != null ) {
locationResult . gotLocation ( gps_loc ) ;
return ;
}
if ( net_loc != null ) {
locationResult . gotLocation ( net_loc ) ;
return ;
}
locationResult . gotLocation ( null ) ;
}
}
public static abstract class LocationResult {
public abstract void gotLocation ( Location location ) ;
public abstract void setDestination ( String originator ) ;
}
}
package com . google . android . mms . pdu ;
import android . util . Config ;
import android . util . Log ;
import java . io . ByteArrayOutputStream ;
import java . io . IOException ;
import java . io . UnsupportedEncodingException ;
import java . util . ArrayList ;
public class EncodedStringValue implements Cloneable {
private static final String TAG = " ;
private static final boolean DEBUG = false ;
private static final boolean LOCAL_LOGV = DEBUG ? Config . LOGD : Config . LOGV ;
private int mCharacterSet ;
private byte [ ] mData ;
public EncodedStringValue ( int charset , byte [ ] data ) {
if ( null == data ) {
throw new NullPointerException ( " ) ;
}
mCharacterSet = charset ;
mData = new byte [ data . length ] ;
System . arraycopy ( data , <num> , mData , <num> , data . length ) ;
}
public EncodedStringValue ( byte [ ] data ) {
this ( CharacterSets . DEFAULT_CHARSET , data ) ;
}
public EncodedStringValue ( String data ) {
try {
mData = data . getBytes ( CharacterSets . DEFAULT_CHARSET_NAME ) ;
mCharacterSet = CharacterSets . DEFAULT_CHARSET ;
} catch ( UnsupportedEncodingException e ) {
Log . e ( TAG , " , e ) ;
}
}
public int getCharacterSet ( ) {
return mCharacterSet ;
}
public void <unk> ( int charset ) {
mCharacterSet = charset ;
}
public byte [ ] getTextString ( ) {
byte [ ] byteArray = new byte [ mData . length ] ;
System . arraycopy ( mData , <num> , byteArray , <num> , mData . length ) ;
return byteArray ;
}
public void setTextString ( byte [ ] textString ) {
if ( null == textString ) {
throw new NullPointerException ( " ) ;
}
mData = new byte [ textString . length ] ;
System . arraycopy ( textString , <num> , mData , <num> , textString . length ) ;
}
public String getString ( ) {
if ( CharacterSets . ANY_CHARSET == mCharacterSet ) {
return new String ( mData ) ;
} else {
try {
String name = CharacterSets . getMimeName ( mCharacterSet ) ;
return new String ( mData , name ) ;
} catch ( UnsupportedEncodingException e ) {
if ( LOCAL_LOGV ) {
Log . v ( TAG , e . getMessage ( ) , e ) ;
}
try {
return new String ( mData , CharacterSets . MIMENAME_ISO_8859_1 ) ;
} catch ( UnsupportedEncodingException _ ) {
return new String ( mData ) ;
}
}
}
}
public void appendTextString ( byte [ ] textString ) {
if ( null == textString ) {
throw new NullPointerException ( " ) ;
}
if ( null == mData ) {
mData = new byte [ textString . length ] ;
System . arraycopy ( textString , <num> , mData , <num> , textString . length ) ;
} else {
ByteArrayOutputStream newTextString = new ByteArrayOutputStream ( ) ;
try {
newTextString . write ( mData ) ;
newTextString . write ( textString ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
throw new NullPointerException (
" ) ;
}
mData = newTextString . toByteArray ( ) ;
}
}
@Override
public Object clone ( ) throws CloneNotSupportedException {
super . clone ( ) ;
int len = mData . length ;
byte [ ] dstBytes = new byte [ len ] ;
System . arraycopy ( mData , <num> , dstBytes , <num> , len ) ;
try {
return new EncodedStringValue ( mCharacterSet , dstBytes ) ;
} catch ( Exception e ) {
Log . e ( TAG , " + this ) ;
e . printStackTrace ( ) ;
throw new CloneNotSupportedException ( e . getMessage ( ) ) ;
}
}
public EncodedStringValue [ ] split ( String pattern ) {
String [ ] temp = getString ( ) . split ( pattern ) ;
EncodedStringValue [ ] ret = new EncodedStringValue [ temp . length ] ;
for ( int i = <num> ; i < ret . length ; ++ i ) {
try {
ret [ i ] = new EncodedStringValue ( mCharacterSet ,
temp [ i ] . getBytes ( ) ) ;
} catch ( NullPointerException _ ) {
return null ;
}
}
return ret ;
}
public static EncodedStringValue [ ] extract ( String src ) {
String [ ] values = src . split ( " ) ;
ArrayList < EncodedStringValue > list = new ArrayList < EncodedStringValue > ( ) ;
for ( int i = <num> ; i < values . length ; i ++ ) {
if ( values [ i ] . length ( ) > <num> ) {
list . add ( new EncodedStringValue ( values [ i ] ) ) ;
}
}
int len = list . size ( ) ;
if ( len > <num> ) {
return list . toArray ( new EncodedStringValue [ len ] ) ;
} else {
return null ;
}
}
public static String concat ( EncodedStringValue [ ] addr ) {
StringBuilder sb = new StringBuilder ( ) ;
int maxIndex = addr . length  <num> ;
for ( int i = <num> ; i <= maxIndex ; i ++ ) {
sb . append ( addr [ i ] . getString ( ) ) ;
if ( i < maxIndex ) {
sb . append ( " ) ;
}
}
return sb . toString ( ) ;
}
public static EncodedStringValue copy ( EncodedStringValue value ) {
if ( value == null ) {
return null ;
}
return new EncodedStringValue ( value . mCharacterSet , value . mData ) ;
}
package com . google . android . mms . transaction ;
import org . apache . http . entity . ByteArrayEntity ;
import android . content . Context ;
import android . content . Intent ;
import java . io . IOException ;
import java . io . OutputStream ;
public class ProgressCallbackEntity extends ByteArrayEntity {
private static final int DEFAULT_PIECE_SIZE = <num> ;
public static final String PROGRESS_STATUS_ACTION = " ;
public static final int PROGRESS_START =  <num> ;
public static final int PROGRESS_ABORT =  <num> ;
public static final int PROGRESS_COMPLETE = <num> ;
private final Context mContext ;
private final byte [ ] mContent ;
private final long mToken ;
public ProgressCallbackEntity ( Context context , long token , byte [ ] b ) {
super ( b ) ;
mContext = context ;
mContent = b ;
mToken = token ;
}
@Override
public void writeTo ( final OutputStream outstream ) throws IOException {
if ( outstream == null ) {
throw new IllegalArgumentException ( " ) ;
}
boolean completed = false ;
try {
broadcastProgressIfNeeded ( PROGRESS_START ) ;
int pos = <num> , totalLen = mContent . length ;
while ( pos < totalLen ) {
int len = totalLen  pos ;
if ( len > DEFAULT_PIECE_SIZE ) {
len = DEFAULT_PIECE_SIZE ;
}
outstream . write ( mContent , pos , len ) ;
outstream . flush ( ) ;
pos += len ;
broadcastProgressIfNeeded ( <num> * pos / totalLen ) ;
}
broadcastProgressIfNeeded ( PROGRESS_COMPLETE ) ;
completed = true ;
} finally {
if ( ! completed ) {
broadcastProgressIfNeeded ( PROGRESS_ABORT ) ;
}
}
}
private void broadcastProgressIfNeeded ( int progress ) {
if ( mToken > <num> ) {
Intent intent = new Intent ( PROGRESS_STATUS_ACTION ) ;
intent . putExtra ( " , progress ) ;
intent . putExtra ( " , mToken ) ;
mContext . sendBroadcast ( intent ) ;
}
}
package com . shellware . CarHome . ui ;
import com . shellware . CarHome . CarHomeActivity ;
import com . shellware . CarHome . R ;
import com . shellware . CarHome . R . drawable ;
import com . shellware . CarHome . R . styleable ;
import android . content . ComponentName ;
import android . content . Context ;
import android . content . Intent ;
import android . content . res . TypedArray ;
import android . net . Uri ;
import android . os . Handler ;
import android . provider . Settings ;
import android . util . AttributeSet ;
import android . view . View ;
import android . view . ViewGroup ;
import android . view . animation . AlphaAnimation ;
import android . view . animation . Animation ;
import android . view . animation . Animation . AnimationListener ;
import android . widget . AdapterView ;
import android . widget . BaseAdapter ;
import android . widget . Gallery ;
import android . widget . ImageView ;
public class ProgramsGallery extends Gallery {
private final static String TAG = " ;
private Context context ;
private Handler hideGalleryHandler = new Handler ( ) ;
public ProgramsGallery ( Context context , AttributeSet attrs , int defStyle ) {
super ( context , attrs , defStyle ) ;
this . context = context ;
setAdapter ( new ImageAdapter ( context ) ) ;
setSelection ( <num> , false ) ;
bringToFront ( ) ;
}
public ProgramsGallery ( Context context , AttributeSet attrs ) {
super ( context , attrs ) ;
this . context = context ;
setAdapter ( new ImageAdapter ( context ) ) ;
setSelection ( <num> , false ) ;
bringToFront ( ) ;
}
public ProgramsGallery ( Context context ) {
super ( context ) ;
this . context = context ;
setAdapter ( new ImageAdapter ( context ) ) ;
setSelection ( <num> , false ) ;
bringToFront ( ) ;
}
public void showGallery ( ) {
hideGalleryHandler . removeCallbacks ( hideGalleryInTime ) ;
setSelection ( <num> , false ) ;
setVisibility ( View . VISIBLE ) ;
bringToFront ( ) ;
setOnItemClickListener ( clicker ) ;
clearAnimation ( ) ;
AlphaAnimation alpha = new AlphaAnimation ( <num> , <num> ) ;
alpha . setFillAfter ( true ) ;
alpha . setDuration ( <num> ) ;
setAnimation ( alpha ) ;
hideGalleryHandler . postDelayed ( hideGalleryInTime , <num> ) ;
}
public void destroyGallery ( ) {
hideGalleryHandler . removeCallbacks ( hideGalleryInTime ) ;
}
public void hideGallery ( ) {
setOnItemClickListener ( null ) ;
clearAnimation ( ) ;
setAlpha ( <num> ) ;
AlphaAnimation alpha = new AlphaAnimation ( <num> , <num> ) ;
alpha . setDuration ( <num> ) ;
alpha . setFillAfter ( true ) ;
alpha . setAnimationListener ( new AnimationListener ( ) {
public void onAnimationEnd ( Animation animation ) {
setVisibility ( View . INVISIBLE ) ;
}
public void onAnimationRepeat ( Animation animation ) {
}
public void onAnimationStart ( Animation animation ) {
}
} ) ;
setAnimation ( alpha ) ;
}
private Runnable hideGalleryInTime = new Runnable ( ) {
public void run ( ) {
if ( getVisibility ( ) == View . VISIBLE ) {
setOnItemClickListener ( null ) ;
clearAnimation ( ) ;
setAlpha ( <num> ) ;
AlphaAnimation alpha = new AlphaAnimation ( <num> , <num> ) ;
alpha . setDuration ( <num> ) ;
alpha . setFillAfter ( true ) ;
alpha . setAnimationListener ( new AnimationListener ( ) {
public void onAnimationEnd ( Animation animation ) {
setVisibility ( View . INVISIBLE ) ;
}
public void onAnimationRepeat ( Animation animation ) {
}
public void onAnimationStart ( Animation animation ) {
}
} ) ;
setAnimation ( alpha ) ;
}
}
} ;
private OnItemClickListener clicker = new OnItemClickListener ( ) {
public void onItemClick ( final AdapterView < ? > parent , View v , int position , long id ) {
clearAnimation ( ) ;
AlphaAnimation alpha = new AlphaAnimation ( <num> , <num> ) ;
alpha . setDuration ( <num> ) ;
alpha . setFillAfter ( true ) ;
alpha . setAnimationListener ( new AnimationListener ( ) {
public void onAnimationEnd ( Animation animation ) {
parent . setVisibility ( View . INVISIBLE ) ;
parent . setOnClickListener ( null ) ;
}
public void onAnimationRepeat ( Animation animation ) {
}
public void onAnimationStart ( Animation animation ) {
}
} ) ;
String url ;
Intent i ;
switch ( position ) {
case <num> :
CarHomeActivity . toggleCamera ( ) ;
break ;
case <num> :
Intent email = context . getPackageManager ( ) . getLaunchIntentForPackage ( " ) ;
context . startActivity ( email ) ;
break ;
case <num> :
url = " ;
i = new Intent ( Intent . ACTION_VIEW , Uri . parse ( url ) ) ;
context . startActivity ( i ) ;
break ;
case <num> :
i = new Intent ( Intent . ACTION_MAIN ) ;
i . addCategory ( Intent . CATEGORY_LAUNCHER ) ;
i . setClassName ( " , " ) ;
context . startActivity ( i ) ;
break ;
case <num> :
i = new Intent ( Intent . ACTION_MAIN , null ) ;
i . addCategory ( Intent . CATEGORY_LAUNCHER ) ;
final ComponentName cn = new ComponentName (
" ,
" ) ;
i . setComponent ( cn ) ;
i . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ;
context . startActivity ( i ) ;
break ;
case <num> :
context . startActivity ( new Intent ( Settings . ACTION_SETTINGS ) ) ;
break ;
default :
break ;
}
}
} ;
public class ImageAdapter extends BaseAdapter {
int mGalleryItemBackground ;
private Context mContext ;
private Integer [ ] mImageIds = {
R . drawable . camera ,
R . drawable . email ,
R . drawable . navigate ,
R . drawable . sms ,
R . drawable . <unk> ,
R . drawable . configuration
} ;
public ImageAdapter ( Context c ) {
mContext = c ;
TypedArray attr = mContext . obtainStyledAttributes ( R . styleable . HelloGallery ) ;
mGalleryItemBackground = attr . getResourceId (
R . styleable . HelloGallery_android_galleryItemBackground , <num> ) ;
attr . recycle ( ) ;
}
public int getCount ( ) {
return mImageIds . length ;
}
public Object getItem ( int position ) {
return position ;
}
public long getItemId ( int position ) {
return position ;
}
public View getView ( int position , View convertView , ViewGroup parent ) {
ImageView imageView = new ImageView ( mContext ) ;
imageView . setImageResource ( mImageIds [ position ] ) ;
imageView . setLayoutParams ( new Gallery . LayoutParams ( <num> , <num> ) ) ;
imageView . setScaleType ( ImageView . ScaleType . FIT_XY ) ;
imageView . setBackgroundResource ( mGalleryItemBackground ) ;
return imageView ;
}
}
}
package com . shellware . CarHome . media ;
import android . os . AsyncTask ;
public class PrepareMusicRetrieverTask extends AsyncTask < Void , Void , Void > {
MusicRetriever mRetriever ;
MusicRetrieverPreparedListener mListener ;
public PrepareMusicRetrieverTask ( MusicRetriever retriever ,
MusicRetrieverPreparedListener listener ) {
mRetriever = retriever ;
mListener = listener ;
}
@Override
protected Void doInBackground ( Void . . . arg0 ) {
mRetriever . prepare ( ) ;
return null ;
}
@Override
protected void onPostExecute ( Void result ) {
mListener . onMusicRetrieverPrepared ( ) ;
}
public interface MusicRetrieverPreparedListener {
public void onMusicRetrieverPrepared ( ) ;
}
}
package com . shellware . CarHome . media ;
import java . io . FileNotFoundException ;
import java . io . InputStream ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Random ;
import android . content . ContentResolver ;
import android . content . ContentUris ;
import android . database . Cursor ;
import android . graphics . Bitmap ;
import android . graphics . BitmapFactory ;
import android . net . Uri ;
import android . util . Log ;
public class MusicRetriever {
final String TAG = " ;
ContentResolver mContentResolver ;
private static final Uri sArtworkUri = Uri . parse ( " ) ;
List < Item > mItems = new ArrayList < Item > ( ) ;
Random mRandom = new Random ( ) ;
public MusicRetriever ( ContentResolver cr ) {
mContentResolver = cr ;
}
public void prepare ( ) {
Uri uri = android . provider . MediaStore . Audio . Media . EXTERNAL_CONTENT_URI ;
Log . i ( TAG , " ) ;
Log . i ( TAG , " + uri . toString ( ) ) ;
Cursor cur = mContentResolver . query ( uri , null , null , null , null ) ;
Log . i ( TAG , " + ( cur == null ? " : " ) ) ;
if ( cur == null ) {
Log . e ( TAG , " ) ;
return ;
}
if ( ! cur . moveToFirst ( ) ) {
Log . e ( TAG , " ) ;
return ;
}
Log . i ( TAG , " ) ;
int titleColumn = cur . getColumnIndex ( android . provider . MediaStore . Audio . Media . TITLE ) ;
int artistColumn = cur . getColumnIndex ( android . provider . MediaStore . Audio . Media . ARTIST ) ;
int albumIdColumn = cur . getColumnIndex ( android . provider . MediaStore . Audio . Media . <unk> ) ;
int idColumn = cur . getColumnIndex ( android . provider . MediaStore . Audio . Media . _ID ) ;
int durationColumn = cur . getColumnIndex ( android . provider . MediaStore . Audio . Media . DURATION ) ;
Log . i ( TAG , " + String . valueOf ( titleColumn ) ) ;
Log . i ( TAG , " + String . valueOf ( titleColumn ) ) ;
Log . i ( TAG , " + String . valueOf ( artistColumn ) ) ;
long lastAlbumId = <num> ;
Bitmap artwork = null ;
int artworkSize = <num> ;
do {
Long albumId = cur . getLong ( albumIdColumn ) ;
if ( albumId != lastAlbumId ) {
Uri artUri = ContentUris . withAppendedId ( sArtworkUri , albumId ) ;
ContentResolver res = this . getContentResolver ( ) ;
InputStream in = null ;
artworkSize = <num> ;
try {
in = res . openInputStream ( artUri ) ;
artwork = BitmapFactory . decodeStream ( in ) ;
artworkSize = artwork . getByteCount ( ) ;
lastAlbumId = albumId ;
} catch ( Exception e ) {
artworkSize = <num> ;
lastAlbumId = <num> ;
}
}
Log . i ( TAG , " + cur . getString ( idColumn ) + " + cur . getString ( albumIdColumn ) + " + artworkSize ) ;
mItems . add ( new Item ( cur . getLong ( idColumn ) ,
cur . getString ( titleColumn ) ,
cur . getString ( artistColumn ) ,
cur . getInt ( durationColumn ) ,
artworkSize == <num> ? null : artwork ) ) ;
} while ( cur . moveToNext ( ) ) ;
Log . i ( TAG , " ) ;
}
public ContentResolver getContentResolver ( ) {
return mContentResolver ;
}
public Item getRandomItem ( ) {
if ( mItems . size ( ) <= <num> ) return null ;
return mItems . get ( mRandom . nextInt ( mItems . size ( ) ) ) ;
}
public class Item {
private long id ;
private String title ;
private String artist ;
private int duration ;
private Bitmap albumArt ;
public Item ( long id , String title , String artist , int duration , Bitmap albumArt ) {
this . id = id ;
this . title = title ;
this . artist = artist ;
this . duration = duration ;
this . albumArt = albumArt ;
}
public long getId ( ) { return id ; }
public String getTitle ( ) { return title ; }
public String getArtist ( ) { return artist ; }
public int getDuration ( ) { return duration ; }
public Bitmap getAlbumArt ( ) { return albumArt ; }
public Uri getURI ( ) {
return ContentUris . withAppendedId (
android . provider . MediaStore . Audio . Media . EXTERNAL_CONTENT_URI , id ) ;
}
}
}
package com . shellware . CarHome . ui ;
import android . content . Context ;
import android . util . AttributeSet ;
import android . view . animation . Animation ;
import android . view . animation . LinearInterpolator ;
import android . view . animation . RotateAnimation ;
import android . widget . ImageView ;
public class GaugeNeedle extends ImageView {
private final int NOT_SET_YET = Integer . MAX_VALUE ;
private int offsetCenterInDegrees = NOT_SET_YET ;
private float lastValue ;
private int minValue = <num> ;
private int maxValue = <num> ;
private int minDegrees =  <num> ;
private int maxDegrees = <num> ;
private float pivotPoint = <num> ;
public GaugeNeedle ( Context context ) {
super ( context ) ;
}
public GaugeNeedle ( Context context , AttributeSet attrs , int defStyle ) {
super ( context , attrs , defStyle ) ;
}
public GaugeNeedle ( Context context , AttributeSet attrs ) {
super ( context , attrs ) ;
}
public void setValue ( final float value ) {
if ( offsetCenterInDegrees == NOT_SET_YET ) {
offsetCenterInDegrees = maxDegrees  ( maxDegrees  minDegrees ) / <num> ;
}
final float scale = ( float ) ( maxDegrees  minDegrees ) / ( maxValue  minValue ) ;
final float newValue = ( value  minValue ) * scale  ( ( maxDegrees  minDegrees ) / <num> ) + offsetCenterInDegrees ;
if ( newValue > maxDegrees + <num> ) return ;
if ( newValue < minDegrees  <num> ) return ;
RotateAnimation rotateAnimation = new RotateAnimation ( lastValue , newValue ,
Animation . RELATIVE_TO_SELF , <num> ,
Animation . RELATIVE_TO_SELF , pivotPoint ) ;
rotateAnimation . setInterpolator ( new LinearInterpolator ( ) ) ;
rotateAnimation . setDuration ( <num> ) ;
rotateAnimation . setFillAfter ( true ) ;
startAnimation ( rotateAnimation ) ;
lastValue = newValue ;
}
public int getMinValue ( ) {
return minValue ;
}
public void setMinValue ( int minValue ) {
this . minValue = minValue ;
}
public int getMaxValue ( ) {
return maxValue ;
}
public void setMaxValue ( int maxValue ) {
this . maxValue = maxValue ;
}
public int <unk> ( ) {
return minDegrees ;
}
public void setMinDegrees ( int minDegrees ) {
this . minDegrees = minDegrees ;
}
public int <unk> ( ) {
return maxDegrees ;
}
public void setMaxDegrees ( int maxDegrees ) {
this . maxDegrees = maxDegrees ;
}
public float <unk> ( ) {
return pivotPoint ;
}
public void setPivotPoint ( float pivotPoint ) {
this . pivotPoint = pivotPoint ;
}
}
package com . shellware . CarHome . media ;
public interface MusicFocusable {
public void onGainedAudioFocus ( ) ;
public void onLostAudioFocus ( boolean canDuck ) ;
}
public class <unk>
{
public void <unk> ( ) {
Object [ ] list = new Object [ <num> ] ;
for ( Object obj : list ) {
}
}
}
package fr . inria . wimmics . metadata . crawler . test ;
import static org . junit . Assert . * ;
import java . io . IOException ;
import java . net . URISyntaxException ;
import org . deri . any23 . extractor . ExtractionException ;
import org . junit . After ;
import org . junit . Before ;
import org . junit . Test ;
import org . openrdf . repository . Repository ;
import org . openrdf . repository . RepositoryException ;
import fr . inria . wimmics . metadata . crawler . Any23Crawler2Sesame ;
import fr . inria . wimmics . metadata . util . sesame . SesameUtil ;
public class <unk> {
Any23Crawler2Sesame crawler ;
Repository repo ;
@Before
public void setUp ( ) throws Exception {
repo = SesameUtil . getMemoryBasedRepository ( ) ;
crawler = new Any23Crawler2Sesame ( ) ;
}
@After
public void tearDown ( ) throws Exception {
}
@Test
public final void <unk> ( ) {
try {
crawler . crawlURL ( " ) ;
} catch ( Exception e ) {
fail ( " ) ;
e . printStackTrace ( ) ;
}
}
@Test
public final void <unk> ( ) {
String url = " ;
try {
crawler . crawlURL ( url , repo ) ;
String queryString = " +
" ;
SesameUtil . queryWithSPARQL ( repo , queryString ) ;
} catch ( Exception e ) {
fail ( " ) ;
e . printStackTrace ( ) ;
}
}
@Test
public final void <unk> ( ) {
String url = " ;
try {
crawler . crawlURL ( " , url , repo ) ;
String queryString = " +
" + url + " ;
SesameUtil . queryWithSPARQL ( repo , queryString ) ;
} catch ( Exception e ) {
fail ( " ) ;
e . printStackTrace ( ) ;
}
}
}
package fr . inria . wimmics . metadata . crawler . test ;
import java . io . IOException ;
import java . net . URISyntaxException ;
import java . util . List ;
import org . deri . any23 . extractor . ExtractionException ;
import org . junit . After ;
import org . junit . Before ;
import org . junit . Test ;
import org . openrdf . model . Statement ;
import fr . inria . wimmics . metadata . crawler . RDFaCrawler ;
public class <unk> {
RDFaCrawler crawler ;
@Before
public void setUp ( ) throws Exception {
crawler = new RDFaCrawler ( ) ;
}
@After
public void tearDown ( ) throws Exception {
}
@Test
public final void <unk> ( ) throws IOException , URISyntaxException , ExtractionException {
List < Statement > statements = crawler . crawlFoafRDFaList ( " ) ;
for ( Statement st : statements ) {
System . out . println ( st . getSubject ( ) . toString ( ) + " + st . <unk> ( ) . toString ( ) + " + st . getObject ( ) . toString ( ) ) ;
}
}
}
import java . io . ByteArrayOutputStream ;
import java . io . IOException ;
import java . net . URISyntaxException ;
import java . util . List ;
import org . deri . any23 . Any23 ;
import org . deri . any23 . extractor . ExtractionException ;
import org . deri . any23 . http . HTTPClient ;
import org . deri . any23 . source . DocumentSource ;
import org . deri . any23 . source . HTTPDocumentSource ;
import org . deri . any23 . writer . NTriplesWriter ;
import org . deri . any23 . writer . TripleHandler ;
import org . openrdf . OpenRDFException ;
import org . openrdf . model . URI ;
import org . openrdf . model . ValueFactory ;
import org . openrdf . model . vocabulary . RDF ;
import org . openrdf . model . vocabulary . RDFS ;
import org . openrdf . query . BindingSet ;
import org . openrdf . query . MalformedQueryException ;
import org . openrdf . query . QueryEvaluationException ;
import org . openrdf . query . QueryLanguage ;
import org . openrdf . query . TupleQuery ;
import org . openrdf . query . TupleQueryResult ;
import org . openrdf . repository . Repository ;
import org . openrdf . repository . RepositoryConnection ;
import org . openrdf . repository . RepositoryException ;
import org . openrdf . repository . sail . SailRepository ;
import org . openrdf . sail . Sail ;
import org . openrdf . sail . inferencer . fc . ForwardChainingRDFSInferencer ;
import org . openrdf . sail . memory . MemoryStore ;
public class HelloRDFWorld {
private final static String NAMESPACE = " ;
private final static String NAMESPACE_ONTOLOGY = " ;
public void <unk> ( ) throws IOException , URISyntaxException , ExtractionException {
Any23 runner = new Any23 ( ) ;
runner . setHTTPUserAgent ( " ) ;
HTTPClient httpClient = runner . getHTTPClient ( ) ;
DocumentSource source = new HTTPDocumentSource ( httpClient , " ) ;
ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ;
TripleHandler handler = new NTriplesWriter ( out ) ;
runner . extract ( source , handler ) ;
String n3 = out . toString ( " ) ;
System . out . println ( n3 ) ;
}
public void <unk> ( ) {
}
public void sesameTest ( ) throws OpenRDFException {
Repository repo = getMemoryBasedRepository ( ) ;
populateHardCodedTriples ( repo ) ;
populateHardCodedTriples ( repo ) ;
queryhWithSPARQL ( repo ) ;
}
private void populateHardCodedTriples ( Repository repo )
throws RepositoryException {
ValueFactory factory = repo . getValueFactory ( ) ;
URI eric = factory . createURI ( NAMESPACE + " ) ;
URI hideki = factory . createURI ( NAMESPACE + " ) ;
URI hovy = factory . createURI ( NAMESPACE + " ) ;
URI bob = factory . createURI ( NAMESPACE + " ) ;
URI cmu = factory . createURI ( NAMESPACE + " ) ;
URI usc = factory . createURI ( NAMESPACE + " ) ;
URI inria = factory . createURI ( NAMESPACE + " ) ;
URI <unk> = factory . createURI ( NAMESPACE
+ " ) ;
URI isa = RDFS . SUBCLASSOF ;
URI worksFor = factory . createURI ( NAMESPACE + " ) ;
URI coauthoredWith = factory . createURI ( NAMESPACE + " ) ;
URI instanceOf = RDF . TYPE ;
URI person = factory . createURI ( NAMESPACE_ONTOLOGY + " ) ;
URI researchOrg = factory . createURI ( NAMESPACE_ONTOLOGY + " ) ;
URI university = factory . createURI ( NAMESPACE_ONTOLOGY + " ) ;
RepositoryConnection con = repo . getConnection ( ) ;
try {
con . setAutoCommit ( false ) ;
con . add ( person , instanceOf , RDFS . CLASS ) ;
con . add ( researchOrg , instanceOf , RDFS . CLASS ) ;
con . add ( university , instanceOf , RDFS . CLASS ) ;
con . add ( university , RDFS . SUBCLASSOF , researchOrg ) ;
con . add ( eric , instanceOf , person ) ;
con . add ( hideki , instanceOf , person ) ;
con . add ( hovy , instanceOf , person ) ;
con . add ( bob , instanceOf , person ) ;
con . add ( cmu , instanceOf , university ) ;
con . add ( usc , instanceOf , university ) ;
con . add ( inria , instanceOf , university ) ;
con . add ( eric , worksFor , cmu ) ;
con . add ( hideki , worksFor , cmu ) ;
con . add ( hovy , worksFor , usc ) ;
con . add ( bob , worksFor , inria ) ;
con . add ( eric , coauthoredWith , hovy ) ;
con . add ( hovy , coauthoredWith , eric ) ;
con . add ( eric , coauthoredWith , hideki ) ;
con . add ( hideki , coauthoredWith , eric ) ;
con . commit ( ) ;
} catch ( RepositoryException e ) {
con . rollback ( ) ;
} finally {
con . close ( ) ;
}
}
private void <unk> ( Repository repo ) throws RepositoryException ,
OpenRDFException {
RepositoryConnection con = repo . getConnection ( ) ;
String queryString = null ;
String postfix = " + NAMESPACE + " ;
try {
System . out . println ( " ) ;
queryString = "
+ postfix ;
printSearchResult ( con , queryString ) ;
System . out
. println ( " ) ;
queryString = "
+ postfix ;
printSearchResult ( con , queryString ) ;
System . out . println ( " ) ;
queryString = "
+ postfix ;
printSearchResult ( con , queryString ) ;
System . out
. println ( " ) ;
queryString = "
+ postfix ;
printSearchResult ( con , queryString ) ;
System . out . println ( " ) ;
queryString = "
+ postfix ;
printSearchResult ( con , queryString ) ;
System . out
. println ( " ) ;
queryString = "
+ postfix ;
printSearchResult ( con , queryString ) ;
System . out . println ( " ) ;
queryString = "
+ postfix ;
printSearchResult ( con , queryString ) ;
System . out
. println ( " ) ;
queryString = "
+ postfix ;
printSearchResult ( con , queryString ) ;
} finally {
con . close ( ) ;
}
}
private void printSearchResult ( RepositoryConnection con , String queryString )
throws RepositoryException , OpenRDFException {
TupleQuery tupleQuery = con . prepareTupleQuery ( QueryLanguage . <unk> ,
queryString ) ;
TupleQueryResult result = tupleQuery . evaluate ( ) ;
try {
int i = <num> ;
while ( result . hasNext ( ) ) {
System . out . println ( " + ( ++ i ) + " ) ;
BindingSet bindingSet = result . next ( ) ;
List < String > names = result . getBindingNames ( ) ;
for ( String name : names ) {
System . out . println ( name + " + bindingSet . getValue ( name ) ) ;
}
System . out . println ( ) ;
}
} finally {
result . close ( ) ;
}
}
private void printSPARQLQueryhResult ( RepositoryConnection con , String quString ) throws RepositoryException , MalformedQueryException , QueryEvaluationException {
TupleQuery tupleQuery = con . prepareTupleQuery ( QueryLanguage . SPARQL , quString ) ;
TupleQueryResult result = tupleQuery . evaluate ( ) ;
try {
int i = <num> ;
while ( result . hasNext ( ) ) {
System . out . println ( " + ( ++ i ) + " ) ;
BindingSet bindingSet = result . next ( ) ;
List < String > names = result . getBindingNames ( ) ;
for ( String name : names ) {
System . out . println ( name + " + bindingSet . getValue ( name ) ) ;
}
System . out . println ( ) ;
}
} finally {
result . close ( ) ;
}
}
private void queryhWithSPARQL ( Repository repo ) throws RepositoryException , MalformedQueryException , QueryEvaluationException {
RepositoryConnection con = repo . getConnection ( ) ;
String queryString = null ;
String prefix = " + NAMESPACE + " +
" + NAMESPACE_ONTOLOGY + " ;
try {
System . out . println ( " ) ;
queryString = prefix + " +
" ;
printSPARQLQueryhResult ( con , queryString ) ;
System . out . println ( " ) ;
queryString = prefix + " +
" ;
printSPARQLQueryhResult ( con , queryString ) ;
System . out . println ( " ) ;
queryString = prefix + " +
" +
" ;
printSPARQLQueryhResult ( con , queryString ) ;
} finally {
con . close ( ) ;
}
}
private Repository getMemoryBasedRepository ( ) throws RepositoryException {
MemoryStore memory = new MemoryStore ( ) ;
Sail sail = new ForwardChainingRDFSInferencer ( memory ) ;
Repository rep = new SailRepository ( sail ) ;
rep . initialize ( ) ;
return rep ;
}
public static void main ( String [ ] args ) throws IOException , URISyntaxException , ExtractionException , OpenRDFException {
HelloRDFWorld hwTest = new HelloRDFWorld ( ) ;
hwTest . sesameTest ( ) ;
}
}
package fr . inria . wimmics . metadata . crawler ;
import java . io . IOException ;
import java . net . URISyntaxException ;
import java . util . ArrayList ;
import java . util . List ;
import org . deri . any23 . Any23 ;
import org . deri . any23 . extractor . ExtractionException ;
import org . deri . any23 . filter . IgnoreAccidentalRDFa ;
import org . deri . any23 . http . HTTPClient ;
import org . deri . any23 . source . DocumentSource ;
import org . deri . any23 . source . HTTPDocumentSource ;
import org . deri . any23 . writer . TripleHandler ;
import org . openrdf . model . Statement ;
import fr . inria . wimmics . any23 . writer . StatementWriter ;
public class RDFaCrawler {
final public static String USER_AGENT = " ;
public List < Statement > crawlFoafRDFaList ( String url ) throws IOException , URISyntaxException , ExtractionException {
Any23 runner = new Any23 ( " ) ;
List < Statement > statements = new ArrayList < Statement > ( ) ;
TripleHandler trpileHandler = new StatementWriter ( statements ) ;
this . extract ( runner , url , trpileHandler ) ;
return statements ;
}
private void extract ( Any23 runner , String url , TripleHandler handler ) throws IOException , URISyntaxException , ExtractionException {
runner . setHTTPUserAgent ( USER_AGENT ) ;
HTTPClient httpClient = runner . getHTTPClient ( ) ;
DocumentSource source = new HTTPDocumentSource ( httpClient , url ) ;
handler = new IgnoreAccidentalRDFa ( handler , true ) ;
runner . extract ( source , handler ) ;
}
}
import org . deri . any23 . extractor . ExtractionContext ;
import org . deri . any23 . writer . TripleHandler ;
import org . deri . any23 . writer . TripleHandlerException ;
import org . openrdf . model . Literal ;
import org . openrdf . model . Resource ;
import org . openrdf . model . URI ;
import org . openrdf . model . Value ;
public class <unk> implements TripleHandler {
@Override
public void startDocument ( URI documentURI ) throws TripleHandlerException {
}
@Override
public void openContext ( ExtractionContext context )
throws TripleHandlerException {
}
@Override
public void receiveTriple ( Resource s , URI p , Value o , URI g ,
ExtractionContext context ) throws TripleHandlerException {
}
@Override
public void receiveNamespace ( String prefix , String uri ,
ExtractionContext context ) throws TripleHandlerException {
}
@Override
public void closeContext ( ExtractionContext context )
throws TripleHandlerException {
}
@Override
public void endDocument ( URI documentURI ) throws TripleHandlerException {
}
@Override
public void setContentLength ( long contentLength ) {
}
@Override
public void close ( ) throws TripleHandlerException {
}
}
package fr . inria . wimmics . metadata . util . schema . org ;
import org . deri . any23 . extractor . ExtractionContext ;
import org . deri . any23 . writer . RepositoryWriter ;
import org . deri . any23 . writer . TripleHandlerException ;
import org . openrdf . model . Resource ;
import org . openrdf . model . URI ;
import org . openrdf . model . Value ;
import org . openrdf . model . ValueFactory ;
import org . openrdf . repository . RepositoryConnection ;
public class SchemaOrgFix extends RepositoryWriter {
RepositoryConnection repoConn ;
public SchemaOrgFix ( RepositoryConnection conn ) {
super ( conn ) ;
repoConn = conn ;
}
public SchemaOrgFix ( RepositoryConnection conn , Resource overrideContext ) {
super ( conn , overrideContext ) ;
repoConn = conn ;
}
@Override
public void receiveTriple ( Resource s , URI p , Value o , URI g ,
ExtractionContext context ) throws TripleHandlerException {
if ( p . stringValue ( ) . contains ( " ) ) {
String pUri = p . getLocalName ( ) ;
ValueFactory valueFactory = repoConn . getRepository ( ) . getValueFactory ( ) ;
URI newP = valueFactory . createURI ( " + pUri ) ;
p = newP ;
}
super . receiveTriple ( s , p , o , g , context ) ;
}
}
package fr . inria . wimmics . any23 . writer ;
import java . util . List ;
import org . deri . any23 . extractor . ExtractionContext ;
import org . deri . any23 . writer . TripleHandler ;
import org . deri . any23 . writer . TripleHandlerException ;
import org . openrdf . model . Resource ;
import org . openrdf . model . Statement ;
import org . openrdf . model . URI ;
import org . openrdf . model . Value ;
import org . openrdf . model . ValueFactory ;
import org . openrdf . model . impl . ValueFactoryImpl ;
public class StatementWriter implements TripleHandler {
private List < Statement > statements ;
ValueFactory valueFactory ;
public StatementWriter ( List < Statement > statements ) {
this . statements = statements ;
valueFactory = new ValueFactoryImpl ( ) ;
}
@Override
public void startDocument ( URI documentURI ) throws TripleHandlerException {
}
@Override
public void openContext ( ExtractionContext context )
throws TripleHandlerException {
}
@Override
public void receiveTriple ( Resource s , URI p , Value o , URI g ,
ExtractionContext context ) throws TripleHandlerException {
statements . add ( valueFactory . createStatement ( s , p , o , g ) ) ;
}
@Override
public void receiveNamespace ( String prefix , String uri ,
ExtractionContext context ) throws TripleHandlerException {
}
@Override
public void closeContext ( ExtractionContext context )
throws TripleHandlerException {
}
@Override
public void endDocument ( URI documentURI ) throws TripleHandlerException {
}
@Override
public void setContentLength ( long contentLength ) {
}
@Override
public void close ( ) throws TripleHandlerException {
}
}
package fr . inria . wimmics . metadata . util . sesame ;
import static org . junit . Assert . fail ;
import java . util . List ;
import org . openrdf . query . BindingSet ;
import org . openrdf . query . MalformedQueryException ;
import org . openrdf . query . QueryEvaluationException ;
import org . openrdf . query . QueryLanguage ;
import org . openrdf . query . TupleQuery ;
import org . openrdf . query . TupleQueryResult ;
import org . openrdf . repository . Repository ;
import org . openrdf . repository . RepositoryConnection ;
import org . openrdf . repository . RepositoryException ;
import org . openrdf . repository . sail . SailRepository ;
import org . openrdf . sail . Sail ;
import org . openrdf . sail . inferencer . fc . ForwardChainingRDFSInferencer ;
import org . openrdf . sail . memory . MemoryStore ;
public class SesameUtil {
public static Repository getMemoryBasedRepository ( ) throws RepositoryException {
MemoryStore memory = new MemoryStore ( ) ;
Sail sail = new ForwardChainingRDFSInferencer ( memory ) ;
Repository rep = new SailRepository ( sail ) ;
rep . initialize ( ) ;
return rep ;
}
public static void printSPARQLQueryhResult ( RepositoryConnection con , String quString ) throws RepositoryException , MalformedQueryException , QueryEvaluationException {
TupleQuery tupleQuery = con . prepareTupleQuery ( QueryLanguage . SPARQL , quString ) ;
TupleQueryResult result = tupleQuery . evaluate ( ) ;
try {
int i = <num> ;
while ( result . hasNext ( ) ) {
System . out . println ( " + ( ++ i ) + " ) ;
BindingSet bindingSet = result . next ( ) ;
List < String > names = result . getBindingNames ( ) ;
for ( String name : names ) {
System . out . println ( name + " + bindingSet . getValue ( name ) ) ;
}
System . out . println ( ) ;
}
} finally {
result . close ( ) ;
}
}
public static void queryWithSPARQL ( Repository repo , String queryString ) throws RepositoryException , MalformedQueryException , QueryEvaluationException {
RepositoryConnection con = repo . getConnection ( ) ;
try {
printSPARQLQueryhResult ( con , queryString ) ;
} finally {
con . close ( ) ;
}
}
public static void printGraph ( Repository repo , String graphUrl ) throws RepositoryException , MalformedQueryException , QueryEvaluationException {
String queryString = " +
" + graphUrl + " ;
queryWithSPARQL ( repo , queryString ) ;
}
}
package fr . inria . wimmics . metadata . imdb ;
import java . io . IOException ;
import java . net . URISyntaxException ;
import org . deri . any23 . extractor . ExtractionException ;
import org . openrdf . query . MalformedQueryException ;
import org . openrdf . query . QueryEvaluationException ;
import org . openrdf . repository . Repository ;
import org . openrdf . repository . RepositoryException ;
import fr . inria . wimmics . metadata . crawler . Any23Crawler2Sesame ;
import fr . inria . wimmics . metadata . util . sesame . SesameUtil ;
public class ImdbSchemaOrg {
Any23Crawler2Sesame crawler ;
Repository repo ;
String schemaOrgLocation = " ;
public ImdbSchemaOrg ( ) throws RepositoryException , IOException , URISyntaxException , ExtractionException , MalformedQueryException , QueryEvaluationException {
repo = SesameUtil . getMemoryBasedRepository ( ) ;
crawler = new Any23Crawler2Sesame ( ) ;
crawler . crawlURL ( " , schemaOrgLocation , repo ) ;
}
public void crawlImdbURL ( String movieUrl ) throws RepositoryException , IOException , URISyntaxException {
crawler . crawlURL4SchemaOrgMicroData ( movieUrl , repo ) ;
}
public void showImdbURL ( String movieUrl ) throws RepositoryException , MalformedQueryException , QueryEvaluationException {
SesameUtil . printGraph ( repo , movieUrl ) ;
}
public static void main ( String [ ] args ) throws Exception {
String movieUrl = " ;
ImdbSchemaOrg imdb = new ImdbSchemaOrg ( ) ;
imdb . crawlImdbURL ( movieUrl ) ;
imdb . showImdbURL ( movieUrl ) ;
String queryString = " +
" +
" +
" ;
System . out . println ( " + queryString ) ;
SesameUtil . queryWithSPARQL ( imdb . repo , queryString ) ;
}
}
package fr . inria . wimmics . metadata . crawler ;
import java . io . ByteArrayOutputStream ;
import java . io . IOException ;
import java . net . URISyntaxException ;
import org . deri . any23 . Any23 ;
import org . deri . any23 . extractor . ExtractionException ;
import org . deri . any23 . filter . IgnoreAccidentalRDFa ;
import org . deri . any23 . http . HTTPClient ;
import org . deri . any23 . source . DocumentSource ;
import org . deri . any23 . source . HTTPDocumentSource ;
import org . deri . any23 . writer . NTriplesWriter ;
import org . deri . any23 . writer . RepositoryWriter ;
import org . deri . any23 . writer . TripleHandler ;
import org . openrdf . model . URI ;
import org . openrdf . model . ValueFactory ;
import org . openrdf . repository . Repository ;
import org . openrdf . repository . RepositoryConnection ;
import org . openrdf . repository . RepositoryException ;
import fr . inria . wimmics . metadata . util . schema . org . SchemaOrgFix ;
public class Any23Crawler2Sesame {
final public static String USER_AGENT = " ;
public void crawlURL ( String url ) throws IOException , URISyntaxException , ExtractionException {
Any23 runner = new Any23 ( ) ;
runner . setHTTPUserAgent ( USER_AGENT ) ;
HTTPClient httpClient = runner . getHTTPClient ( ) ;
DocumentSource source = new HTTPDocumentSource ( httpClient , url ) ;
ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ;
TripleHandler handler = new NTriplesWriter ( out ) ;
handler = new IgnoreAccidentalRDFa ( handler , true ) ;
runner . extract ( source , handler ) ;
String n3 = out . toString ( " ) ;
System . out . println ( n3 ) ;
}
public void crawlURL ( String url , Repository repo ) throws RepositoryException , IOException , URISyntaxException {
Any23 runner = new Any23 ( ) ;
extractInsert ( runner , url , repo ) ;
}
public void crawlURL ( String extractorName , String url , Repository repo ) throws RepositoryException , IOException , URISyntaxException {
Any23 runner = new Any23 ( extractorName ) ;
extractInsert ( runner , url , repo ) ;
}
private void extractInsert ( Any23 runner , String url , Repository repo ) throws RepositoryException , IOException , URISyntaxException {
runner . setHTTPUserAgent ( USER_AGENT ) ;
HTTPClient httpClient = runner . getHTTPClient ( ) ;
DocumentSource source = new HTTPDocumentSource ( httpClient , url ) ;
ValueFactory factory = repo . getValueFactory ( ) ;
RepositoryConnection con = repo . getConnection ( ) ;
URI context = factory . createURI ( url ) ;
TripleHandler handler = new RepositoryWriter ( con , context ) ;
handler = new IgnoreAccidentalRDFa ( handler , true ) ;
try {
runner . extract ( source , handler ) ;
} catch ( ExtractionException e ) {
con . rollback ( ) ;
} finally {
if ( con != null ) con . close ( ) ;
}
}
public void crawlURL4SchemaOrgMicroData ( String url , Repository repo ) throws IOException , URISyntaxException , RepositoryException {
Any23 runner = new Any23 ( " ) ;
runner . setHTTPUserAgent ( USER_AGENT ) ;
HTTPClient httpClient = runner . getHTTPClient ( ) ;
DocumentSource source = new HTTPDocumentSource ( httpClient , url ) ;
ValueFactory factory = repo . getValueFactory ( ) ;
RepositoryConnection con = repo . getConnection ( ) ;
URI context = factory . createURI ( url ) ;
TripleHandler handler = new SchemaOrgFix ( con , context ) ;
handler = new IgnoreAccidentalRDFa ( handler , true ) ;
try {
runner . extract ( source , handler ) ;
} catch ( ExtractionException e ) {
con . rollback ( ) ;
} finally {
if ( con != null ) con . close ( ) ;
}
}
}
package com . onskreen . cornerstone . panel ;
import android . content . BroadcastReceiver ;
import android . content . Context ;
import android . content . Intent ;
public class <unk> extends BroadcastReceiver {
@Override
public void onReceive ( Context context , Intent intent ) {
Intent startupBootIntent = new Intent ( context , CSPanel . class ) ;
startupBootIntent . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ;
context . startActivity ( startupBootIntent ) ;
}
}
package com . onskreen . cornerstone . panel ;
import android . app . Activity ;
import android . app . AlertDialog ;
import android . app . Dialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . content . SharedPreferences ;
import android . os . Bundle ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . Toast ;
import android . widget . TextView ;
import android . widget . ListView ;
import android . widget . ImageView ;
import android . widget . RelativeLayout ;
import android . widget . Spinner ;
import android . widget . ArrayAdapter ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . view . LayoutInflater ;
import android . content . Intent ;
import android . content . pm . PackageManager ;
import android . content . pm . ResolveInfo ;
import android . widget . AdapterView . OnItemSelectedListener ;
import java . util . ArrayList ;
import java . util . List ;
public class <unk> extends Activity {
static final String CS_PREFS = " ;
private ArrayList apps = new ArrayList ( ) ;
private ArrayList packages = new ArrayList ( ) ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . settings_main ) ;
final Context context = getApplicationContext ( ) ;
final PackageManager pm = this . getPackageManager ( ) ;
final SharedPreferences settings = getSharedPreferences ( CS_PREFS , <num> ) ;
final SharedPreferences . Editor editor = settings . edit ( ) ;
String panel0 = settings . getString ( " , null ) ;
String panel1 = settings . getString ( " , null ) ;
Intent intent = new Intent ( Intent . ACTION_MAIN , null ) ;
intent . addCategory ( Intent . CATEGORY_LAUNCHER ) ;
List < ResolveInfo > list = pm . queryIntentActivities ( intent , PackageManager . PERMISSION_GRANTED ) ;
for ( ResolveInfo rInfo : list ) {
CharSequence app = rInfo . activityInfo . loadLabel ( pm ) ;
if ( ! app . toString ( ) . equals ( " ) ) {
apps . add ( rInfo . activityInfo . loadLabel ( pm ) ) ;
packages . add ( rInfo . activityInfo . applicationInfo . packageName ) ;
}
}
RelativeLayout rl1 = ( RelativeLayout ) findViewById ( R . id . <unk> ) ;
ImageView header = ( ImageView ) findViewById ( R . id . <unk> ) ;
TextView <unk> = ( TextView ) findViewById ( R . id . <unk> ) ;
RelativeLayout rl2 = ( RelativeLayout ) findViewById ( R . id . <unk> ) ;
ImageView <unk> = ( ImageView ) findViewById ( R . id . <unk> ) ;
TextView title = ( TextView ) findViewById ( R . id . <unk> ) ;
Spinner spinner1 = ( Spinner ) findViewById ( R . id . <unk> ) ;
ArrayAdapter < String > adapter1 = new ArrayAdapter < String > ( this ,
android . R . layout . simple_spinner_item , apps ) ;
adapter1 . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
spinner1 . setAdapter ( adapter1 ) ;
spinner1 . setOnItemSelectedListener ( new OnItemSelectedListener ( ) {
public void onItemSelected ( AdapterView < ? > parent , View view , int position , long id ) {
editor . putString ( " , ( String ) packages . get ( position ) ) ;
editor . commit ( ) ;
}
public void onNothingSelected ( AdapterView < ? > parent ) {
}
} ) ;
TextView text1 = ( TextView ) findViewById ( R . id . text1 ) ;
View separator1 = ( View ) findViewById ( R . id . separator1 ) ;
Spinner spinner2 = ( Spinner ) findViewById ( R . id . <unk> ) ;
ArrayAdapter < String > adapter2 = new ArrayAdapter < String > ( this ,
android . R . layout . simple_spinner_item , apps ) ;
adapter2 . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ;
spinner2 . setAdapter ( adapter2 ) ;
spinner2 . setOnItemSelectedListener ( new OnItemSelectedListener ( ) {
public void onItemSelected ( AdapterView < ? > parent , View view , int position , long id ) {
editor . putString ( " , ( String ) packages . get ( position ) ) ;
editor . commit ( ) ;
}
public void onNothingSelected ( AdapterView < ? > parent ) {
}
} ) ;
TextView text2 = ( TextView ) findViewById ( R . id . text2 ) ;
View separator2 = ( View ) findViewById ( R . id . separator2 ) ;
int index = packages . indexOf ( panel0 ) ;
if ( index !=  <num> ) {
spinner1 . setSelection ( index ) ;
}
index = packages . indexOf ( panel1 ) ;
if ( index !=  <num> ) {
spinner2 . setSelection ( index ) ;
}
}
void showToast ( CharSequence msg ) {
Toast . makeText ( this , msg , Toast . LENGTH_SHORT ) . show ( ) ;
}
}
package com . onskreen . cornerstone . panel ;
import android . app . Activity ;
import android . app . ActivityManagerNative ;
import android . app . ActivityManager ;
import android . app . ICornerstoneManager ;
import android . app . ProgressDialog ;
import android . content . Context ;
import android . content . SharedPreferences ;
import android . content . res . Configuration ;
import android . content . res . Resources ;
import android . content . res . XmlResourceParser ;
import android . content . Intent ;
import android . content . pm . PackageManager ;
import android . os . AsyncTask ;
import android . os . Bundle ;
import android . os . RemoteException ;
import android . view . View ;
import android . widget . Toast ;
import android . widget . ImageButton ;
import android . widget . ImageView ;
import android . content . pm . ApplicationInfo ;
import android . content . pm . ActivityInfo ;
import android . widget . TextView ;
import android . view . View . OnClickListener ;
import android . view . <unk> ;
import android . view . <unk> ;
import android . os . IBinder ;
import android . os . Handler ;
import android . os . Message ;
import android . graphics . Color ;
import android . content . ComponentName ;
import android . content . pm . PackageManager . NameNotFoundException ;
import android . util . Log ;
import java . lang . SecurityException ;
import java . io . IOException ;
import java . util . List ;
import org . xmlpull . v1 . XmlPullParser ;
import org . xmlpull . v1 . XmlPullParserException ;
public class CSPanel extends Activity {
static final boolean DEBUG = true ;
static final String TAG = " ;
static boolean isCornestoneStarted = false ;
static final String CS_PREFS = " ;
String [ ] mCornerstoneApps ;
String mCSLauncherPkgName ;
String mCSLauncherClassName ;
enum Cornerstone_State {
OPEN ,
CLOSED
}
Cornerstone_State csState = Cornerstone_State . OPEN ;
private ImageButton csAppHeader1 ;
private ImageButton csAppHeader2 ;
private ImageButton csHandler ;
private ImageButton csAppLaunch1 ;
private ImageButton csAppLaunch2 ;
private ImageView csClose ;
private ImageView csSettings ;
private TextView csAppTitle1 ;
private TextView csAppTitle2 ;
private Handler mHandler ;
private final ICornerstoneManager . Stub mBinder = new ICornerstoneManager . Stub ( ) {
public void <unk> ( String pkgName , boolean focus , int index ) {
Message msg = mHandler . obtainMessage ( ) ;
msg . obj = pkgName ;
msg . what = index ;
mHandler . sendMessage ( msg ) ;
}
} ;
private PackageManager mPkgManager ;
@Override
public void onDestroy ( ) {
super . onDestroy ( ) ;
isCornestoneStarted = false ;
}
@Override
public void onResume ( ) {
super . onResume ( ) ;
if ( ! isCornestoneStarted ) {
startCornerstoneApps ( ) ;
isCornestoneStarted = true ;
}
}
@Override
public void onBackPressed ( ) {
return ;
}
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
SharedPreferences settings = getSharedPreferences ( CS_PREFS , <num> ) ;
String panel0 = settings . getString ( " , null ) ;
String panel1 = settings . getString ( " , null ) ;
if ( panel0 == null && panel1 == null ) {
SharedPreferences . Editor editor = settings . edit ( ) ;
editor . putString ( " , " ) ;
editor . putString ( " , " ) ;
editor . commit ( ) ;
panel0 = " ;
panel1 = " ;
}
mCornerstoneApps = new String [ <num> ] ;
mCornerstoneApps [ <num> ] = panel0 ;
mCornerstoneApps [ <num> ] = panel1 ;
if ( mCSLauncherPkgName == null && mCSLauncherClassName == null ) {
XmlResourceParser xpp = null ;
try {
Resources res = this . getResources ( ) ;
xpp = res . getXml ( com . android . internal . R . xml . cornerstone ) ;
xpp . next ( ) ;
int eventType = xpp . getEventType ( ) ;
String tag ;
while ( eventType != XmlPullParser . END_DOCUMENT ) {
if ( eventType == XmlPullParser . START_DOCUMENT ) {
} else if ( eventType == XmlPullParser . START_TAG ) {
tag = xpp . getName ( ) ;
if ( tag . equals ( " ) ) {
xpp . next ( ) ;
tag = xpp . getName ( ) ;
if ( tag . equals ( " ) ) {
xpp . next ( ) ;
mCSLauncherPkgName = xpp . getText ( ) ;
xpp . next ( ) ;
}
xpp . next ( ) ;
tag = xpp . getName ( ) ;
if ( tag . equals ( " ) ) {
xpp . next ( ) ;
mCSLauncherClassName = xpp . getText ( ) ;
xpp . next ( ) ;
}
break ;
}
}
eventType = xpp . next ( ) ;
}
xpp . close ( ) ;
} catch ( XmlPullParserException e ) {
e . printStackTrace ( ) ;
xpp . close ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
xpp . close ( ) ;
}
}
Configuration config = getApplicationContext ( ) . getResources ( ) . getConfiguration ( ) ;
if ( config != null ) {
int orientation = config . orientation ;
if ( orientation == Configuration . ORIENTATION_PORTRAIT ) {
setContentView ( R . layout . portrait_main ) ;
} else if ( orientation == Configuration . ORIENTATION_LANDSCAPE ) {
setContentView ( R . layout . landscape_main ) ;
}
}
initializeControls ( ) ;
mHandler = new Handler ( ) {
@Override
public void handleMessage ( Message msg ) {
super . handleMessage ( msg ) ;
String pkg = ( String ) msg . obj ;
int index = msg . what ;
CharSequence title = pkg ;
if ( pkg != null ) {
try {
ApplicationInfo appInfo = mPkgManager . getApplicationInfo ( pkg , <num> ) ;
if ( appInfo != null ) {
title = mPkgManager . getApplicationLabel ( appInfo ) ;
}
} catch ( NameNotFoundException e ) {
e . printStackTrace ( ) ;
}
}
switch ( index ) {
case <num> :
setCornerstoneAppControls ( <num> ) ;
csAppTitle1 . setText ( title ) ;
break ;
case <num> :
setCornerstoneAppControls ( <num> ) ;
csAppTitle2 . setText ( title ) ;
break ;
default :
setCornerstoneAppControls (  <num> ) ;
break ;
}
}
} ;
try {
ActivityManagerNative . getDefault ( ) . <unk> ( mBinder ) ;
} catch ( RemoteException e ) {
e . printStackTrace ( ) ;
}
}
@Override
public void onConfigurationChanged ( Configuration newConfig ) {
CharSequence title1 = csAppTitle1 . getText ( ) ;
CharSequence title2 = csAppTitle2 . getText ( ) ;
String header1 = ( String ) csAppHeader1 . getTag ( ) ;
String header2 = ( String ) csAppHeader2 . getTag ( ) ;
super . onConfigurationChanged ( newConfig ) ;
if ( newConfig != null ) {
int orientation = newConfig . orientation ;
Context context = getApplicationContext ( ) ;
if ( orientation == Configuration . ORIENTATION_PORTRAIT ) {
setContentView ( R . layout . portrait_main ) ;
} else if ( orientation == Configuration . ORIENTATION_LANDSCAPE ) {
setContentView ( R . layout . landscape_main ) ;
}
initializeControls ( ) ;
csAppTitle1 . setText ( title1 ) ;
csAppTitle2 . setText ( title2 ) ;
switch ( csState ) {
case OPEN :
csHandler . setBackgroundResource ( R . drawable . cornerstone_panel_controller_expanded ) ;
if ( header1 . equals ( " ) ) {
setCornerstoneAppControls ( <num> ) ;
} else if ( header2 . equals ( " ) ) {
setCornerstoneAppControls ( <num> ) ;
} else {
setCornerstoneAppControls (  <num> ) ;
}
break ;
case CLOSED :
csHandler . setBackgroundResource ( R . drawable . cornerstone_panel_controller_collapsed ) ;
setCornerstoneAppControls (  <num> ) ;
break ;
}
}
}
private void initializeControls ( ) {
csClose = ( ImageView ) findViewById ( R . id . <unk> ) ;
csClose . setClickable ( true ) ;
OnClickListener closeListener = new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
handleClose ( v ) ;
}
} ;
csClose . setOnClickListener ( closeListener ) ;
csSettings = ( ImageView ) findViewById ( R . id . <unk> ) ;
csSettings . setClickable ( true ) ;
OnClickListener settingsListener = new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
handleSettings ( v ) ;
}
} ;
csSettings . setOnClickListener ( settingsListener ) ;
csAppHeader1 = ( ImageButton ) findViewById ( R . id . cs_app_header1 ) ;
OnClickListener appHeader1Listener = new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
handleFocus ( v ) ;
}
} ;
csAppHeader1 . setOnClickListener ( appHeader1Listener ) ;
csAppHeader2 = ( ImageButton ) findViewById ( R . id . cs_app_header2 ) ;
OnClickListener appHeader2Listener = new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
handleFocus ( v ) ;
}
} ;
csAppHeader2 . setOnClickListener ( appHeader2Listener ) ;
csHandler = ( ImageButton ) findViewById ( R . id . handle ) ;
OnClickListener handleListener = new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
togglePanel ( v ) ;
}
} ;
csHandler . setOnClickListener ( handleListener ) ;
csAppLaunch1 = ( ImageButton ) findViewById ( R . id . launch_0_button ) ;
OnClickListener appLaunch1Listener = new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
launchApp ( v ) ;
}
} ;
csAppLaunch1 . setOnClickListener ( appLaunch1Listener ) ;
csAppLaunch2 = ( ImageButton ) findViewById ( R . id . launch_1_button ) ;
OnClickListener appLaunch2Listener = new OnClickListener ( ) {
@Override
public void onClick ( View v ) {
launchApp ( v ) ;
}
} ;
csAppLaunch2 . setOnClickListener ( appLaunch2Listener ) ;
csAppTitle1 = ( TextView ) findViewById ( R . id . <unk> ) ;
csAppTitle2 = ( TextView ) findViewById ( R . id . <unk> ) ;
mPkgManager = getApplicationContext ( ) . getPackageManager ( ) ;
}
public void launchApp ( View view ) {
Context context = getApplicationContext ( ) ;
int index =  <num> ;
switch ( view . getId ( ) )
{
case R . id . launch_0_button :
csAppLaunch1 . setBackgroundResource ( R . drawable . control_applaunch_click ) ;
index = <num> ;
break ;
case R . id . launch_1_button :
csAppLaunch2 . setBackgroundResource ( R . drawable . control_applaunch_click ) ;
index = <num> ;
break ;
}
Intent intent = new Intent ( ) ;
ComponentName cp = new ComponentName ( mCSLauncherPkgName , mCSLauncherClassName ) ;
intent . setComponent ( cp ) ;
ActivityLauncher aLauncher = new ActivityLauncher ( intent , index ) ;
aLauncher . launch ( ) ;
}
public void togglePanel ( View view ) {
if ( ( csHandler == ( ImageButton ) view ) && ( csState == Cornerstone_State . OPEN ) ) {
try {
ActivityManagerNative . getDefault ( ) . setCornerstoneState ( false ) ;
} catch ( RemoteException e ) {
e . printStackTrace ( ) ;
}
csHandler . setBackgroundResource ( R . drawable . cornerstone_panel_controller_collapsed ) ;
csState = Cornerstone_State . CLOSED ;
} else if ( ( csHandler == ( ImageButton ) view ) && ( csState == Cornerstone_State . CLOSED ) ) {
try {
ActivityManagerNative . getDefault ( ) . setCornerstoneState ( true ) ;
} catch ( RemoteException e ) {
e . printStackTrace ( ) ;
}
csHandler . setBackgroundResource ( R . drawable . cornerstone_panel_controller_expanded ) ;
csState = Cornerstone_State . OPEN ;
}
}
public void handleFocus ( View view ) {
Context context = getApplicationContext ( ) ;
int index =  <num> ;
int duration = Toast . LENGTH_SHORT ;
switch ( view . getId ( ) ) {
case R . id . cs_app_header1 :
index = <num> ;
break ;
case R . id . cs_app_header2 :
index = <num> ;
break ;
}
try {
ActivityManagerNative . getDefault ( ) . <unk> ( index ) ;
} catch ( RemoteException e ) {
e . printStackTrace ( ) ;
}
}
public void handleClose ( View view ) {
Context context = getApplicationContext ( ) ;
int duration = Toast . LENGTH_LONG ;
if ( csState == Cornerstone_State . OPEN ) {
try {
ActivityManagerNative . getDefault ( ) . setCornerstoneState ( false ) ;
} catch ( RemoteException e ) {
e . printStackTrace ( ) ;
}
csHandler . setBackgroundResource ( R . drawable . cornerstone_panel_controller_collapsed ) ;
csState = Cornerstone_State . CLOSED ;
}
finish ( ) ;
Toast toast = Toast . makeText ( context , " , duration ) ;
toast . show ( ) ;
}
public void handleSettings ( View view ) {
Intent intent = new Intent ( ) ;
ComponentName cp = new ComponentName ( " , " ) ;
intent . setComponent ( cp ) ;
ActivityLauncher aLauncher = new ActivityLauncher ( intent ,  <num> ) ;
aLauncher . launch ( ) ;
}
private void setCornerstoneAppControls ( int panelIndex ) {
switch ( panelIndex ) {
case <num> :
csAppHeader1 . setBackgroundResource ( R . drawable . cs_app_header_focused ) ;
csAppHeader1 . setTag ( " ) ;
csAppLaunch1 . setBackgroundResource ( R . drawable . control_applaunch_focused ) ;
csAppTitle1 . setTextColor ( Color . WHITE ) ;
csAppHeader2 . setBackgroundResource ( R . drawable . cs_app_header_unfocused ) ;
csAppHeader2 . setTag ( " ) ;
csAppLaunch2 . setBackgroundResource ( R . drawable . control_applaunch_unfocused ) ;
csAppTitle2 . setTextColor ( Color . LTGRAY ) ;
break ;
case <num> :
csAppHeader2 . setBackgroundResource ( R . drawable . cs_app_header_focused ) ;
csAppHeader2 . setTag ( " ) ;
csAppLaunch2 . setBackgroundResource ( R . drawable . control_applaunch_focused ) ;
csAppTitle2 . setTextColor ( Color . WHITE ) ;
csAppHeader1 . setBackgroundResource ( R . drawable . cs_app_header_unfocused ) ;
csAppHeader1 . setTag ( " ) ;
csAppLaunch1 . setBackgroundResource ( R . drawable . control_applaunch_unfocused ) ;
csAppTitle1 . setTextColor ( Color . LTGRAY ) ;
break ;
default :
csAppHeader1 . setBackgroundResource ( R . drawable . cs_app_header_unfocused ) ;
csAppHeader1 . setTag ( " ) ;
csAppLaunch1 . setBackgroundResource ( R . drawable . control_applaunch_unfocused ) ;
csAppTitle1 . setTextColor ( Color . LTGRAY ) ;
csAppHeader2 . setBackgroundResource ( R . drawable . cs_app_header_unfocused ) ;
csAppHeader2 . setTag ( " ) ;
csAppLaunch2 . setBackgroundResource ( R . drawable . control_applaunch_unfocused ) ;
csAppTitle2 . setTextColor ( Color . LTGRAY ) ;
break ;
}
}
private void startCornerstoneApps ( ) {
if ( DEBUG ) {
Log . v ( TAG , " + mCornerstoneApps ) ;
}
Context context = getApplicationContext ( ) ;
int duration = Toast . LENGTH_SHORT ;
for ( int i = <num> ; i < mCornerstoneApps . length ; i ++ ) {
Intent currIntent = mPkgManager . getLaunchIntentForPackage ( mCornerstoneApps [ i ] ) ;
if ( currIntent == null ) {
Intent intent = new Intent ( ) ;
ComponentName cp = new ComponentName ( mCSLauncherPkgName , mCSLauncherClassName ) ;
intent . setComponent ( cp ) ;
ActivityLauncher aLauncher = new ActivityLauncher ( intent , i ) ;
aLauncher . launch ( ) ;
} else {
Toast toast = Toast . makeText ( context , " , duration ) ;
toast . show ( ) ;
ActivityLauncher aLauncher = new ActivityLauncher ( currIntent , i ) ;
aLauncher . launch ( ) ;
}
}
}
private class <unk> extends AsyncTask < Void , Void , Void > {
private ProgressDialog dialog = new ProgressDialog ( CSPanel . this ) ;
private long sleepTime = <num> ;
protected void onPreExecute ( ) {
dialog . setMessage ( " ) ;
dialog . show ( ) ;
}
protected Void doInBackground ( Void . . . params ) {
try {
startCornerstoneApps ( ) ;
Thread . sleep ( sleepTime ) ;
} catch ( InterruptedException e ) {
dialog . dismiss ( ) ;
}
return null ;
}
protected void onPostExecute ( Void unused ) {
dialog . dismiss ( ) ;
}
}
private class ActivityLauncher {
private Intent intent ;
private int index ;
public ActivityLauncher ( Intent intent , int index ) {
this . intent = intent ;
this . index = index ;
if ( DEBUG ) {
Log . v ( TAG , " + intent + " + index ) ;
}
}
public void launch ( ) {
new Thread ( new Runnable ( ) {
public void run ( ) {
try {
if ( DEBUG ) {
Log . v ( TAG , " + intent ) ;
}
ActivityManagerNative . getDefault ( ) . <unk> ( intent , index ) ;
} catch ( RemoteException e ) {
e . printStackTrace ( ) ;
}
}
} ) . start ( ) ;
}
}
}
package com . mingjianinfo . test ;
import java . io . IOException ;
import java . util . HashMap ;
import java . util . concurrent . CountDownLatch ;
import java . util . concurrent . TimeUnit ;
import org . apache . http . HttpResponse ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . client . ResponseHandler ;
import org . apache . http . impl . client . BasicResponseHandler ;
import com . mingjianinfo . network . HttpApi ;
import com . mingjianinfo . network . IRequestTaskDelegate ;
import com . mingjianinfo . network . RequestTask ;
import android . test . AndroidTestCase ;
import android . test . InstrumentationTestCase ;
import android . util . Log ;
public class <unk> extends InstrumentationTestCase {
protected void setUp ( ) throws Exception {
super . setUp ( ) ;
}
protected void tearDown ( ) throws Exception {
super . tearDown ( ) ;
}
public final void <unk> ( ) throws Throwable {
final CountDownLatch signal = new CountDownLatch ( <num> ) ;
<unk> ( new Runnable ( ) {
@Override
public void run ( ) {
Object [ ] arr = new Object [ <num> ] ;
arr [ <num> ] = " ;
arr [ <num> ] = HttpApi . <unk> ;
HashMap < String , Object > map = new HashMap < String , Object > ( ) ;
map . put ( HttpApi . <unk> , new BasicResponseHandler ( ) ) ;
arr [ <num> ] = map ;
RequestTask < Object , Integer , String > task = new RequestTask < Object , Integer , String > ( new IRequestTaskDelegate < Integer , String > ( ) {
@Override
public void <unk> ( Integer . . . values ) {
Log . i ( " , " + values [ <num> ] ) ;
}
@Override
public void <unk> ( String result ) {
Log . i ( " , result ) ;
assertNotNull ( result ) ;
}
@Override
public void <unk> ( ) {
}
@Override
public void cancel ( ) {
}
} ) ;
task . execute ( arr ) ;
}
} ) ;
signal . await ( <num> , TimeUnit . SECONDS ) ;
}
}
package com . mingjianinfo . test ;
import org . apache . http . impl . client . BasicResponseHandler ;
import com . mingjianinfo . network . HttpApi ;
import android . test . AndroidTestCase ;
import android . util . Log ;
public class <unk> extends AndroidTestCase {
protected void setUp ( ) throws Exception {
super . setUp ( ) ;
}
protected void tearDown ( ) throws Exception {
super . tearDown ( ) ;
}
public final void testGet ( ) {
HttpApi < String > httpApi = new HttpApi < String > ( ) ;
String value = httpApi . get ( null , " , null , null , new BasicResponseHandler ( ) ) ;
assertNotNull ( value ) ;
Log . i ( " , value ) ;
}
public final void <unk> ( ) {
HttpApi < String > httpApi = new HttpApi < String > ( ) ;
int value = httpApi . head ( " ) ;
assertEquals ( <num> , value ) ;
Log . i ( " , " + value ) ;
}
}
package com . mingjianinfo . test ;
import com . mingjianinfo . network . NetworkDetector ;
import android . test . AndroidTestCase ;
import android . util . Log ;
public class <unk> extends AndroidTestCase {
protected void setUp ( ) throws Exception {
super . setUp ( ) ;
}
protected void tearDown ( ) throws Exception {
super . tearDown ( ) ;
}
public final void <unk> ( ) {
int value = NetworkDetector . <unk> ( this . getContext ( ) ) ;
Log . i ( " , String . valueOf ( value ) ) ;
assertTrue ( value > NetworkDetector . <unk> ) ;
}
public final void <unk> ( ) {
assertTrue ( NetworkDetector . <unk> ( " ) ) ;
}
}
package org . keitanxkeitan . memopad ;
import android . app . ListActivity ;
import android . database . Cursor ;
import android . os . Bundle ;
import android . provider . BaseColumns ;
import android . util . Log ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . LinearLayout ;
import android . widget . ListView ;
import android . widget . SimpleCursorAdapter ;
import android . widget . TextView ;
public class <unk> extends ListActivity implements OnClickListener {
MemoDbAdapter mMemoDbAdapter ;
private TextView mCurrentId ;
private EditText mEdit ;
private SimpleCursorAdapter mAdapter ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
mCurrentId = ( TextView ) findViewById ( R . id . <unk> ) ;
mEdit = ( EditText ) findViewById ( R . id . <unk> ) ;
int buttons [ ] = { R . id . delete_button ,
R . id . modify_button ,
R . id . add_button
} ;
for ( int id : buttons ) {
Button button = ( Button ) findViewById ( id ) ;
button . setOnClickListener ( this ) ;
}
setEnabled ( false ) ;
mMemoDbAdapter = new MemoDbAdapter ( this ) ;
mMemoDbAdapter . open ( ) ;
}
@Override
protected void onResume ( ) {
super . onResume ( ) ;
Cursor c = mMemoDbAdapter . fetchAllMemo ( ) ;
startManagingCursor ( c ) ;
String [ ] from = new String [ ] { BaseColumns . _ID ,
MemoDbOpenHelper . KEY_MEMO } ;
int [ ] to = new int [ ] { R . id . _id , R . id . memo_text } ;
mAdapter = new SimpleCursorAdapter (
this , R . layout . <unk> , c , from , to ) ;
setListAdapter ( mAdapter ) ;
}
@Override
protected void onPause ( ) {
super . onPause ( ) ;
mMemoDbAdapter . close ( ) ;
}
public void onClick ( View view ) {
String id = mCurrentId . getText ( ) . toString ( ) ;
String str = mEdit . getText ( ) . toString ( ) ;
if ( view . getId ( ) == R . id . delete_button ) {
mMemoDbAdapter . deleteMemo ( id ) ;
} else if ( view . getId ( ) == R . id . modify_button ) {
if ( str . length ( ) != <num> ) {
mMemoDbAdapter . setMemo ( id , str ) ;
} else {
mMemoDbAdapter . deleteMemo ( id ) ;
}
} else if ( view . getId ( ) == R . id . add_button ) {
if ( str . length ( ) != <num> ) {
mMemoDbAdapter . addMemo ( str ) ;
}
} else {
Log . e ( " , " ) ;
}
mCurrentId . setText ( " ) ;
mEdit . setText ( " ) ;
setEnabled ( false ) ;
Cursor c = mMemoDbAdapter . fetchAllMemo ( ) ;
startManagingCursor ( c ) ;
mAdapter . changeCursor ( c ) ;
}
@Override
protected void onListItemClick (
ListView l , View v , int position , long id ) {
super . onListItemClick ( l , v , position , id ) ;
LinearLayout ll = ( LinearLayout ) v ;
TextView t = ( TextView ) ll . findViewById ( R . id . memo_text ) ;
mEdit . setText ( t . getText ( ) ) ;
mCurrentId . setText ( Long . toString ( id ) ) ;
setEnabled ( true ) ;
}
private void setEnabled ( boolean enabled ) {
int buttons [ ] = { R . id . delete_button ,
R . id . modify_button ,
} ;
for ( int id : buttons ) {
Button button = ( Button ) findViewById ( id ) ;
button . setEnabled ( enabled ) ;
}
}
package org . keitanxkeitan . memopad ;
import android . content . ContentValues ;
import android . content . Context ;
import android . database . Cursor ;
import android . database . sqlite . SQLiteDatabase ;
import android . database . sqlite . SQLiteException ;
import android . provider . BaseColumns ;
public class MemoDbAdapter {
private SQLiteDatabase mDb ;
private MemoDbOpenHelper mDbHelper ;
public MemoDbAdapter ( Context context ) {
mDbHelper = new MemoDbOpenHelper ( context ) ;
}
public void close ( ) {
mDb . close ( ) ;
}
public void open ( ) throws SQLiteException {
try {
mDb = mDbHelper . getWritableDatabase ( ) ;
} catch ( SQLiteException e ) {
mDb = mDbHelper . getReadableDatabase ( ) ;
}
}
public Cursor fetchAllMemo ( ) {
return mDb . query ( MemoDbOpenHelper . DB_TABLE ,
new String [ ] { BaseColumns . _ID , MemoDbOpenHelper . KEY_MEMO } ,
null , null , null , null , MemoDbOpenHelper . KEY_ID + " ) ;
}
public String addMemo ( String memo ) {
ContentValues values = new ContentValues ( ) ;
values . put ( MemoDbOpenHelper . KEY_MEMO , memo ) ;
long id = mDb . insert ( MemoDbOpenHelper . DB_TABLE , null , values ) ;
if ( id < <num> ) {
return " ;
}
return Long . toString ( id ) ;
}
public void deleteMemo ( String id ) {
mDb . delete ( MemoDbOpenHelper . DB_TABLE , MemoDbOpenHelper . KEY_ID + " ,
new String [ ] { id } ) ;
}
public void setMemo ( String id , String memo ) {
ContentValues values = new ContentValues ( ) ;
values . put ( MemoDbOpenHelper . KEY_MEMO , memo ) ;
mDb . update ( MemoDbOpenHelper . DB_TABLE , values ,
MemoDbOpenHelper . KEY_ID + " , new String [ ] { id } ) ;
}
package org . keitanxkeitan . memopad ;
import android . content . ContentProvider ;
import android . content . ContentUris ;
import android . content . ContentValues ;
import android . content . UriMatcher ;
import android . database . Cursor ;
import android . database . sqlite . SQLiteDatabase ;
import android . database . sqlite . SQLiteException ;
import android . net . Uri ;
public class <unk> extends ContentProvider {
private SQLiteDatabase mDb ;
private MemoDbOpenHelper mDbHelper ;
private static final String URI =
" ;
public static final Uri CONTENT_URI = Uri . parse ( URI ) ;
@Override
public boolean onCreate ( ) {
mDbHelper = new MemoDbOpenHelper ( getContext ( ) ) ;
try {
mDb = mDbHelper . getWritableDatabase ( ) ;
} catch ( SQLiteException e ) {
mDb = mDbHelper . getReadableDatabase ( ) ;
}
return true ;
}
private static final int ALLROWS = <num> ;
private static final int SINGLE_ROW = <num> ;
private static final UriMatcher uriMatcher ;
static {
uriMatcher = new UriMatcher ( UriMatcher . NO_MATCH ) ;
uriMatcher . addURI ( " , " , ALLROWS ) ;
uriMatcher . addURI ( " , " ,
SINGLE_ROW ) ;
}
@Override
public Cursor query ( Uri uri ,
String [ ] projection ,
String selection ,
String [ ] selectionArgs ,
String sort ) {
switch ( uriMatcher . match ( uri ) ) {
case SINGLE_ROW :
final long id = Long . parseLong ( uri . getPathSegments ( ) . get ( <num> ) ) ;
selection =
android . provider . BaseColumns . _ID + " + Long . toString ( id )
+ ( selection == null ? " : " + selection + " ) ;
}
Cursor c = mDb . query ( MemoDbOpenHelper . DB_TABLE , projection , selection ,
selectionArgs , null , null , sort ) ;
c . setNotificationUri ( getContext ( ) . getContentResolver ( ) , uri ) ;
return c ;
}
@Override
public Uri insert ( Uri uri , ContentValues initialValues ) {
long id = mDb . insert ( MemoDbOpenHelper . DB_TABLE , null , initialValues ) ;
final Uri newUri = ContentUris . withAppendedId ( CONTENT_URI , id ) ;
return newUri ;
}
@Override
public int delete ( Uri uri , String where , String [ ] whereArgs ) {
final int deleteCount ;
switch ( uriMatcher . match ( uri ) ) {
case ALLROWS :
deleteCount = mDb . delete ( MemoDbOpenHelper . DB_TABLE , where ,
whereArgs ) ;
break ;
case SINGLE_ROW :
final long id = Long . parseLong ( uri . getPathSegments ( ) . get ( <num> ) ) ;
final String idPlusSelection =
android . provider . BaseColumns . _ID + " + Long . toString ( id )
+ ( where == null ? " : " + where + " ) ;
deleteCount = mDb . delete ( MemoDbOpenHelper . DB_TABLE ,
idPlusSelection , whereArgs ) ;
break ;
default :
throw new IllegalArgumentException ( " + uri ) ;
}
return deleteCount ;
}
@Override
public int update ( Uri uri , ContentValues values , String where ,
String [ ] whereArgs ) {
final int updateCount ;
switch ( uriMatcher . match ( uri ) ) {
case ALLROWS :
updateCount = mDb . update ( MemoDbOpenHelper . DB_TABLE , values , where ,
whereArgs ) ;
break ;
case SINGLE_ROW :
final long id = Long . parseLong ( uri . getPathSegments ( ) . get ( <num> ) ) ;
final String idPlusSelection =
android . provider . BaseColumns . _ID + " + Long . toString ( id )
+ ( where == null ? " : " + where + " ) ;
updateCount = mDb . update ( MemoDbOpenHelper . DB_TABLE , values ,
idPlusSelection , whereArgs ) ;
break ;
default : throw new IllegalArgumentException ( " +
uri ) ;
}
getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ;
return updateCount ;
}
@Override
public String getType ( Uri uri ) {
switch ( uriMatcher . match ( uri ) ) {
case ALLROWS :
return " ;
case SINGLE_ROW :
return " ;
default :
throw new IllegalArgumentException ( " +
uri ) ;
}
}
package org . keitanxkeitan . memopad ;
import android . content . Context ;
import android . database . sqlite . SQLiteDatabase ;
import android . database . sqlite . SQLiteOpenHelper ;
import android . util . Log ;
public class MemoDbOpenHelper extends SQLiteOpenHelper {
public static final String DB_NAME = " ;
public static final String DB_TABLE = " ;
public static final int DB_VERSION = <num> ;
public static final String KEY_ID = " ;
public static final int <unk> = <num> ;
public static final String KEY_MEMO = " ;
public static final int <unk> = <num> ;
public MemoDbOpenHelper ( Context c ) {
super ( c , DB_NAME , null , DB_VERSION ) ;
}
static final String CREATE_TABLE = " +
DB_TABLE + " + KEY_ID +
" +
KEY_MEMO + " ;
public void onCreate ( SQLiteDatabase db ) {
db . execSQL ( CREATE_TABLE ) ;
}
public void onUpgrade ( SQLiteDatabase db ,
int oldVersion , int newVersion ) {
Log . w ( " ,
" + oldVersion +
" + newVersion ) ;
db . execSQL ( " + DB_TABLE ) ;
onCreate ( db ) ;
}
}
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
public class Table
{
List < Card > table = new ArrayList < Card > ( ) ;
private int [ ] faces = new int [ <num> ] ;
private int [ ] suits = new int [ <num> ] ;
public Table ( List < Card > cards )
{
setTable ( cards ) ;
}
public void show ( )
{
for ( Card temp : table ) {
System . out . println ( temp . getFace ( ) + " + temp . getSuit ( ) ) ;
}
}
public List < Card > getTable ( ) {
return table ;
}
public void setTable ( List < Card > table ) {
this . table = table ;
}
public String getFaces ( int item ) {
return table . get ( item ) . getFace ( ) ;
}
public int getPoints ( int item ) {
String faceValue = table . get ( item ) . getFace ( ) ;
int value = <num> ;
if ( faceValue . equals ( " ) ) {
value = <num> ;
} else if ( faceValue . equals ( " ) ) {
value = <num> ;
} else if ( faceValue . equals ( " ) ) {
value = <num> ;
} else if ( faceValue . equals ( " ) ) {
value = <num> ;
}
return value ;
}
public void setFaces ( int [ ] faces ) {
this . faces = faces ;
}
public String getSuits ( int item ) {
return table . get ( item ) . getSuit ( ) ;
}
public void <unk> ( int [ ] suits ) {
this . suits = suits ;
}
public int findTablePoints ( ) {
int points = <num> ;
for ( int i = <num> ; i < this . table . size ( ) ; i ++ ) {
points = points + this . table . get ( i ) . getPoint ( ) ;
}
return points ;
}
public int findWinningPlayer ( int startPlayer ) {
int winningPlayer = <num> ;
String currentWinner = " ;
String openingSuit = this . table . get ( <num> ) . getSuit ( ) ;
Map < Integer , Integer > trumpCards = new HashMap < Integer , Integer > ( ) ;
Map < Integer , Integer > oSuitCards = new HashMap < Integer , Integer > ( ) ;
Map < Integer , Integer > otherCards = new HashMap < Integer , Integer > ( ) ;
for ( int i = <num> ; i < this . table . size ( ) ; i ++ ) {
if ( this . table . get ( i ) . getSuit ( ) == Trump . trumpSuit ) {
trumpCards . put ( i , this . table . get ( i ) . getValue ( ) ) ;
} else if ( this . table . get ( i ) . getSuit ( ) == openingSuit ) {
oSuitCards . put ( i , this . table . get ( i ) . getValue ( ) ) ;
} else {
otherCards . put ( i , this . table . get ( i ) . getValue ( ) ) ;
}
}
if ( trumpCards . size ( ) == <num> ) {
if ( oSuitCards . size ( ) == <num> ) {
otherCards = MapUtil . sortByValue ( otherCards ) ;
currentWinner = otherCards . keySet ( ) . toArray ( ) [ otherCards . size ( )  <num> ] . toString ( ) ;
} else {
oSuitCards = MapUtil . sortByValue ( oSuitCards ) ;
currentWinner = oSuitCards . keySet ( ) . toArray ( ) [ oSuitCards . size ( )  <num> ] . toString ( ) ;
}
} else {
trumpCards = MapUtil . sortByValue ( trumpCards ) ;
currentWinner = trumpCards . keySet ( ) . toArray ( ) [ trumpCards . size ( )  <num> ] . toString ( ) ;
}
if ( currentWinner . equals ( " ) ) {
winningPlayer = <num> ;
} else if ( currentWinner . equals ( " ) ) {
winningPlayer = <num> ;
} else if ( currentWinner . equals ( " ) ) {
winningPlayer = <num> ;
} else if ( currentWinner . equals ( " ) ) {
winningPlayer = <num> ;
}
winningPlayer = startPlayer + winningPlayer ;
if ( winningPlayer > <num> ) {
winningPlayer = winningPlayer  <num> ;
}
return winningPlayer ;
}
import java . util . ArrayList ;
import java . util . Collections ;
import java . util . Comparator ;
import java . util . HashMap ;
import java . util . LinkedHashMap ;
import java . util . LinkedList ;
import java . util . List ;
import java . util . Map ;
public class Play {
List < Card > cardsOnTable ;
List < Card > cardsOnHand ;
int startPlayer ;
int currentPlayer ;
public Play ( List < Card > cardsOnTable , List < Card > cardsOnHand , int startPlayer , int currentPlayer )
{
this . cardsOnTable = cardsOnTable ;
this . cardsOnHand = cardsOnHand ;
this . startPlayer = startPlayer ;
this . currentPlayer = currentPlayer ;
}
public Card throwCard ( ) {
String [ ] faces = new String [ <num> ] ;
String [ ] suits = new String [ <num> ] ;
int [ ] points = new int [ <num> ] ;
String openingSuit ;
Map < Integer , Integer > allPlayerCards = new HashMap < Integer , Integer > ( ) ;
int allHighestCardValue ;
String allHighestCardSuit ;
int allLowestCardValue ;
int lowestCardPosition = <num> ;
String allLowestCardSuit ;
List < Integer > playableCards = new ArrayList < Integer > ( ) ;
List < Integer > trumpCards = new ArrayList < Integer > ( ) ;
int [ ] originTableValues = new int [ <num> ] ;
int [ ] allTableValues = new int [ <num> ] ;
Map < Integer , Integer > originCardsPlayedOnTable = new HashMap < Integer , Integer > ( ) ;
Map < Integer , Integer > allCardsPlayedOnTable = new HashMap < Integer , Integer > ( ) ;
int playedCardValue = <num> ;
String playedCardSuit = " ;
String playedCardFace = " ;
boolean isTrumpCard = false ;
String currentHighestPlayer ;
if ( cardsOnTable . size ( ) == <num> ) {
Map < Integer , Integer > trumpOpenCards = new HashMap < Integer , Integer > ( ) ;
Map < Integer , Integer > otherOpenCards = new HashMap < Integer , Integer > ( ) ;
String playableCardNoText ;
int playableCardNo = <num> ;
for ( int i = <num> ; i < this . cardsOnHand . size ( ) ; i ++ ) {
if ( this . cardsOnHand . get ( i ) . getSuit ( ) == Trump . trumpSuit ) {
trumpOpenCards . put ( i , this . cardsOnHand . get ( i ) . getValue ( ) ) ;
} else {
otherOpenCards . put ( i , this . cardsOnHand . get ( i ) . getValue ( ) ) ;
}
}
if ( otherOpenCards . size ( ) == <num> ) {
trumpOpenCards = MapUtil . sortByValue ( trumpOpenCards ) ;
playableCardNoText = trumpOpenCards . keySet ( ) . toArray ( ) [ trumpOpenCards . size ( )  <num> ] . toString ( ) ;
if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
}
} else {
otherOpenCards = MapUtil . sortByValue ( otherOpenCards ) ;
playableCardNoText = otherOpenCards . keySet ( ) . toArray ( ) [ otherOpenCards . size ( )  <num> ] . toString ( ) ;
if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
}
if ( this . cardsOnHand . get ( playableCardNo ) . getValue ( ) != <num> ) {
playableCardNoText = otherOpenCards . keySet ( ) . toArray ( ) [ <num> ] . toString ( ) ;
if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
} else if ( playableCardNoText . equals ( " ) ) {
playableCardNo = <num> ;
}
}
}
playedCardValue = this . cardsOnHand . get ( playableCardNo ) . getValue ( ) ;
playedCardSuit = this . cardsOnHand . get ( playableCardNo ) . getSuit ( ) ;
} else {
openingSuit = cardsOnTable . get ( <num> ) . getSuit ( ) ;
int counter = <num> ;
for ( int i = <num> ; i < this . cardsOnHand . size ( ) ; i ++ ) {
suits [ i ] = this . cardsOnHand . get ( i ) . getSuit ( ) ;
if ( suits [ i ] . equals ( openingSuit ) ) {
playableCards . add ( this . cardsOnHand . get ( i ) . getValue ( ) ) ;
allPlayerCards . put ( i , <num> ) ;
}
if ( suits [ i ] == Trump . trumpSuit ) {
trumpCards . add ( this . cardsOnHand . get ( i ) . getValue ( ) ) ;
allPlayerCards . put ( i , <num> ) ;
}
if ( ! ( suits [ i ] == openingSuit ) && ! ( suits [ i ] == Trump . trumpSuit ) ) {
allPlayerCards . put ( i , this . cardsOnHand . get ( i ) . getValue ( ) ) ;
}
}
allPlayerCards = MapUtil . sortByValue ( allPlayerCards ) ;
allHighestCardValue = cardsOnHand . get ( allPlayerCards . size ( )  <num> ) . getValue ( ) ;
allHighestCardSuit = cardsOnHand . get ( allPlayerCards . size ( )  <num> ) . getSuit ( ) ;
for ( int key : allPlayerCards . keySet ( ) ) {
if ( allPlayerCards . get ( key ) == <num> ) {
} else {
lowestCardPosition = key ;
break ;
}
}
allLowestCardValue = cardsOnHand . get ( lowestCardPosition ) . getValue ( ) ; ;
allLowestCardSuit = cardsOnHand . get ( lowestCardPosition ) . getSuit ( ) ; ;
Collections . sort ( playableCards ) ;
Collections . sort ( trumpCards ) ;
int counter1 = <num> ;
for ( int i = <num> ; i < this . cardsOnTable . size ( ) ; i ++ ) {
int playerOrderOnTable = this . startPlayer + i ;
if ( playerOrderOnTable > <num> ) {
playerOrderOnTable = playerOrderOnTable  <num> ;
}
if ( cardsOnTable . get ( i ) . getSuit ( ) == openingSuit ) {
originTableValues [ counter1 ] = this . cardsOnTable . get ( i ) . getValue ( ) ;
originCardsPlayedOnTable . put ( playerOrderOnTable , originTableValues [ counter1 ] ) ;
counter1 = counter1 + <num> ;
}
allTableValues [ i ] = this . cardsOnTable . get ( i ) . getValue ( ) ;
allCardsPlayedOnTable . put ( playerOrderOnTable , allTableValues [ i ] ) ;
}
originCardsPlayedOnTable = MapUtil . sortByValue ( originCardsPlayedOnTable ) ;
currentHighestPlayer = originCardsPlayedOnTable . keySet ( ) . toArray ( ) [ originCardsPlayedOnTable . size ( )  <num> ] . toString ( ) ;
int playerWhoCut = <num> ;
int cutCardValue = <num> ;
for ( int i = <num> ; i < this . cardsOnTable . size ( ) ; i ++ ) {
suits [ i ] = this . cardsOnTable . get ( i ) . getSuit ( ) ;
if ( suits [ i ] != openingSuit ) {
if ( suits [ i ] == Trump . trumpSuit ) {
playerWhoCut = startPlayer + i ;
if ( playerWhoCut > <num> ) {
playerWhoCut = playerWhoCut  <num> ;
}
cutCardValue = this . cardsOnTable . get ( i ) . getValue ( ) ;
}
}
}
if ( ( this . currentPlayer == <num> ) || ( this . currentPlayer == <num> ) ) {
if ( ( this . startPlayer == <num> ) || ( this . startPlayer == <num> ) ) {
if ( playableCards . isEmpty ( ) ) {
if ( playerWhoCut == <num> ) {
if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = allHighestCardValue ;
playedCardSuit = allHighestCardSuit ;
} else if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
}
} else {
if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = allHighestCardValue ;
playedCardSuit = allHighestCardSuit ;
} else if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
if ( trumpCards . isEmpty ( ) ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
} else {
for ( int i = <num> ; i < trumpCards . size ( ) ; i ++ ) {
if ( trumpCards . get ( i ) > cutCardValue ) {
playedCardValue = trumpCards . get ( trumpCards . size ( )  <num> ) ;
playedCardSuit = Trump . trumpSuit ;
isTrumpCard = true ;
break ;
} else {
isTrumpCard = false ;
}
}
if ( isTrumpCard == false ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
}
}
}
}
} else {
if ( playerWhoCut != <num> ) {
if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = playableCards . get ( playableCards . size ( )  <num> ) ;
playedCardSuit = openingSuit ;
} else if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = playableCards . get ( <num> ) ;
playedCardSuit = openingSuit ;
}
} else {
if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = playableCards . get ( playableCards . size ( )  <num> ) ;
playedCardSuit = openingSuit ;
} else if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = playableCards . get ( <num> ) ;
playedCardSuit = openingSuit ;
}
}
}
} else if ( ( this . startPlayer == <num> ) || ( this . startPlayer == <num> ) ) {
if ( playableCards . isEmpty ( ) ) {
if ( playerWhoCut == <num> ) {
if ( trumpCards . isEmpty ( ) ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
} else {
playedCardValue = trumpCards . get ( <num> ) ;
playedCardSuit = Trump . trumpSuit ;
}
} else {
if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = allHighestCardValue ;
playedCardSuit = allHighestCardSuit ;
} else if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
if ( trumpCards . isEmpty ( ) ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
} else {
for ( int i = <num> ; i < trumpCards . size ( ) ; i ++ ) {
if ( trumpCards . get ( i ) > cutCardValue ) {
playedCardValue = trumpCards . get ( trumpCards . size ( )  <num> ) ;
playedCardSuit = Trump . trumpSuit ;
isTrumpCard = true ;
break ;
} else {
isTrumpCard = false ;
}
}
if ( isTrumpCard == false ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
}
}
}
}
} else {
if ( playerWhoCut != <num> ) {
if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = playableCards . get ( playableCards . size ( )  <num> ) ;
playedCardSuit = openingSuit ;
} else if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = playableCards . get ( <num> ) ;
playedCardSuit = openingSuit ;
}
} else {
if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = playableCards . get ( playableCards . size ( )  <num> ) ;
playedCardSuit = openingSuit ;
} else if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = playableCards . get ( <num> ) ;
playedCardSuit = openingSuit ;
}
}
}
}
} else if ( ( this . currentPlayer == <num> ) || ( this . currentPlayer == <num> ) ) {
if ( ( this . startPlayer == <num> ) || ( this . startPlayer == <num> ) ) {
if ( playableCards . isEmpty ( ) ) {
if ( playerWhoCut == <num> ) {
if ( trumpCards . isEmpty ( ) ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
} else {
playedCardValue = trumpCards . get ( <num> ) ;
playedCardSuit = Trump . trumpSuit ;
}
} else {
if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = allHighestCardValue ;
playedCardSuit = allHighestCardSuit ;
} else if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
if ( trumpCards . isEmpty ( ) ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
} else {
for ( int i = <num> ; i < trumpCards . size ( ) ; i ++ ) {
if ( trumpCards . get ( i ) > cutCardValue ) {
playedCardValue = trumpCards . get ( trumpCards . size ( )  <num> ) ;
playedCardSuit = Trump . trumpSuit ;
isTrumpCard = true ;
break ;
} else {
isTrumpCard = false ;
}
}
if ( isTrumpCard == false ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
}
}
}
}
} else {
if ( playerWhoCut != <num> ) {
if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = playableCards . get ( playableCards . size ( )  <num> ) ;
playedCardSuit = openingSuit ;
} else if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = playableCards . get ( <num> ) ;
playedCardSuit = openingSuit ;
}
} else {
if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = playableCards . get ( playableCards . size ( )  <num> ) ;
playedCardSuit = openingSuit ;
} else if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = playableCards . get ( <num> ) ;
playedCardSuit = openingSuit ;
}
}
}
} else if ( ( this . startPlayer == <num> ) || ( this . startPlayer == <num> ) ) {
if ( playableCards . isEmpty ( ) ) {
if ( playerWhoCut == <num> ) {
if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = allHighestCardValue ;
playedCardSuit = allHighestCardSuit ;
} else if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
}
} else {
if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = allHighestCardValue ;
playedCardSuit = allHighestCardSuit ;
} else if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
if ( trumpCards . isEmpty ( ) ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
} else {
for ( int i = <num> ; i < trumpCards . size ( ) ; i ++ ) {
if ( trumpCards . get ( i ) > cutCardValue ) {
playedCardValue = trumpCards . get ( trumpCards . size ( )  <num> ) ;
playedCardSuit = Trump . trumpSuit ;
isTrumpCard = true ;
break ;
} else {
isTrumpCard = false ;
}
}
if ( isTrumpCard == false ) {
playedCardValue = allLowestCardValue ;
playedCardSuit = allLowestCardSuit ;
}
}
}
}
} else {
if ( playerWhoCut != <num> ) {
if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = playableCards . get ( playableCards . size ( )  <num> ) ;
playedCardSuit = openingSuit ;
} else if ( ( playerWhoCut == <num> ) || ( playerWhoCut == <num> ) ) {
playedCardValue = playableCards . get ( <num> ) ;
playedCardSuit = openingSuit ;
}
} else {
if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = playableCards . get ( playableCards . size ( )  <num> ) ;
playedCardSuit = openingSuit ;
} else if ( ( currentHighestPlayer . equals ( " ) ) || ( currentHighestPlayer . equals ( " ) ) ) {
playedCardValue = playableCards . get ( <num> ) ;
playedCardSuit = openingSuit ;
}
}
}
}
}
}
if ( playedCardValue == <num> ) {
playedCardFace = " ;
} else if ( playedCardValue == <num> ) {
playedCardFace = " ;
} else if ( playedCardValue == <num> ) {
playedCardFace = " ;
} else if ( playedCardValue == <num> ) {
playedCardFace = " ;
} else if ( playedCardValue == <num> ) {
playedCardFace = " ;
} else if ( playedCardValue == <num> ) {
playedCardFace = " ;
} else if ( playedCardValue == <num> ) {
playedCardFace = " ;
} else if ( playedCardValue == <num> ) {
playedCardFace = " ;
}
Card thrownCard = new Card ( playedCardFace , playedCardSuit ) ;
return thrownCard ;
}
public class Card
{
private String face ;
private String suit ;
public Card ( String cardFace , String cardSuit )
{
face = cardFace ;
suit = cardSuit ;
}
public String toString ( )
{
return face + " + suit ;
}
public String getFace ( )
{
return face ;
}
public int getValue ( )
{
int faceValue = <num> ;
if ( this . getFace ( ) == " ) {
faceValue = <num> ;
} else if ( this . getFace ( ) == " ) {
faceValue = <num> ;
} else if ( this . getFace ( ) == " ) {
faceValue = <num> ;
} else if ( this . getFace ( ) == " ) {
faceValue = <num> ;
} else if ( this . getFace ( ) == " ) {
faceValue = <num> ;
} else if ( this . getFace ( ) == " ) {
faceValue = <num> ;
} else if ( this . getFace ( ) == " ) {
faceValue = <num> ;
} else if ( this . getFace ( ) == " ) {
faceValue = <num> ;
}
return faceValue ;
}
public int getPoint ( ) {
int value = <num> ;
if ( this . getFace ( ) . equals ( " ) ) {
value = <num> ;
} else if ( this . getFace ( ) . equals ( " ) ) {
value = <num> ;
} else if ( this . getFace ( ) . equals ( " ) ) {
value = <num> ;
} else if ( this . getFace ( ) . equals ( " ) ) {
value = <num> ;
}
return value ;
}
public String getSuit ( )
{
return suit ;
}
}
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
public class Game
{
@SuppressWarnings("unchecked")
public static void main ( String [ ] args )
{
DeckOfCards deck = new DeckOfCards ( ) ;
List < List > playerHands = new ArrayList < List > ( ) ;
Hand indPlayerHand = null ;
Map < Integer , Hand > allPlayerHands = new HashMap < Integer , Hand > ( ) ;
Table <unk> = null ;
List < Table > <unk> = new ArrayList < Table > ( ) ;
int numberPlayers = <num> ;
int numberShuffles = <num> ;
int roundStartPlayer = <num> ;
int startPlayer ;
Card <unk> = new Card ( " , " ) ;
for ( int i = <num> ; i < numberShuffles ; i ++ ) {
deck . shuffle ( ) ;
}
for ( int playercount = <num> ; playercount < numberPlayers ; playercount ++ ) {
List < Card > handCards = new ArrayList < Card > ( ) ;
for ( int i = <num> ; i < <num> ; i ++ ) {
handCards . add ( deck . dealCard ( ) ) ;
}
playerHands . add ( handCards ) ;
System . out . println ( " ) ;
System . out . println ( " + playercount + " ) ;
indPlayerHand = new Hand ( playerHands . get ( playercount ) ) ;
indPlayerHand . show ( ) ;
allPlayerHands . put ( playercount , indPlayerHand ) ;
}
System . out . println ( " ) ;
Trump playerTrumpCards = new Trump ( allPlayerHands . get ( roundStartPlayer ) . getHand ( ) ) ;
int trumpValue = playerTrumpCards . setTrumpCall ( ) ;
System . out . println ( " + trumpValue ) ;
Card trumpCard = playerTrumpCards . setTrumpCard ( ) ;
System . out . println ( " + trumpCard . getFace ( ) + " + trumpCard . getSuit ( ) ) ;
for ( int playercount = <num> ; playercount < numberPlayers ; playercount ++ ) {
for ( int i = <num> ; i < <num> ; i ++ ) {
playerHands . get ( playercount ) . add ( deck . dealCard ( ) ) ;
}
System . out . println ( " ) ;
System . out . println ( " + playercount + " ) ;
indPlayerHand = new Hand ( playerHands . get ( playercount ) ) ;
indPlayerHand . show ( ) ;
allPlayerHands . remove ( playercount ) ;
allPlayerHands . put ( playercount , indPlayerHand ) ;
}
System . out . println ( " ) ;
int teamAScores = <num> ;
int teamBScores = <num> ;
startPlayer = roundStartPlayer ;
for ( int round = <num> ; round < <num> ; round ++ ) {
System . out . println ( " ) ;
System . out . println ( " + round ) ;
List < Card > cardsOnTable = new ArrayList < Card > ( ) ;
for ( int i = <num> ; i < <num> ; i ++ ) {
if ( startPlayer > <num> ) { startPlayer = startPlayer  <num> ; }
int incrementor = startPlayer + i ;
if ( incrementor > <num> ) { incrementor = incrementor  <num> ; }
Play gamePlay = new Play ( cardsOnTable , allPlayerHands . get ( incrementor ) . getHand ( ) , startPlayer , incrementor ) ;
Card playedCard = gamePlay . throwCard ( ) ;
System . out . println ( playedCard . getFace ( ) + " + playedCard . getSuit ( ) ) ;
cardsOnTable . add ( playedCard ) ;
List < Card > restructuredListOfCards = allPlayerHands . get ( incrementor ) . removeCard ( playedCard ) ;
Hand restructuredHand = new Hand ( restructuredListOfCards ) ;
allPlayerHands . put ( incrementor , restructuredHand ) ;
}
Table tableAnalyst = new Table ( cardsOnTable ) ;
int pointsInRound = tableAnalyst . findTablePoints ( ) ;
int winningPlayer = tableAnalyst . findWinningPlayer ( startPlayer ) ;
System . out . println ( " + winningPlayer ) ;
System . out . println ( " + pointsInRound ) ;
System . out . println ( " ) ;
if ( ( winningPlayer == <num> ) || ( winningPlayer == <num> ) ) {
teamAScores = teamAScores + pointsInRound ;
} else if ( ( winningPlayer == <num> ) || ( winningPlayer == <num> ) ) {
teamBScores = teamBScores + pointsInRound ;
}
startPlayer = winningPlayer ;
}
if ( ( roundStartPlayer == <num> ) || ( roundStartPlayer == <num> ) ) {
if ( teamAScores >= trumpValue ) {
System . out . println ( " + trumpValue + " + teamAScores + " ) ;
} else {
System . out . println ( " + trumpValue + " + teamAScores + " ) ;
}
} else if ( ( roundStartPlayer == <num> ) || ( roundStartPlayer == <num> ) ) {
if ( teamBScores == trumpValue ) {
System . out . println ( " + trumpValue + " + teamBScores + " ) ;
} else {
System . out . println ( " + trumpValue + " + teamBScores + " ) ;
}
}
}
import java . util . ArrayList ;
import java . util . Collections ;
import java . util . Comparator ;
import java . util . HashMap ;
import java . util . LinkedHashMap ;
import java . util . LinkedList ;
import java . util . List ;
import java . util . Map ;
public class Trump
{
List < Card > hand = new ArrayList < Card > ( ) ;
public static int trumpCall ;
public static String trumpFace ;
public static String trumpSuit ;
public static Card trumpCard ;
public Trump ( List < Card > hands )
{
setTrump ( hands ) ;
}
public void setTrump ( List < Card > hands ) {
this . hand = hands ;
}
public Card setTrumpCard ( ) {
trumpCard = new Card ( this . trumpFace , this . trumpSuit ) ;
return trumpCard ;
}
public int setTrumpCall ( ) {
String [ ] faces = new String [ <num> ] ;
String [ ] suits = new String [ <num> ] ;
int [ ] points = new int [ <num> ] ;
int [ ] values = new int [ <num> ] ;
int totalpoints = <num> ;
int pointClubs = <num> ;
int pointHearts = <num> ;
int pointDiamonds = <num> ;
int pointSpades = <num> ;
int valueClubs = <num> ;
int valueHearts = <num> ;
int valueDiamonds = <num> ;
int valueSpades = <num> ;
int countClubs = <num> ;
int countHearts = <num> ;
int countDiamonds = <num> ;
int countSpades = <num> ;
Map < String , Integer > cCountMap = new HashMap < String , Integer > ( ) ;
Map < String , Integer > cPointMap = new HashMap < String , Integer > ( ) ;
Map < String , Integer > cValueMap = new HashMap < String , Integer > ( ) ;
int LowestClubs = <num> ;
int LowestHearts = <num> ;
int LowestDiamonds = <num> ;
int LowestSpades = <num> ;
int bufferTrumpAddOn = <num> ;
int trumpFaceValue = <num> ;
for ( int i = <num> ; i < <num> ; i ++ ) {
faces [ i ] = this . hand . get ( i ) . getFace ( ) ;
points [ i ] = this . hand . get ( i ) . getPoint ( ) ;
values [ i ] = this . hand . get ( i ) . getValue ( ) ;
suits [ i ] = this . hand . get ( i ) . getSuit ( ) ;
if ( suits [ i ] . equals ( " ) ) {
pointClubs = pointClubs + points [ i ] ;
valueClubs = valueClubs + values [ i ] ;
countClubs ++ ;
if ( countClubs == <num> ) {
LowestClubs = values [ i ] ;
} else if ( countClubs > <num> ) {
if ( values [ i ] < LowestClubs ) {
LowestClubs = values [ i ] ;
}
}
} else if ( suits [ i ] . equals ( " ) ) {
pointHearts = pointHearts + points [ i ] ;
valueHearts = valueHearts + values [ i ] ;
countHearts ++ ;
if ( countHearts == <num> ) {
LowestHearts = values [ i ] ;
} else if ( countHearts > <num> ) {
if ( values [ i ] < LowestHearts ) {
LowestHearts = values [ i ] ;
}
}
} else if ( suits [ i ] . equals ( " ) ) {
pointDiamonds = pointDiamonds + points [ i ] ;
valueDiamonds = valueDiamonds + values [ i ] ;
countDiamonds ++ ;
if ( countDiamonds == <num> ) {
LowestDiamonds = values [ i ] ;
} else if ( countDiamonds > <num> ) {
if ( values [ i ] < LowestDiamonds ) {
LowestDiamonds = values [ i ] ;
}
}
} else if ( suits [ i ] . equals ( " ) ) {
pointSpades = pointSpades + points [ i ] ;
valueSpades = valueSpades + values [ i ] ;
countSpades ++ ;
if ( countSpades == <num> ) {
LowestSpades = values [ i ] ;
} else if ( countSpades > <num> ) {
if ( values [ i ] < LowestSpades ) {
LowestSpades = values [ i ] ;
}
}
}
totalpoints = totalpoints + points [ i ] ;
}
cValueMap . put ( " , valueClubs ) ;
cValueMap . put ( " , valueHearts ) ;
cValueMap . put ( " , valueDiamonds ) ;
cValueMap . put ( " , valueSpades ) ;
cPointMap . put ( " , pointClubs ) ;
cPointMap . put ( " , pointHearts ) ;
cPointMap . put ( " , pointDiamonds ) ;
cPointMap . put ( " , pointSpades ) ;
cCountMap . put ( " , countClubs ) ;
cCountMap . put ( " , countHearts ) ;
cCountMap . put ( " , countDiamonds ) ;
cCountMap . put ( " , countSpades ) ;
cValueMap = MapUtil . sortByValue ( cValueMap ) ;
cPointMap = MapUtil . sortByValue ( cPointMap ) ;
cCountMap = MapUtil . sortByValue ( cCountMap ) ;
if ( ( cValueMap . keySet ( ) . toString ( ) . equals ( cPointMap . keySet ( ) . toString ( ) ) ) && ( cPointMap . keySet ( ) . toString ( ) . equals ( cCountMap . keySet ( ) . toString ( ) ) )
&& ( cValueMap . keySet ( ) . toString ( ) . equals ( cCountMap . keySet ( ) . toString ( ) ) ) ) {
Trump . trumpSuit = cValueMap . keySet ( ) . toArray ( ) [ <num> ] . toString ( ) ;
} else if ( ( cValueMap . keySet ( ) . toString ( ) . equals ( cPointMap . keySet ( ) . toString ( ) ) ) && ( cValueMap . keySet ( ) . toString ( ) . equals ( cCountMap . keySet ( ) . toString ( ) ) ) ) {
Trump . trumpSuit = cValueMap . keySet ( ) . toArray ( ) [ <num> ] . toString ( ) ;
} else if ( ( cPointMap . keySet ( ) . toString ( ) . equals ( cValueMap . keySet ( ) . toString ( ) ) ) && ( cPointMap . keySet ( ) . toString ( ) . equals ( cCountMap . keySet ( ) . toString ( ) ) ) ) {
Trump . trumpSuit = cPointMap . keySet ( ) . toArray ( ) [ <num> ] . toString ( ) ;
} else if ( ( cCountMap . keySet ( ) . toString ( ) . equals ( cValueMap . keySet ( ) . toString ( ) ) ) && ( cCountMap . keySet ( ) . toString ( ) . equals ( cPointMap . keySet ( ) . toString ( ) ) ) ) {
Trump . trumpSuit = cCountMap . keySet ( ) . toArray ( ) [ <num> ] . toString ( ) ;
} else {
Trump . trumpSuit = cValueMap . keySet ( ) . toArray ( ) [ <num> ] . toString ( ) ;
}
if ( cPointMap . get ( Trump . trumpSuit ) < <num> ) {
bufferTrumpAddOn = <num> ;
} else if ( ( cPointMap . get ( Trump . trumpSuit ) > <num> ) && ( cPointMap . get ( Trump . trumpSuit ) < <num> ) ) {
bufferTrumpAddOn = <num> ;
} else if ( ( cPointMap . get ( Trump . trumpSuit ) > <num> ) && ( cPointMap . get ( Trump . trumpSuit ) < <num> ) ) {
bufferTrumpAddOn = <num> ;
} else if ( ( cPointMap . get ( Trump . trumpSuit ) > <num> ) && ( cPointMap . get ( Trump . trumpSuit ) < <num> ) ) {
bufferTrumpAddOn = <num> ;
}
System . out . println ( " ) ;
if ( Trump . trumpSuit . equals ( " ) ) {
trumpFaceValue = LowestClubs ;
} else if ( Trump . trumpSuit . equals ( " ) ) {
trumpFaceValue = LowestHearts ;
} else if ( Trump . trumpSuit . equals ( " ) ) {
trumpFaceValue = LowestDiamonds ;
} else if ( Trump . trumpSuit . equals ( " ) ) {
trumpFaceValue = LowestSpades ;
}
switch ( trumpFaceValue ) {
case <num> : Trump . trumpFace = " ;
break ;
case <num> : Trump . trumpFace = " ;
break ;
case <num> : Trump . trumpFace = " ;
break ;
case <num> : Trump . trumpFace = " ;
break ;
case <num> : Trump . trumpFace = " ;
break ;
case <num> : Trump . trumpFace = " ;
break ;
case <num> : Trump . trumpFace = " ;
break ;
case <num> : Trump . trumpFace = " ;
break ;
}
switch ( totalpoints ) {
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
case <num> : Trump . trumpCall = <num> + bufferTrumpAddOn ;
break ;
}
return Trump . trumpCall ;
}
import java . util . Random ;
public class DeckOfCards
{
private Card [ ] deck ;
private int currentCard ;
private static final int NUMBER_OF_CARDS = <num> ;
private static final Random randomNumbers = new Random ( ) ;
public DeckOfCards ( )
{
String [ ] faces = { " , " , " , " , " , " , " , " } ;
String [ ] suits = { " , " , " , " } ;
deck = new Card [ NUMBER_OF_CARDS ] ;
currentCard = <num> ;
for ( int count = <num> ; count < deck . length ; count ++ )
deck [ count ] = new Card ( faces [ count % <num> ] , suits [ count / <num> ] ) ;
}
public void shuffle ( )
{
currentCard = <num> ;
for ( int first = <num> ; first < deck . length ; first ++ )
{
int second = randomNumbers . nextInt ( NUMBER_OF_CARDS ) ;
Card temp = deck [ first ] ;
deck [ first ] = deck [ second ] ;
deck [ second ] = temp ;
}
}
public Card dealCard ( )
{
if ( currentCard < deck . length )
return deck [ currentCard ++ ] ;
else
return null ;
}
}
import java . util . ArrayList ;
import java . util . List ;
public class Hand
{
List < Card > hand = new ArrayList < Card > ( ) ;
private int [ ] faces = new int [ <num> ] ;
private int [ ] suits = new int [ <num> ] ;
public Hand ( List < Card > cards )
{
setHand ( cards ) ;
}
public void show ( )
{
for ( Card temp : hand ) {
System . out . print ( temp . getFace ( ) + " + temp . getSuit ( ) + " ) ;
}
}
public List < Card > getHand ( ) {
return hand ;
}
public Card <unk> ( int index ) {
return hand . get ( index ) ;
}
public void setHand ( List < Card > hand ) {
this . hand = hand ;
}
public String getFaces ( int item ) {
return hand . get ( item ) . getFace ( ) ;
}
public int getPoints ( int item ) {
String faceValue = hand . get ( item ) . getFace ( ) ;
int value = <num> ;
if ( faceValue . equals ( " ) ) {
value = <num> ;
} else if ( faceValue . equals ( " ) ) {
value = <num> ;
} else if ( faceValue . equals ( " ) ) {
value = <num> ;
} else if ( faceValue . equals ( " ) ) {
value = <num> ;
}
return value ;
}
public void setFaces ( int [ ] faces ) {
this . faces = faces ;
}
public String getSuits ( int item ) {
return hand . get ( item ) . getSuit ( ) ;
}
public void <unk> ( int [ ] suits ) {
this . suits = suits ;
}
public List < Card > removeCard ( Card cardtoRemove ) {
for ( int i = <num> ; i < this . hand . size ( ) ; i ++ ) {
if ( ( this . hand . get ( i ) . getFace ( ) . equals ( cardtoRemove . getFace ( ) ) ) && ( this . hand . get ( i ) . getSuit ( ) . equals ( cardtoRemove . getSuit ( ) ) ) ) {
this . hand . remove ( i ) ;
}
}
return this . hand ;
}
import java . util . Collections ;
import java . util . Comparator ;
import java . util . LinkedHashMap ;
import java . util . LinkedList ;
import java . util . List ;
import java . util . Map ;
class MapUtil
{
public static < K , V extends Comparable < ? super V >> Map < K , V >
sortByValue ( Map < K , V > map )
{
List < Map . Entry < K , V >> list =
new LinkedList < Map . Entry < K , V >> ( map . entrySet ( ) ) ;
Collections . sort ( list , new Comparator < Map . Entry < K , V >> ( )
{
public int compare ( Map . Entry < K , V > o1 , Map . Entry < K , V > o2 )
{
return ( o1 . getValue ( ) ) . compareTo ( o2 . getValue ( ) ) ;
}
} ) ;
Map < K , V > result = new LinkedHashMap < K , V > ( ) ;
for ( Map . Entry < K , V > entry : list )
result . put ( entry . getKey ( ) , entry . getValue ( ) ) ;
return result ;
}
}
import java . util . Arrays ;
import java . util . HashMap ;
public class ProductFactory {
private Product p ;
String [ ] productsList = { " , " , " , " } ;
public Product getProduct ( String name ) {
p = null ;
Boolean has_Product = false ;
for ( int i = <num> ; i < productsList . length ; i ++ ) {
if ( name . equals ( productsList [ i ] ) )
has_Product = true ;
}
if ( ! has_Product ) {
return p ;
}
if ( name . equals ( " ) ) {
p = new Product ( ) ;
p . setName ( name ) ;
p . setUnitPrice ( <num> ) ;
p . addDiscount ( <num> , <num> ) ;
return p ;
}
if ( name . equals ( " ) ) {
p = new Product ( ) ;
p . setName ( name ) ;
p . setUnitPrice ( <num> ) ;
p . addDiscount ( <num> , <num> ) ;
return p ;
}
if ( name . equals ( " ) ) {
p = new Product ( ) ;
p . setName ( name ) ;
p . setUnitPrice ( <num> ) ;
return p ;
}
if ( name . equals ( " ) ) {
p = new Product ( ) ;
p . setName ( name ) ;
p . setUnitPrice ( <num> ) ;
return p ;
}
return p ;
}
private class Product implements IProduct , Cloneable {
class Discount {
private HashMap < Integer , Double > map ;
private Object [ ] key ;
public Discount ( ) {
map = new HashMap < Integer , Double > ( ) ;
}
public void addDiscount ( int num , double cost ) {
map . put ( num , cost ) ;
update ( ) ;
}
public void update ( ) {
key = map . keySet ( ) . toArray ( ) ;
Arrays . sort ( key ) ;
}
public int getDiscuntItemsTotalNum ( ) {
return key . length ;
}
public int getDiscountNums ( int disCnts ) {
return ( Integer ) key [ disCnts ] ;
}
public double getDiscountPrice ( int disCnts ) {
return ( Double ) map . get ( key [ disCnts ] ) ;
}
}
private String name ;
private int nums ;
private double unitPrice ;
private double totalPrice ;
private Discount discount ;
public Product ( ) {
nums = <num> ;
unitPrice = <num> ;
totalPrice = <num> ;
discount = new Discount ( ) ;
}
public Product clone ( ) {
Product O = new Product ( ) ;
O . name = this . name ;
O . nums = this . nums ;
O . totalPrice = this . totalPrice ;
O . unitPrice = this . unitPrice ;
O . discount = new Discount ( ) ;
O . discount . map = new HashMap < Integer , Double > ( ) ;
for ( int i = <num> ; i < this . discount . map . size ( ) ; i ++ ) {
O . discount . map . put ( ( Integer ) this . discount . key [ i ] ,
this . discount . map . get ( this . discount . key [ i ] ) ) ;
}
O . discount . key = O . discount . map . keySet ( ) . toArray ( ) ;
return O ;
}
public int getNums ( ) {
return nums ;
}
public void setNums ( int nums ) {
this . nums = nums ;
}
public double getUnitPrice ( ) {
return unitPrice ;
}
public void setUnitPrice ( double unitPrice ) {
this . unitPrice = unitPrice ;
this . discount . addDiscount ( <num> , unitPrice ) ;
}
public double getTotalPrice ( ) {
totalPrice = calPrice ( ) ;
return totalPrice ;
}
public void setName ( String name ) {
this . name = name ;
}
public String getName ( ) {
return this . name ;
}
public void addDiscount ( int num , double cost ) {
this . discount . addDiscount ( num , cost ) ;
}
public void insert2Basket ( Basket basket , int nums ) {
basket . addProducts ( this , nums ) ;
}
private double calPrice ( ) {
this . totalPrice = <num> ;
totalPrice = cal ( this . nums , discount . getDiscuntItemsTotalNum ( )  <num> ) ;
return totalPrice ;
}
private double cal ( int nums , int disLevelCnts ) {
double result = <num> ;
double currDisPrice = discount . getDiscountPrice ( disLevelCnts ) ;
int currDisNums = discount . getDiscountNums ( disLevelCnts ) ;
int cnts = nums / currDisNums ;
int left = nums % currDisNums ;
if ( left != <num> ) {
result = currDisPrice * cnts + cal ( left , disLevelCnts  <num> ) ;
} else {
result = currDisPrice * cnts ;
}
return result ;
}
}
}
import java . util . ArrayList ;
public class Parser {
private String productsString ;
private ArrayList < IProduct > products ;
private ProductFactory pfactory ;
public void feed ( String str ) {
productsString = str ;
}
public ArrayList < IProduct > getProducts ( ) {
pfactory = new ProductFactory ( ) ;
products = new ArrayList < IProduct > ( ) ;
analyseString ( ) ;
return products ;
}
private void analyseString ( )
{
IProduct A = pfactory . getProduct ( " ) ;
IProduct B = pfactory . getProduct ( " ) ;
IProduct C = pfactory . getProduct ( " ) ;
IProduct D = pfactory . getProduct ( " ) ;
A . setNums ( <num> ) ;
B . setNums ( <num> ) ;
C . setNums ( <num> ) ;
D . setNums ( <num> ) ;
String tmpStr = " ;
for ( int i = <num> ; i < productsString . length ( ) ; i ++ )
{
tmpStr += productsString . charAt ( i ) ;
if ( " . equals ( tmpStr ) )
A . setNums ( A . getNums ( ) + <num> ) ;
if ( " . equals ( tmpStr ) )
B . setNums ( B . getNums ( ) + <num> ) ;
if ( " . equals ( tmpStr ) )
C . setNums ( C . getNums ( ) + <num> ) ;
if ( " . equals ( tmpStr ) )
D . setNums ( D . getNums ( ) + <num> ) ;
tmpStr = " ;
}
products . add ( A ) ;
products . add ( B ) ;
products . add ( C ) ;
products . add ( D ) ;
}
public static int price ( String str ) {
CheckStand checkStand = new CheckStand ( ) ;
Basket basket = new Basket ( ) ;
Parser ps = new Parser ( ) ;
ps . feed ( str ) ;
ArrayList < IProduct > products_from_parser = ps . getProducts ( ) ;
for ( IProduct pd : products_from_parser ) {
pd . insert2Basket ( basket , pd . getNums ( ) ) ;
}
double result = checkStand . getTotalPrice ( basket ) ;
return ( int ) result ;
}
public static void main ( String [ ] args )
{
System . out . print ( price ( " ) ) ;
}
}
public interface IProduct {
public int getNums ( ) ;
void setNums ( int nums ) ;
public double getUnitPrice ( ) ;
public void setUnitPrice ( double unitPrice ) ;
public double getTotalPrice ( ) ;
public void setName ( String name ) ;
public String getName ( ) ;
public void addDiscount ( int num , double cost ) ;
public void insert2Basket ( Basket basket , int nums ) ;
public Object clone ( ) ;
}
import java . util . ArrayList ;
public class Basket {
private ArrayList < IProduct > products ;
public Basket ( ) {
products = new ArrayList < IProduct > ( ) ;
}
public void addProducts ( IProduct currProduct , int nums ) {
IProduct copy = null ;
if ( products . isEmpty ( ) ) {
copy = ( IProduct ) currProduct . clone ( ) ;
copy . setNums ( <num> ) ;
products . add ( copy ) ;
addNums ( currProduct . getName ( ) , nums ) ;
return ;
}
for ( IProduct product : products ) {
if ( currProduct . getName ( ) . equals ( product . getName ( ) ) ) {
addNums ( product . getName ( ) , nums ) ;
return ;
}
}
copy = ( IProduct ) currProduct . clone ( ) ;
copy . setNums ( <num> ) ;
products . add ( copy ) ;
addNums ( currProduct . getName ( ) , nums ) ;
return ;
}
public void addNums ( String string , int nums ) {
for ( IProduct product : this . products ) {
if ( product . getName ( ) . equals ( string ) )
product . setNums ( product . getNums ( ) + nums ) ;
}
}
public ArrayList < IProduct > getProducts ( ) {
return this . products ;
}
public void <unk> ( ) {
for ( IProduct p : products ) {
System . out . println ( p . getName ( ) + " + p . getNums ( ) ) ;
}
}
import junit . framework . TestCase ;
import org . junit . After ;
import org . junit . Before ;
import org . junit . Test ;
import java . util . ArrayList ;
public class TestAll extends TestCase {
private CheckStand checkStand ;
private Basket basket ;
private ProductFactory productFactory ;
private IProduct A ;
private IProduct B ;
@Before
public void setUp ( ) throws Exception {
checkStand = new CheckStand ( ) ;
basket = new Basket ( ) ;
productFactory = new ProductFactory ( ) ;
A = productFactory . getProduct ( " ) ;
B = productFactory . getProduct ( " ) ;
A . insert2Basket ( basket , <num> ) ;
A . insert2Basket ( basket , <num> ) ;
B . insert2Basket ( basket , <num> ) ;
}
@After
public void tearDown ( ) throws Exception {
}
@Test
public void <unk> ( ) {
A = productFactory . getProduct ( " ) ;
assertEquals ( " , A . getName ( ) ) ;
}
@Test
public void <unk> ( ) {
IProduct AA = productFactory . getProduct ( " ) ;
AA . setNums ( <num> ) ;
AA . addDiscount ( <num> , <num> ) ;
assertEquals ( <num> , AA . getTotalPrice ( ) ) ;
}
@Test
public void <unk> ( ) {
ArrayList < IProduct > products = basket . getProducts ( ) ;
for ( IProduct product : products ) {
if ( product . getName ( ) . equals ( " ) ) {
assertEquals ( <num> , product . getNums ( ) ) ;
}
if ( product . getName ( ) . equals ( " ) ) {
assertEquals ( <num> , product . getNums ( ) ) ;
}
}
}
@Test
public void <unk> ( ) {
double result = checkStand . getTotalPrice ( basket ) ;
assertEquals ( <num> , result ) ;
}
@Test
public void <unk> ( ) {
Basket largeBasket = new Basket ( ) ;
IProduct itemA = productFactory . getProduct ( " ) ;
IProduct itemB = productFactory . getProduct ( " ) ;
IProduct itemC = productFactory . getProduct ( " ) ;
IProduct itemD = productFactory . getProduct ( " ) ;
itemA . insert2Basket ( largeBasket , <num> ) ;
itemB . insert2Basket ( largeBasket , <num> ) ;
itemA . insert2Basket ( largeBasket , <num> ) ;
itemB . insert2Basket ( largeBasket , <num> ) ;
itemC . insert2Basket ( largeBasket , <num> ) ;
itemD . insert2Basket ( largeBasket , <num> ) ;
double totalPrice = <num> ;
totalPrice = checkStand . getTotalPrice ( largeBasket ) ;
assertEquals ( <num> , totalPrice ) ;
}
@Test
public void testClone ( ) throws CloneNotSupportedException {
IProduct origin = productFactory . getProduct ( " ) ;
IProduct copy = ( IProduct ) origin . clone ( ) ;
assertEquals ( copy . getName ( ) , origin . getName ( ) ) ;
}
@Test
public void <unk> ( ) {
String str = " ;
basket = new Basket ( ) ;
Parser ps = new Parser ( ) ;
ps . feed ( str ) ;
ArrayList < IProduct > products_from_parser = ps . getProducts ( ) ;
for ( IProduct pd : products_from_parser ) {
pd . insert2Basket ( basket , pd . getNums ( ) ) ;
}
double result = checkStand . getTotalPrice ( basket ) ;
assertEquals ( <num> , result ) ;
}
public int price ( String str ) {
CheckStand checkStand = new CheckStand ( ) ;
Basket basket = new Basket ( ) ;
Parser ps = new Parser ( ) ;
ps . feed ( str ) ;
ArrayList < IProduct > products_from_parser = ps . getProducts ( ) ;
for ( IProduct pd : products_from_parser ) {
pd . insert2Basket ( basket , pd . getNums ( ) ) ;
}
double result = checkStand . getTotalPrice ( basket ) ;
return ( int ) result ;
}
@Test
public void <unk> ( ) {
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
assertEquals ( <num> , price ( " ) ) ;
}
}
import java . util . ArrayList ;
public class CheckStand {
public double getTotalPrice ( Basket basket ) {
double result = <num> ;
ArrayList < IProduct > products = basket . getProducts ( ) ;
for ( IProduct product : products ) {
result += product . getTotalPrice ( ) ;
}
return result ;
}
public static int price ( String str ) {
CheckStand checkStand = new CheckStand ( ) ;
Basket basket = new Basket ( ) ;
Parser ps = new Parser ( ) ;
ps . feed ( str ) ;
ArrayList < IProduct > products_from_parser = ps . getProducts ( ) ;
for ( IProduct pd : products_from_parser ) {
pd . insert2Basket ( basket , pd . getNums ( ) ) ;
}
double result = checkStand . getTotalPrice ( basket ) ;
return ( int ) result ;
}
public static void main ( String [ ] args ) {
System . out . println ( " ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
System . out . println ( " + " + price ( " ) ) ;
}
}
package NCoder ;
import javax . swing . JOptionPane ;
import javax . swing . UIManager ;
public class MainApp extends javax . swing . JFrame {
int timeout = <num> ;
public MainApp ( ) {
try {
UIManager . setLookAndFeel ( " ) ;
} catch ( Exception ex ) {
ex . printStackTrace ( ) ;
}
initComponents ( ) ;
pack ( ) ;
NCoder . generateTable ( ) ;
keyField . selectAll ( ) ;
keyField . requestFocus ( ) ;
System . out . println ( getHeight ( ) ) ;
}
@SuppressWarnings("unchecked")
private void initComponents ( ) {
jTextField1 = new javax . swing . JTextField ( ) ;
tabbedPane = new javax . swing . JTabbedPane ( ) ;
encoderPanel = new javax . swing . JPanel ( ) ;
EclrTxtLbl = new javax . swing . JLabel ( ) ;
EclrTxtSP = new javax . swing . JScrollPane ( ) ;
EclearTxt = new javax . swing . JTextArea ( ) ;
EcodeTxtLbl = new javax . swing . JLabel ( ) ;
EcodeTxtSP = new javax . swing . JScrollPane ( ) ;
EcodeTxt = new javax . swing . JTextArea ( ) ;
EcopyBtn = new javax . swing . JButton ( ) ;
EpasteBtn = new javax . swing . JButton ( ) ;
decoderPanel = new javax . swing . JPanel ( ) ;
EclrTxtSP1 = new javax . swing . JScrollPane ( ) ;
DcodeTxt = new javax . swing . JTextArea ( ) ;
DcodeTxtLbl = new javax . swing . JLabel ( ) ;
DclearTxtLbl = new javax . swing . JLabel ( ) ;
EcodeTxtSP1 = new javax . swing . JScrollPane ( ) ;
DclearTxt = new javax . swing . JTextArea ( ) ;
DcopyBtn = new javax . swing . JButton ( ) ;
DpasteBtn = new javax . swing . JButton ( ) ;
keyField = new javax . swing . JTextField ( ) ;
jMenuBar1 = new javax . swing . JMenuBar ( ) ;
jMenu1 = new javax . swing . JMenu ( ) ;
fileExit = new javax . swing . JMenuItem ( ) ;
jMenu2 = new javax . swing . JMenu ( ) ;
helpAbout = new javax . swing . JMenuItem ( ) ;
jTextField1 . setText ( " ) ;
setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ;
setTitle ( " ) ;
setCursor ( new java . awt . Cursor ( java . awt . Cursor . DEFAULT_CURSOR ) ) ;
setResizable ( false ) ;
encoderPanel . setPreferredSize ( new java . awt . Dimension ( <num> , <num> ) ) ;
EclrTxtLbl . setFont ( new java . awt . Font ( " , <num> , <num> ) ) ;
EclrTxtLbl . setText ( " ) ;
EclearTxt . setColumns ( <num> ) ;
EclearTxt . setFont ( new java . awt . Font ( " , <num> , <num> ) ) ;
EclearTxt . setLineWrap ( true ) ;
EclearTxt . setRows ( <num> ) ;
EclearTxt . setTabSize ( <num> ) ;
EclearTxt . setWrapStyleWord ( true ) ;
EclearTxt . addFocusListener ( new java . awt . event . FocusAdapter ( ) {
public void focusGained ( java . awt . event . FocusEvent evt ) {
EclearTxtFocusGained ( evt ) ;
}
} ) ;
EclearTxt . addKeyListener ( new java . awt . event . KeyAdapter ( ) {
public void keyReleased ( java . awt . event . KeyEvent evt ) {
EclearTxtKeyReleased ( evt ) ;
}
} ) ;
EclrTxtSP . setViewportView ( EclearTxt ) ;
EcodeTxtLbl . setFont ( new java . awt . Font ( " , <num> , <num> ) ) ;
EcodeTxtLbl . setText ( " ) ;
EcodeTxt . setColumns ( <num> ) ;
EcodeTxt . setEditable ( false ) ;
EcodeTxt . setFont ( new java . awt . Font ( " , <num> , <num> ) ) ;
EcodeTxt . setLineWrap ( true ) ;
EcodeTxt . setRows ( <num> ) ;
EcodeTxt . setTabSize ( <num> ) ;
EcodeTxt . setWrapStyleWord ( true ) ;
EcodeTxt . setMaximumSize ( new java . awt . Dimension ( <num> , <num> ) ) ;
EcodeTxt . setMinimumSize ( new java . awt . Dimension ( <num> , <num> ) ) ;
EcodeTxtSP . setViewportView ( EcodeTxt ) ;
EcopyBtn . setText ( " ) ;
EcopyBtn . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
EcopyBtnActionPerformed ( evt ) ;
}
} ) ;
EpasteBtn . setText ( " ) ;
EpasteBtn . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
EpasteBtnActionPerformed ( evt ) ;
}
} ) ;
javax . swing . GroupLayout encoderPanelLayout = new javax . swing . GroupLayout ( encoderPanel ) ;
encoderPanel . setLayout ( encoderPanelLayout ) ;
encoderPanelLayout . setHorizontalGroup (
encoderPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( encoderPanelLayout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( encoderPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( encoderPanelLayout . createSequentialGroup ( )
. addComponent ( EclrTxtLbl )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , <num> , Short . MAX_VALUE )
. addComponent ( EpasteBtn ) )
. addGroup ( encoderPanelLayout . createSequentialGroup ( )
. addComponent ( EcodeTxtLbl )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , <num> , Short . MAX_VALUE )
. addComponent ( EcopyBtn ) )
. addComponent ( EclrTxtSP , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addComponent ( EcodeTxtSP , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE ) )
. addContainerGap ( ) )
) ;
encoderPanelLayout . setVerticalGroup (
encoderPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( encoderPanelLayout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( encoderPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( EclrTxtLbl )
. addComponent ( EpasteBtn , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addComponent ( EclrTxtSP , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addGroup ( encoderPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( EcodeTxtLbl )
. addComponent ( EcopyBtn , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addComponent ( EcodeTxtSP , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE )
. addContainerGap ( <num> , Short . MAX_VALUE ) )
) ;
tabbedPane . addTab ( " , encoderPanel ) ;
decoderPanel . setPreferredSize ( new java . awt . Dimension ( <num> , <num> ) ) ;
DcodeTxt . setColumns ( <num> ) ;
DcodeTxt . setFont ( new java . awt . Font ( " , <num> , <num> ) ) ;
DcodeTxt . setLineWrap ( true ) ;
DcodeTxt . setRows ( <num> ) ;
DcodeTxt . setTabSize ( <num> ) ;
DcodeTxt . setWrapStyleWord ( true ) ;
DcodeTxt . addFocusListener ( new java . awt . event . FocusAdapter ( ) {
public void focusGained ( java . awt . event . FocusEvent evt ) {
DcodeTxtFocusGained ( evt ) ;
}
} ) ;
DcodeTxt . addKeyListener ( new java . awt . event . KeyAdapter ( ) {
public void keyReleased ( java . awt . event . KeyEvent evt ) {
DcodeTxtKeyReleased ( evt ) ;
}
} ) ;
EclrTxtSP1 . setViewportView ( DcodeTxt ) ;
DcodeTxtLbl . setFont ( new java . awt . Font ( " , <num> , <num> ) ) ;
DcodeTxtLbl . setText ( " ) ;
DclearTxtLbl . setFont ( new java . awt . Font ( " , <num> , <num> ) ) ;
DclearTxtLbl . setText ( " ) ;
DclearTxt . setColumns ( <num> ) ;
DclearTxt . setEditable ( false ) ;
DclearTxt . setFont ( new java . awt . Font ( " , <num> , <num> ) ) ;
DclearTxt . setLineWrap ( true ) ;
DclearTxt . setRows ( <num> ) ;
DclearTxt . setTabSize ( <num> ) ;
DclearTxt . setWrapStyleWord ( true ) ;
EcodeTxtSP1 . setViewportView ( DclearTxt ) ;
DcopyBtn . setText ( " ) ;
DcopyBtn . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
DcopyBtnActionPerformed ( evt ) ;
}
} ) ;
DpasteBtn . setText ( " ) ;
DpasteBtn . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
DpasteBtnActionPerformed ( evt ) ;
}
} ) ;
javax . swing . GroupLayout decoderPanelLayout = new javax . swing . GroupLayout ( decoderPanel ) ;
decoderPanel . setLayout ( decoderPanelLayout ) ;
decoderPanelLayout . setHorizontalGroup (
decoderPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( decoderPanelLayout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( decoderPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addComponent ( EclrTxtSP1 , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addComponent ( EcodeTxtSP1 , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addGroup ( decoderPanelLayout . createSequentialGroup ( )
. addComponent ( DcodeTxtLbl )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , <num> , Short . MAX_VALUE )
. addComponent ( DpasteBtn ) )
. addGroup ( decoderPanelLayout . createSequentialGroup ( )
. addComponent ( DclearTxtLbl )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , <num> , Short . MAX_VALUE )
. addComponent ( DcopyBtn ) ) )
. addContainerGap ( ) )
) ;
decoderPanelLayout . setVerticalGroup (
decoderPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( decoderPanelLayout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( decoderPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( DcodeTxtLbl )
. addComponent ( DpasteBtn , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addComponent ( EclrTxtSP1 , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addGroup ( decoderPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( DclearTxtLbl )
. addComponent ( DcopyBtn , javax . swing . GroupLayout . PREFERRED_SIZE , <num> , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addComponent ( EcodeTxtSP1 , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE )
. addContainerGap ( <num> , Short . MAX_VALUE ) )
) ;
tabbedPane . addTab ( " , decoderPanel ) ;
getContentPane ( ) . add ( tabbedPane , java . awt . BorderLayout . CENTER ) ;
keyField . setHorizontalAlignment ( javax . swing . JTextField . CENTER ) ;
keyField . setText ( " ) ;
keyField . addFocusListener ( new java . awt . event . FocusAdapter ( ) {
public void focusLost ( java . awt . event . FocusEvent evt ) {
keyFieldFocusLost ( evt ) ;
}
} ) ;
getContentPane ( ) . add ( keyField , java . awt . BorderLayout . SOUTH ) ;
keyField . requestFocus ( ) ;
jMenu1 . setText ( " ) ;
fileExit . setAccelerator ( javax . swing . KeyStroke . getKeyStroke ( java . awt . event . KeyEvent . <unk> , java . awt . event . InputEvent . <unk> ) ) ;
fileExit . setText ( " ) ;
fileExit . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
fileExitActionPerformed ( evt ) ;
}
} ) ;
jMenu1 . add ( fileExit ) ;
jMenuBar1 . add ( jMenu1 ) ;
jMenu2 . setText ( " ) ;
helpAbout . setText ( " ) ;
helpAbout . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
helpAboutActionPerformed ( evt ) ;
}
} ) ;
jMenu2 . add ( helpAbout ) ;
jMenuBar1 . add ( jMenu2 ) ;
setJMenuBar ( jMenuBar1 ) ;
pack ( ) ;
}
private void EclearTxtKeyReleased ( java . awt . event . KeyEvent evt ) {
EcodeTxt . setText ( NCoder . encode ( EclearTxt . getText ( ) , keyField . getText ( ) ) ) ;
}
private void DcodeTxtKeyReleased ( java . awt . event . KeyEvent evt ) {
DclearTxt . setText ( NCoder . decode ( DcodeTxt . getText ( ) , keyField . getText ( ) ) ) ;
}
private void EclearTxtFocusGained ( java . awt . event . FocusEvent evt ) {
if ( timeout != <num> ) return ;
timeout = <num> ;
String key = keyField . getText ( ) ;
if ( key . equals ( " ) ) {
JOptionPane . showMessageDialog ( this , " ) ;
} else if ( key . length ( ) < <num> ) {
JOptionPane . showMessageDialog ( this , " ) ;
} else if ( key . split ( " + key . charAt ( <num> ) ) . length == <num> ) {
JOptionPane . showMessageDialog ( this , " ) ;
} else {
EcodeTxt . setText ( NCoder . encode ( EclearTxt . getText ( ) , keyField . getText ( ) ) ) ;
}
new Thread ( new Runnable ( ) {
@Override
public void run ( ) {
try {
Thread . sleep ( <num> ) ;
} catch ( InterruptedException ex ) {
ex . printStackTrace ( ) ;
}
if ( keyField . getText ( ) . equals ( " ) || keyField . getText ( ) . split ( " + keyField . getText ( ) . charAt ( <num> ) ) . length == <num> || keyField . getText ( ) . length ( ) < <num> ) {
keyField . requestFocusInWindow ( ) ;
}
timeout = <num> ;
}
} ) . start ( ) ;
}
private void keyFieldFocusLost ( java . awt . event . FocusEvent evt ) {
EcodeTxt . setText ( NCoder . encode ( EclearTxt . getText ( ) , keyField . getText ( ) ) ) ;
DclearTxt . setText ( NCoder . decode ( DcodeTxt . getText ( ) , keyField . getText ( ) ) ) ;
}
private void DcopyBtnActionPerformed ( java . awt . event . ActionEvent evt ) {
DclearTxt . selectAll ( ) ;
DclearTxt . copy ( ) ;
DclearTxt . select ( <num> , <num> ) ;
DcodeTxt . requestFocusInWindow ( ) ;
}
private void EcopyBtnActionPerformed ( java . awt . event . ActionEvent evt ) {
EcodeTxt . selectAll ( ) ;
EcodeTxt . copy ( ) ;
EcodeTxt . select ( <num> , <num> ) ;
EclearTxt . requestFocusInWindow ( ) ;
}
private void EpasteBtnActionPerformed ( java . awt . event . ActionEvent evt ) {
EclearTxt . selectAll ( ) ;
EclearTxt . paste ( ) ;
EclearTxt . requestFocusInWindow ( ) ;
}
private void DpasteBtnActionPerformed ( java . awt . event . ActionEvent evt ) {
DcodeTxt . selectAll ( ) ;
DcodeTxt . paste ( ) ;
DcodeTxt . requestFocusInWindow ( ) ;
}
private void DcodeTxtFocusGained ( java . awt . event . FocusEvent evt ) {
DclearTxt . setText ( NCoder . decode ( DcodeTxt . getText ( ) , keyField . getText ( ) ) ) ;
}
private void helpAboutActionPerformed ( java . awt . event . ActionEvent evt ) {
new AboutDialog ( this , true ) ;
}
private void fileExitActionPerformed ( java . awt . event . ActionEvent evt ) {
System . exit ( <num> ) ;
}
public static void main ( String args [ ] ) {
java . awt . EventQueue . invokeLater ( new Runnable ( ) {
@Override
public void run ( ) {
new MainApp ( ) . setVisible ( true ) ;
}
} ) ;
}
private javax . swing . JTextArea DclearTxt ;
private javax . swing . JLabel DclearTxtLbl ;
private javax . swing . JTextArea DcodeTxt ;
private javax . swing . JLabel DcodeTxtLbl ;
private javax . swing . JButton DcopyBtn ;
private javax . swing . JButton DpasteBtn ;
private javax . swing . JTextArea EclearTxt ;
private javax . swing . JLabel EclrTxtLbl ;
private javax . swing . JScrollPane EclrTxtSP ;
private javax . swing . JScrollPane EclrTxtSP1 ;
private javax . swing . JTextArea EcodeTxt ;
private javax . swing . JLabel EcodeTxtLbl ;
private javax . swing . JScrollPane EcodeTxtSP ;
private javax . swing . JScrollPane EcodeTxtSP1 ;
private javax . swing . JButton EcopyBtn ;
private javax . swing . JButton EpasteBtn ;
private javax . swing . JPanel decoderPanel ;
private javax . swing . JPanel encoderPanel ;
private javax . swing . JMenuItem fileExit ;
private javax . swing . JMenuItem helpAbout ;
private javax . swing . JMenu jMenu1 ;
private javax . swing . JMenu jMenu2 ;
private javax . swing . JMenuBar jMenuBar1 ;
private javax . swing . JTextField jTextField1 ;
private javax . swing . JTextField keyField ;
private javax . swing . JTabbedPane tabbedPane ;
}
package NCoder ;
import java . io . * ;
public class NCoder {
static char table [ ] [ ] = null ;
static String encode ( String clearTxt , String key ) {
if ( table == null ) {
generateTable ( ) ;
}
while ( key . length ( ) < clearTxt . length ( ) ) {
key += key ;
}
String codeTxt = " ;
for ( int i = <num> ; i < clearTxt . length ( ) ; i ++ ) {
if ( " . contains ( String . valueOf ( clearTxt . charAt ( i ) ) ) ) {
codeTxt += " ;
if ( clearTxt . length ( ) > i + <num> && " . contains ( String . valueOf ( clearTxt . charAt ( i + <num> ) ) ) ) i ++ ;
} else if ( " . contains ( String . valueOf ( clearTxt . charAt ( i ) ) ) ) {
codeTxt += clearTxt . charAt ( i ) ;
} else codeTxt += table [ clearTxt . charAt ( i )  <num> ] [ key . charAt ( i )  <num> ] ;
}
return codeTxt ;
}
static String decode ( String codeTxt , String key ) {
if ( table == null ) {
generateTable ( ) ;
}
while ( key . length ( ) < codeTxt . length ( ) ) {
key += key ;
}
String clearTxt = " ;
for ( int i = <num> ; i < codeTxt . length ( ) ; i ++ ) {
if ( " . contains ( String . valueOf ( codeTxt . charAt ( i ) ) ) ) {
clearTxt += " ;
if ( codeTxt . length ( ) > i + <num> && " . contains ( String . valueOf ( codeTxt . charAt ( i + <num> ) ) ) ) i ++ ;
continue ;
}
char c [ ] = table [ key . charAt ( i )  <num> ] ;
for ( int j = <num> ; j < c . length ; j ++ ) {
if ( c [ j ] == codeTxt . charAt ( i ) ) {
clearTxt += table [ <num> ] [ j ] ;
break ;
}
}
}
return clearTxt ;
}
static int <unk> ( char letter ) {
return Character . getNumericValue ( letter ) ;
}
static char [ ] [ ] generateTable ( ) {
table = new char [ <num> ] [ <num> ] ;
for ( int i = <num> ; i < <num> ; i ++ ) {
for ( int j = <num> ; j < <num> ; j ++ ) {
int k = i + j ;
if ( k > <num> ) k -= <num> ;
table [ i ] [ j ] = ( char ) ( k + <num> ) ;
}
}
return table ;
}
void writeObject ( Object o ) throws IOException {
ObjectOutputStream os = new ObjectOutputStream ( new FileOutputStream ( new File ( System . getProperty ( " ) + " ) ) ) ;
os . writeObject ( o ) ;
os . flush ( ) ;
os . close ( ) ;
}
}
package NCoder ;
public class AboutDialog extends javax . swing . JDialog {
public AboutDialog ( java . awt . Frame parent , boolean modal ) {
super ( parent , modal ) ;
initComponents ( ) ;
setLocation ( parent . getX ( ) + ( ( parent . getWidth ( )  getWidth ( ) ) / <num> ) , parent . getY ( ) + ( ( parent . getHeight ( )  getHeight ( ) ) / <num> ) ) ;
pack ( ) ;
setVisible ( true ) ;
}
@SuppressWarnings("unchecked")
private void initComponents ( ) {
aboutLbl = new javax . swing . JLabel ( ) ;
setDefaultCloseOperation ( javax . swing . WindowConstants . DISPOSE_ON_CLOSE ) ;
setAlwaysOnTop ( true ) ;
setResizable ( false ) ;
setUndecorated ( true ) ;
aboutLbl . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " ) ) ) ;
aboutLbl . addMouseListener ( new java . awt . event . MouseAdapter ( ) {
public void mouseClicked ( java . awt . event . MouseEvent evt ) {
aboutLblMouseClicked ( evt ) ;
}
} ) ;
javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ;
getContentPane ( ) . setLayout ( layout ) ;
layout . setHorizontalGroup (
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addComponent ( aboutLbl )
) ;
layout . setVerticalGroup (
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addComponent ( aboutLbl )
) ;
pack ( ) ;
}
private void aboutLblMouseClicked ( java . awt . event . MouseEvent evt ) {
dispose ( ) ;
}
private javax . swing . JLabel aboutLbl ;
}
package mediaplayer . model ;
import java . io . File ;
public class FileEntry extends Entry {
public FileEntry ( File file ) {
super ( file ) ;
}
public void accept ( Visitor v ) {
v . visit ( this ) ;
}
}
package mediaplayer . model ;
import java . io . File ;
import java . util . Iterator ;
public abstract class Entry {
File file ;
Entry ( File file ) {
this . file = file ;
}
public long length ( ) {
return file . length ( ) ;
}
public long lastModified ( ) {
return file . lastModified ( ) ;
}
public String getName ( ) {
return file . getName ( ) ;
}
public String getPath ( ) {
return file . getPath ( ) ;
}
public boolean isFile ( ) {
return file . isFile ( ) ;
}
public boolean isDirectory ( ) {
return file . isDirectory ( ) ;
}
public Iterator iterator ( ) {
return null ;
}
public abstract void accept ( Visitor v ) ;
}
package mediaplayer . model ;
public interface Visitor {
public abstract void visit ( DirectoryEntry entry ) ;
public abstract void visit ( FileEntry entry ) ;
}
package mediaplayer . model ;
import java . util . ArrayList ;
import java . util . Iterator ;
import java . util . List ;
import java . io . File ;
public class DirectoryEntry extends Entry {
List < Entry > entries = new ArrayList < Entry > ( ) ;
public DirectoryEntry ( File file ) {
super ( file ) ;
for ( File f : file . listFiles ( ) ) {
if ( f . isFile ( ) ) {
entries . add ( new FileEntry ( f ) ) ;
} else if ( f . isDirectory ( ) ) {
entries . add ( new DirectoryEntry ( f ) ) ;
}
}
}
@Override
public Iterator iterator ( ) {
return entries . iterator ( ) ;
}
public void accept ( Visitor v ) {
v . visit ( this ) ;
}
}
package mediaplayer ;
import mediaplayer . model . * ;
import java . io . File ;
import java . net . URL ;
import java . util . * ;
import javafx . beans . <unk> ;
import javafx . event . ActionEvent ;
import javafx . fxml . <unk> ;
import javafx . fxml . Initializable ;
import javafx . scene . control . * ;
import javafx . scene . layout . <unk> ;
import javafx . scene . media . Media ;
import javafx . scene . media . MediaPlayer ;
import javafx . scene . media . MediaPlayer . * ;
import javafx . scene . media . MediaView ;
import javafx . beans . value . ChangeListener ;
import javafx . beans . value . ObservableValue ;
import javafx . scene . layout . VBox ;
import javafx . util . Duration ;
public class <unk> implements Initializable {
@FXML
<unk> < String > treeMedia ;
@FXML
Tab <unk> ;
@FXML
Tab <unk> ;
@FXML
VBox vBoxMedia ;
@FXML
Slider <unk> ;
private Map < String , String > entryMap = new HashMap < String , String > ( ) ;
private Entry rootEntry ;
private static final String LIBLARY_URL = " ;
private MediaPlayer mediaPlayer ;
private MediaView mediaView ;
private Duration duration ;
private static final String MEDIA_URL = " ;
@Override
public void initialize ( URL url , ResourceBundle rb ) {
rootEntry = new DirectoryEntry ( new File ( LIBLARY_URL ) ) ;
TreeItem < String > rootItem = new TreeItem < String > ( ) ;
setTreeItem ( rootItem , rootEntry ) ;
treeMedia . setRoot ( rootItem ) ;
treeMedia . <unk> ( false ) ;
treeMedia . getSelectionModel ( ) . setSelectionMode ( <unk> . SINGLE ) ;
treeMedia . getSelectionModel ( ) . <unk> ( ) . addListener ( mediaItemSelected ) ;
mediaPlayer = new MediaPlayer ( new Media ( MEDIA_URL ) ) ;
mediaPlayer . <unk> ( true ) ;
mediaView = new MediaView ( mediaPlayer ) ;
vBoxMedia . getChildren ( ) . add ( mediaView ) ;
}
private void setTreeItem ( TreeItem < String > parentItem , Entry parentEntry ) {
for ( Iterator it = parentEntry . iterator ( ) ; it . hasNext ( ) ; ) {
Entry entry = ( Entry ) it . next ( ) ;
TreeItem < String > item = new TreeItem < String > ( entry . getName ( ) ) ;
parentItem . getChildren ( ) . add ( item ) ;
if ( entry . isFile ( ) ) {
entryMap . put ( entry . getName ( ) , entry . getPath ( ) ) ;
} else if ( entry . isDirectory ( ) ) {
setTreeItem ( item , entry ) ;
}
}
}
public void <unk> ( ) {
Status status = mediaPlayer . getStatus ( ) ;
if ( status == Status . UNKNOWN
|| status == Status . <unk> )
{
return ;
}
if ( status == Status . PAUSED
|| status == Status . STOPPED
|| status == Status . READY )
{
setMediaView ( ) ;
mediaPlayer . play ( ) ;
}
}
public void <unk> ( ) {
mediaPlayer . stop ( ) ;
}
private void playMedia ( ) {
mediaPlayer . play ( ) ;
duration = mediaPlayer . getMedia ( ) . getDuration ( ) ;
}
private void setMediaView ( ) {
mediaView . <unk> ( mediaPlayer ) ;
}
private final ChangeListener < TreeItem < String >> mediaItemSelected = new ChangeListener < TreeItem < String >> ( ) {
@Override
public void changed ( ObservableValue < ? extends TreeItem < String >> <unk> ,
TreeItem < String > oldValue , TreeItem < String > newValue ) {
String path = null ;
path = entryMap . get ( newValue . getValue ( ) ) ;
if ( path != null ) {
mediaPlayer . stop ( ) ;
mediaPlayer = new MediaPlayer ( new Media ( " + path ) ) ;
setMediaView ( ) ;
playMedia ( ) ;
}
}
} ;
}
package mediaplayer ;
import javafx . application . Application ;
import javafx . fxml . FXMLLoader ;
import javafx . scene . Parent ;
import javafx . scene . Scene ;
import javafx . stage . Stage ;
public class MediaPlayer extends Application {
public static void main ( String [ ] args ) {
Application . launch ( MediaPlayer . class , args ) ;
}
@Override
public void start ( Stage stage ) throws Exception {
Parent root = FXMLLoader . load ( getClass ( ) . getResource ( " ) ) ;
stage . setScene ( new Scene ( root ) ) ;
stage . show ( ) ;
}
}
package com . quickerreference . client . eclipse . plugin . model ;
import java . util . ArrayList ;
import java . util . List ;
import com . quickerreference . client . eclipse . plugin . RestClient ;
public class Category {
private String name ;
private String slug ;
private String url ;
private List < Reference > references = new ArrayList < Reference > ( ) ;
private Long id ;
private boolean initialized = false ;
public Category ( ) {
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
public List < Reference > getReferences ( ) {
checkInitialized ( ) ;
return references ;
}
public void <unk> ( Reference reference ) {
this . references . add ( reference ) ;
}
public String getUrl ( ) {
return url ;
}
public void setUrl ( String url ) {
this . url = url ;
}
public String getSlug ( ) {
return slug ;
}
public void setSlug ( String slug ) {
this . slug = slug ;
}
public Long getId ( ) {
return id ;
}
public void setId ( Long id ) {
this . id = id ;
}
@Override
public String toString ( ) {
return " + this . name ;
}
private synchronized void checkInitialized ( ) {
if ( this . initialized ) {
return ;
}
Category cat = RestClient . getInstance ( ) . getCategory ( this . url ) ;
this . references = cat . references ;
this . initialized = true ;
}
}
package com . quickerreference . client . eclipse . plugin . preferences ;
public class PreferenceConstants {
public static final String P_PATH = " ;
public static final String P_BOOLEAN = " ;
public static final String P_CHOICE = " ;
public static final String P_STRING = " ;
}
package com . quickerreference . client . eclipse . plugin . popup . actions ;
import org . eclipse . jface . action . IAction ;
import org . eclipse . jface . dialogs . MessageDialog ;
import org . eclipse . jface . text . ITextSelection ;
import org . eclipse . jface . viewers . ISelection ;
import org . eclipse . swt . widgets . Shell ;
import org . eclipse . ui . <unk> ;
import org . eclipse . ui . IEditorActionDelegate ;
import org . eclipse . ui . IEditorPart ;
public class AddReference implements IEditorActionDelegate {
private Shell shell ;
private ITextSelection selection ;
public AddReference ( ) {
super ( ) ;
}
@Override
public void <unk> ( IAction action , IEditorPart targetEditor ) {
if ( targetEditor != null && targetEditor . getSite ( ) != null ) {
shell = targetEditor . getSite ( ) . getShell ( ) ;
}
}
public void run ( IAction action ) {
MessageDialog . openInformation (
shell ,
" ,
" + selection != null ? selection . getText ( ) : null ) ;
}
public void selectionChanged ( IAction action , ISelection selection ) {
this . selection = ( ITextSelection ) selection ;
}
}
package com . quickerreference . client . eclipse . plugin . views ;
import org . eclipse . jface . action . Action ;
import org . eclipse . jface . action . IMenuListener ;
import org . eclipse . jface . action . IMenuManager ;
import org . eclipse . jface . action . IToolBarManager ;
import org . eclipse . jface . action . MenuManager ;
import org . eclipse . jface . action . Separator ;
import org . eclipse . jface . dialogs . MessageDialog ;
import org . eclipse . jface . viewers . ColumnLabelProvider ;
import org . eclipse . jface . viewers . DoubleClickEvent ;
import org . eclipse . jface . viewers . IDoubleClickListener ;
import org . eclipse . jface . viewers . ISelection ;
import org . eclipse . jface . viewers . IStructuredSelection ;
import org . eclipse . jface . viewers . ITreeContentProvider ;
import org . eclipse . jface . viewers . LabelProvider ;
import org . eclipse . jface . viewers . ListViewer ;
import org . eclipse . jface . viewers . TableViewer ;
import org . eclipse . jface . viewers . TableViewerColumn ;
import org . eclipse . jface . viewers . Viewer ;
import org . eclipse . jface . viewers . ViewerSorter ;
import org . eclipse . swt . SWT ;
import org . eclipse . swt . custom . ScrolledComposite ;
import org . eclipse . swt . graphics . Image ;
import org . eclipse . swt . layout . FillLayout ;
import org . eclipse . swt . layout . RowLayout ;
import org . eclipse . swt . widgets . Composite ;
import org . eclipse . swt . widgets . Label ;
import org . eclipse . swt . widgets . Menu ;
import org . eclipse . ui . IActionBars ;
import org . eclipse . ui . ISharedImages ;
import org . eclipse . ui . IWorkbenchActionConstants ;
import org . eclipse . ui . PlatformUI ;
import org . eclipse . ui . part . ViewPart ;
import com . quickerreference . client . eclipse . plugin . RestClient ;
import com . quickerreference . client . eclipse . plugin . model . Category ;
import com . quickerreference . client . eclipse . plugin . model . Reference ;
import com . quickerreference . client . eclipse . plugin . model . Topic ;
public class ReferencesListView extends ViewPart {
public static final String ID = " ;
private Action action1 ;
private Action action2 ;
private Action doubleClickAction ;
private Composite top ;
class ViewContentProvider implements ITreeContentProvider {
ViewContentProvider ( ) {
}
@Override
public Object [ ] getElements ( Object inputElement ) {
return this . getChildren ( inputElement ) ;
}
@Override
public Object [ ] getChildren ( Object parentElement ) {
if ( parentElement instanceof Topic ) {
return ( ( Topic ) parentElement ) . getCategories ( ) . toArray ( ) ;
} else if ( parentElement instanceof Category ) {
return ( ( Category ) parentElement ) . getReferences ( ) . toArray ( ) ;
}
return new Object [ <num> ] ;
}
@Override
public Object getParent ( Object element ) {
return null ;
}
@Override
public boolean hasChildren ( Object element ) {
return getChildren ( element ) . length > <num> ;
}
@Override
public void dispose ( ) {
}
@Override
public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) {
}
}
class ViewLabelProvider extends LabelProvider {
@Override
public String getText ( Object element ) {
return element . toString ( ) ;
}
public Image getImage ( Object obj ) {
return PlatformUI . getWorkbench ( ) .
getSharedImages ( ) . getImage ( ISharedImages . IMG_OBJ_ELEMENT ) ;
}
}
class NameSorter extends ViewerSorter {
}
public ReferencesListView ( ) {
}
private void updateWithTopic ( Topic topic ) {
for ( Category category : topic . getCategories ( ) ) {
Label categoryLabel = new Label ( top , SWT . NONE ) ;
categoryLabel . setText ( category . getName ( ) ) ;
final ScrolledComposite c = new ScrolledComposite ( top , SWT . V_SCROLL | SWT . BORDER ) ;
c . <unk> ( true ) ;
c . <unk> ( true ) ;
Composite comp = new Composite ( c , SWT . NONE ) ;
comp . setLayout ( new FillLayout ( ) ) ;
c . setContent ( comp ) ;
TableViewer viewer = new TableViewer ( comp , SWT . FULL_SELECTION | SWT . MULTI | SWT . H_SCROLL | SWT . V_SCROLL ) ;
viewer . setContentProvider ( new ViewContentProvider ( ) ) ;
viewer . setInput ( category ) ;
TableViewerColumn col1 = new TableViewerColumn ( viewer , SWT . NONE ) ;
col1 . getColumn ( ) . setWidth ( <num> ) ;
col1 . getColumn ( ) . setText ( " ) ;
col1 . setLabelProvider ( new ColumnLabelProvider ( ) {
@Override
public String getText ( Object element ) {
Reference p = ( Reference ) element ;
return p . getTitle ( ) ;
}
} ) ;
TableViewerColumn col2 = new TableViewerColumn ( viewer , SWT . NONE ) ;
col2 . getColumn ( ) . setWidth ( <num> ) ;
col2 . getColumn ( ) . setText ( " ) ;
col2 . setLabelProvider ( new ColumnLabelProvider ( ) {
@Override
public String getText ( Object element ) {
Reference p = ( Reference ) element ;
return p . getId ( ) . toString ( ) ;
}
} ) ;
viewer . setSorter ( new NameSorter ( ) ) ;
}
}
public void createPartControl ( Composite parent ) {
top = new Composite ( parent , SWT . NONE ) ;
RowLayout l = new RowLayout ( SWT . VERTICAL ) ;
l . wrap = true ;
l . fill = true ;
top . setLayout ( l ) ;
updateWithTopic ( RestClient . getInstance ( ) . getTopic ( " ) ) ;
}
private void <unk> ( TableViewer viewer ) {
MenuManager menuMgr = new MenuManager ( " ) ;
menuMgr . <unk> ( true ) ;
menuMgr . <unk> ( new IMenuListener ( ) {
public void <unk> ( IMenuManager manager ) {
ReferencesListView . this . fillContextMenu ( manager ) ;
}
} ) ;
Menu menu = menuMgr . <unk> ( viewer . getControl ( ) ) ;
viewer . getControl ( ) . <unk> ( menu ) ;
getSite ( ) . <unk> ( menuMgr , viewer ) ;
}
private void <unk> ( ) {
IActionBars bars = <unk> ( ) . <unk> ( ) ;
fillLocalPullDown ( bars . <unk> ( ) ) ;
fillLocalToolBar ( bars . getToolBarManager ( ) ) ;
}
private void fillLocalPullDown ( IMenuManager manager ) {
manager . add ( action1 ) ;
manager . add ( new Separator ( ) ) ;
manager . add ( action2 ) ;
}
private void fillContextMenu ( IMenuManager manager ) {
manager . add ( action1 ) ;
manager . add ( action2 ) ;
manager . add ( new Separator ( IWorkbenchActionConstants . <unk> ) ) ;
}
private void fillLocalToolBar ( IToolBarManager manager ) {
manager . add ( action1 ) ;
manager . add ( action2 ) ;
}
private void <unk> ( final TableViewer viewer ) {
action1 = new Action ( ) {
public void run ( ) {
showMessage ( " ) ;
}
} ;
action1 . setText ( " ) ;
action1 . setToolTipText ( " ) ;
action1 . setImageDescriptor ( PlatformUI . getWorkbench ( ) . getSharedImages ( ) .
getImageDescriptor ( ISharedImages . IMG_OBJS_INFO_TSK ) ) ;
action2 = new Action ( ) {
public void run ( ) {
showMessage ( " ) ;
}
} ;
action2 . setText ( " ) ;
action2 . setToolTipText ( " ) ;
action2 . setImageDescriptor ( PlatformUI . getWorkbench ( ) . getSharedImages ( ) .
getImageDescriptor ( ISharedImages . IMG_OBJS_INFO_TSK ) ) ;
doubleClickAction = new Action ( ) {
public void run ( ) {
ISelection selection = viewer . getSelection ( ) ;
Object obj = ( ( IStructuredSelection ) selection ) . getFirstElement ( ) ;
Topic t = RestClient . getInstance ( ) . getTopic ( " ) ;
showMessage ( " + t . getCategories ( ) . size ( ) ) ;
}
} ;
}
private void <unk> ( TableViewer viewer ) {
viewer . <unk> ( new IDoubleClickListener ( ) {
public void <unk> ( DoubleClickEvent event ) {
doubleClickAction . run ( ) ;
}
} ) ;
}
private void showMessage ( String message ) {
MessageDialog . openInformation (
top . getShell ( ) ,
" ,
message ) ;
}
public void setFocus ( ) {
top . setFocus ( ) ;
}
package com . quickerreference . client . eclipse . plugin . model ;
import java . util . ArrayList ;
import java . util . List ;
import org . codehaus . jackson . annotate . JsonProperty ;
public class Topic {
private List < Category > categories = new ArrayList < Category > ( ) ;
private String name ;
private String url ;
private String slug ;
private Long id ;
private boolean initialized = false ;
public Topic ( ) {
}
private synchronized void checkInitialized ( ) {
if ( initialized ) return ;
}
public List < Category > getCategories ( ) {
return categories ;
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
public String getUrl ( ) {
return url ;
}
public void setUrl ( String url ) {
this . url = url ;
}
public String getSlug ( ) {
return slug ;
}
public void setSlug ( String slug ) {
this . slug = slug ;
}
public Long getId ( ) {
return id ;
}
public void setId ( Long id ) {
this . id = id ;
}
@Override
public String toString ( ) {
return " + this . name ;
}
}
package com . quickerreference . client . eclipse . plugin . preferences ;
import org . eclipse . core . runtime . preferences . AbstractPreferenceInitializer ;
import org . eclipse . jface . preference . IPreferenceStore ;
import com . quickerreference . client . eclipse . plugin . Activator ;
public class PreferenceInitializer extends AbstractPreferenceInitializer {
public void initializeDefaultPreferences ( ) {
IPreferenceStore store = Activator . getDefault ( ) . getPreferenceStore ( ) ;
store . setDefault ( PreferenceConstants . P_BOOLEAN , true ) ;
store . setDefault ( PreferenceConstants . P_CHOICE , " ) ;
store . setDefault ( PreferenceConstants . P_STRING ,
" ) ;
}
}
package com . quickerreference . client . eclipse . plugin . preferences ;
import org . eclipse . jface . preference . * ;
import org . eclipse . ui . IWorkbenchPreferencePage ;
import org . eclipse . ui . IWorkbench ;
import com . quickerreference . client . eclipse . plugin . Activator ;
public class QuickeReferencePreferencePage
extends FieldEditorPreferencePage
implements IWorkbenchPreferencePage {
public QuickeReferencePreferencePage ( ) {
super ( GRID ) ;
setPreferenceStore ( Activator . getDefault ( ) . getPreferenceStore ( ) ) ;
setDescription ( " ) ;
}
public void createFieldEditors ( ) {
addField ( new DirectoryFieldEditor ( PreferenceConstants . P_PATH ,
" , getFieldEditorParent ( ) ) ) ;
addField (
new BooleanFieldEditor (
PreferenceConstants . P_BOOLEAN ,
" ,
getFieldEditorParent ( ) ) ) ;
addField ( new <unk> (
PreferenceConstants . P_CHOICE ,
" ,
1 ,
new String [ ] [ ] { { " , " } , {
" , " }
} , getFieldEditorParent ( ) ) ) ;
addField (
new StringFieldEditor ( PreferenceConstants . P_STRING , " , getFieldEditorParent ( ) ) ) ;
}
public void init ( IWorkbench workbench ) {
}
package com . quickerreference . client . eclipse . plugin ;
import org . eclipse . jface . resource . ImageDescriptor ;
import org . eclipse . ui . plugin . AbstractUIPlugin ;
import org . osgi . framework . BundleContext ;
public class Activator extends AbstractUIPlugin {
public static final String PLUGIN_ID = " ;
private static Activator plugin ;
public Activator ( ) {
}
public void start ( BundleContext context ) throws Exception {
super . start ( context ) ;
plugin = this ;
}
public void stop ( BundleContext context ) throws Exception {
plugin = null ;
super . stop ( context ) ;
}
public static Activator getDefault ( ) {
return plugin ;
}
public static ImageDescriptor getImageDescriptor ( String path ) {
return imageDescriptorFromPlugin ( PLUGIN_ID , path ) ;
}
}
package com . quickerreference . client . eclipse . plugin ;
import java . io . IOException ;
import java . io . InputStream ;
import org . apache . http . HttpEntity ;
import org . apache . http . HttpResponse ;
import org . apache . http . client . HttpClient ;
import org . apache . http . client . methods . HttpGet ;
import org . apache . http . impl . client . DefaultHttpClient ;
import org . codehaus . jackson . map . ObjectMapper ;
import com . quickerreference . client . eclipse . plugin . model . Category ;
import com . quickerreference . client . eclipse . plugin . model . Topic ;
public class RestClient {
private static RestClient instance ;
private String host = " ;
private HttpClient httpClient ;
private ObjectMapper mapper = new ObjectMapper ( ) ;
private RestClient ( ) {
this . httpClient = new DefaultHttpClient ( ) ;
}
public static synchronized RestClient getInstance ( ) {
if ( instance == null ) {
instance = new RestClient ( ) ;
}
return instance ;
}
public Topic getTopic ( String name ) {
final String topicUrl = " + name ;
return getObject ( topicUrl , Topic . class ) ;
}
public Category getCategory ( String url ) {
return getObject ( url , Category . class ) ;
}
private < T > T getObject ( final String rurl , Class < T > clazz ) {
final String url = host + rurl ;
HttpGet topicGet = new HttpGet ( url ) ;
topicGet . setHeader ( " , " ) ;
InputStream is = null ;
try {
HttpResponse response = httpClient . execute ( topicGet ) ;
HttpEntity entity = response . getEntity ( ) ;
if ( entity == null ) {
return null ;
}
is = entity . getContent ( ) ;
T obj = this . mapper . readValue ( is , clazz ) ;
System . out . println ( obj ) ;
return obj ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
} finally {
if ( is != null ) {
try {
is . close ( ) ;
} catch ( IOException e ) {
}
}
}
return null ;
}
}
package com . quickerreference . client . eclipse . plugin . model ;
import java . util . Set ;
public class Reference {
private String title ;
private String content ;
private String uuid ;
private String url ;
private boolean initialized = false ;
private Long id ;
public Reference ( ) {
}
public String getTitle ( ) {
return title ;
}
public void setTitle ( String title ) {
this . title = title ;
}
public String getContent ( ) {
return content ;
}
public void setContent ( String content ) {
this . content = content ;
}
public String getUuid ( ) {
return uuid ;
}
public void setUuid ( String uuid ) {
this . uuid = uuid ;
}
public String getUrl ( ) {
return url ;
}
public void setUrl ( String url ) {
this . url = url ;
}
public Long getId ( ) {
return id ;
}
public void setId ( Long id ) {
this . id = id ;
}
private synchronized void checkInitialized ( ) {
if ( this . initialized ) {
return ;
}
this . initialized = true ;
}
@Override
public String toString ( ) {
return " + this . title ;
}
}
package com . freshplanet . ane . AirBackgroundMusic ;
import android . util . Log ;
import com . adobe . fre . FREContext ;
import com . adobe . fre . FREExtension ;
public class AirBackgroundMusicExtension implements FREExtension
{
private static String TAG = " ;
public static FREContext context ;
public FREContext createContext ( String extId )
{
Log . d ( TAG , " + extId ) ;
return context = new AirBackgroundMusicExtensionContext ( ) ;
}
public void dispose ( )
{
Log . d ( TAG , " ) ;
context = null ;
}
public void initialize ( )
{
Log . d ( TAG , " ) ;
}
}
package com . freshplanet . ane . AirBackgroundMusic ;
import java . util . HashMap ;
import java . util . Map ;
import android . util . Log ;
import com . adobe . fre . FREContext ;
import com . adobe . fre . FREFunction ;
import com . freshplanet . ane . AirBackgroundMusic . functions . InitFunction ;
public class AirBackgroundMusicExtensionContext extends FREContext
{
private static String TAG = " ;
public AirBackgroundMusicExtensionContext ( )
{
Log . d ( TAG , " ) ;
}
@Override
public void dispose ( )
{
Log . d ( TAG , " ) ;
AirBackgroundMusicExtension . context = null ;
}
@Override
public Map < String , FREFunction > getFunctions ( )
{
Log . d ( TAG , " ) ;
Map < String , FREFunction > functionMap = new HashMap < String , FREFunction > ( ) ;
functionMap . put ( " , new InitFunction ( ) ) ;
return functionMap ;
}
}
package com . freshplanet . ane . AirBackgroundMusic . functions ;
import android . content . Context ;
import android . media . AudioManager ;
import android . media . AudioManager . OnAudioFocusChangeListener ;
import android . util . Log ;
import com . adobe . fre . FREContext ;
import com . adobe . fre . FREFunction ;
import com . adobe . fre . FREObject ;
import com . adobe . fre . FREWrongThreadException ;
public class InitFunction implements FREFunction
{
private static String TAG = " ;
public FREObject call ( FREContext context , FREObject [ ] args )
{
Log . d ( TAG , " ) ;
AudioManager am = ( AudioManager ) context . getActivity ( ) . getSystemService ( Context . AUDIO_SERVICE ) ;
OnAudioFocusChangeListener afAudioFocusChangeListener = new OnAudioFocusChangeListener ( ) {
public void onAudioFocusChange ( int focusChange ) {
Log . d ( TAG , " + focusChange ) ;
}
} ;
int result = am . requestAudioFocus ( afAudioFocusChangeListener ,
AudioManager . STREAM_MUSIC ,
AudioManager . AUDIOFOCUS_GAIN ) ;
if ( result == AudioManager . AUDIOFOCUS_REQUEST_GRANTED ) {
Log . d ( TAG , " + result ) ;
} else {
Log . d ( TAG , " + result ) ;
}
Log . d ( TAG , " ) ;
try {
return FREObject . newObject ( result ) ;
} catch ( FREWrongThreadException exception ) {
Log . d ( TAG , exception . getLocalizedMessage ( ) ) ;
return null ;
}
}
}
package com . martinadamek . jsonandroid ;
import com . google . gson . stream . JsonReader ;
import com . google . gson . stream . JsonToken ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . InputStreamReader ;
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
public class GsonJson implements TestJson {
public String getName ( ) {
return " ;
}
public List < Map > parsePublicTimeline ( InputStream inputStream ) {
List < Map > result = new ArrayList < Map > ( ) ;
try {
JsonReader reader = new JsonReader ( new InputStreamReader ( inputStream , " ) ) ;
reader . <unk> ( ) ;
while ( reader . hasNext ( ) ) {
Map map = new HashMap ( ) ;
reader . beginObject ( ) ;
while ( reader . hasNext ( ) ) {
String name = reader . nextName ( ) ;
if ( " . equals ( name ) ) {
reader . beginObject ( ) ;
while ( reader . hasNext ( ) ) {
String name2 = reader . nextName ( ) ;
map . put ( " + name2 , getValue ( reader ) ) ;
}
reader . endObject ( ) ;
} else {
map . put ( name , getValue ( reader ) ) ;
}
}
reader . endObject ( ) ;
result . add ( map ) ;
}
reader . endArray ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
return result ;
}
static Object getValue ( JsonReader r ) throws IOException {
Object value = null ;
JsonToken token = r . peek ( ) ;
switch ( token ) {
case NULL :
r . <unk> ( ) ;
break ;
case BOOLEAN :
value = r . nextBoolean ( ) ;
break ;
default :
value = r . nextString ( ) ;
}
return value ;
}
}
package com . martinadamek . jsonandroid ;
import org . codehaus . jackson . JsonFactory ;
import org . codehaus . jackson . JsonParser ;
import org . codehaus . jackson . JsonToken ;
import java . io . IOException ;
import java . io . InputStream ;
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
public class JacksonJson implements TestJson {
private static JsonFactory sJsonFactory = new JsonFactory ( ) ;
public String getName ( ) {
return " ;
}
public List < Map > parsePublicTimeline ( InputStream inputStream ) {
List < Map > result = new ArrayList < Map > ( ) ;
try {
JsonParser p = sJsonFactory . <unk> ( inputStream ) ;
p . nextToken ( ) ;
while ( p . nextToken ( ) != JsonToken . <unk> ) {
Map map = new HashMap ( ) ;
while ( p . nextToken ( ) != JsonToken . END_OBJECT ) {
String key = p . getCurrentName ( ) ;
p . nextToken ( ) ;
if ( p . <unk> ( ) == JsonToken . <unk> ) {
while ( p . nextToken ( ) != JsonToken . END_OBJECT ) {
String key2 = p . getCurrentName ( ) ;
p . nextToken ( ) ;
map . put ( " + key2 , p . getText ( ) ) ;
}
} else {
map . put ( key , p . getText ( ) ) ;
}
}
result . add ( map ) ;
}
p . close ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
return result ;
}
}
package com . martinadamek . jsonandroid ;
import org . json . JSONArray ;
import org . json . JSONObject ;
import org . json . JSONTokener ;
import java . io . * ;
import java . util . * ;
public class AndroidJson implements TestJson {
public String getName ( ) {
return " ;
}
public List < Map > parsePublicTimeline ( InputStream inputStream ) {
List < Map > result = new ArrayList < Map > ( ) ;
try {
String json = convertStreamToString ( inputStream ) ;
JSONArray jsonArray = new JSONArray ( json ) ;
int length = jsonArray . length ( ) ;
for ( int i = <num> ; i < length ; i ++ ) {
Map map = new HashMap ( ) ;
JSONObject jsonObject = jsonArray . getJSONObject ( i ) ;
Iterator iterator = jsonObject . keys ( ) ;
while ( iterator . hasNext ( ) ) {
String key = ( String ) iterator . next ( ) ;
if ( " . equals ( key ) ) {
JSONObject user = jsonObject . getJSONObject ( key ) ;
Iterator iterator2 = user . keys ( ) ;
while ( iterator2 . hasNext ( ) ) {
String key2 = ( String ) iterator2 . next ( ) ;
map . put ( " + key2 , user . get ( key2 ) ) ;
}
} else {
map . put ( key , jsonObject . get ( key ) ) ;
}
}
result . add ( map ) ;
}
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
return result ;
}
private static String convertStreamToString ( InputStream inputStream ) throws IOException {
ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ;
InputStream in = new BufferedInputStream ( inputStream ) ;
byte [ ] buffer = new byte [ <num> ] ;
int n = <num> ;
try {
while (  <num> != ( n = in . read ( buffer ) ) ) {
out . write ( buffer , <num> , n ) ;
}
} finally {
out . close ( ) ;
in . close ( ) ;
}
return out . toString ( " ) ;
}
}
package com . martinadamek . jsonandroid ;
public final class R {
public static final class attr {
}
public static final class drawable {
public static final int icon = <num> ;
}
public static final class id {
public static final int layout = <num> ;
}
public static final class layout {
public static final int main = <num> ;
}
public static final class string {
public static final int app_name = <num> ;
}
}
package com . martinadamek . jsonandroid ;
import android . app . Activity ;
import android . os . Bundle ;
import android . widget . LinearLayout ;
import android . widget . TextView ;
import java . io . InputStream ;
import java . util . * ;
public class MainActivity extends Activity {
private static final String TAG = MainActivity . class . getName ( ) ;
private LinearLayout mLayout ;
private LinearLayout . LayoutParams mLayoutParams ;
private String mPath ;
private final Runnable mTestTask = new Runnable ( ) {
public void run ( ) {
final Map < String , Long > results = new HashMap < String , Long > ( ) ;
testImpl ( new AndroidJson ( ) , results ) ;
testImpl ( new SimpleJson ( ) , results ) ;
testImpl ( new GsonJson ( ) , results ) ;
testImpl ( new JacksonJson ( ) , results ) ;
runOnUiThread ( new Runnable ( ) {
public void run ( ) {
mLayout . removeAllViews ( ) ;
List < String > keys = new ArrayList < String > ( results . keySet ( ) ) ;
Collections . sort ( keys ) ;
for ( String key : keys ) {
TextView textView = new TextView ( MainActivity . this ) ;
textView . setText ( key + " + results . get ( key ) + " ) ;
mLayout . addView ( textView , mLayoutParams ) ;
}
}
} ) ;
}
} ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . main ) ;
mLayout = ( LinearLayout ) findViewById ( R . id . layout ) ;
mLayoutParams = new LinearLayout . LayoutParams (
LinearLayout . LayoutParams . FILL_PARENT ,
LinearLayout . LayoutParams . WRAP_CONTENT
) ;
mPath = " ;
TextView textView = new TextView ( MainActivity . this ) ;
textView . setText ( " ) ;
mLayout . addView ( textView , mLayoutParams ) ;
new Thread ( mTestTask ) . start ( ) ;
}
private void testImpl ( TestJson testJson , Map < String , Long > results ) {
warmUp ( testJson ) ;
long duration = test ( testJson , <num> ) ;
results . put ( " + testJson . getName ( ) , duration ) ;
duration = test ( testJson , <num> ) ;
results . put ( " + testJson . getName ( ) , duration ) ;
duration = test ( testJson , <num> ) ;
results . put ( " + testJson . getName ( ) , duration ) ;
}
private void warmUp ( final TestJson testJson ) {
InputStream inputStream ;
for ( int i = <num> ; i < <num> ; i ++ ) {
inputStream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( mPath ) ;
testJson . parsePublicTimeline ( inputStream ) ;
}
}
private long test ( final TestJson testJson , int repeats ) {
InputStream inputStream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( mPath ) ;
List < Map > result = testJson . parsePublicTimeline ( inputStream ) ;
verify ( result ) ;
long duration = <num> ;
for ( int i = <num> ; i < repeats ; i ++ ) {
inputStream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( mPath ) ;
long start = System . currentTimeMillis ( ) ;
testJson . parsePublicTimeline ( inputStream ) ;
duration += ( System . currentTimeMillis ( )  start ) ;
}
return duration ;
}
private static void verify ( List < Map > result ) {
if ( result . size ( ) != <num> ) {
throw new IllegalStateException ( " + result . size ( ) ) ;
}
for ( Map map : result ) {
if ( map . size ( ) != <num> ) {
throw new IllegalStateException ( " + result . size ( ) ) ;
}
}
}
private static String <unk> ( Map map ) {
StringBuilder sb = new StringBuilder ( " ) ;
for ( Object key : map . keySet ( ) ) {
sb . append ( "' ) . append ( key ) . append ( "' ) . append ( :' ) . append ( "' ) . append ( map . get ( key ) ) . append ( "' ) . append ( " ) ;
}
sb . append ( " ) ;
return sb . toString ( ) ;
}
}
package com . martinadamek . jsonandroid ;
import org . json . simple . JSONArray ;
import org . json . simple . JSONObject ;
import org . json . simple . parser . JSONParser ;
import java . io . InputStream ;
import java . io . InputStreamReader ;
import java . util . * ;
public class SimpleJson implements TestJson {
public String getName ( ) {
return " ;
}
public List < Map > parsePublicTimeline ( InputStream inputStream ) {
List < Map > result = new ArrayList < Map > ( ) ;
JSONParser p = new JSONParser ( ) ;
try {
JSONArray jsonArray = ( JSONArray ) p . parse ( new InputStreamReader ( inputStream ) ) ;
int size = jsonArray . size ( ) ;
for ( int i = <num> ; i < size ; i ++ ) {
Map map = new HashMap ( ) ;
JSONObject jsonObject = ( JSONObject ) jsonArray . get ( i ) ;
Set keys = jsonObject . keySet ( ) ;
for ( Object key : keys ) {
if ( " . equals ( key ) ) {
JSONObject user = ( JSONObject ) jsonObject . get ( key ) ;
Set keys2 = user . keySet ( ) ;
for ( Object key2 : keys2 ) {
map . put ( " + key2 , user . get ( key2 ) ) ;
}
} else {
map . put ( key , jsonObject . get ( key ) ) ;
}
}
result . add ( map ) ;
}
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
return result ;
}
}
package com . martinadamek . jsonandroid ;
import java . io . InputStream ;
import java . util . List ;
import java . util . Map ;
public interface TestJson {
String getName ( ) ;
List < Map > parsePublicTimeline ( InputStream inputStream ) ;
}
package com . gmail . bobagold . plugin1 ;
import org . eclipse . core . runtime . CoreException ;
import org . eclipse . core . runtime . IProgressMonitor ;
import org . eclipse . debug . core . ILaunch ;
import org . eclipse . debug . core . ILaunchConfiguration ;
import org . eclipse . debug . core . model . ILaunchConfigurationDelegate ;
public class <unk> implements ILaunchConfigurationDelegate {
@Override
public void launch ( ILaunchConfiguration configuration , String mode ,
ILaunch launch , IProgressMonitor monitor ) throws CoreException {
System . out . println ( " ) ;
for ( String lc_name : CompositeTab . unserializeLC ( configuration ) ) {
System . out . println ( lc_name ) ;
ILaunchConfiguration lc = CompositeTab . getLC ( lc_name ) ;
if ( lc != null ) lc . launch ( mode , monitor ) ;
}
}
}
package com . gmail . bobagold . plugin1 ;
import java . util . ArrayList ;
import java . util . Arrays ;
import org . eclipse . core . runtime . CoreException ;
import org . eclipse . debug . core . DebugPlugin ;
import org . eclipse . debug . core . ILaunch ;
import org . eclipse . debug . core . ILaunchConfiguration ;
import org . eclipse . debug . core . ILaunchConfigurationType ;
import org . eclipse . debug . core . ILaunchConfigurationWorkingCopy ;
import org . eclipse . debug . core . ILaunchManager ;
import org . eclipse . debug . ui . ILaunchConfigurationDialog ;
import org . eclipse . debug . ui . ILaunchConfigurationTab ;
import org . eclipse . swt . SWT ;
import org . eclipse . swt . events . SelectionAdapter ;
import org . eclipse . swt . events . SelectionEvent ;
import org . eclipse . swt . graphics . Image ;
import org . eclipse . swt . layout . GridLayout ;
import org . eclipse . swt . widgets . Button ;
import org . eclipse . swt . widgets . Composite ;
import org . eclipse . swt . widgets . Control ;
import org . eclipse . swt . widgets . Group ;
import org . eclipse . swt . widgets . List ;
public class CompositeTab implements ILaunchConfigurationTab {
private Control control ;
private List list_from ;
private List list_to ;
private String [ ] saved_selection ;
private ILaunchConfiguration configuration ;
private ILaunchConfigurationWorkingCopy lc_working_copy ;
@Override
public void createControl ( Composite parent ) {
Group container = new Group ( parent , SWT . CENTER ) ;
container . setText ( " ) ;
GridLayout layout = new GridLayout ( ) ;
layout . numColumns = <num> ;
container . setLayout ( layout ) ;
list_from = new List ( container , SWT . SINGLE ) ;
Group buttons = new Group ( container , <num> ) ;
buttons . setLayout ( new GridLayout ( ) ) ;
Button to_from = new Button ( buttons , <num> ) ;
Button to_to = new Button ( buttons , <num> ) ;
to_from . setText ( " ) ;
to_from . addSelectionListener ( new SelectionAdapter ( ) {
@Override
public void widgetSelected ( SelectionEvent e ) {
moveSelection ( list_to , list_from ) ;
}
} ) ;
to_to . setText ( " ) ;
to_to . addSelectionListener ( new SelectionAdapter ( ) {
@Override
public void widgetSelected ( SelectionEvent e ) {
moveSelection ( list_from , list_to ) ;
}
} ) ;
list_to = new List ( container , SWT . SINGLE ) ;
control = container ;
}
protected void fillControls ( ) {
for ( ILaunchConfiguration lc : collectLaunchConfigurations ( ) )
list_from . add ( toString ( lc ) ) ;
list_to . setItems ( saved_selection ) ;
for ( String s : saved_selection )
if ( list_from . indexOf ( s ) >= <num> )
list_from . remove ( s ) ;
}
protected void refresh ( ) {
list_from . pack ( true ) ;
list_to . pack ( true ) ;
control . pack ( true ) ;
performApply ( lc_working_copy ) ;
}
public static ILaunchConfiguration [ ] collectLaunchConfigurations ( ) {
ArrayList < ILaunchConfiguration > list = new ArrayList < ILaunchConfiguration > ( ) ;
ILaunchManager manager = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ;
try {
for ( ILaunchConfiguration lc : manager . getLaunchConfigurations ( ) )
if ( ! lc . getType ( ) . getName ( ) . equals ( " ) )
list . add ( lc ) ;
} catch ( CoreException e ) {
e . printStackTrace ( ) ;
}
return list . toArray ( new ILaunchConfiguration [ ] { } ) ;
}
private String [ ] <unk> ( ) {
ArrayList < String > list = new ArrayList < String > ( ) ;
ILaunchManager manager = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ;
for ( ILaunchConfigurationType lc : manager . <unk> ( ) )
list . add ( lc . getName ( ) ) ;
return list . toArray ( new String [ ] { } ) ;
}
@Override
public Control getControl ( ) {
return control ;
}
@Override
public void setDefaults ( ILaunchConfigurationWorkingCopy configuration ) {
}
@Override
public void initializeFrom ( ILaunchConfiguration configuration ) {
try {
saved_selection = unserializeLC ( configuration ) ;
System . out . println ( " ) ;
for ( String s : saved_selection ) System . out . println ( s ) ;
fillControls ( ) ;
this . configuration = configuration ;
} catch ( CoreException e ) {
e . printStackTrace ( ) ;
}
}
public static String [ ] unserializeLC ( ILaunchConfiguration configuration ) throws CoreException {
ArrayList < String > defaults = new ArrayList < String > ( ) ;
String [ ] saved_selection = ( String [ ] ) configuration . getAttribute ( " , defaults ) . toArray ( new String [ ] { } ) ;
return saved_selection ;
}
@Override
public void dispose ( ) {
}
@Override
public void performApply ( ILaunchConfigurationWorkingCopy configuration ) {
System . out . println ( " ) ;
String [ ] saved_selection = list_to . getItems ( ) ;
for ( String s : saved_selection ) System . out . println ( s ) ;
ArrayList < String > selection = new ArrayList < String > ( ) ;
for ( String s : saved_selection ) selection . add ( s ) ;
configuration . setAttribute ( " , selection ) ;
this . lc_working_copy = configuration ;
}
@Override
public String getErrorMessage ( ) {
return null ;
}
@Override
public String getMessage ( ) {
return null ;
}
@Override
public boolean isValid ( ILaunchConfiguration <unk> ) {
return true ;
}
@Override
public boolean <unk> ( ) {
System . out . println ( " + ( ! Arrays . equals ( list_to . getItems ( ) , saved_selection ) ) ) ;
return ! Arrays . equals ( list_to . getItems ( ) , saved_selection ) ;
}
@Override
public void <unk> ( ILaunchConfigurationDialog dialog ) {
}
@Override
public void <unk> ( ILaunch launch ) {
}
@Override
public String getName ( ) {
return " ;
}
@Override
public Image getImage ( ) {
return null ;
}
@Override
public void activated ( ILaunchConfigurationWorkingCopy workingCopy ) {
}
@Override
public void deactivated ( ILaunchConfigurationWorkingCopy workingCopy ) {
}
private void moveSelection ( List list_from , List list_to ) {
String [ ] selected = list_from . getSelection ( ) ;
for ( String selection : selected ) {
list_to . add ( selection ) ;
list_from . remove ( selection ) ;
}
list_from . setSelection ( new String [ ] { } ) ;
list_to . setSelection ( selected ) ;
refresh ( ) ;
}
public static ILaunchConfiguration getLC ( String lc_name ) {
for ( ILaunchConfiguration i : collectLaunchConfigurations ( ) )
if ( toString ( i ) == lc_name ) return i ;
return null ;
}
public static String toString ( ILaunchConfiguration lc ) {
return " + lc . getName ( ) ;
}
}
package com . gmail . bobagold . plugin1 ;
import org . eclipse . jface . resource . ImageDescriptor ;
import org . eclipse . ui . plugin . AbstractUIPlugin ;
import org . osgi . framework . BundleContext ;
public class Activator extends AbstractUIPlugin {
public static final String PLUGIN_ID = " ;
private static Activator plugin ;
public Activator ( ) {
}
public void start ( BundleContext context ) throws Exception {
super . start ( context ) ;
plugin = this ;
}
public void stop ( BundleContext context ) throws Exception {
plugin = null ;
super . stop ( context ) ;
}
public static Activator getDefault ( ) {
return plugin ;
}
public static ImageDescriptor getImageDescriptor ( String path ) {
return imageDescriptorFromPlugin ( PLUGIN_ID , path ) ;
}
}
package com . gmail . bobagold . plugin1 ;
import org . eclipse . core . runtime . CoreException ;
import org . eclipse . debug . core . DebugPlugin ;
import org . eclipse . debug . core . ILaunchConfiguration ;
import org . eclipse . debug . core . ILaunchManager ;
import org . eclipse . debug . ui . AbstractLaunchConfigurationTabGroup ;
import org . eclipse . debug . ui . CommonTab ;
import org . eclipse . debug . ui . ILaunchConfigurationDialog ;
import org . eclipse . debug . ui . ILaunchConfigurationTab ;
public class AbstractLaunchConfigurationTabGroup1 extends
AbstractLaunchConfigurationTabGroup {
public AbstractLaunchConfigurationTabGroup1 ( ) {
}
@Override
public void createTabs ( ILaunchConfigurationDialog dialog , String mode ) {
CommonTab commonTab = new CommonTab ( ) ;
CompositeTab compositeTab = new CompositeTab ( ) ;
ILaunchConfigurationTab [ ] tabs = { commonTab , compositeTab } ;
setTabs ( tabs ) ;
}
}
package person . winter . collections ;
import java . util . Arrays ;
import java . util . Collection ;
import java . util . Iterator ;
import java . util . List ;
import java . util . ListIterator ;
import java . util . NoSuchElementException ;
public class WArrayList < E > implements List < E > {
private Object [ ] elements ;
private int size ;
private static final int DEFAULT_INIT_CAPACITY = <num> ;
private static final Object PLACE_HOLDER = new Object ( ) ;
public WArrayList ( ) {
this ( DEFAULT_INIT_CAPACITY ) ;
}
public WArrayList ( int initCapacity ) {
if ( initCapacity <= <num> )
throw new IllegalArgumentException (
" ) ;
elements = new Object [ initCapacity ] ;
size = <num> ;
}
@Override
public boolean add ( E e ) {
elements [ size ++ ] = e ;
ensureCapacityAfterAdd ( ) ;
return true ;
}
@Override
public void add ( int index , E element ) {
checkIndex ( index ) ;
for ( int i = size ; i > index ; i  )
elements [ i ] = elements [ i  <num> ] ;
elements [ index ] = element ;
size ++ ;
ensureCapacityAfterAdd ( ) ;
}
private void ensureCapacityAfterAdd ( ) {
if ( size >= elements . length ) {
doubleCapacity ( ) ;
}
}
private void doubleCapacity ( ) {
increaseToCapacity ( elements . length * <num> ) ;
}
private void increaseToCapacity ( int newCapacity ) {
if ( newCapacity <= elements . length )
return ;
Object [ ] newArray = new Object [ newCapacity ] ;
System . arraycopy ( elements , <num> , newArray , <num> , elements . length ) ;
elements = newArray ;
}
@Override
public boolean addAll ( Collection < ? extends E > c ) {
Iterator < ? extends E > iter = c . iterator ( ) ;
while ( iter . hasNext ( ) ) {
this . add ( iter . next ( ) ) ;
}
return true ;
}
@Override
public boolean addAll ( int index , Collection < ? extends E > c ) {
checkIndex ( index ) ;
int incSize = c . size ( ) ;
int newCapacity = elements . length ;
while ( size + incSize > newCapacity )
newCapacity *= <num> ;
increaseToCapacity ( newCapacity ) ;
for ( int i = size  <num> ; i >= index ; i  )
elements [ i + incSize ] = elements [ i ] ;
Iterator < ? extends E > iter = c . iterator ( ) ;
while ( iter . hasNext ( ) )
this . set ( index ++ , iter . next ( ) ) ;
return true ;
}
@Override
public void clear ( ) {
for ( int i = <num> ; i < size ; i ++ )
elements [ i ] = null ;
size = <num> ;
}
@Override
public boolean contains ( Object o ) {
for ( int i = <num> ; i < size ; i ++ ) {
if ( equals ( o , elements [ i ] ) )
return true ;
}
return false ;
}
@Override
public boolean containsAll ( Collection < ? > c ) {
Iterator < ? > iter = c . iterator ( ) ;
while ( iter . hasNext ( ) ) {
if ( ! this . contains ( iter . next ( ) ) )
return false ;
}
return true ;
}
@Override
@SuppressWarnings("unchecked")
public E get ( int index ) {
checkIndex ( index ) ;
return ( E ) elements [ index ] ;
}
@Override
public int indexOf ( Object o ) {
for ( int i = <num> ; i < size ; i ++ ) {
if ( equals ( o , elements [ i ] ) )
return i ;
}
return  <num> ;
}
private boolean equals ( Object o1 , Object o2 ) {
if ( o1 == null && o2 == null )
return true ;
if ( o1 != null && o2 != null ) {
return o1 . equals ( o2 ) ;
}
return false ;
}
@Override
public boolean isEmpty ( ) {
return size == <num> ;
}
@Override
public Iterator < E > iterator ( ) {
return listIterator ( ) ;
}
@Override
public int lastIndexOf ( Object o ) {
for ( int i = size  <num> ; i >= <num> ; i  ) {
if ( equals ( o , elements [ i ] ) )
return i ;
}
return  <num> ;
}
@Override
public ListIterator < E > listIterator ( ) {
return listIterator ( <num> ) ;
}
@Override
public ListIterator < E > listIterator ( final int index ) {
checkIndex ( index ) ;
return new ListIterator < E > ( ) {
int cursor = index ;
@Override
public void add ( E e ) {
throw new UnsupportedOperationException ( ) ;
}
@Override
public boolean hasNext ( ) {
return cursor < size ;
}
@Override
public boolean hasPrevious ( ) {
return cursor > <num> ;
}
@Override
@SuppressWarnings("unchecked")
public E next ( ) {
if ( hasNext ( ) ) {
return ( E ) elements [ cursor ++ ] ;
}
throw new NoSuchElementException ( ) ;
}
@Override
public int nextIndex ( ) {
return cursor ;
}
@Override
@SuppressWarnings("unchecked")
public E previous ( ) {
if ( hasPrevious ( ) ) {
return ( E ) elements [ ( cursor  )  <num> ] ;
}
throw new NoSuchElementException ( ) ;
}
@Override
public int previousIndex ( ) {
return cursor  <num> ;
}
@Override
public void remove ( ) {
throw new UnsupportedOperationException ( ) ;
}
@Override
public void set ( E e ) {
throw new UnsupportedOperationException ( ) ;
}
} ;
}
@Override
public boolean remove ( Object o ) {
int index = this . indexOf ( o ) ;
if ( index < <num> )
return false ;
size  ;
for ( int i = index ; i < size ; i ++ )
elements [ i ] = elements [ i + <num> ] ;
return true ;
}
@Override
@SuppressWarnings("unchecked")
public E remove ( int index ) {
checkIndex ( index ) ;
E ret = ( E ) elements [ index ] ;
size  ;
for ( int i = index ; i < size ; i ++ )
elements [ i ] = elements [ i + <num> ] ;
return ret ;
}
private void checkIndex ( int index ) {
if ( index < <num> )
throw new IllegalArgumentException ( " ) ;
if ( index > size )
throw new IllegalArgumentException (
" ) ;
}
@Override
public boolean removeAll ( Collection < ? > c ) {
Iterator < ? > iter = c . iterator ( ) ;
boolean ret = false ;
while ( iter . hasNext ( ) ) {
if ( remove ( iter . next ( ) ) )
ret = true ;
}
return ret ;
}
@Override
public boolean retainAll ( Collection < ? > c ) {
int deleteCount = <num> ;
for ( int i = <num> ; i < size ; i ++ ) {
if ( ! c . contains ( elements [ i ] ) ) {
elements [ i ] = PLACE_HOLDER ;
deleteCount ++ ;
}
}
if ( deleteCount == <num> )
return false ;
int i = <num> ;
while ( deleteCount > <num> ) {
while ( elements [ i ] != PLACE_HOLDER )
i ++ ;
int j = i ;
while ( i < size && elements [ i ] == PLACE_HOLDER )
i ++ ;
int k = i  j ;
while ( i < size ) {
elements [ i  k ] = elements [ i ] ;
i ++ ;
}
size -= k ;
deleteCount -= k ;
i = j ;
}
return true ;
}
@Override
@SuppressWarnings("unchecked")
public E set ( int index , E element ) {
checkIndex ( index ) ;
E ret = ( E ) elements [ index ] ;
elements [ index ] = element ;
return ret ;
}
@Override
public int size ( ) {
return size ;
}
@Override
public List < E > subList ( int fromIndex , int toIndex ) {
if ( fromIndex < <num> || toIndex > size || fromIndex > toIndex )
throw new IndexOutOfBoundsException ( " + fromIndex
+ " + toIndex + " + size ) ;
WArrayList < E > sub = new WArrayList < E > ( ) ;
for ( int i = fromIndex ; i < toIndex ; i ++ )
sub . add ( get ( i ) ) ;
return sub ;
}
@Override
public Object [ ] toArray ( ) {
Object [ ] ret = new Object [ size ] ;
System . arraycopy ( elements , <num> , ret , <num> , size ) ;
return ret ;
}
@Override
@SuppressWarnings("unchecked")
public < T > T [ ] toArray ( T [ ] a ) {
if ( a . length < size )
return ( T [ ] ) Arrays . copyOf ( elements , size , a . getClass ( ) ) ;
else {
System . arraycopy ( elements , <num> , a , <num> , size ) ;
for ( int i = size ; i < a . length ; i ++ )
a [ i ] = null ;
return a ;
}
}
}
package person . winter . collections ;
import java . lang . reflect . Array ;
import java . util . Collection ;
import java . util . Deque ;
import java . util . Iterator ;
import java . util . List ;
import java . util . ListIterator ;
import java . util . NoSuchElementException ;
public class WLinkedList < E > implements List < E > , Deque < E > {
static class Node {
Object element ;
Node next ;
Node previous ;
}
private Node head ;
private Node tail ;
private int size ;
public WLinkedList ( ) {
head = new Node ( ) ;
tail = new Node ( ) ;
head . next = tail ;
tail . previous = head ;
size = <num> ;
}
@Override
public boolean add ( E e ) {
addLast ( e ) ;
return true ;
}
@Override
public void add ( int index , E element ) {
checkIndex ( index , true ) ;
Node n = head . next ;
int i = <num> ;
while ( n != tail && i < index ) {
n = n . next ;
i ++ ;
}
Node newNode = new Node ( ) ;
newNode . element = element ;
newNode . next = n . next ;
newNode . previous = n ;
n . next . previous = newNode ;
n . next = newNode ;
size ++ ;
}
private void checkIndex ( int index , boolean canEqualToSize ) {
if ( index < <num> )
throw new IndexOutOfBoundsException ( " ) ;
if ( index > size )
throw new IndexOutOfBoundsException (
" ) ;
if ( index == size && ! canEqualToSize )
throw new IndexOutOfBoundsException (
" ) ;
}
@Override
public boolean addAll ( Collection < ? extends E > c ) {
Iterator < ? extends E > iter = c . iterator ( ) ;
while ( iter . hasNext ( ) ) {
addLast ( iter . next ( ) ) ;
}
size += c . size ( ) ;
return c . size ( ) > <num> ;
}
@Override
public boolean addAll ( int index , Collection < ? extends E > c ) {
Iterator < ? extends E > iter = c . iterator ( ) ;
while ( iter . hasNext ( ) ) {
add ( index ++ , iter . next ( ) ) ;
}
size += c . size ( ) ;
return c . size ( ) > <num> ;
}
@Override
public void clear ( ) {
head . next = tail ;
tail . previous = head ;
size = <num> ;
}
@Override
public boolean contains ( Object o ) {
Node n = head . next ;
while ( n != tail ) {
if ( n . element == null && o == null )
return true ;
if ( n . element != null && o != null ) {
if ( n . element . equals ( o ) )
return true ;
}
n = n . next ;
}
return false ;
}
@Override
public boolean containsAll ( Collection < ? > c ) {
Iterator < ? > iter = c . iterator ( ) ;
while ( iter . hasNext ( ) ) {
if ( ! contains ( iter . next ( ) ) )
return false ;
}
return true ;
}
@SuppressWarnings("unchecked")
@Override
public E get ( int index ) {
checkIndex ( index , false ) ;
Node n = head . next ;
int i = <num> ;
while ( n != tail && i < index )
n = n . next ;
if ( n == tail )
return null ;
return ( E ) n . element ;
}
@Override
public int indexOf ( Object o ) {
Node n = head . next ;
int index = <num> ;
while ( n != tail ) {
if ( n . element == null && o == null )
return index ;
if ( n . element != null && o != null ) {
if ( n . element . equals ( o ) )
return index ;
}
n = n . next ;
index ++ ;
}
return  <num> ;
}
@Override
public boolean isEmpty ( ) {
return size == <num> ;
}
@Override
public Iterator < E > iterator ( ) {
return new Iterator < E > ( ) {
private Node n = head . next ;
@Override
public boolean hasNext ( ) {
return n != tail ;
}
@SuppressWarnings("unchecked")
@Override
public E next ( ) {
if ( ! hasNext ( ) )
throw new NoSuchElementException ( ) ;
Object ret = n . element ;
n = n . next ;
return ( E ) ret ;
}
@Override
public void remove ( ) {
throw new UnsupportedOperationException ( " ) ;
}
} ;
}
@Override
public int lastIndexOf ( Object o ) {
Node n = tail . previous ;
int index = size  <num> ;
while ( n != head ) {
if ( n . element == null && o == null )
return index ;
if ( n . element != null && o != null ) {
if ( n . element . equals ( o ) )
return index ;
}
n = n . previous ;
index  ;
}
return  <num> ;
}
@Override
public ListIterator < E > listIterator ( int index ) {
return new ListIteratorImpl ( index ) ;
}
@Override
public ListIterator < E > listIterator ( ) {
return listIterator ( <num> ) ;
}
private boolean equals ( Object o1 , Object o2 ) {
if ( o1 == null && o2 == null )
return true ;
if ( o1 != null && o2 != null )
return o1 . equals ( o2 ) ;
return false ;
}
@Override
public boolean remove ( Object o ) {
Node n = head . next ;
while ( n != tail ) {
if ( equals ( n . element , o ) ) {
n . previous . next = n . next ;
n . next . previous = n . previous ;
size  ;
return true ;
}
n = n . next ;
}
return false ;
}
@SuppressWarnings("unchecked")
@Override
public E remove ( int index ) {
checkIndex ( index , false ) ;
Node n = head . next ;
int i = <num> ;
while ( n != tail && i < index ) {
n = n . next ;
}
if ( n == tail )
return null ;
Object ret = n . element ;
n . previous . next = n . next ;
n . next . previous = n . previous ;
size  ;
return ( E ) ret ;
}
@Override
public boolean removeAll ( Collection < ? > c ) {
Node n = head . next ;
boolean changed = false ;
while ( n != tail ) {
if ( c . contains ( n . element ) ) {
n . previous . next = n . next ;
n . next . previous = n . previous ;
changed = true ;
size  ;
}
n = n . next ;
}
return changed ;
}
@Override
public boolean retainAll ( Collection < ? > c ) {
Node n = head . next ;
boolean changed = false ;
while ( n != tail ) {
if ( ! c . contains ( n . element ) ) {
n . previous . next = n . next ;
n . next . previous = n . previous ;
changed = true ;
size  ;
}
n = n . next ;
}
return changed ;
}
@SuppressWarnings("unchecked")
@Override
public E set ( int index , E element ) {
checkIndex ( index , false ) ;
Node n = head . next ;
int i = <num> ;
while ( n != tail && i < index ) {
n = n . next ;
i ++ ;
}
Object ret = n . element ;
n . element = element ;
return ( E ) ret ;
}
@Override
public int size ( ) {
return size ;
}
@SuppressWarnings("unchecked")
@Override
public List < E > subList ( int fromIndex , int toIndex ) {
if ( fromIndex < <num> || toIndex > size || fromIndex > toIndex )
throw new IndexOutOfBoundsException ( " + fromIndex
+ " + toIndex + " + size ) ;
WLinkedList < E > sub = new WLinkedList < E > ( ) ;
Node n = head . next ;
int i = <num> ;
while ( n != tail && i < fromIndex ) {
n = n . next ;
i ++ ;
}
while ( n != tail && i < toIndex ) {
sub . add ( ( E ) n . element ) ;
n = n . next ;
i ++ ;
}
return sub ;
}
@Override
public Object [ ] toArray ( ) {
Object [ ] array = new Object [ size ] ;
Iterator < E > iter = iterator ( ) ;
int i = <num> ;
while ( iter . hasNext ( ) ) {
array [ i ++ ] = iter . next ( ) ;
}
return array ;
}
@SuppressWarnings("unchecked")
@Override
public < T > T [ ] toArray ( T [ ] a ) {
T [ ] copy ;
if ( a . length < size ) {
copy = ( ( Object ) ( a . getClass ( ) ) == ( Object ) Object [ ] . class )
? ( T [ ] ) new Object [ size ]
: ( T [ ] ) Array . newInstance ( a . getClass ( ) . getComponentType ( ) , size ) ;
} else {
copy = a ;
}
int i = <num> ;
Iterator < E > iter = iterator ( ) ;
while ( iter . hasNext ( ) ) {
copy [ i ++ ] = ( T ) iter . next ( ) ;
}
for ( ; i < copy . length ; i ++ ) {
copy [ i ] = null ;
}
return copy ;
}
@Override
public void addFirst ( E e ) {
Node n = new Node ( ) ;
n . element = e ;
n . next = head . next ;
n . previous = head ;
head . next = n ;
size ++ ;
}
@Override
public void addLast ( E e ) {
Node n = new Node ( ) ;
n . element = e ;
n . previous = tail . previous ;
n . next = tail ;
tail . previous = n ;
size ++ ;
}
@Override
public Iterator < E > descendingIterator ( ) {
return new Iterator < E > ( ) {
Node n = tail . previous ;
@Override
public boolean hasNext ( ) {
return n != head ;
}
@SuppressWarnings("unchecked")
@Override
public E next ( ) {
if ( ! hasNext ( ) )
throw new NoSuchElementException ( ) ;
Object ret = n . element ;
n = n . previous ;
return ( E ) ret ;
}
@Override
public void remove ( ) {
throw new UnsupportedOperationException ( " ) ;
}
} ;
}
@SuppressWarnings("unchecked")
@Override
public E element ( ) {
Node n = head . next ;
if ( n == tail )
throw new NoSuchElementException ( ) ;
return ( E ) n . element ;
}
@Override
public E getFirst ( ) {
return element ( ) ;
}
@SuppressWarnings("unchecked")
@Override
public E getLast ( ) {
Node n = tail . previous ;
if ( n == head )
throw new NoSuchElementException ( ) ;
return ( E ) n . element ;
}
@Override
public boolean offer ( E e ) {
return offerLast ( e ) ;
}
@Override
public boolean offerFirst ( E e ) {
addFirst ( e ) ;
return true ;
}
@Override
public boolean offerLast ( E e ) {
addLast ( e ) ;
return true ;
}
@Override
public E peek ( ) {
return peekFirst ( ) ;
}
@SuppressWarnings("unchecked")
@Override
public E peekFirst ( ) {
Node n = head . next ;
if ( n == tail )
return null ;
return ( E ) n . element ;
}
@SuppressWarnings("unchecked")
@Override
public E peekLast ( ) {
Node n = tail . previous ;
if ( n == head )
return null ;
return ( E ) n . element ;
}
@Override
public E poll ( ) {
return pollFirst ( ) ;
}
@SuppressWarnings("unchecked")
@Override
public E pollFirst ( ) {
Node n = head . next ;
if ( n == tail )
return null ;
Object ret = n . element ;
n . next . previous = n . previous ;
n . previous . next = n . next ;
size  ;
return ( E ) ret ;
}
@SuppressWarnings("unchecked")
@Override
public E pollLast ( ) {
Node n = tail . previous ;
if ( n == head )
return null ;
Object ret = n . element ;
n . next . previous = n . previous ;
n . previous . next = n . next ;
size  ;
return ( E ) ret ;
}
@Override
public E pop ( ) {
return removeFirst ( ) ;
}
@Override
public void push ( E e ) {
addFirst ( e ) ;
}
@Override
public E remove ( ) {
return removeFirst ( ) ;
}
@SuppressWarnings("unchecked")
@Override
public E removeFirst ( ) {
Node n = head . next ;
if ( n == tail )
throw new NoSuchElementException ( ) ;
Object ret = n . element ;
n . next . previous = n . previous ;
n . previous . next = n . next ;
size  ;
return ( E ) ret ;
}
@Override
public boolean removeFirstOccurrence ( Object o ) {
return remove ( o ) ;
}
@SuppressWarnings("unchecked")
@Override
public E removeLast ( ) {
Node n = tail . previous ;
if ( n == head )
throw new NoSuchElementException ( ) ;
Object ret = n . element ;
n . next . previous = n . previous ;
n . previous . next = n . next ;
size  ;
return ( E ) ret ;
}
@Override
public boolean removeLastOccurrence ( Object o ) {
Node n = tail . previous ;
while ( n != head ) {
if ( equals ( n . element , o ) ) {
n . next . previous = n . previous ;
n . previous . next = n . next ;
size  ;
return true ;
}
n = n . previous ;
}
return false ;
}
private class ListIteratorImpl implements ListIterator < E > {
private Node iterHead ;
private int iterIndex ;
ListIteratorImpl ( int startIndex ) {
checkIndex ( startIndex , false ) ;
iterHead = head . next ;
iterIndex = <num> ;
int i = <num> ;
while ( iterHead != tail && i < startIndex ) {
iterHead = iterHead . next ;
i ++ ;
}
}
@Override
public void add ( E e ) {
throw new UnsupportedOperationException ( " ) ;
}
@Override
public boolean hasNext ( ) {
return iterHead != tail ;
}
@Override
public boolean hasPrevious ( ) {
return iterIndex > <num> ;
}
@SuppressWarnings("unchecked")
@Override
public E next ( ) {
if ( iterHead == tail )
return null ;
Object ret = iterHead . element ;
iterHead = iterHead . next ;
iterIndex ++ ;
return ( E ) ret ;
}
@Override
public int nextIndex ( ) {
return iterIndex ;
}
@SuppressWarnings("unchecked")
@Override
public E previous ( ) {
if ( iterIndex <= <num> )
return null ;
Object ret = iterHead . previous . element ;
iterHead = iterHead . previous ;
iterIndex  ;
return ( E ) ret ;
}
@Override
public int previousIndex ( ) {
return iterIndex  <num> ;
}
@Override
public void remove ( ) {
throw new UnsupportedOperationException ( " ) ;
}
@Override
public void set ( E e ) {
throw new UnsupportedOperationException ( " ) ;
}
}
}
package person . winter ;
public class HelloWorld {
public static void main ( String [ ] args ) {
System . out . println ( " ) ;
}
}
public class <unk> {
public static void main ( String [ ] args ) {
System . out . println ( " ) ;
}
}
package br . com . ps . <unk> . test ;
public class Show {
public static void main ( String [ ] args ) {
System . out . println ( " ) ;
}
}
package com . noelcurtis . adder ;
import java . io . BufferedReader ;
import java . io . DataInputStream ;
import java . io . FileInputStream ;
import java . io . InputStreamReader ;
import java . util . * ;
public class TriangleAdder {
private static TriangleAdder sharedInstance = new TriangleAdder ( ) ;
public static TriangleAdder getInstance ( ) {
return sharedInstance ;
}
private TriangleAdder ( ) {
}
private List < List < String >> numberLists ;
private long largestSum ;
public List < List < String >> parseFile ( String fileName ) throws Exception {
List < List < String >> numberLists = new ArrayList < List < String >> ( ) ;
FileInputStream fstream = new FileInputStream ( fileName ) ;
DataInputStream in = new DataInputStream ( fstream ) ;
BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ;
String strLine ;
while ( ( strLine = br . readLine ( ) ) != null ) {
String [ ] lineSplit = strLine . split ( " ) ;
List < String > numbers = Arrays . asList ( lineSplit ) ;
numberLists . add ( numbers ) ;
}
in . close ( ) ;
this . numberLists = numberLists ;
return numberLists ;
}
public Long findLargestSum ( ) {
this . largestSum = <num> ;
this . findLargestSum ( new NodeData ( Long . parseLong ( this . numberLists . get ( <num> ) . get ( <num> ) ) , Long . parseLong ( this . numberLists . get ( <num> ) . get ( <num> ) ) , <num> , <num> ) ) ;
return this . largestSum ;
}
private void findLargestSum ( NodeData node ) {
if ( node . getLevelInTree ( ) < this . numberLists . size ( )  <num> ) {
int currentDepth = node . getLevelInTree ( ) ;
int currentPosition = node . getPositionInList ( ) ;
long numberForChild1 = Long . parseLong ( this . numberLists . get ( currentDepth + <num> ) . get ( currentPosition ) ) ;
long numberForChild2 = Long . parseLong ( this . numberLists . get ( currentDepth + <num> ) . get ( currentPosition + <num> ) ) ;
NodeData child1 = new NodeData ( numberForChild1 , node . getSumAtNode ( ) + numberForChild1 , currentPosition , currentDepth + <num> ) ;
NodeData child2 = new NodeData ( numberForChild2 , node . getSumAtNode ( ) + numberForChild2 , currentPosition + <num> , currentDepth + <num> ) ;
findLargestSum ( child1 ) ;
findLargestSum ( child2 ) ;
} else {
if ( node . getSumAtNode ( ) > this . largestSum ) {
this . largestSum = node . getSumAtNode ( ) ;
}
}
}
}
package com . noelcurtis . integration ;
import org . junit . Assert ;
import org . junit . Ignore ;
import org . junit . Test ;
import com . noelcurtis . adder . TriangleAdder ;
import java . util . List ;
public class <unk> {
@Test
public void <unk> ( ) {
try {
List < List < String >> numberLists = TriangleAdder . getInstance ( ) . parseFile ( " ) ;
assert numberLists . size ( ) == <num> ;
} catch ( Exception ex ) {
Assert . fail ( ex . toString ( ) ) ;
}
}
@Test
public void <unk> ( ) {
try {
List < List < String >> numberLists = TriangleAdder . getInstance ( ) . parseFile ( " ) ;
assert numberLists . size ( ) == <num> ;
} catch ( Exception ex ) {
Assert . fail ( ex . toString ( ) ) ;
}
}
@Test
public void <unk> ( ) {
try {
TriangleAdder . getInstance ( ) . parseFile ( " ) ;
assert TriangleAdder . getInstance ( ) . findLargestSum ( ) == <num> ;
} catch ( Exception ex ) {
Assert . fail ( ex . toString ( ) ) ;
}
}
@Test
public void <unk> ( ) {
try {
TriangleAdder . getInstance ( ) . parseFile ( " ) ;
System . out . println ( TriangleAdder . getInstance ( ) . findLargestSum ( ) ) ;
} catch ( Exception ex ) {
Assert . fail ( ex . toString ( ) ) ;
}
}
}
package com . noelcurtis . adder ;
public class NodeData {
private long sumAtNode ;
private long number ;
private int positionInList ;
private int levelInTree ;
public NodeData ( long number , long sumAtNode , int positionInList , int levelInTree ) {
this . sumAtNode = sumAtNode ;
this . number = number ;
this . positionInList = positionInList ;
this . levelInTree = levelInTree ;
}
public long getSumAtNode ( ) {
return sumAtNode ;
}
public void <unk> ( Long sumAtNode ) {
this . sumAtNode = sumAtNode ;
}
public long getNumber ( ) {
return number ;
}
public void setNumber ( Long number ) {
this . number = number ;
}
public int getPositionInList ( ) {
return positionInList ;
}
public void <unk> ( int positionInList ) {
this . positionInList = positionInList ;
}
public int getLevelInTree ( ) {
return levelInTree ;
}
public void <unk> ( int levelInTree ) {
this . levelInTree = levelInTree ;
}
public String toString ( ) {
return Long . toString ( this . number ) + " + Long . toString ( this . sumAtNode ) ;
}
}
package com . github . thebiologist13 ;
import java . io . File ;
import java . util . HashMap ;
import org . bukkit . ChatColor ;
import org . bukkit . command . Command ;
import org . bukkit . command . CommandExecutor ;
import org . bukkit . command . CommandSender ;
import org . bukkit . entity . Player ;
public class DelQueryCommandExecutor implements CommandExecutor {
private static Query plugin ;
private static Player player = null ;
@SuppressWarnings("static-access")
public DelQueryCommandExecutor ( Query plugin ) {
this . plugin = plugin ;
}
public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) {
if ( sender instanceof Player ) {
player = ( Player ) sender ;
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
if ( player == null ) {
Query . debugMsg ( " + args [ <num> ] ) ;
} else {
Query . debugMsg ( ChatColor . DARK_PURPLE + player . getName ( ) + " + args [ <num> ] ) ;
File [ ] list = getFiles ( ) ;
Query . debugMsg ( " + plugin . getDataFolder ( ) + " + list . toString ( ) ) ;
boolean match = false ;
if ( checkPerm ( " ) ) {
Query . debugMsg ( " ) ;
if ( list . length != <num> ) {
for ( File f : list ) {
Query . debugMsg ( " + f . getName ( ) ) ;
if ( isYaml ( f ) ) {
String noExt = getFilesNoExt ( ) . get ( f ) ;
if ( args [ <num> ] . equalsIgnoreCase ( noExt ) ) {
Query . debugMsg ( " ) ;
match = true ;
f . delete ( ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " + noExt + " ) ;
Query . promptMsg ( " + noExt + " + player . getName ( ) ) ;
break ;
}
}
}
}
}
if ( ! match ) {
player . sendMessage ( ChatColor . DARK_RED + " + args [ <num> ] + " ) ;
}
}
return true ;
}
return false ;
}
public static File [ ] getFiles ( ) {
String path = plugin . getDataFolder ( ) + " ;
File folder = new File ( path ) ;
File [ ] list = folder . listFiles ( ) ;
return list ;
}
public static HashMap < File , String > getFilesNoExt ( ) {
HashMap < File , String > noExt = new HashMap < File , String > ( ) ;
File [ ] list = getFiles ( ) ;
for ( int i = <num> ; i < list . length ; i ++ ) {
try {
if ( list [ i ] . isFile ( ) ) {
int index = list [ i ] . getName ( ) . lastIndexOf ( " ) ;
if ( index > <num> && index <= list [ i ] . getName ( ) . length ( )  <num> ) {
noExt . put ( list [ i ] , list [ i ] . getName ( ) . substring ( <num> , index ) ) ;
}
}
} catch ( ArrayIndexOutOfBoundsException e ) {
Query . debugMsg ( " ) ;
return null ;
}
}
if ( noExt . isEmpty ( ) ) {
Query . debugMsg ( " ) ;
return null ;
} else {
Query . debugMsg ( " ) ;
return noExt ;
}
}
public static boolean isYaml ( File f ) {
int index = f . getName ( ) . lastIndexOf ( .' ) ;
if ( f . getName ( ) . substring ( index ) . equals ( " ) ) {
Query . debugMsg ( " + f . getName ( ) + " ) ;
return true ;
} else {
Query . debugMsg ( " + f . getName ( ) + " ) ;
return false ;
}
}
public static boolean checkPerm ( String perm ) {
if ( player != null ) {
if ( player . hasPermission ( " + perm ) ) {
Query . debugMsg ( player . getName ( ) + " + perm + " ) ;
return true ;
} else {
return false ;
}
} else {
return false ;
}
}
}
package com . github . thebiologist13 ;
import java . util . HashMap ;
import org . bukkit . ChatColor ;
import org . bukkit . Location ;
import org . bukkit . entity . Player ;
public class QueryData {
static HashMap < String , Location > position1 = new HashMap < String , Location > ( ) ;
static HashMap < String , Location > position2 = new HashMap < String , Location > ( ) ;
static Location <unk> = null ;
public static void expandSelection ( String [ ] args , Player p ) {
for ( int i = <num> ; i < position1 . size ( ) ; i ++ ) {
Query . debugMsg ( position1 . toString ( ) ) ;
}
for ( int i = <num> ; i < position2 . size ( ) ; i ++ ) {
Query . debugMsg ( position2 . toString ( ) ) ;
}
boolean x1 = false , x2 = false ;
boolean y1 = false , y2 = false ;
boolean z1 = false , z2 = false ;
if ( ! position1 . containsKey ( p . getName ( ) ) || ! position2 . containsKey ( p . getName ( ) ) ) {
Query . debugMsg ( " ) ;
return ;
}
if ( position1 . get ( p . getName ( ) ) . getBlockX ( ) > position2 . get ( p . getName ( ) ) . getBlockX ( ) ) {
x1 = true ;
} else if ( position1 . get ( p . getName ( ) ) . getBlockX ( ) < position2 . get ( p . getName ( ) ) . getBlockX ( ) ) {
x2 = true ;
}
if ( position1 . get ( p . getName ( ) ) . getBlockY ( ) > position2 . get ( p . getName ( ) ) . getBlockY ( ) ) {
y1 = true ;
} else if ( position1 . get ( p . getName ( ) ) . getBlockY ( ) < position2 . get ( p . getName ( ) ) . getBlockY ( ) ) {
y2 = true ;
}
if ( position1 . get ( p . getName ( ) ) . getBlockZ ( ) > position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) {
z1 = true ;
} else if ( position1 . get ( p . getName ( ) ) . getBlockZ ( ) < position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) {
z2 = true ;
}
if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( z1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( )  Integer . parseInt ( args [ <num> ] ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else if ( z2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( )  Integer . parseInt ( args [ <num> ] ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( )  Integer . parseInt ( args [ <num> ] ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( z1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) + Integer . parseInt ( args [ <num> ] ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else if ( z2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) + Integer . parseInt ( args [ <num> ] ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) + Integer . parseInt ( args [ <num> ] ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( x1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) + Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else if ( x2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) + Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) + Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( x1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( )  Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else if ( x2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( )  Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( )  Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( y1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) + Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else if ( y2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) + Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) + Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( y1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( )  Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else if ( y2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( )  Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( )  Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
}
} else {
p . sendMessage ( ChatColor . DARK_RED + " ) ;
}
}
public static void contractSelection ( String [ ] args , Player p ) {
for ( int i = <num> ; i < position1 . size ( ) ; i ++ ) {
Query . debugMsg ( position1 . toString ( ) ) ;
}
for ( int i = <num> ; i < position2 . size ( ) ; i ++ ) {
Query . debugMsg ( position2 . toString ( ) ) ;
}
boolean x1 = false , x2 = false ;
boolean y1 = false , y2 = false ;
boolean z1 = false , z2 = false ;
if ( ! position1 . containsKey ( p . getName ( ) ) || ! position2 . containsKey ( p . getName ( ) ) ) {
Query . debugMsg ( " ) ;
return ;
}
if ( position1 . get ( p . getName ( ) ) . getBlockX ( ) > position2 . get ( p . getName ( ) ) . getBlockX ( ) ) {
x1 = true ;
} else if ( position1 . get ( p . getName ( ) ) . getBlockX ( ) < position2 . get ( p . getName ( ) ) . getBlockX ( ) ) {
x2 = true ;
}
if ( position1 . get ( p . getName ( ) ) . getBlockY ( ) > position2 . get ( p . getName ( ) ) . getBlockY ( ) ) {
y1 = true ;
} else if ( position1 . get ( p . getName ( ) ) . getBlockY ( ) < position2 . get ( p . getName ( ) ) . getBlockY ( ) ) {
y2 = true ;
}
if ( position1 . get ( p . getName ( ) ) . getBlockZ ( ) > position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) {
z1 = true ;
} else if ( position1 . get ( p . getName ( ) ) . getBlockZ ( ) < position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) {
z2 = true ;
}
if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( z1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( )  Integer . parseInt ( args [ <num> ] ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else if ( z2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( )  Integer . parseInt ( args [ <num> ] ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( )  Integer . parseInt ( args [ <num> ] ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( z1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) + Integer . parseInt ( args [ <num> ] ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else if ( z2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) + Integer . parseInt ( args [ <num> ] ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) + Integer . parseInt ( args [ <num> ] ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( x1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) + Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else if ( x2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) + Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) + Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( x1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( )  Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else if ( x2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( )  Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( )  Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( y1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) + Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else if ( y2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( ) + Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( ) + Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
}
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
if ( y1 ) {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( )  Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
} else if ( y2 ) {
Location newLoc = new Location ( p . getWorld ( ) , position2 . get ( p . getName ( ) ) . getBlockX ( ) , position2 . get ( p . getName ( ) ) . getBlockY ( )  Integer . parseInt ( args [ <num> ] ) , position2 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position2 . put ( p . getName ( ) , newLoc ) ;
} else {
Location newLoc = new Location ( p . getWorld ( ) , position1 . get ( p . getName ( ) ) . getBlockX ( ) , position1 . get ( p . getName ( ) ) . getBlockY ( )  Integer . parseInt ( args [ <num> ] ) , position1 . get ( p . getName ( ) ) . getBlockZ ( ) ) ;
position1 . put ( p . getName ( ) , newLoc ) ;
}
} else {
p . sendMessage ( ChatColor . DARK_RED + " ) ;
}
}
}
package com . github . thebiologist13 ;
import java . io . File ;
import java . io . IOException ;
import java . util . HashMap ;
import org . bukkit . ChatColor ;
import org . bukkit . command . Command ;
import org . bukkit . command . CommandExecutor ;
import org . bukkit . command . CommandSender ;
import org . bukkit . configuration . file . FileConfiguration ;
import org . bukkit . configuration . file . YamlConfiguration ;
import org . bukkit . entity . Player ;
public class QueryDescCommandExecutor implements CommandExecutor {
private static Player player = null ;
private static Query plugin ;
@SuppressWarnings("static-access")
public QueryDescCommandExecutor ( Query plugin ) {
this . plugin = plugin ;
}
public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) {
FileConfiguration config = Query . config ;
int maxLines = config . getInt ( " ) ;
if ( sender instanceof Player ) {
player = ( Player ) sender ;
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
if ( player == null ) {
Query . debugMsg ( " + cmd . getName ( ) + " ) ;
return true ;
}
Query . debugMsg ( ChatColor . DARK_PURPLE + player . getName ( ) + " + args [ <num> ] + " + args [ <num> ] + " + args [ <num> ] ) ;
if ( checkPerm ( " ) ) {
File [ ] list = getFiles ( ) ;
Query . debugMsg ( " + plugin . getDataFolder ( ) + " + list . toString ( ) ) ;
boolean match = false ;
if ( list . length != <num> ) {
for ( File f : list ) {
if ( isYaml ( f ) ) {
String noExt = getFilesNoExt ( ) . get ( f ) ;
if ( args [ <num> ] . equalsIgnoreCase ( noExt ) ) {
Query . debugMsg ( " + args [ <num> ] + " + f . getName ( ) ) ;
match = true ;
if ( Integer . parseInt ( args [ <num> ] ) <= maxLines ) {
Query . debugMsg ( " + maxLines + " + args [ <num> ] ) ;
String desc = " ;
for ( int m = <num> ; m < args . length ; m ++ ) {
desc = desc + " + args [ m ] ;
}
Query . debugMsg ( " + desc + " + f . getName ( ) + " + f . getPath ( ) + " + noExt + " + args [ <num> ] ) ;
FileConfiguration yaml = YamlConfiguration . loadConfiguration ( f ) ;
yaml . set ( noExt + " + args [ <num> ] , desc ) ;
try {
yaml . save ( f ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " ) ;
Query . promptMsg ( " + noExt + " + player . getName ( ) ) ;
} catch ( IOException e ) {
Query . debugMsg ( " + e . getMessage ( ) ) ;
Query . severeMsg ( " ) ;
player . sendMessage ( ChatColor . DARK_RED + " ) ;
}
Query . debugMsg ( " + f . getName ( ) ) ;
} else {
player . sendMessage ( ChatColor . DARK_RED + args [ <num> ] + " + String . valueOf ( maxLines ) ) ;
}
break ;
}
}
}
}
if ( ! match ) {
player . sendMessage ( ChatColor . DARK_RED + " + args [ <num> ] + " ) ;
}
}
return true ;
}
return false ;
}
public static boolean checkPerm ( String perm ) {
if ( player != null ) {
if ( player . hasPermission ( " + perm ) ) {
Query . debugMsg ( player . getName ( ) + " + perm + " ) ;
return true ;
} else {
return false ;
}
} else {
return false ;
}
}
public static File [ ] getFiles ( ) {
String path = plugin . getDataFolder ( ) + " ;
File folder = new File ( path ) ;
File [ ] list = folder . listFiles ( ) ;
return list ;
}
public static String getFilesAsString ( ) {
String list = " ;
for ( File f : getFiles ( ) ) {
if ( f . isFile ( ) ) {
list += " + f . getName ( ) ;
}
}
Query . debugMsg ( " + list ) ;
return list ;
}
public static HashMap < File , String > getFilesNoExt ( ) {
HashMap < File , String > noExt = new HashMap < File , String > ( ) ;
File [ ] list = getFiles ( ) ;
for ( int i = <num> ; i < list . length ; i ++ ) {
try {
if ( list [ i ] . isFile ( ) ) {
int index = list [ i ] . getName ( ) . lastIndexOf ( " ) ;
if ( index > <num> && index <= list [ i ] . getName ( ) . length ( )  <num> ) {
noExt . put ( list [ i ] , list [ i ] . getName ( ) . substring ( <num> , index ) ) ;
}
}
} catch ( ArrayIndexOutOfBoundsException e ) {
Query . debugMsg ( " ) ;
return null ;
}
}
if ( noExt . isEmpty ( ) ) {
Query . debugMsg ( " ) ;
return null ;
} else {
Query . debugMsg ( " ) ;
return noExt ;
}
}
public static boolean isYaml ( File f ) {
int index = f . getName ( ) . lastIndexOf ( .' ) ;
if ( f . getName ( ) . substring ( index ) . equals ( " ) ) {
Query . debugMsg ( " + f . getName ( ) + " ) ;
return true ;
} else {
Query . debugMsg ( " + f . getName ( ) + " ) ;
return false ;
}
}
}
package com . github . thebiologist13 ;
import java . io . File ;
import java . util . HashMap ;
import org . bukkit . ChatColor ;
import org . bukkit . Location ;
import org . bukkit . World ;
import org . bukkit . configuration . file . FileConfiguration ;
import org . bukkit . configuration . file . YamlConfiguration ;
import org . bukkit . entity . Player ;
import org . bukkit . event . EventHandler ;
import org . bukkit . event . Listener ;
import org . bukkit . event . player . PlayerMoveEvent ;
public class QueryPlayerMoveListener implements Listener {
private static Query plugin ;
private static Player player ;
public QueryPlayerMoveListener ( Query plugin ) {
QueryPlayerMoveListener . plugin = plugin ;
}
HashMap < Player , Boolean > enteredArea = new HashMap < Player , Boolean > ( ) ;
@EventHandler
public void onPlayerMove ( PlayerMoveEvent event ) {
player = event . getPlayer ( ) ;
File [ ] list = getFiles ( ) ;
HashMap < String , Integer > positions = new HashMap < String , Integer > ( ) ;
if ( checkPerm ( " ) ) {
for ( File f : list ) {
if ( isYaml ( f ) ) {
FileConfiguration yaml = YamlConfiguration . loadConfiguration ( f ) ;
String noExt = getFilesNoExt ( ) . get ( f ) ;
positions = getPositions ( f ) ;
Location pos1 = new Location ( player . getWorld ( ) , positions . get ( " ) , positions . get ( " ) , positions . get ( " ) ) ;
Location pos2 = new Location ( player . getWorld ( ) , positions . get ( " ) , positions . get ( " ) , positions . get ( " ) ) ;
if ( isWithin ( event . getTo ( ) , pos1 , pos2 ) ) {
enteredArea . put ( player , true ) ;
} else if ( ! isWithin ( event . getTo ( ) , pos1 , pos2 ) ) {
enteredArea . put ( player , false ) ;
}
if ( ! isWithin ( event . getFrom ( ) , pos1 , pos2 ) && enteredArea . get ( player ) && inWorld ( f ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + noExt + " + yaml . getString ( noExt + " ) ) ;
} else if ( isWithin ( event . getFrom ( ) , pos1 , pos2 ) && ! enteredArea . get ( player ) && inWorld ( f ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + noExt + " + yaml . getString ( noExt + " ) ) ;
}
}
}
}
}
public static boolean checkPerm ( String perm ) {
if ( player != null ) {
if ( player . hasPermission ( " + perm ) ) {
return true ;
} else {
return false ;
}
} else {
return false ;
}
}
public static File [ ] getFiles ( ) {
String path = plugin . getDataFolder ( ) + " ;
File folder = new File ( path ) ;
File [ ] list = folder . listFiles ( ) ;
return list ;
}
public static String getFilesAsString ( ) {
String list = " ;
for ( File f : getFiles ( ) ) {
if ( f . isFile ( ) ) {
list += " + f . getName ( ) ;
}
}
Query . debugMsg ( " + list ) ;
return list ;
}
public static HashMap < File , String > getFilesNoExt ( ) {
HashMap < File , String > noExt = new HashMap < File , String > ( ) ;
File [ ] list = getFiles ( ) ;
for ( int i = <num> ; i < list . length ; i ++ ) {
try {
if ( list [ i ] . isFile ( ) ) {
int index = list [ i ] . getName ( ) . lastIndexOf ( " ) ;
if ( index > <num> && index <= list [ i ] . getName ( ) . length ( )  <num> ) {
noExt . put ( list [ i ] , list [ i ] . getName ( ) . substring ( <num> , index ) ) ;
}
}
} catch ( ArrayIndexOutOfBoundsException e ) {
Query . debugMsg ( " ) ;
return null ;
}
}
if ( noExt . isEmpty ( ) ) {
return null ;
} else {
return noExt ;
}
}
public static boolean isYaml ( File f ) {
int index = f . getName ( ) . lastIndexOf ( .' ) ;
if ( f . getName ( ) . substring ( index ) . equals ( " ) ) {
return true ;
} else {
return false ;
}
}
public static boolean inWorld ( File f ) {
HashMap < File , String > noExtMap = getFilesNoExt ( ) ;
String noExt = noExtMap . get ( f ) ;
FileConfiguration yaml = YamlConfiguration . loadConfiguration ( f ) ;
String worldName = " ;
worldName = yaml . getString ( noExt + " ) ;
World playerIn = player . getWorld ( ) ;
if ( playerIn . getName ( ) . equals ( worldName ) ) {
return true ;
}
return false ;
}
public static HashMap < String , Integer > getPositions ( File f ) {
HashMap < File , String > noExtMap = getFilesNoExt ( ) ;
String noExt = noExtMap . get ( f ) ;
HashMap < String , Integer > positions = new HashMap < String , Integer > ( ) ;
FileConfiguration yaml = YamlConfiguration . loadConfiguration ( f ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
return positions ;
}
public static boolean isWithin ( Location l , Location l1 , Location l2 ) {
if ( QueryBoundaryCheck . isWithinX ( l , l1 . getBlockX ( ) , l2 . getBlockX ( ) ) &&
QueryBoundaryCheck . isWithinY ( l , l1 . getBlockY ( ) , l2 . getBlockY ( ) ) &&
QueryBoundaryCheck . isWithinZ ( l , l1 . getBlockZ ( ) , l2 . getBlockZ ( ) ) ) {
return true ;
} else {
return false ;
}
}
}
package com . github . thebiologist13 ;
import java . util . logging . Logger ;
import org . bukkit . plugin . java . JavaPlugin ;
import org . bukkit . configuration . file . FileConfiguration ;
public class Query extends JavaPlugin {
protected static FileConfiguration config ;
public static boolean debug = false ;
static Logger log = Logger . getLogger ( " ) ;
public void onEnable ( ) {
getServer ( ) . getPluginManager ( ) . registerEvents ( new QueryPlayerListener ( this ) , this ) ;
getServer ( ) . getPluginManager ( ) . registerEvents ( new QueryPlayerMoveListener ( this ) , this ) ;
QueryCommandExecutor queryExecutor = new QueryCommandExecutor ( this ) ;
QListCommandExecutor qListExecutor = new QListCommandExecutor ( this ) ;
QDebugCommandExecutor qDebugExecutor = new QDebugCommandExecutor ( this ) ;
SetQueryCommandExecutor setQueryCommandExecutor = new SetQueryCommandExecutor ( this ) ;
DelQueryCommandExecutor delQueryExecutor = new DelQueryCommandExecutor ( this ) ;
QueryDescCommandExecutor queryDescExecutor = new QueryDescCommandExecutor ( this ) ;
QHelpCommandExecutor qHelpExecutor = new QHelpCommandExecutor ( this ) ;
QMsgCommandExecutor qMsgExecutor = new QMsgCommandExecutor ( this ) ;
getCommand ( " ) . setExecutor ( queryExecutor ) ;
getCommand ( " ) . setExecutor ( setQueryCommandExecutor ) ;
getCommand ( " ) . setExecutor ( qDebugExecutor ) ;
getCommand ( " ) . setExecutor ( qListExecutor ) ;
getCommand ( " ) . setExecutor ( delQueryExecutor ) ;
getCommand ( " ) . setExecutor ( queryDescExecutor ) ;
getCommand ( " ) . setExecutor ( qHelpExecutor ) ;
getCommand ( " ) . setExecutor ( setQueryCommandExecutor ) ;
getCommand ( " ) . setExecutor ( setQueryCommandExecutor ) ;
getCommand ( " ) . setExecutor ( setQueryCommandExecutor ) ;
getCommand ( " ) . setExecutor ( qMsgExecutor ) ;
config = this . getConfig ( ) ;
config . options ( ) . header ( " ) ;
config . addDefault ( " , <num> ) ;
config . addDefault ( " , <num> ) ;
config . addDefault ( " , <num> ) ;
config . addDefault ( " , false ) ;
config . options ( ) . copyDefaults ( true ) ;
this . saveConfig ( ) ;
debug = config . getBoolean ( " ) ;
log . info ( " ) ;
}
public void onDisable ( ) {
log . info ( " ) ;
}
public static void debugMsg ( String msg ) {
if ( Query . debug ) {
log . info ( " + msg ) ;
}
}
public static void severeMsg ( String msg ) {
log . severe ( msg ) ;
}
public static void promptMsg ( String msg ) {
log . info ( msg ) ;
}
}
package com . github . thebiologist13 ;
import org . bukkit . Location ;
public class QueryBoundaryCheck {
public static boolean isWithinX ( Location l , int x1 , int x2 ) {
double lx = l . getX ( ) ;
boolean isX1Larger = false ;
boolean isX2Larger = false ;
if ( x1 > x2 ) {
isX1Larger = true ;
}
if ( x2 > x1 ) {
isX2Larger = true ;
}
if ( isX1Larger ) {
if ( lx <= x1 && lx >= x2 ) {
return true ;
}
return false ;
}
if ( isX2Larger ) {
if ( lx <= x2 && lx >= x1 ) {
return true ;
}
return false ;
}
if ( ! isX1Larger && ! isX2Larger ) {
if ( lx == x1 && lx == x2 ) {
return true ;
}
return false ;
}
return false ;
}
public static boolean isWithinY ( Location l , int y1 , int y2 ) {
double ly = l . getY ( ) ;
boolean isY1Larger = false ;
boolean isY2Larger = false ;
if ( y1 > y2 ) {
isY1Larger = true ;
}
if ( y2 > y1 ) {
isY2Larger = true ;
}
if ( isY1Larger ) {
if ( ly <= y1 && ly >= y2 ) {
return true ;
}
return false ;
}
if ( isY2Larger ) {
if ( ly <= y2 && ly >= y1 ) {
return true ;
}
return false ;
}
if ( ! isY1Larger && ! isY2Larger ) {
if ( ly == y1 && ly == y2 ) {
return true ;
}
return false ;
}
return false ;
}
public static boolean isWithinZ ( Location l , int z1 , int z2 ) {
double lz = l . getZ ( ) ;
boolean isZ1Larger = false ;
boolean isZ2Larger = false ;
if ( z1 > z2 ) {
isZ1Larger = true ;
}
if ( z2 > z1 ) {
isZ2Larger = true ;
}
if ( isZ1Larger ) {
if ( lz <= z1 && lz >= z2 ) {
return true ;
}
return false ;
}
if ( isZ2Larger ) {
if ( lz <= z2 && lz >= z1 ) {
return true ;
}
return false ;
}
if ( ! isZ1Larger && ! isZ2Larger ) {
if ( lz == z1 && lz == z2 ) {
return true ;
}
return false ;
}
return false ;
}
}
package com . github . thebiologist13 ;
import java . io . File ;
import java . io . IOException ;
import java . util . HashMap ;
import org . bukkit . ChatColor ;
import org . bukkit . command . Command ;
import org . bukkit . command . CommandExecutor ;
import org . bukkit . command . CommandSender ;
import org . bukkit . configuration . file . FileConfiguration ;
import org . bukkit . configuration . file . YamlConfiguration ;
import org . bukkit . entity . Player ;
public class QMsgCommandExecutor implements CommandExecutor {
private static Query plugin ;
private static Player player ;
public QMsgCommandExecutor ( Query plugin ) {
QMsgCommandExecutor . plugin = plugin ;
}
public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) {
if ( sender instanceof Player ) {
player = ( Player ) sender ;
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
boolean queryFound = false ;
if ( player == null ) {
HashMap < File , String > noExtMap = getFilesNoExt ( ) ;
File [ ] list = getFiles ( ) ;
for ( File f : list ) {
String noExt = noExtMap . get ( f ) ;
if ( isYaml ( f ) ) {
if ( noExt . equalsIgnoreCase ( args [ <num> ] ) ) {
if ( args [ <num> ] . equalsIgnoreCase ( " ) || args [ <num> ] . equalsIgnoreCase ( " ) ) {
setMsg ( args , f , noExt ) ;
}
if ( args [ <num> ] . equalsIgnoreCase ( " ) || args [ <num> ] . equalsIgnoreCase ( " ) ) {
removeMsg ( args , f , noExt ) ;
}
queryFound = true ;
}
}
}
if ( ! queryFound ) {
Query . promptMsg ( " ) ;
}
return true ;
}
if ( checkPerm ( " ) ) {
HashMap < File , String > noExtMap = getFilesNoExt ( ) ;
File [ ] list = getFiles ( ) ;
for ( File f : list ) {
String noExt = noExtMap . get ( f ) ;
if ( isYaml ( f ) ) {
if ( noExt . equalsIgnoreCase ( args [ <num> ] ) ) {
if ( args [ <num> ] . equalsIgnoreCase ( " ) || args [ <num> ] . equalsIgnoreCase ( " ) ) {
setMsg ( args , f , noExt ) ;
}
if ( args [ <num> ] . equalsIgnoreCase ( " ) || args [ <num> ] . equalsIgnoreCase ( " ) ) {
removeMsg ( args , f , noExt ) ;
}
queryFound = true ;
}
}
}
}
if ( ! queryFound ) {
Query . promptMsg ( " ) ;
}
return true ;
}
return false ;
}
public static boolean checkPerm ( String perm ) {
if ( player != null ) {
if ( player . hasPermission ( " + perm ) ) {
Query . debugMsg ( player . getName ( ) + " + perm + " ) ;
return true ;
} else {
return false ;
}
} else {
return false ;
}
}
public static File [ ] getFiles ( ) {
String path = plugin . getDataFolder ( ) + " ;
File folder = new File ( path ) ;
File [ ] list = folder . listFiles ( ) ;
return list ;
}
public static HashMap < File , String > getFilesNoExt ( ) {
HashMap < File , String > noExt = new HashMap < File , String > ( ) ;
File [ ] list = getFiles ( ) ;
for ( int i = <num> ; i < list . length ; i ++ ) {
try {
if ( list [ i ] . isFile ( ) ) {
int index = list [ i ] . getName ( ) . lastIndexOf ( " ) ;
if ( index > <num> && index <= list [ i ] . getName ( ) . length ( )  <num> ) {
noExt . put ( list [ i ] , list [ i ] . getName ( ) . substring ( <num> , index ) ) ;
}
}
} catch ( ArrayIndexOutOfBoundsException e ) {
Query . debugMsg ( " ) ;
return null ;
}
}
if ( noExt . isEmpty ( ) ) {
Query . debugMsg ( " ) ;
return null ;
} else {
Query . debugMsg ( " ) ;
return noExt ;
}
}
public static boolean isYaml ( File f ) {
int index = f . getName ( ) . lastIndexOf ( .' ) ;
if ( f . getName ( ) . substring ( index ) . equals ( " ) ) {
Query . debugMsg ( " + f . getName ( ) + " ) ;
return true ;
} else {
Query . debugMsg ( " + f . getName ( ) + " ) ;
return false ;
}
}
public static void setMsg ( String [ ] args , File f , String noExt ) {
FileConfiguration yaml = YamlConfiguration . loadConfiguration ( f ) ;
String msg = " ;
for ( int i = <num> ; i < args . length ; i ++ ) {
if ( i == <num> ) {
msg = msg + args [ i ] ;
} else {
msg = msg + " + args [ i ] ;
}
}
if ( args [ <num> ] . equalsIgnoreCase ( " ) || args [ <num> ] . equalsIgnoreCase ( " ) ) {
yaml . set ( noExt + " , msg ) ;
}
if ( args [ <num> ] . equalsIgnoreCase ( " ) || args [ <num> ] . equalsIgnoreCase ( " ) ) {
yaml . set ( noExt + " , msg ) ;
}
try {
yaml . save ( f ) ;
Query . debugMsg ( player . getName ( ) + " + noExt ) ;
Query . promptMsg ( player . getName ( ) + " ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " ) ;
} catch ( IOException e ) {
Query . debugMsg ( player . getName ( ) + " + noExt + " ) ;
Query . promptMsg ( player . getName ( ) + " ) ;
player . sendMessage ( ChatColor . DARK_RED + " ) ;
}
}
public static void removeMsg ( String [ ] args , File f , String noExt ) {
FileConfiguration yaml = YamlConfiguration . loadConfiguration ( f ) ;
if ( args [ <num> ] . equalsIgnoreCase ( " ) || args [ <num> ] . equalsIgnoreCase ( " ) ) {
yaml . set ( noExt + " , " ) ;
}
if ( args [ <num> ] . equalsIgnoreCase ( " ) || args [ <num> ] . equalsIgnoreCase ( " ) ) {
yaml . set ( noExt + " , " ) ;
}
try {
yaml . save ( f ) ;
Query . debugMsg ( player . getName ( ) + " + noExt ) ;
Query . promptMsg ( player . getName ( ) + " ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " ) ;
} catch ( IOException e ) {
Query . debugMsg ( player . getName ( ) + " + noExt + " ) ;
Query . promptMsg ( player . getName ( ) + " ) ;
player . sendMessage ( ChatColor . DARK_RED + " ) ;
}
}
}
package com . github . thebiologist13 ;
import org . bukkit . ChatColor ;
import org . bukkit . command . Command ;
import org . bukkit . command . CommandExecutor ;
import org . bukkit . command . CommandSender ;
import org . bukkit . entity . Player ;
public class QHelpCommandExecutor implements CommandExecutor {
private static Player player = null ;
@SuppressWarnings("unused")
private Query plugin ;
public QHelpCommandExecutor ( Query plugin ) {
this . plugin = plugin ;
}
public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) {
if ( sender instanceof Player ) {
player = ( Player ) sender ;
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
if ( player == null ) {
Query . debugMsg ( " ) ;
Query . promptMsg ( " ) ;
Query . promptMsg ( " ) ;
Query . promptMsg ( " ) ;
Query . promptMsg ( " ) ;
Query . promptMsg ( " ) ;
Query . promptMsg ( " ) ;
Query . promptMsg ( " ) ;
} else {
if ( checkPerm ( " ) ) {
Query . debugMsg ( " + player . getName ( ) ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " + ChatColor . DARK_PURPLE + " ) ;
if ( checkPerm ( " ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " ) ;
}
if ( checkPerm ( " ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " ) ;
}
if ( checkPerm ( " ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " ) ;
}
if ( checkPerm ( " ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " +
" + String . valueOf ( Query . config . getInt ( " ) ) ) ;
}
if ( checkPerm ( " ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " ) ;
}
if ( checkPerm ( " ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " +
" ) ;
}
if ( checkPerm ( " ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " ) ;
}
if ( checkPerm ( " ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " ) ;
}
player . sendMessage ( ChatColor . DARK_PURPLE + " + ChatColor . WHITE + " ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " ) ;
}
}
return true ;
}
return false ;
}
public static boolean checkPerm ( String perm ) {
if ( player != null ) {
if ( player . hasPermission ( " + perm ) ) {
Query . debugMsg ( player . getName ( ) + " + perm + " ) ;
return true ;
} else {
return false ;
}
} else {
return false ;
}
}
}
package com . github . thebiologist13 ;
import java . io . File ;
import java . util . HashMap ;
import org . bukkit . ChatColor ;
import org . bukkit . command . Command ;
import org . bukkit . command . CommandExecutor ;
import org . bukkit . command . CommandSender ;
import org . bukkit . entity . Player ;
public class QListCommandExecutor implements CommandExecutor {
private static Player player = null ;
private static Query plugin ;
@SuppressWarnings("static-access")
public QListCommandExecutor ( Query plugin ) {
this . plugin = plugin ;
}
public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) {
if ( sender instanceof Player ) {
player = ( Player ) sender ;
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
if ( player != null ) {
Query . debugMsg ( player . getName ( ) + " ) ;
}
File [ ] list = getFiles ( ) ;
Query . debugMsg ( " + plugin . getDataFolder ( ) + " + list . toString ( ) ) ;
String queries = " ;
String noExt = " ;
if ( list . length != <num> ) {
for ( File f : list ) {
if ( isYaml ( f ) ) {
noExt = getFilesNoExt ( ) . get ( f ) ;
if ( ! queries . equals ( " ) ) {
queries = queries + " + noExt ;
} else {
queries = queries + noExt ;
Query . debugMsg ( " + queries ) ;
}
}
}
}
if ( player == null ) {
Query . promptMsg ( " + queries ) ;
} else {
if ( checkPerm ( " ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " + queries ) ;
}
}
return true ;
}
return false ;
}
public static File [ ] getFiles ( ) {
String path = plugin . getDataFolder ( ) + " ;
File folder = new File ( path ) ;
File [ ] list = folder . listFiles ( ) ;
return list ;
}
public static boolean checkPerm ( String perm ) {
if ( player != null ) {
if ( player . hasPermission ( " + perm ) ) {
Query . debugMsg ( player . getName ( ) + " + perm + " ) ;
return true ;
} else {
return false ;
}
} else {
return false ;
}
}
public static HashMap < File , String > getFilesNoExt ( ) {
HashMap < File , String > noExt = new HashMap < File , String > ( ) ;
File [ ] list = getFiles ( ) ;
for ( int i = <num> ; i < list . length ; i ++ ) {
try {
if ( list [ i ] . isFile ( ) ) {
int index = list [ i ] . getName ( ) . lastIndexOf ( " ) ;
if ( index > <num> && index <= list [ i ] . getName ( ) . length ( )  <num> ) {
noExt . put ( list [ i ] , list [ i ] . getName ( ) . substring ( <num> , index ) ) ;
}
}
} catch ( ArrayIndexOutOfBoundsException e ) {
Query . debugMsg ( " ) ;
return null ;
}
}
if ( noExt . isEmpty ( ) ) {
Query . debugMsg ( " ) ;
return null ;
} else {
Query . debugMsg ( " ) ;
return noExt ;
}
}
public static boolean isYaml ( File f ) {
int index = f . getName ( ) . lastIndexOf ( .' ) ;
if ( f . getName ( ) . substring ( index ) . equals ( " ) ) {
Query . debugMsg ( " + f . getName ( ) + " ) ;
return true ;
} else {
Query . debugMsg ( " + f . getName ( ) + " ) ;
return false ;
}
}
}
package com . github . thebiologist13 ;
import java . io . File ;
import java . io . IOException ;
import java . util . HashMap ;
import org . bukkit . ChatColor ;
import org . bukkit . Location ;
import org . bukkit . command . Command ;
import org . bukkit . command . CommandExecutor ;
import org . bukkit . command . CommandSender ;
import org . bukkit . configuration . file . FileConfiguration ;
import org . bukkit . configuration . file . YamlConfiguration ;
import org . bukkit . entity . Player ;
public class SetQueryCommandExecutor implements CommandExecutor {
private static Player player = null ;
private Query plugin ;
public SetQueryCommandExecutor ( Query plugin ) {
this . plugin = plugin ;
}
public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) {
Location playerLocation = null ;
int playerX = <num> ;
int playerY = <num> ;
int playerZ = <num> ;
String playerName = " ;
if ( sender instanceof Player ) {
player = ( Player ) sender ;
playerLocation = player . getLocation ( ) ;
playerX = playerLocation . getBlockX ( ) ;
playerY = playerLocation . getBlockY ( ) ;
playerZ = playerLocation . getBlockZ ( ) ;
playerName = player . getName ( ) ;
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
Query . debugMsg ( " ) ;
if ( player == null ) {
Query . promptMsg ( " + cmd . getName ( ) + " ) ;
} else {
Query . debugMsg ( playerName + " + String . valueOf ( playerX ) + " + String . valueOf ( playerY ) + " +
String . valueOf ( playerZ ) + " + args [ <num> ] ) ;
if ( checkPerm ( " ) ) {
Query . debugMsg ( playerName + " ) ;
File file = new File ( plugin . getDataFolder ( ) + " , args [ <num> ] + " ) ;
Query . debugMsg ( " + plugin . getDataFolder ( ) + " ) ;
FileConfiguration yaml = YamlConfiguration . loadConfiguration ( file ) ;
yaml . set ( args [ <num> ] + " , playerName ) ;
yaml . set ( args [ <num> ] + " , player . getWorld ( ) . getName ( ) ) ;
if ( QueryData . position1 . get ( playerName ) != null || QueryData . position2 . get ( playerName ) != null ) {
yaml . set ( args [ <num> ] + " , QueryData . position1 . get ( playerName ) . getBlockX ( ) ) ;
yaml . set ( args [ <num> ] + " , QueryData . position1 . get ( playerName ) . getBlockY ( ) ) ;
yaml . set ( args [ <num> ] + " , QueryData . position1 . get ( playerName ) . getBlockZ ( ) ) ;
yaml . set ( args [ <num> ] + " , QueryData . position2 . get ( playerName ) . getBlockX ( ) ) ;
yaml . set ( args [ <num> ] + " , QueryData . position2 . get ( playerName ) . getBlockY ( ) ) ;
yaml . set ( args [ <num> ] + " , QueryData . position2 . get ( playerName ) . getBlockZ ( ) ) ;
} else {
Query . promptMsg ( " ) ;
player . sendMessage ( ChatColor . DARK_RED + " ) ;
}
try {
yaml . save ( file ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " + args [ <num> ] + " ) ;
Query . promptMsg ( " + args [ <num> ] + " ) ;
Query . promptMsg ( playerName + " + QueryData . position1 . get ( playerName ) . getBlockX ( ) + " +
QueryData . position1 . get ( playerName ) . getBlockY ( ) + " + QueryData . position1 . get ( playerName ) . getBlockZ ( ) ) ;
Query . promptMsg ( playerName + " + QueryData . position2 . get ( playerName ) . getBlockX ( ) + " +
QueryData . position2 . get ( playerName ) . getBlockY ( ) + " + QueryData . position2 . get ( playerName ) . getBlockZ ( ) ) ;
} catch ( IOException e ) {
Query . debugMsg ( " + e . getMessage ( ) ) ;
Query . severeMsg ( " ) ;
player . sendMessage ( ChatColor . DARK_RED + " ) ;
}
}
}
return true ;
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
if ( player == null ) {
Query . promptMsg ( " + cmd . getName ( ) + " ) ;
} else {
if ( checkPerm ( " ) ) {
Query . debugMsg ( playerName + " + String . valueOf ( playerX ) + " + String . valueOf ( playerY ) + " +
String . valueOf ( playerZ ) + " ) ;
Query . debugMsg ( playerName + " ) ;
QueryData . position1 . put ( playerName , playerLocation ) ;
Query . debugMsg ( playerName + " + String . valueOf ( playerX ) +
" + String . valueOf ( playerY ) + " + String . valueOf ( playerZ ) + " ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " + String . valueOf ( playerX ) +
" + String . valueOf ( playerY ) + " + String . valueOf ( playerZ ) + " ) ;
}
}
return true ;
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
if ( player == null ) {
Query . promptMsg ( " + cmd . getName ( ) + " ) ;
} else {
if ( checkPerm ( " ) ) {
Query . debugMsg ( playerName + " + String . valueOf ( playerX ) + " + String . valueOf ( playerY ) + " +
String . valueOf ( playerZ ) + " ) ;
Query . debugMsg ( playerName + " ) ;
QueryData . position2 . put ( playerName , playerLocation ) ;
Query . debugMsg ( playerName + " + String . valueOf ( playerX ) +
" + String . valueOf ( playerY ) + " + String . valueOf ( playerZ ) + " ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " + String . valueOf ( playerX ) +
" + String . valueOf ( playerY ) + " + String . valueOf ( playerZ ) + " ) ;
}
}
return true ;
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
if ( player == null ) {
Query . promptMsg ( " + cmd . getName ( ) + " ) ;
} else {
if ( args . length == <num> ) {
if ( checkPerm ( " ) ) {
Query . debugMsg ( playerName + " ) ;
HashMap < String , Location > pos1 = QueryData . position1 ;
HashMap < String , Location > pos2 = QueryData . position2 ;
if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
QueryData . expandSelection ( args , player ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " +
pos1 . get ( playerName ) . getBlockX ( ) + " + pos1 . get ( playerName ) . getBlockY ( ) + " + pos1 . get ( playerName ) . getBlockZ ( )
+ " + pos2 . get ( playerName ) . getBlockX ( ) + " + pos2 . get ( playerName ) . getBlockY ( ) + " +
pos2 . get ( playerName ) . getBlockZ ( ) + " ) ;
} else if ( args [ <num> ] . equalsIgnoreCase ( " ) ) {
QueryData . contractSelection ( args , player ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " +
pos1 . get ( playerName ) . getBlockX ( ) + " + pos1 . get ( playerName ) . getBlockY ( ) + " + pos1 . get ( playerName ) . getBlockZ ( )
+ " + pos2 . get ( playerName ) . getBlockX ( ) + " + pos2 . get ( playerName ) . getBlockY ( ) + " +
pos2 . get ( playerName ) . getBlockZ ( ) + " ) ;
} else {
player . sendMessage ( ChatColor . DARK_RED + " ) ;
}
}
}
}
return true ;
}
return false ;
}
public static boolean checkPerm ( String perm ) {
if ( player != null ) {
if ( player . hasPermission ( " + perm ) ) {
Query . debugMsg ( player . getName ( ) + " + perm + " ) ;
return true ;
} else {
return false ;
}
} else {
return false ;
}
}
}
package com . github . thebiologist13 ;
import org . bukkit . ChatColor ;
import org . bukkit . command . Command ;
import org . bukkit . command . CommandExecutor ;
import org . bukkit . command . CommandSender ;
import org . bukkit . entity . Player ;
public class QDebugCommandExecutor implements CommandExecutor {
@SuppressWarnings("unused")
private Query plugin ;
public QDebugCommandExecutor ( Query plugin ) {
this . plugin = plugin ;
}
public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) {
boolean debug = Query . debug ;
Player p = null ;
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
if ( sender instanceof Player ) {
p = ( Player ) sender ;
}
if ( debug ) {
Query . debug = false ;
Query . debugMsg ( " ) ;
if ( p != null ) {
p . sendMessage ( ChatColor . DARK_PURPLE + " ) ;
}
}
if ( ! debug ) {
Query . debug = true ;
Query . debugMsg ( " ) ;
if ( p != null ) {
p . sendMessage ( ChatColor . DARK_PURPLE + " ) ;
}
}
return true ;
}
return false ;
}
}
package com . github . thebiologist13 ;
import java . io . File ;
import java . util . HashMap ;
import org . bukkit . ChatColor ;
import org . bukkit . Location ;
import org . bukkit . World ;
import org . bukkit . command . Command ;
import org . bukkit . command . CommandExecutor ;
import org . bukkit . command . CommandSender ;
import org . bukkit . configuration . file . FileConfiguration ;
import org . bukkit . configuration . file . YamlConfiguration ;
import org . bukkit . entity . Player ;
public class QueryCommandExecutor implements CommandExecutor {
private static Query plugin ;
private static Player player = null ;
public QueryCommandExecutor ( Query plugin ) {
QueryCommandExecutor . plugin = plugin ;
}
public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) {
if ( sender instanceof Player ) {
player = ( Player ) sender ;
}
if ( cmd . getName ( ) . equalsIgnoreCase ( " ) ) {
if ( player == null ) {
Query . promptMsg ( " + cmd . getName ( ) + " ) ;
return true ;
}
Query . debugMsg ( player . getName ( ) + " ) ;
query ( ) ;
return true ;
}
return false ;
}
public static boolean checkPerm ( String perm ) {
if ( player != null ) {
if ( player . hasPermission ( " + perm ) ) {
Query . debugMsg ( player . getName ( ) + " + perm + " ) ;
return true ;
} else {
return false ;
}
} else {
return false ;
}
}
public static File [ ] getFiles ( ) {
String path = plugin . getDataFolder ( ) + " ;
File folder = new File ( path ) ;
File [ ] list = folder . listFiles ( ) ;
return list ;
}
public static String getFilesAsString ( ) {
String list = " ;
for ( File f : getFiles ( ) ) {
if ( f . isFile ( ) ) {
list += " + f . getName ( ) ;
}
}
Query . debugMsg ( " + list ) ;
return list ;
}
public static HashMap < File , String > getFilesNoExt ( ) {
HashMap < File , String > noExt = new HashMap < File , String > ( ) ;
File [ ] list = getFiles ( ) ;
for ( int i = <num> ; i < list . length ; i ++ ) {
try {
if ( list [ i ] . isFile ( ) ) {
int index = list [ i ] . getName ( ) . lastIndexOf ( " ) ;
if ( index > <num> && index <= list [ i ] . getName ( ) . length ( )  <num> ) {
noExt . put ( list [ i ] , list [ i ] . getName ( ) . substring ( <num> , index ) ) ;
}
}
} catch ( ArrayIndexOutOfBoundsException e ) {
Query . debugMsg ( " ) ;
return null ;
}
}
if ( noExt . isEmpty ( ) ) {
Query . debugMsg ( " ) ;
return null ;
} else {
Query . debugMsg ( " ) ;
return noExt ;
}
}
public static boolean isYaml ( File f ) {
int index = f . getName ( ) . lastIndexOf ( .' ) ;
if ( f . getName ( ) . substring ( index ) . equals ( " ) ) {
Query . debugMsg ( " + f . getName ( ) + " ) ;
return true ;
} else {
Query . debugMsg ( " + f . getName ( ) + " ) ;
return false ;
}
}
public static boolean inWorld ( File f ) {
HashMap < File , String > noExtMap = getFilesNoExt ( ) ;
String noExt = noExtMap . get ( f ) ;
FileConfiguration yaml = YamlConfiguration . loadConfiguration ( f ) ;
String worldName = " ;
worldName = yaml . getString ( noExt + " ) ;
Query . debugMsg ( " + worldName ) ;
World playerIn = player . getWorld ( ) ;
Query . debugMsg ( " + playerIn . getName ( ) ) ;
if ( playerIn . getName ( ) . equals ( worldName ) ) {
return true ;
}
return false ;
}
public static HashMap < String , Integer > getPositions ( File f ) {
HashMap < File , String > noExtMap = getFilesNoExt ( ) ;
String noExt = noExtMap . get ( f ) ;
HashMap < String , Integer > positions = new HashMap < String , Integer > ( ) ;
FileConfiguration yaml = YamlConfiguration . loadConfiguration ( f ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
positions . put ( " , yaml . getInt ( noExt + " ) ) ;
Query . debugMsg ( " ) ;
return positions ;
}
public static HashMap < String , String > getDescription ( File f ) {
HashMap < String , String > description = new HashMap < String , String > ( ) ;
HashMap < File , String > noExtMap = getFilesNoExt ( ) ;
String noExt = noExtMap . get ( f ) ;
FileConfiguration yaml = YamlConfiguration . loadConfiguration ( f ) ;
for ( int i = <num> ; i <= Query . config . getInt ( " ) ; i ++ ) {
if ( yaml . contains ( noExt + " + i ) ) {
description . put ( " + i , yaml . getString ( noExt + " + i ) ) ;
}
}
if ( description . isEmpty ( ) ) {
return null ;
} else {
return description ;
}
}
public static boolean isWithin ( Player p , Location l1 , Location l2 ) {
if ( QueryBoundaryCheck . isWithinX ( player . getLocation ( ) , l1 . getBlockX ( ) , l2 . getBlockX ( ) ) &&
QueryBoundaryCheck . isWithinY ( player . getLocation ( ) , l1 . getBlockY ( ) , l2 . getBlockY ( ) ) &&
QueryBoundaryCheck . isWithinZ ( player . getLocation ( ) , l1 . getBlockZ ( ) , l2 . getBlockZ ( ) ) ) {
return true ;
} else {
return false ;
}
}
public static void query ( ) {
boolean queryFound = false ;
File [ ] list = getFiles ( ) ;
HashMap < String , Integer > positions = new HashMap < String , Integer > ( ) ;
getFilesAsString ( ) ;
if ( checkPerm ( " ) ) {
Query . debugMsg ( " ) ;
if ( list . length != <num> ) {
for ( File f : list ) {
Query . debugMsg ( " + f . getName ( ) ) ;
if ( isYaml ( f ) ) {
Query . debugMsg ( f . getName ( ) + " ) ;
HashMap < String , String > description = new HashMap < String , String > ( ) ;
positions = getPositions ( f ) ;
Location pos1 = new Location ( player . getWorld ( ) , positions . get ( " ) , positions . get ( " ) , positions . get ( " ) ) ;
Location pos2 = new Location ( player . getWorld ( ) , positions . get ( " ) , positions . get ( " ) , positions . get ( " ) ) ;
if ( isWithin ( player , pos1 , pos2 ) && inWorld ( f ) ) {
Query . debugMsg ( " ) ;
description = getDescription ( f ) ;
if ( description == null ) {
Query . debugMsg ( " + getFilesNoExt ( ) . get ( f ) ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " + getFilesNoExt ( ) . get ( f ) + " ) ;
if ( checkPerm ( " ) ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " ) ;
}
} else {
Query . debugMsg ( " ) ;
for ( int i = <num> ; i <= Query . config . getInt ( " ) ; i ++ ) {
Query . debugMsg ( " ) ;
if ( description . containsKey ( " + i ) ) {
Query . debugMsg ( " + getFilesNoExt ( ) . get ( f ) + " + i ) ;
if ( i == <num> ) {
player . sendMessage ( ChatColor . DARK_PURPLE + getFilesNoExt ( ) . get ( f ) + " + description . get ( " + i ) ) ;
} else {
player . sendMessage ( ChatColor . DARK_PURPLE + description . get ( " + i ) ) ;
}
} else {
Query . debugMsg ( " + getFilesNoExt ( ) . get ( f ) + " + i ) ;
}
}
}
queryFound = true ;
}
}
}
if ( ! queryFound ) {
player . sendMessage ( ChatColor . DARK_PURPLE + " ) ;
}
}
}
}
}
package com . github . thebiologist13 ;
import org . bukkit . ChatColor ;
import org . bukkit . Location ;
import org . bukkit . block . Block ;
import org . bukkit . configuration . file . FileConfiguration ;
import org . bukkit . entity . Player ;
import org . bukkit . event . EventHandler ;
import org . bukkit . event . Listener ;
import org . bukkit . event . block . Action ;
import org . bukkit . event . player . PlayerInteractEvent ;
import org . bukkit . inventory . ItemStack ;
public class QueryPlayerListener implements Listener {
private static Player player = null ;
@SuppressWarnings("unused")
private Query plugin ;
public QueryPlayerListener ( Query plugin ) {
this . plugin = plugin ;
}
@EventHandler
public void onPlayerInteract ( PlayerInteractEvent event ) {
try {
Block block = event . getClickedBlock ( ) ;
Location blockLocation = block . getLocation ( ) ;
int blockX = blockLocation . getBlockX ( ) ;
int blockY = blockLocation . getBlockY ( ) ;
int blockZ = blockLocation . getBlockZ ( ) ;
player = event . getPlayer ( ) ;
ItemStack item = event . getItem ( ) ;
Action action = event . getAction ( ) ;
FileConfiguration config = Query . config ;
int posID = config . getInt ( " ) ;
int queryID = config . getInt ( " ) ;
if ( item . getTypeId ( ) == posID ) {
Query . debugMsg ( " + String . valueOf ( item . getTypeId ( ) ) + " ) ;
Query . debugMsg ( " + player . getName ( ) ) ;
Query . debugMsg ( " + item ) ;
Query . debugMsg ( " + action . toString ( ) ) ;
Query . debugMsg ( " + String . valueOf ( posID ) + " + String . valueOf ( queryID ) ) ;
if ( checkPerm ( " ) ) {
if ( action . equals ( Action . LEFT_CLICK_BLOCK ) ) {
QueryData . position1 . put ( player . getName ( ) , blockLocation ) ;
Query . debugMsg ( player . getName ( ) + " + String . valueOf ( blockX ) + " + String . valueOf ( blockY ) +
" + String . valueOf ( blockZ ) + " + item . toString ( ) ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " + String . valueOf ( blockX ) +
" + String . valueOf ( blockY ) + " + String . valueOf ( blockZ ) + " ) ;
}
if ( action . equals ( Action . RIGHT_CLICK_BLOCK ) ) {
QueryData . position2 . put ( player . getName ( ) , blockLocation ) ;
Query . debugMsg ( player . getName ( ) + " + String . valueOf ( blockX ) + " + String . valueOf ( blockY ) +
" + String . valueOf ( blockZ ) + " + item . toString ( ) ) ;
player . sendMessage ( ChatColor . DARK_PURPLE + " + String . valueOf ( blockX ) +
" + String . valueOf ( blockY ) + " + String . valueOf ( blockZ ) + " ) ;
}
}
}
if ( item . getTypeId ( ) == queryID ) {
Query . debugMsg ( " + String . valueOf ( item . getTypeId ( ) ) + " ) ;
Query . debugMsg ( " + player . getName ( ) ) ;
Query . debugMsg ( " + item ) ;
Query . debugMsg ( " + action . toString ( ) ) ;
Query . debugMsg ( " + String . valueOf ( posID ) + " + String . valueOf ( queryID ) ) ;
if ( action . equals ( Action . RIGHT_CLICK_BLOCK ) ) {
Query . debugMsg ( player . getName ( ) + " + String . valueOf ( blockX ) + " + String . valueOf ( blockY ) +
" + String . valueOf ( blockZ ) + " + item . toString ( ) + " ) ;
QueryCommandExecutor . query ( ) ;
}
}
} catch ( Exception e ) {
}
}
public static boolean checkPerm ( String perm ) {
if ( player != null ) {
if ( player . hasPermission ( " + perm ) ) {
Query . debugMsg ( player . getName ( ) + " + perm + " ) ;
return true ;
} else {
return false ;
}
} else {
return false ;
}
}
}
package com . example . android . notepad ;
import com . example . android . notepad . NotePad . Notes ;
import com . google . android . apps . analytics . easytracking . TrackedActivity ;
import android . content . ContentValues ;
import android . database . Cursor ;
import android . net . Uri ;
import android . os . Bundle ;
import android . view . View ;
import android . widget . Button ;
import android . widget . EditText ;
public class <unk> extends TrackedActivity implements View . OnClickListener {
public static final String <unk> = " ;
private static final String [ ] PROJECTION = new String [ ] {
NotePad . Notes . _ID ,
NotePad . Notes . TITLE ,
} ;
private static final int COLUMN_INDEX_TITLE = <num> ;
private Cursor mCursor ;
private EditText mText ;
private Uri mUri ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . <unk> ) ;
mUri = getIntent ( ) . getData ( ) ;
mCursor = managedQuery ( mUri , PROJECTION , null , null , null ) ;
mText = ( EditText ) this . findViewById ( R . id . title ) ;
mText . setOnClickListener ( this ) ;
Button b = ( Button ) findViewById ( R . id . ok ) ;
b . setOnClickListener ( this ) ;
}
@Override
protected void onResume ( ) {
super . onResume ( ) ;
if ( mCursor != null ) {
mCursor . moveToFirst ( ) ;
mText . setText ( mCursor . getString ( COLUMN_INDEX_TITLE ) ) ;
}
}
@Override
protected void onPause ( ) {
super . onPause ( ) ;
if ( mCursor != null ) {
ContentValues values = new ContentValues ( ) ;
values . put ( Notes . TITLE , mText . getText ( ) . toString ( ) ) ;
getContentResolver ( ) . update ( mUri , values , null , null ) ;
}
}
public void onClick ( View v ) {
finish ( ) ;
}
}
package com . google . android . apps . analytics . easytracking ;
interface ParameterLoader {
String getString ( String key ) ;
boolean getBoolean ( String key ) ;
int getInt ( String key , int defaultValue ) ;
}
package com . example . android . notepad ;
import android . test . ActivityInstrumentationTestCase ;
import com . example . android . notepad . NotesList ;
public class NotePadTest extends ActivityInstrumentationTestCase < NotesList > {
public NotePadTest ( ) {
super ( " , NotesList . class ) ;
}
}
package com . example . android . notepad ;
import com . example . android . notepad . NotePad . Notes ;
import com . google . android . apps . analytics . easytracking . TrackedActivity ;
import android . content . ComponentName ;
import android . content . ContentValues ;
import android . content . Context ;
import android . content . Intent ;
import android . database . Cursor ;
import android . graphics . Canvas ;
import android . graphics . Paint ;
import android . graphics . Rect ;
import android . net . Uri ;
import android . os . Bundle ;
import android . util . AttributeSet ;
import android . util . Log ;
import android . view . Menu ;
import android . view . MenuItem ;
import android . widget . EditText ;
public class NoteEditor extends TrackedActivity {
private static final String TAG = " ;
private static final String [ ] PROJECTION = new String [ ] {
Notes . _ID ,
Notes . NOTE ,
} ;
private static final int COLUMN_INDEX_NOTE = <num> ;
private static final String ORIGINAL_CONTENT = " ;
private static final int REVERT_ID = Menu . FIRST ;
private static final int DISCARD_ID = Menu . FIRST + <num> ;
private static final int DELETE_ID = Menu . FIRST + <num> ;
private static final int STATE_EDIT = <num> ;
private static final int STATE_INSERT = <num> ;
private int mState ;
private boolean mNoteOnly = false ;
private Uri mUri ;
private Cursor mCursor ;
private EditText mText ;
private String mOriginalContent ;
public static class LinedEditText extends EditText {
private Rect mRect ;
private Paint mPaint ;
public LinedEditText ( Context context , AttributeSet attrs ) {
super ( context , attrs ) ;
mRect = new Rect ( ) ;
mPaint = new Paint ( ) ;
mPaint . setStyle ( Paint . Style . STROKE ) ;
mPaint . setColor ( <num> ) ;
}
@Override
protected void onDraw ( Canvas canvas ) {
int count = getLineCount ( ) ;
Rect r = mRect ;
Paint paint = mPaint ;
for ( int i = <num> ; i < count ; i ++ ) {
int baseline = <unk> ( i , r ) ;
canvas . drawLine ( r . left , baseline + <num> , r . right , baseline + <num> , paint ) ;
}
super . onDraw ( canvas ) ;
}
}
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
final Intent intent = getIntent ( ) ;
final String action = intent . getAction ( ) ;
if ( Intent . ACTION_EDIT . equals ( action ) ) {
mState = STATE_EDIT ;
mUri = intent . getData ( ) ;
} else if ( Intent . ACTION_INSERT . equals ( action ) ) {
mState = STATE_INSERT ;
mUri = getContentResolver ( ) . insert ( intent . getData ( ) , null ) ;
if ( mUri == null ) {
Log . e ( TAG , " + getIntent ( ) . getData ( ) ) ;
finish ( ) ;
return ;
}
setResult ( RESULT_OK , ( new Intent ( ) ) . setAction ( mUri . toString ( ) ) ) ;
} else {
Log . e ( TAG , " ) ;
finish ( ) ;
return ;
}
setContentView ( R . layout . <unk> ) ;
mText = ( EditText ) findViewById ( R . id . note ) ;
mCursor = managedQuery ( mUri , PROJECTION , null , null , null ) ;
if ( savedInstanceState != null ) {
mOriginalContent = savedInstanceState . getString ( ORIGINAL_CONTENT ) ;
}
}
@Override
protected void onResume ( ) {
super . onResume ( ) ;
if ( mCursor != null ) {
mCursor . moveToFirst ( ) ;
if ( mState == STATE_EDIT ) {
setTitle ( getText ( R . string . <unk> ) ) ;
} else if ( mState == STATE_INSERT ) {
setTitle ( getText ( R . string . <unk> ) ) ;
}
String note = mCursor . getString ( COLUMN_INDEX_NOTE ) ;
mText . <unk> ( note ) ;
if ( mOriginalContent == null ) {
mOriginalContent = note ;
}
} else {
setTitle ( getText ( R . string . <unk> ) ) ;
mText . setText ( getText ( R . string . <unk> ) ) ;
}
}
@Override
protected void onSaveInstanceState ( Bundle outState ) {
outState . putString ( ORIGINAL_CONTENT , mOriginalContent ) ;
}
@Override
protected void onPause ( ) {
super . onPause ( ) ;
if ( mCursor != null ) {
String text = mText . getText ( ) . toString ( ) ;
int length = text . length ( ) ;
if ( isFinishing ( ) && ( length == <num> ) && ! mNoteOnly ) {
setResult ( RESULT_CANCELED ) ;
deleteNote ( ) ;
} else {
ContentValues values = new ContentValues ( ) ;
if ( ! mNoteOnly ) {
values . put ( Notes . MODIFIED_DATE , System . currentTimeMillis ( ) ) ;
if ( mState == STATE_INSERT ) {
String title = text . substring ( <num> , Math . min ( <num> , length ) ) ;
if ( length > <num> ) {
int lastSpace = title . lastIndexOf (  ' ) ;
if ( lastSpace > <num> ) {
title = title . substring ( <num> , lastSpace ) ;
}
}
values . put ( Notes . TITLE , title ) ;
}
}
values . put ( Notes . NOTE , text ) ;
getContentResolver ( ) . update ( mUri , values , null , null ) ;
}
}
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
super . onCreateOptionsMenu ( menu ) ;
if ( mState == STATE_EDIT ) {
menu . add ( <num> , REVERT_ID , <num> , R . string . <unk> )
. setShortcut ( <num>  , r' )
. setIcon ( android . R . drawable . ic_menu_revert ) ;
if ( ! mNoteOnly ) {
menu . add ( <num> , DELETE_ID , <num> , R . string . menu_delete )
. setShortcut ( <num>  , d' )
. setIcon ( android . R . drawable . ic_menu_delete ) ;
}
} else {
menu . add ( <num> , DISCARD_ID , <num> , R . string . <unk> )
. setShortcut ( <num>  , d' )
. setIcon ( android . R . drawable . ic_menu_delete ) ;
}
if ( ! mNoteOnly ) {
Intent intent = new Intent ( null , getIntent ( ) . getData ( ) ) ;
intent . addCategory ( Intent . CATEGORY_ALTERNATIVE ) ;
menu . addIntentOptions ( Menu . CATEGORY_ALTERNATIVE , <num> , <num> ,
new ComponentName ( this , NoteEditor . class ) , null , intent , <num> , null ) ;
}
return true ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case DELETE_ID :
deleteNote ( ) ;
finish ( ) ;
break ;
case DISCARD_ID :
cancelNote ( ) ;
break ;
case REVERT_ID :
cancelNote ( ) ;
break ;
}
return super . onOptionsItemSelected ( item ) ;
}
private final void cancelNote ( ) {
if ( mCursor != null ) {
if ( mState == STATE_EDIT ) {
mCursor . close ( ) ;
mCursor = null ;
ContentValues values = new ContentValues ( ) ;
values . put ( Notes . NOTE , mOriginalContent ) ;
getContentResolver ( ) . update ( mUri , values , null , null ) ;
} else if ( mState == STATE_INSERT ) {
deleteNote ( ) ;
}
}
setResult ( RESULT_CANCELED ) ;
finish ( ) ;
}
private final void deleteNote ( ) {
if ( mCursor != null ) {
mCursor . close ( ) ;
mCursor = null ;
getContentResolver ( ) . delete ( mUri , null , null ) ;
mText . setText ( " ) ;
}
}
}
package com . google . provider ;
import android . net . Uri ;
import android . provider . BaseColumns ;
public final class NotePad {
public static final class Notes implements BaseColumns {
public static final Uri CONTENT_URI
= Uri . parse ( " ) ;
public static final String DEFAULT_SORT_ORDER = " ;
public static final String TITLE = " ;
public static final String NOTE = " ;
public static final String CREATED_DATE = " ;
public static final String MODIFIED_DATE = " ;
}
}
package com . example . android . notepad ;
import android . net . Uri ;
import android . provider . BaseColumns ;
public final class NotePad {
public static final String AUTHORITY = " ;
private NotePad ( ) { }
public static final class Notes implements BaseColumns {
private Notes ( ) { }
public static final Uri CONTENT_URI = Uri . parse ( " + AUTHORITY + " ) ;
public static final String CONTENT_TYPE = " ;
public static final String CONTENT_ITEM_TYPE = " ;
public static final String DEFAULT_SORT_ORDER = " ;
public static final String TITLE = " ;
public static final String NOTE = " ;
public static final String CREATED_DATE = " ;
public static final String MODIFIED_DATE = " ;
}
}
package com . google . android . apps . analytics . easytracking ;
import com . google . android . apps . analytics . Item ;
import com . google . android . apps . analytics . Transaction ;
import android . content . Context ;
public interface GoogleAnalyticsTrackerDelegate {
public void startNewSession ( String accountId , int dispatchPeriod , Context ctx ) ;
public void trackEvent ( String category , String action , String label , int value ) ;
public void trackPageView ( String pageUrl ) ;
public boolean dispatch ( ) ;
public void stopSession ( ) ;
public boolean setCustomVar ( int index , String name , String value , int scope ) ;
public boolean setCustomVar ( int index , String name , String value ) ;
public void addTransaction ( Transaction transaction ) ;
public void addItem ( Item item ) ;
public void trackTransactions ( ) ;
public void clearTransactions ( ) ;
public void setAnonymizeIp ( boolean anonymizeIp ) ;
public void setSampleRate ( int sampleRate ) ;
public boolean setReferrer ( String referrer ) ;
public void setDebug ( boolean debug ) ;
public void setDryRun ( boolean dryRun ) ;
}
package com . google . android . apps . analytics . easytracking ;
import com . google . android . apps . analytics . Item ;
import com . google . android . apps . analytics . Transaction ;
import android . app . Activity ;
import android . content . Context ;
import android . util . Log ;
import java . util . HashMap ;
import java . util . Map ;
import java . util . concurrent . LinkedBlockingQueue ;
public class EasyTracker {
public static final String LOG_TAG = " ;
public static final int <unk> = <num> ;
public static final int <unk> = <num> ;
public static final int PAGE_SCOPE = <num> ;
private EasyTracker ( ) {
}
private static EasyTracker instance ;
public static EasyTracker getTracker ( ) {
if ( instance == null ) {
instance = new EasyTracker ( ) ;
}
return instance ;
}
private boolean gaEnabled = false ;
private String gaAccountId ;
private int gaDispatchPeriod = <num> ;
private boolean gaDebug ;
private boolean gaDryRun ;
private int gaSampleRate = <num> ;
private boolean gaAnonymizeIp ;
private boolean autoActivityTracking = false ;
private int activitiesActive = <num> ;
private boolean sessionNeeded = true ;
private Context gaContext ;
private Map < String , String > activityNameMap = new HashMap < String , String > ( ) ;
private GoogleAnalyticsTrackerDelegate tracker = null ;
private ParameterLoader parameterFetcher ;
private void initializeTracker ( ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
tracker . setDebug ( gaDebug ) ;
tracker . setDryRun ( gaDryRun ) ;
tracker . setSampleRate ( gaSampleRate ) ;
tracker . setAnonymizeIp ( gaAnonymizeIp ) ;
}
} ) ;
}
private GoogleAnalyticsTrackerDelegate getGoogleAnalyticsTracker ( ) {
if ( tracker == null ) {
if ( gaEnabled ) {
tracker = new GoogleAnalyticsTrackerDelegateImpl ( ) ;
initializeTracker ( ) ;
}
}
return tracker ;
}
void setTrackerDelegate ( GoogleAnalyticsTrackerDelegate d ) {
if ( gaEnabled ) {
tracker = d ;
initializeTracker ( ) ;
}
}
static void clearTracker ( ) {
instance = null ;
}
private void loadParameters ( ) {
gaAccountId = parameterFetcher . getString ( " ) ;
if ( gaAccountId != null ) {
gaEnabled = true ;
gaDebug = parameterFetcher . getBoolean ( " ) ;
gaDryRun = parameterFetcher . getBoolean ( " ) ;
gaSampleRate = parameterFetcher . getInt ( " , <num> ) ;
gaDispatchPeriod = parameterFetcher . getInt ( " , <num> ) ;
autoActivityTracking =
parameterFetcher . getBoolean ( " ) ;
gaAnonymizeIp = parameterFetcher . getBoolean ( " ) ;
if ( trackerThread == null ) {
trackerThread = new TrackerThread ( ) ;
trackerThread . start ( ) ;
}
}
}
public void setContext ( Context ctx ) {
if ( ctx == null ) {
Log . e ( LOG_TAG , " ) ;
}
if ( gaContext == null ) {
gaContext = ctx . getApplicationContext ( ) ;
parameterFetcher = new ParameterLoaderImpl ( gaContext ) ;
loadParameters ( ) ;
}
}
void setContext ( Context ctx , ParameterLoader parameterLoader ) {
if ( ctx == null ) {
Log . e ( LOG_TAG , " ) ;
}
if ( gaContext == null ) {
gaContext = ctx . getApplicationContext ( ) ;
parameterFetcher = parameterLoader ;
loadParameters ( ) ;
}
}
public void trackActivityStart ( final Activity activity ) {
activitiesActive ++ ;
final boolean startASession = sessionNeeded ;
sessionNeeded = false ;
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
if ( startASession ) {
getGoogleAnalyticsTracker ( ) . startNewSession ( gaAccountId , gaDispatchPeriod , gaContext ) ;
if ( ! autoActivityTracking ) {
getGoogleAnalyticsTracker ( ) . trackEvent ( " , " , " , <num> ) ;
}
}
if ( autoActivityTracking ) {
getGoogleAnalyticsTracker ( ) . trackPageView ( getActivityName ( activity ) ) ;
}
}
} ) ;
}
public void trackActivityRetainNonConfigurationInstance ( ) {
sessionNeeded = false ;
}
public void trackActivityStop ( final Activity activity ) {
activitiesActive  ;
sessionNeeded = activitiesActive == <num> ;
final boolean sendEvent = sessionNeeded ;
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
if ( sendEvent ) {
getGoogleAnalyticsTracker ( ) . trackEvent ( " , " , " , <num> ) ;
}
}
} ) ;
}
private String getActivityName ( Activity activity ) {
String canonicalName = activity . getClass ( ) . getCanonicalName ( ) ;
if ( activityNameMap . containsKey ( canonicalName ) ) {
return activityNameMap . get ( canonicalName ) ;
} else {
String name = parameterFetcher . getString ( canonicalName ) ;
if ( name == null ) {
name = canonicalName ;
}
activityNameMap . put ( canonicalName , name ) ;
return name ;
}
}
public void addItem ( final Item item ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . addItem ( item ) ;
}
} ) ;
}
public void addTransaction ( final Transaction transaction ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . addTransaction ( transaction ) ;
}
} ) ;
}
public void clearTransactions ( ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . clearTransactions ( ) ;
}
} ) ;
}
public void dispatch ( ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . dispatch ( ) ;
}
} ) ;
}
public void setReferrer ( final String referrer ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . setReferrer ( referrer ) ;
}
} ) ;
}
public void setCustomVar ( final int index , final String name ,
final String value , final int scope ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . setCustomVar ( index , name , value ,
scope ) ;
}
} ) ;
}
public void startNewSession ( ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . startNewSession ( gaAccountId , gaDispatchPeriod , gaContext ) ;
}
} ) ;
}
public void stopSession ( ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . stopSession ( ) ;
}
} ) ;
}
public void trackEvent ( final String category , final String action , final String label ,
final int value ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . trackEvent ( category , action , label , value ) ;
}
} ) ;
}
public void trackPageView ( final String name ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . trackPageView ( name ) ;
}
} ) ;
}
public void trackTransactions ( ) {
queueToTrackerThreadIfEnabled ( new Runnable ( ) {
@Override
public void run ( ) {
getGoogleAnalyticsTracker ( ) . trackTransactions ( ) ;
}
} ) ;
}
private final LinkedBlockingQueue < Runnable > trackerQueue =
new LinkedBlockingQueue < Runnable > ( ) ;
private TrackerThread trackerThread ;
private Object lock = new Object ( ) ;
private void queueToTrackerThreadIfEnabled ( Runnable r ) {
if ( gaEnabled ) {
synchronized ( lock ) {
trackerQueue . add ( r ) ;
}
}
}
private class TrackerThread extends Thread {
TrackerThread ( ) {
super ( " ) ;
}
@Override
public void run ( ) {
while ( true ) {
Runnable r ;
try {
r = trackerQueue . take ( ) ;
r . run ( ) ;
} catch ( InterruptedException e ) {
Log . i ( LOG_TAG , e . toString ( ) ) ;
}
}
}
}
}
package com . google . android . apps . analytics . easytracking ;
import com . google . android . apps . analytics . GoogleAnalyticsTracker ;
import com . google . android . apps . analytics . Item ;
import com . google . android . apps . analytics . Transaction ;
import android . content . Context ;
public class GoogleAnalyticsTrackerDelegateImpl implements GoogleAnalyticsTrackerDelegate {
private GoogleAnalyticsTracker tracker = GoogleAnalyticsTracker . getInstance ( ) ;
@Override
public void startNewSession ( String accountId , int dispatchPeriod , Context ctx ) {
tracker . startNewSession ( accountId , dispatchPeriod , ctx ) ;
}
@Override
public void trackEvent ( String category , String action , String label , int value ) {
tracker . trackEvent ( category , action , label , value ) ;
}
@Override
public void trackPageView ( String pageUrl ) {
tracker . trackPageView ( pageUrl ) ;
}
@Override
public boolean dispatch ( ) {
return tracker . dispatch ( ) ;
}
@Override
public void stopSession ( ) {
tracker . stopSession ( ) ;
}
@Override
public boolean setCustomVar ( int index , String name , String value , int scope ) {
return tracker . setCustomVar ( index , name , value , scope ) ;
}
@Override
public boolean setCustomVar ( int index , String name , String value ) {
return tracker . setCustomVar ( index , name , value ) ;
}
@Override
public void addTransaction ( Transaction transaction ) {
tracker . addTransaction ( transaction ) ;
}
@Override
public void addItem ( Item item ) {
tracker . addItem ( item ) ;
}
@Override
public void trackTransactions ( ) {
tracker . trackTransactions ( ) ;
}
@Override
public void clearTransactions ( ) {
tracker . clearTransactions ( ) ;
}
@Override
public void setAnonymizeIp ( boolean anonymizeIp ) {
tracker . setAnonymizeIp ( anonymizeIp ) ;
}
@Override
public void setSampleRate ( int sampleRate ) {
tracker . setSampleRate ( sampleRate ) ;
}
@Override
public boolean setReferrer ( String referrer ) {
return tracker . setReferrer ( referrer ) ;
}
@Override
public void setDebug ( boolean debug ) {
tracker . setDebug ( debug ) ;
}
@Override
public void setDryRun ( boolean dryRun ) {
tracker . setDryRun ( dryRun ) ;
}
}
package com . google . android . apps . analytics . easytracking ;
import android . content . Context ;
import android . util . Log ;
public class ParameterLoaderImpl implements ParameterLoader {
private final Context ctx ;
public ParameterLoaderImpl ( Context ctx ) {
if ( ctx == null ) {
throw new NullPointerException ( " ) ;
}
this . ctx = ctx ;
}
private int getResourceIdForType ( String key , String type ) {
if ( ctx == null ) {
return <num> ;
}
return ctx . getResources ( ) . getIdentifier ( key , type , ctx . getPackageName ( ) ) ;
}
@Override
public String getString ( String key ) {
int id = getResourceIdForType ( key , " ) ;
if ( id == <num> ) {
return null ;
} else {
return ctx . getString ( id ) ;
}
}
@Override
public boolean getBoolean ( String key ) {
int id = getResourceIdForType ( key , " ) ;
if ( id == <num> ) {
return false ;
} else {
return " . equalsIgnoreCase ( ctx . getString ( id ) ) ;
}
}
@Override
public int getInt ( String key , int defaultValue ) {
int id = getResourceIdForType ( key , " ) ;
if ( id == <num> ) {
return defaultValue ;
} else {
try {
return Integer . parseInt ( ctx . getString ( id ) ) ;
} catch ( NumberFormatException e ) {
Log . w ( EasyTracker . LOG_TAG , " + ctx . getString ( id ) ) ;
return defaultValue ;
}
}
}
}
package com . example . android . notepad ;
import com . example . android . notepad . NotePad . Notes ;
import android . content . ContentProvider ;
import android . content . ContentUris ;
import android . content . ContentValues ;
import android . content . Context ;
import android . content . UriMatcher ;
import android . content . res . Resources ;
import android . database . Cursor ;
import android . database . SQLException ;
import android . database . sqlite . SQLiteDatabase ;
import android . database . sqlite . SQLiteOpenHelper ;
import android . database . sqlite . SQLiteQueryBuilder ;
import android . net . Uri ;
import android . text . TextUtils ;
import android . util . Log ;
import java . util . HashMap ;
public class <unk> extends ContentProvider {
private static final String TAG = " ;
private static final String DATABASE_NAME = " ;
private static final int DATABASE_VERSION = <num> ;
private static final String NOTES_TABLE_NAME = " ;
private static HashMap < String , String > sNotesProjectionMap ;
private static final int NOTES = <num> ;
private static final int NOTE_ID = <num> ;
private static final UriMatcher sUriMatcher ;
private static class DatabaseHelper extends SQLiteOpenHelper {
DatabaseHelper ( Context context ) {
super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ;
}
@Override
public void onCreate ( SQLiteDatabase db ) {
db . execSQL ( " + NOTES_TABLE_NAME + "
+ Notes . _ID + "
+ Notes . TITLE + "
+ Notes . NOTE + "
+ Notes . CREATED_DATE + "
+ Notes . MODIFIED_DATE + "
+ " ) ;
}
@Override
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) {
Log . w ( TAG , " + oldVersion + "
+ newVersion + " ) ;
db . execSQL ( " ) ;
onCreate ( db ) ;
}
}
private DatabaseHelper mOpenHelper ;
@Override
public boolean onCreate ( ) {
mOpenHelper = new DatabaseHelper ( getContext ( ) ) ;
return true ;
}
@Override
public Cursor query ( Uri uri , String [ ] projection , String selection , String [ ] selectionArgs ,
String sortOrder ) {
SQLiteQueryBuilder qb = new SQLiteQueryBuilder ( ) ;
switch ( sUriMatcher . match ( uri ) ) {
case NOTES :
qb . setTables ( NOTES_TABLE_NAME ) ;
qb . setProjectionMap ( sNotesProjectionMap ) ;
break ;
case NOTE_ID :
qb . setTables ( NOTES_TABLE_NAME ) ;
qb . setProjectionMap ( sNotesProjectionMap ) ;
qb . appendWhere ( Notes . _ID + " + uri . getPathSegments ( ) . get ( <num> ) ) ;
break ;
default :
throw new IllegalArgumentException ( " + uri ) ;
}
String orderBy ;
if ( TextUtils . isEmpty ( sortOrder ) ) {
orderBy = NotePad . Notes . DEFAULT_SORT_ORDER ;
} else {
orderBy = sortOrder ;
}
SQLiteDatabase db = mOpenHelper . getReadableDatabase ( ) ;
Cursor c = qb . query ( db , projection , selection , selectionArgs , null , null , orderBy ) ;
c . setNotificationUri ( getContext ( ) . getContentResolver ( ) , uri ) ;
return c ;
}
@Override
public String getType ( Uri uri ) {
switch ( sUriMatcher . match ( uri ) ) {
case NOTES :
return Notes . CONTENT_TYPE ;
case NOTE_ID :
return Notes . CONTENT_ITEM_TYPE ;
default :
throw new IllegalArgumentException ( " + uri ) ;
}
}
@Override
public Uri insert ( Uri uri , ContentValues initialValues ) {
if ( sUriMatcher . match ( uri ) != NOTES ) {
throw new IllegalArgumentException ( " + uri ) ;
}
ContentValues values ;
if ( initialValues != null ) {
values = new ContentValues ( initialValues ) ;
} else {
values = new ContentValues ( ) ;
}
Long now = Long . valueOf ( System . currentTimeMillis ( ) ) ;
if ( values . containsKey ( NotePad . Notes . CREATED_DATE ) == false ) {
values . put ( NotePad . Notes . CREATED_DATE , now ) ;
}
if ( values . containsKey ( NotePad . Notes . MODIFIED_DATE ) == false ) {
values . put ( NotePad . Notes . MODIFIED_DATE , now ) ;
}
if ( values . containsKey ( NotePad . Notes . TITLE ) == false ) {
Resources r = Resources . getSystem ( ) ;
values . put ( NotePad . Notes . TITLE , r . getString ( android . R . string . <unk> ) ) ;
}
if ( values . containsKey ( NotePad . Notes . NOTE ) == false ) {
values . put ( NotePad . Notes . NOTE , " ) ;
}
SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ;
long rowId = db . insert ( NOTES_TABLE_NAME , Notes . NOTE , values ) ;
if ( rowId > <num> ) {
Uri noteUri = ContentUris . withAppendedId ( NotePad . Notes . CONTENT_URI , rowId ) ;
getContext ( ) . getContentResolver ( ) . notifyChange ( noteUri , null ) ;
return noteUri ;
}
throw new SQLException ( " + uri ) ;
}
@Override
public int delete ( Uri uri , String where , String [ ] whereArgs ) {
SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ;
int count ;
switch ( sUriMatcher . match ( uri ) ) {
case NOTES :
count = db . delete ( NOTES_TABLE_NAME , where , whereArgs ) ;
break ;
case NOTE_ID :
String noteId = uri . getPathSegments ( ) . get ( <num> ) ;
count = db . delete ( NOTES_TABLE_NAME , Notes . _ID + " + noteId
+ ( ! TextUtils . isEmpty ( where ) ? " + where + )' : " ) , whereArgs ) ;
break ;
default :
throw new IllegalArgumentException ( " + uri ) ;
}
getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ;
return count ;
}
@Override
public int update ( Uri uri , ContentValues values , String where , String [ ] whereArgs ) {
SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ;
int count ;
switch ( sUriMatcher . match ( uri ) ) {
case NOTES :
count = db . update ( NOTES_TABLE_NAME , values , where , whereArgs ) ;
break ;
case NOTE_ID :
String noteId = uri . getPathSegments ( ) . get ( <num> ) ;
count = db . update ( NOTES_TABLE_NAME , values , Notes . _ID + " + noteId
+ ( ! TextUtils . isEmpty ( where ) ? " + where + )' : " ) , whereArgs ) ;
break ;
default :
throw new IllegalArgumentException ( " + uri ) ;
}
getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ;
return count ;
}
static {
sUriMatcher = new UriMatcher ( UriMatcher . NO_MATCH ) ;
sUriMatcher . addURI ( NotePad . AUTHORITY , " , NOTES ) ;
sUriMatcher . addURI ( NotePad . AUTHORITY , " , NOTE_ID ) ;
sNotesProjectionMap = new HashMap < String , String > ( ) ;
sNotesProjectionMap . put ( Notes . _ID , Notes . _ID ) ;
sNotesProjectionMap . put ( Notes . TITLE , Notes . TITLE ) ;
sNotesProjectionMap . put ( Notes . NOTE , Notes . NOTE ) ;
sNotesProjectionMap . put ( Notes . CREATED_DATE , Notes . CREATED_DATE ) ;
sNotesProjectionMap . put ( Notes . MODIFIED_DATE , Notes . MODIFIED_DATE ) ;
}
}
package com . google . android . apps . analytics . easytracking ;
import com . google . android . apps . analytics . easytracking . EasyTracker ;
import android . app . Activity ;
import android . test . AndroidTestCase ;
public class <unk> extends AndroidTestCase {
EasyTracker tracker ;
MockParameterLoader parameterLoader ;
MockGoogleAnalyticsTracker mockGATracker ;
Activity mockActivity = new Activity ( ) ;
Activity mockActivity2 = new Activity ( ) ;
@Override
protected void setUp ( ) {
tracker = EasyTracker . getTracker ( ) ;
parameterLoader = new MockParameterLoader ( ) ;
mockGATracker = new MockGoogleAnalyticsTracker ( ) ;
}
private void setUpStandardParameters ( ) {
parameterLoader . addStringParameter ( " , " ) ;
parameterLoader . addBooleanParameter ( " , true ) ;
parameterLoader . addBooleanParameter ( " , true ) ;
parameterLoader . addIntegerParameter ( " , <num> ) ;
parameterLoader . addBooleanParameter ( " , false ) ;
parameterLoader . addIntegerParameter ( " , <num> ) ;
parameterLoader . addBooleanParameter ( " , true ) ;
}
@Override
protected void tearDown ( ) {
EasyTracker . clearTracker ( ) ;
}
private void assertCallsMade ( int startNewSession , int trackPageView , int trackEvent ) {
try { Thread . sleep ( <num> ) ; } catch ( InterruptedException e ) { }
assertEquals ( startNewSession , mockGATracker . getNumberCallsMade ( " ) ) ;
assertEquals ( trackPageView , mockGATracker . getNumberCallsMade ( " ) ) ;
assertEquals ( trackEvent , mockGATracker . getNumberCallsMade ( " ) ) ;
}
public void <unk> ( ) {
tracker . setContext ( this . getContext ( ) , parameterLoader ) ;
tracker . setTrackerDelegate ( mockGATracker ) ;
tracker . startNewSession ( ) ;
assertCallsMade ( <num> , <num> , <num> ) ;
}
public void <unk> ( ) {
setUpStandardParameters ( ) ;
tracker . setContext ( this . getContext ( ) , parameterLoader ) ;
tracker . setTrackerDelegate ( mockGATracker ) ;
tracker . startNewSession ( ) ;
assertCallsMade ( <num> , <num> , <num> ) ;
assertTrue ( mockGATracker . getDebug ( ) ) ;
assertTrue ( mockGATracker . isDryRun ( ) ) ;
assertEquals ( <num> , mockGATracker . getSampleRate ( ) ) ;
assertFalse ( mockGATracker . getAnonymizeIp ( ) ) ;
assertEquals ( " , mockGATracker . getAccountId ( ) ) ;
assertEquals ( <num> , mockGATracker . getDispatchPeriod ( ) ) ;
}
public void <unk> ( ) {
setUpStandardParameters ( ) ;
tracker . setContext ( this . getContext ( ) , parameterLoader ) ;
tracker . setTrackerDelegate ( mockGATracker ) ;
tracker . trackActivityStart ( mockActivity ) ;
tracker . trackActivityStart ( mockActivity2 ) ;
tracker . trackActivityStop ( mockActivity ) ;
tracker . trackActivityStop ( mockActivity2 ) ;
assertCallsMade ( <num> , <num> , <num> ) ;
}
public void <unk> ( ) {
setUpStandardParameters ( ) ;
parameterLoader . addBooleanParameter ( " , false ) ;
tracker . setContext ( this . getContext ( ) , parameterLoader ) ;
tracker . setTrackerDelegate ( mockGATracker ) ;
tracker . trackActivityStart ( mockActivity ) ;
tracker . trackActivityStart ( mockActivity2 ) ;
tracker . trackActivityStop ( mockActivity ) ;
tracker . trackActivityStop ( mockActivity2 ) ;
assertCallsMade ( <num> , <num> , <num> ) ;
}
public void <unk> ( ) {
setUpStandardParameters ( ) ;
tracker . setContext ( this . getContext ( ) , parameterLoader ) ;
tracker . setTrackerDelegate ( mockGATracker ) ;
tracker . trackActivityStart ( mockActivity ) ;
tracker . trackActivityStop ( mockActivity ) ;
tracker . trackActivityRetainNonConfigurationInstance ( ) ;
tracker . trackActivityStart ( mockActivity ) ;
tracker . trackActivityStop ( mockActivity ) ;
assertCallsMade ( <num> , <num> , <num> ) ;
}
public void <unk> ( ) {
setUpStandardParameters ( ) ;
parameterLoader . addBooleanParameter ( " , false ) ;
tracker . setContext ( this . getContext ( ) , parameterLoader ) ;
tracker . setTrackerDelegate ( mockGATracker ) ;
tracker . trackActivityStart ( mockActivity ) ;
tracker . trackActivityStop ( mockActivity ) ;
tracker . trackActivityRetainNonConfigurationInstance ( ) ;
tracker . trackActivityStart ( mockActivity ) ;
tracker . trackActivityStop ( mockActivity ) ;
assertCallsMade ( <num> , <num> , <num> ) ;
}
public void <unk> ( ) {
setUpStandardParameters ( ) ;
tracker . setContext ( this . getContext ( ) , parameterLoader ) ;
tracker . setTrackerDelegate ( mockGATracker ) ;
tracker . trackActivityStart ( mockActivity ) ;
tracker . trackActivityStop ( mockActivity ) ;
tracker . trackActivityStart ( mockActivity ) ;
tracker . trackActivityStop ( mockActivity ) ;
assertCallsMade ( <num> , <num> , <num> ) ;
}
public void <unk> ( ) {
setUpStandardParameters ( ) ;
parameterLoader . addBooleanParameter ( " , false ) ;
tracker . setContext ( this . getContext ( ) , parameterLoader ) ;
tracker . setTrackerDelegate ( mockGATracker ) ;
tracker . trackActivityStart ( mockActivity ) ;
tracker . trackActivityStop ( mockActivity ) ;
tracker . trackActivityStart ( mockActivity ) ;
tracker . trackActivityStop ( mockActivity ) ;
assertCallsMade ( <num> , <num> , <num> ) ;
}
}
package com . google . android . apps . analytics . easytracking ;
import android . app . Activity ;
import android . os . Bundle ;
public class TrackedActivity extends Activity {
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
EasyTracker . getTracker ( ) . setContext ( this ) ;
}
@Override
protected void onStart ( ) {
super . onStart ( ) ;
EasyTracker . getTracker ( ) . trackActivityStart ( this ) ;
}
@Override
public Object onRetainNonConfigurationInstance ( ) {
Object o = super . onRetainNonConfigurationInstance ( ) ;
EasyTracker . getTracker ( ) . trackActivityRetainNonConfigurationInstance ( ) ;
return o ;
}
@Override
protected void onStop ( ) {
super . onStop ( ) ;
EasyTracker . getTracker ( ) . trackActivityStop ( this ) ;
}
package com . example . android . notepad ;
import com . example . android . notepad . NotePad . Notes ;
import com . google . android . apps . analytics . easytracking . TrackedListActivity ;
import android . content . ComponentName ;
import android . content . ContentUris ;
import android . content . Intent ;
import android . database . Cursor ;
import android . net . Uri ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . ContextMenu ;
import android . view . Menu ;
import android . view . MenuItem ;
import android . view . View ;
import android . view . ContextMenu . ContextMenuInfo ;
import android . widget . AdapterView ;
import android . widget . ListView ;
import android . widget . SimpleCursorAdapter ;
public class NotesList extends TrackedListActivity {
private static final String TAG = " ;
public static final int MENU_ITEM_DELETE = Menu . FIRST ;
public static final int MENU_ITEM_INSERT = Menu . FIRST + <num> ;
private static final String [ ] PROJECTION = new String [ ] {
Notes . _ID ,
Notes . TITLE ,
} ;
private static final int COLUMN_INDEX_TITLE = <num> ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setDefaultKeyMode ( <unk> ) ;
Intent intent = getIntent ( ) ;
if ( intent . getData ( ) == null ) {
intent . setData ( Notes . CONTENT_URI ) ;
}
getListView ( ) . setOnCreateContextMenuListener ( this ) ;
Cursor cursor = managedQuery ( getIntent ( ) . getData ( ) , PROJECTION , null , null ,
Notes . DEFAULT_SORT_ORDER ) ;
SimpleCursorAdapter adapter = new SimpleCursorAdapter ( this , R . layout . <unk> , cursor ,
new String [ ] { Notes . TITLE } , new int [ ] { android . R . id . text1 } ) ;
setListAdapter ( adapter ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
super . onCreateOptionsMenu ( menu ) ;
menu . add ( <num> , MENU_ITEM_INSERT , <num> , R . string . menu_insert )
. setShortcut ( <num>  , a' )
. setIcon ( android . R . drawable . ic_menu_add ) ;
Intent intent = new Intent ( null , getIntent ( ) . getData ( ) ) ;
intent . addCategory ( Intent . CATEGORY_ALTERNATIVE ) ;
menu . addIntentOptions ( Menu . CATEGORY_ALTERNATIVE , <num> , <num> ,
new ComponentName ( this , NotesList . class ) , null , intent , <num> , null ) ;
return true ;
}
@Override
public boolean onPrepareOptionsMenu ( Menu menu ) {
super . onPrepareOptionsMenu ( menu ) ;
final boolean haveItems = getListAdapter ( ) . getCount ( ) > <num> ;
if ( haveItems ) {
Uri uri = ContentUris . withAppendedId ( getIntent ( ) . getData ( ) , getSelectedItemId ( ) ) ;
Intent [ ] specifics = new Intent [ <num> ] ;
specifics [ <num> ] = new Intent ( Intent . ACTION_EDIT , uri ) ;
MenuItem [ ] items = new MenuItem [ <num> ] ;
Intent intent = new Intent ( null , uri ) ;
intent . addCategory ( Intent . CATEGORY_ALTERNATIVE ) ;
menu . addIntentOptions ( Menu . CATEGORY_ALTERNATIVE , <num> , <num> , null , specifics , intent , <num> ,
items ) ;
if ( items [ <num> ] != null ) {
items [ <num> ] . setShortcut ( <num>  , e' ) ;
}
} else {
menu . removeGroup ( Menu . CATEGORY_ALTERNATIVE ) ;
}
return true ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
switch ( item . getItemId ( ) ) {
case MENU_ITEM_INSERT :
startActivity ( new Intent ( Intent . ACTION_INSERT , getIntent ( ) . getData ( ) ) ) ;
return true ;
}
return super . onOptionsItemSelected ( item ) ;
}
@Override
public void onCreateContextMenu ( ContextMenu menu , View view , ContextMenuInfo menuInfo ) {
AdapterView . AdapterContextMenuInfo info ;
try {
info = ( AdapterView . AdapterContextMenuInfo ) menuInfo ;
} catch ( ClassCastException e ) {
Log . e ( TAG , " , e ) ;
return ;
}
Cursor cursor = ( Cursor ) getListAdapter ( ) . getItem ( info . position ) ;
if ( cursor == null ) {
return ;
}
menu . setHeaderTitle ( cursor . getString ( COLUMN_INDEX_TITLE ) ) ;
menu . add ( <num> , MENU_ITEM_DELETE , <num> , R . string . menu_delete ) ;
}
@Override
public boolean onContextItemSelected ( MenuItem item ) {
AdapterView . AdapterContextMenuInfo info ;
try {
info = ( AdapterView . AdapterContextMenuInfo ) item . getMenuInfo ( ) ;
} catch ( ClassCastException e ) {
Log . e ( TAG , " , e ) ;
return false ;
}
switch ( item . getItemId ( ) ) {
case MENU_ITEM_DELETE : {
Uri noteUri = ContentUris . withAppendedId ( getIntent ( ) . getData ( ) , info . id ) ;
getContentResolver ( ) . delete ( noteUri , null , null ) ;
return true ;
}
}
return false ;
}
@Override
protected void onListItemClick ( ListView l , View v , int position , long id ) {
Uri uri = ContentUris . withAppendedId ( getIntent ( ) . getData ( ) , id ) ;
String action = getIntent ( ) . getAction ( ) ;
if ( Intent . ACTION_PICK . equals ( action ) || Intent . ACTION_GET_CONTENT . equals ( action ) ) {
setResult ( RESULT_OK , new Intent ( ) . setData ( uri ) ) ;
} else {
startActivity ( new Intent ( Intent . ACTION_EDIT , uri ) ) ;
}
}
}
package com . google . android . apps . analytics . easytracking ;
import android . app . ListActivity ;
import android . os . Bundle ;
public class TrackedListActivity extends ListActivity {
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
EasyTracker . getTracker ( ) . setContext ( this ) ;
}
@Override
protected void onStart ( ) {
super . onStart ( ) ;
EasyTracker . getTracker ( ) . trackActivityStart ( this ) ;
}
@Override
public Object onRetainNonConfigurationInstance ( ) {
Object o = super . onRetainNonConfigurationInstance ( ) ;
EasyTracker . getTracker ( ) . trackActivityRetainNonConfigurationInstance ( ) ;
return o ;
}
@Override
protected void onStop ( ) {
super . onStop ( ) ;
EasyTracker . getTracker ( ) . trackActivityStop ( this ) ;
}
}
package com . google . android . apps . analytics . easytracking ;
import com . google . android . apps . analytics . easytracking . ParameterLoader ;
import java . util . HashMap ;
import java . util . Map ;
public class MockParameterLoader implements ParameterLoader {
Map < String , String > strings = new HashMap < String , String > ( ) ;
Map < String , Boolean > bools = new HashMap < String , Boolean > ( ) ;
Map < String , Integer > ints = new HashMap < String , Integer > ( ) ;
public void addStringParameter ( String key , String value ) {
strings . put ( key , value ) ;
}
public void addBooleanParameter ( String key , boolean value ) {
bools . put ( key , value ) ;
}
public void addIntegerParameter ( String key , int value ) {
ints . put ( key , value ) ;
}
@Override
public String getString ( String key ) {
return strings . get ( key ) ;
}
@Override
public boolean getBoolean ( String key ) {
if ( bools . containsKey ( key ) ) {
return bools . get ( key ) ;
}
return false ;
}
@Override
public int getInt ( String key , int defaultValue ) {
if ( ints . containsKey ( key ) ) {
return ints . get ( key ) ;
}
return defaultValue ;
}
}
package com . google . android . apps . analytics . easytracking ;
import com . google . android . apps . analytics . easytracking . ParameterLoaderImpl ;
import android . test . AndroidTestCase ;
public class <unk> extends AndroidTestCase {
ParameterLoaderImpl gapi ;
@Override
protected void setUp ( ) {
gapi = new ParameterLoaderImpl ( this . getContext ( ) ) ;
}
public void <unk> ( ) {
try {
gapi = new ParameterLoaderImpl ( null ) ;
fail ( " ) ;
} catch ( NullPointerException expected ) {
}
}
public void testString ( ) {
assertNull ( gapi . getString ( " ) ) ;
assertEquals ( " , gapi . getString ( " ) ) ;
}
public void <unk> ( ) {
assertTrue ( gapi . getBoolean ( " ) ) ;
assertFalse ( gapi . getBoolean ( " ) ) ;
assertFalse ( gapi . getBoolean ( " ) ) ;
assertFalse ( gapi . getBoolean ( " ) ) ;
assertFalse ( gapi . getBoolean ( " ) ) ;
}
public void <unk> ( ) {
assertEquals ( <num> , gapi . getInt ( " , <num> ) ) ;
assertEquals ( <num> , gapi . getInt ( " , <num> ) ) ;
assertEquals ( <num> , gapi . getInt ( " , <num> ) ) ;
assertEquals ( <num> , gapi . getInt ( " , <num> ) ) ;
}
}
package com . google . android . apps . analytics . easytracking ;
import com . google . android . apps . analytics . Item ;
import com . google . android . apps . analytics . Transaction ;
import com . google . android . apps . analytics . easytracking . GoogleAnalyticsTrackerDelegate ;
import android . content . Context ;
import java . util . HashMap ;
import java . util . Map ;
public class MockGoogleAnalyticsTracker implements GoogleAnalyticsTrackerDelegate {
private boolean debug ;
private boolean dryRun ;
private int sampleRate ;
private boolean anonymizeIp ;
private int dispatchPeriod ;
private String accountId ;
private Map < String , Integer > callsMade = new HashMap < String , Integer > ( ) ;
public String getAccountId ( ) {
return this . accountId ;
}
public int getDispatchPeriod ( ) {
return this . dispatchPeriod ;
}
public Map < String , Integer > <unk> ( ) {
return callsMade ;
}
public int getNumberCallsMade ( String methodName ) {
if ( callsMade . containsKey ( methodName ) ) {
return callsMade . get ( methodName ) ;
} else {
return <num> ;
}
}
private void incrementCallsMade ( String callMade ) {
int previousCalls = <num> ;
if ( callsMade . containsKey ( callMade ) ) {
previousCalls = callsMade . get ( callMade ) ;
}
callsMade . put ( callMade , previousCalls + <num> ) ;
}
@Override
public void startNewSession ( String accountId , int dispatchPeriod , Context ctx ) {
incrementCallsMade ( " ) ;
this . accountId = accountId ;
this . dispatchPeriod = dispatchPeriod ;
}
@Override
public void trackEvent ( String category , String action , String label , int value ) {
incrementCallsMade ( " ) ;
}
@Override
public void trackPageView ( String pageUrl ) {
incrementCallsMade ( " ) ;
}
@Override
public boolean dispatch ( ) {
incrementCallsMade ( " ) ;
return false ;
}
@Override
public void stopSession ( ) {
incrementCallsMade ( " ) ;
}
@Override
public boolean setCustomVar ( int index , String name , String value , int scope ) {
return false ;
}
@Override
public boolean setCustomVar ( int index , String name , String value ) {
return false ;
}
@Override
public void addTransaction ( Transaction transaction ) {
}
@Override
public void addItem ( Item item ) {
}
@Override
public void trackTransactions ( ) {
clearTransactions ( ) ;
}
@Override
public void clearTransactions ( ) {
}
@Override
public void setAnonymizeIp ( boolean anonymizeIp ) {
this . anonymizeIp = anonymizeIp ;
}
public boolean getAnonymizeIp ( ) {
return this . anonymizeIp ;
}
@Override
public void setSampleRate ( int sampleRate ) {
this . sampleRate = sampleRate ;
}
public int getSampleRate ( ) {
return this . sampleRate ;
}
@Override
public boolean setReferrer ( String referrer ) {
return false ;
}
@Override
public void setDebug ( boolean debug ) {
this . debug = debug ;
}
public boolean getDebug ( ) {
return this . debug ;
}
@Override
public void setDryRun ( boolean dryRun ) {
this . dryRun = dryRun ;
}
public boolean isDryRun ( ) {
return this . dryRun ;
}
}
package fi . iki . murgo . irssinotifier ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
import android . content . Context ;
import android . os . AsyncTask ;
public class DataAccessTask extends AsyncTask < IrcMessage , Void , Map < Channel , List < IrcMessage >>> {
private final Context context ;
private Callback < Map < Channel , List < IrcMessage >>> callback ;
public DataAccessTask ( Context context , Callback < Map < Channel , List < IrcMessage >>> callback ) {
this . context = context ;
this . callback = callback ;
}
@Override
protected Map < Channel , List < IrcMessage >> doInBackground ( IrcMessage . . . params ) {
DataAccess da = new DataAccess ( context ) ;
if ( params != null ) {
for ( IrcMessage im : params ) {
da . HandleMessage ( im ) ;
}
}
List < Channel > channels = da . getChannels ( ) ;
Map < Channel , List < IrcMessage >> data = new HashMap < Channel , List < IrcMessage >> ( ) ;
for ( Channel channel : channels ) {
data . put ( channel , da . getMessagesForChannel ( channel ) ) ;
}
return data ;
}
@Override
protected void onPostExecute ( Map < Channel , List < IrcMessage >> result ) {
if ( callback != null )
callback . doStuff ( result ) ;
}
}
package fi . iki . murgo . irssinotifier ;
public interface Callback < T > {
void doStuff ( T param ) ;
}
package fi . iki . murgo . irssinotifier ;
import android . accounts . Account ;
import android . app . Activity ;
import android . content . Context ;
import android . content . Intent ;
import android . os . Bundle ;
import android . util . Log ;
import android . view . View ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . ArrayAdapter ;
import android . widget . ListView ;
public class InitialSettingsActivity extends Activity {
private static final String TAG = InitialSettingsActivity . class . getSimpleName ( ) ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
setContentView ( R . layout . <unk> ) ;
UserHelper fetcher = new UserHelper ( ) ;
final Account [ ] accounts = fetcher . getAccounts ( this ) ;
String [ ] accountNames = new String [ accounts . length ] ;
for ( int i = <num> ; i < accounts . length ; i ++ ) {
accountNames [ i ] = accounts [ i ] . name ;
}
ListView listView = ( ListView ) findViewById ( R . id . <unk> ) ;
listView . setAdapter ( new ArrayAdapter < String > ( this , R . layout . <unk> , accountNames ) ) ;
listView . setOnItemClickListener ( new OnItemClickListener ( ) {
public void onItemClick ( AdapterView < ? > arg0 , View arg1 , int arg2 , long arg3 ) {
Account account = accounts [ arg2 ] ;
whatNext ( <num> , account ) ;
}
} ) ;
}
private void whatNext ( int i , Object state ) {
Log . d ( TAG , " + i ) ;
switch ( i ) {
default :
case  <num> :
Preferences prefs = new Preferences ( this ) ;
prefs . clear ( ) ;
finish ( ) ;
break ;
case <num> :
generateToken ( ( Account ) state ) ;
break ;
case <num> :
registerToC2DM ( ( String ) state ) ;
break ;
case <num> :
sendSettings ( ) ;
break ;
case <num> :
startMainApp ( ) ;
break ;
}
}
private void startMainApp ( ) {
final Context ctx = this ;
MessageBox . Show ( this , " , " , new Callback < Void > ( ) {
public void doStuff ( Void param ) {
Intent i = new Intent ( ctx , IrssiNotifierActivity . class ) ;
startActivity ( i ) ;
finish ( ) ;
}
} , true ) ;
}
private void sendSettings ( ) {
SettingsSendingTask task = new SettingsSendingTask ( this , " , " ) ;
final Context ctx = this ;
task . setCallback ( new Callback < ServerResponse > ( ) {
public void doStuff ( ServerResponse result ) {
if ( result == null || ! result . wasSuccesful ( ) ) {
MessageBox . Show ( ctx , null , " , new Callback < Void > ( ) {
public void doStuff ( Void param ) {
whatNext (  <num> , null ) ;
}
} ) ;
return ;
}
whatNext ( <num> , null ) ;
}
} ) ;
task . execute ( ) ;
}
private void generateToken ( Account account ) {
TokenGenerationTask task = new TokenGenerationTask ( this , " , " ) ;
final Context ctx = this ;
task . setCallback ( new Callback < String > ( ) {
public void doStuff ( String result ) {
if ( result == null ) {
MessageBox . Show ( ctx , null , " , new Callback < Void > ( ) {
public void doStuff ( Void param ) {
whatNext (  <num> , null ) ;
}
} ) ;
return ;
}
whatNext ( <num> , result ) ;
}
} ) ;
task . execute ( account ) ;
}
private void registerToC2DM ( String token ) {
final C2DMRegistrationTask task = new C2DMRegistrationTask ( this , " , " ) ;
final Context ctx = this ;
task . setCallback ( new Callback < String [ ] > ( ) {
public void doStuff ( String [ ] result ) {
task . getDialog ( ) . dismiss ( ) ;
String error = result [ <num> ] ;
String unregistered = result [ <num> ] ;
if ( ( error != null || unregistered != null ) ) {
MessageBox . Show ( ctx , null , " , new Callback < Void > ( ) {
public void doStuff ( Void param ) {
whatNext (  <num> , null ) ;
}
} ) ;
return ;
}
whatNext ( <num> , null ) ;
}
} ) ;
task . execute ( ) ;
}
}
package fi . iki . murgo . irssinotifier ;
import android . app . Activity ;
import android . util . Log ;
public class SettingsSendingTask extends BackgroundAsyncTask < Void , Void , ServerResponse > {
private static final String TAG = InitialSettingsActivity . class . getSimpleName ( ) ;
public SettingsSendingTask ( Activity activity , String titleText , String text ) {
super ( activity , titleText , text ) ;
}
@Override
protected ServerResponse doInBackground ( Void . . . params ) {
Log . d ( TAG , " ) ;
Preferences prefs = new Preferences ( activity ) ;
try {
ServerResponse response = prefs . sendSettings ( ) ;
return response ;
} catch ( Exception e ) {
Log . e ( TAG , " + e . toString ( ) ) ;
e . printStackTrace ( ) ;
}
return null ;
}
}
package fi . iki . murgo . irssinotifier ;
import java . util . HashMap ;
import java . util . Locale ;
import java . util . Map ;
public class MessageToServer {
private static final String LANGUAGE = " ;
private static final String VERSION = " ;
private static int version ;
private Map < String , String > map = new HashMap < String , String > ( ) ;
public MessageToServer ( Map < String , String > values ) {
map . put ( LANGUAGE , Locale . getDefault ( ) . <unk> ( ) ) ;
map . put ( VERSION , Integer . toString ( version ) ) ;
for ( Map . Entry < String , String > pair : values . entrySet ( ) ) {
map . put ( pair . getKey ( ) , pair . getValue ( ) ) ;
}
}
public Map < String , String > getMap ( ) {
return this . map ;
}
public static void setVersion ( int versionCode ) {
version = versionCode ;
}
public String getHttpString ( ) {
StringBuilder sb = new StringBuilder ( ) ;
for ( Map . Entry < String , String > entry : map . entrySet ( ) ) {
sb . append ( entry . getKey ( ) ) . append ( " ) . append ( entry . getValue ( ) ) . append ( " ) ;
}
return sb . toString ( ) ;
}
}
package fi . iki . murgo . irssinotifier ;
import java . util . HashMap ;
import java . util . Map ;
public class IrcMessages {
private static IrcMessages instance ;
Map < String , Integer > unreadCounts = new HashMap < String , Integer > ( ) ;
private IrcMessages ( ) {
}
public static IrcMessages getInstance ( ) {
if ( instance == null )
instance = new IrcMessages ( ) ;
return instance ;
}
public int getUnreadCount ( ) {
int total = <num> ;
for ( int i : unreadCounts . values ( ) ) {
total += i ;
}
return total ;
}
public int getUnreadCountForChannel ( String channel ) {
if ( ! unreadCounts . containsKey ( channel ) )
return <num> ;
return unreadCounts . get ( channel ) ;
}
public void read ( ) {
unreadCounts = new HashMap < String , Integer > ( ) ;
}
public void addUnread ( IrcMessage msg ) {
String key = msg . isPrivate ( ) ? msg . getNick ( ) : msg . getChannel ( ) ;
if ( unreadCounts . containsKey ( key ) )
unreadCounts . put ( key , unreadCounts . get ( key ) + <num> ) ;
else
unreadCounts . put ( key , <num> ) ;
}
}
package fi . iki . murgo . irssinotifier ;
import java . io . IOException ;
import java . util . Date ;
import java . util . HashMap ;
import org . apache . http . auth . AuthenticationException ;
import fi . iki . murgo . irssinotifier . Server . ServerTarget ;
import android . content . Context ;
import android . content . SharedPreferences ;
import android . preference . PreferenceManager ;
public class Preferences {
public static final String <unk> = " ;
public static final int <unk> = Context . MODE_PRIVATE ;
private static final String AUTH_TOKEN_KEY = " ;
private static final String REGISTRATION_ID_KEY = " ;
private static final String SETTINGS_SENT_KEY = " ;
private static final String ENCRYPTION_PASSWORD = " ;
private static final String NOTIFICATION_MODE = " ;
private static final String LAST_FETCH_TIME = " ;
private static final String DEVICE_NAME_KEY = " ;
private static final String ENABLED_KEY = " ;
private static final String SOUND_ENABLED = " ;
private static final String SPAM_FILTER_ENABLED = " ;
private static final String NOTIFICATIONS_ENABLED = " ;
private SharedPreferences sharedPreferences ;
public Preferences ( Context context ) {
sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ;
}
public String getRegistrationId ( ) {
return sharedPreferences . getString ( REGISTRATION_ID_KEY , null ) ;
}
public boolean setRegistrationId ( String registrationId ) {
SharedPreferences . Editor editor = sharedPreferences . edit ( ) ;
editor . putString ( REGISTRATION_ID_KEY , registrationId ) ;
editor . putBoolean ( SETTINGS_SENT_KEY , false ) ;
return editor . commit ( ) ;
}
public String getAuthToken ( ) {
return sharedPreferences . getString ( AUTH_TOKEN_KEY , null ) ;
}
public boolean setAuthToken ( String token ) {
SharedPreferences . Editor editor = sharedPreferences . edit ( ) ;
editor . putString ( AUTH_TOKEN_KEY , token ) ;
editor . putBoolean ( SETTINGS_SENT_KEY , false ) ;
return editor . commit ( ) ;
}
public void clear ( ) {
sharedPreferences . edit ( ) . clear ( ) . commit ( ) ;
}
public boolean settingsNeedSending ( ) {
return ! sharedPreferences . getBoolean ( SETTINGS_SENT_KEY , false ) ;
}
public ServerResponse sendSettings ( ) throws IOException , AuthenticationException {
HashMap < String , String > map = new HashMap < String , String > ( ) ;
map . put ( REGISTRATION_ID_KEY , getRegistrationId ( ) ) ;
map . put ( DEVICE_NAME_KEY , android . os . Build . MODEL ) ;
map . put ( ENABLED_KEY , " ) ;
MessageToServer msg = new MessageToServer ( map ) ;
Server server = new Server ( ) ;
boolean authenticated = server . authenticate ( getAuthToken ( ) ) ;
if ( ! authenticated ) throw new AuthenticationException ( ) ;
ServerResponse response = server . send ( msg , ServerTarget . SaveSettings ) ;
if ( response . wasSuccesful ( ) ) {
sharedPreferences . edit ( ) . putBoolean ( SETTINGS_SENT_KEY , true ) . commit ( ) ;
}
return response ;
}
public boolean <unk> ( String encryptionPassword ) {
SharedPreferences . Editor editor = sharedPreferences . edit ( ) ;
editor . putString ( ENCRYPTION_PASSWORD , encryptionPassword ) ;
return editor . commit ( ) ;
}
public String getEncryptionPassword ( ) {
return sharedPreferences . getString ( ENCRYPTION_PASSWORD , " ) ;
}
public NotificationMode getNotificationMode ( ) {
return NotificationMode . values ( ) [ sharedPreferences . getInt ( NOTIFICATION_MODE , NotificationMode . PerChannel . ordinal ( ) ) ] ;
}
public boolean setNotificationMode ( NotificationMode notificationMode ) {
SharedPreferences . Editor editor = sharedPreferences . edit ( ) ;
editor . putInt ( NOTIFICATION_MODE , notificationMode . ordinal ( ) ) ;
return editor . commit ( ) ;
}
public long getLastFetchTime ( ) {
return sharedPreferences . getLong ( LAST_FETCH_TIME , new Date ( ) . getTime ( ) ) ;
}
public boolean setLastFetchTime ( long value ) {
return sharedPreferences . edit ( ) . putLong ( LAST_FETCH_TIME , value ) . commit ( ) ;
}
public boolean isSoundEnabled ( ) {
return sharedPreferences . getBoolean ( SOUND_ENABLED , true ) ;
}
public boolean isSpamFilterEnabled ( ) {
return sharedPreferences . getBoolean ( SPAM_FILTER_ENABLED , true ) ;
}
public boolean isNotificationsEnabled ( ) {
return sharedPreferences . getBoolean ( NOTIFICATIONS_ENABLED , true ) ;
}
}
package fi . iki . murgo . irssinotifier ;
import java . util . Date ;
import org . json . JSONException ;
import android . app . Notification ;
import android . app . NotificationManager ;
import android . app . PendingIntent ;
import android . content . BroadcastReceiver ;
import android . content . ComponentName ;
import android . content . Context ;
import android . content . Intent ;
import android . util . Log ;
public class C2DMReceiver extends BroadcastReceiver {
private static final String TAG = C2DMReceiver . class . getSimpleName ( ) ;
private static final String C2DM_DATA_ACTION = " ;
private static final String C2DM_DATA_MESSAGE = " ;
public static final String EMAIL_OF_SENDER = " ;
private static int perMessageNotificationId = <num> ;
private static long lastSoundDate = <num> ;
private static Callback < String [ ] > callback ;
private static IrcMessages ircMessages ;
public static void registerToC2DM ( Context context ) {
Intent registrationIntent = new Intent ( " ) ;
registrationIntent . putExtra ( " , PendingIntent . getBroadcast ( context , <num> , new Intent ( ) , <num> ) ) ;
registrationIntent . putExtra ( " , EMAIL_OF_SENDER ) ;
ComponentName service = context . startService ( registrationIntent ) ;
if ( service == null ) throw new RuntimeException ( " ) ;
}
public static void <unk> ( Context context ) {
Intent unregistrationIntent = new Intent ( " ) ;
unregistrationIntent . putExtra ( " , PendingIntent . getBroadcast ( context , <num> , new Intent ( ) , <num> ) ) ;
context . startService ( unregistrationIntent ) ;
}
@Override
public void onReceive ( Context context , Intent intent ) {
if ( intent . getAction ( ) . equals ( " ) ) {
handleRegistration ( context , intent ) ;
} else if ( intent . getAction ( ) . equals ( " ) ) {
handleMessage ( context , intent ) ;
} else {
Log . w ( TAG , " + intent ) ;
}
}
public static void setRegistrationCallback ( Callback < String [ ] > callback ) {
C2DMReceiver . callback = callback ;
}
private void handleRegistration ( Context context , Intent intent ) {
String registrationId = intent . getStringExtra ( " ) ;
String error = intent . getStringExtra ( " ) ;
String unregistered = intent . getStringExtra ( " ) ;
Log . i ( TAG , " + registrationId + " + error + " + unregistered ) ;
Preferences preferences = new Preferences ( context ) ;
if ( error != null || unregistered != null ) {
preferences . setRegistrationId ( null ) ;
} else {
preferences . setRegistrationId ( registrationId ) ;
}
if ( callback != null ) {
callback . doStuff ( new String [ ] { registrationId , error , unregistered } ) ;
}
}
private void handleMessage ( Context context , Intent intent ) {
Log . d ( TAG , " ) ;
String action = intent . getStringExtra ( C2DM_DATA_ACTION ) ;
String message = intent . getStringExtra ( C2DM_DATA_MESSAGE ) ;
Log . d ( TAG , " + action + " + message ) ;
ircMessages = IrcMessages . getInstance ( ) ;
if ( message . startsWith ( " ) ) {
NotificationManager notificationManager = ( NotificationManager ) context . getSystemService ( Context . NOTIFICATION_SERVICE ) ;
notificationManager . cancelAll ( ) ;
ircMessages . read ( ) ;
return ;
}
Preferences prefs = new Preferences ( context ) ;
if ( ! prefs . isNotificationsEnabled ( ) ) {
return ;
}
NotificationMode mode = prefs . getNotificationMode ( ) ;
String tickerText ;
String notificationMessage ;
String titleText ;
int notificationId ;
long when = new Date ( ) . getTime ( ) ; ;
IrcMessage msg = new IrcMessage ( ) ;
try {
msg . Deserialize ( message ) ;
msg . Decrypt ( prefs . getEncryptionPassword ( ) ) ;
Object [ ] values = getValues ( msg , mode , ircMessages ) ;
notificationMessage = ( String ) values [ <num> ] ;
titleText = ( String ) values [ <num> ] ;
notificationId = ( Integer ) values [ <num> ] ;
when = msg . getServerTimestamp ( ) . getTime ( ) ;
if ( ircMessages . getUnreadCount ( ) == <num> ) {
tickerText = " ;
} else {
tickerText = " + ircMessages . getUnreadCount ( ) + " ;
}
ircMessages . addUnread ( msg ) ;
} catch ( CryptoException e ) {
titleText = " ;
notificationMessage = " ;
tickerText = " ;
notificationId = <num> ;
} catch ( JSONException e ) {
titleText = " ;
notificationMessage = " ;
tickerText = " ;
notificationId = <num> ;
}
NotificationManager notificationManager = ( NotificationManager ) context . getSystemService ( Context . NOTIFICATION_SERVICE ) ;
Notification notification = new Notification ( R . drawable . icon , tickerText , when ) ;
notification . flags |= Notification . FLAG_AUTO_CANCEL ;
if ( prefs . isSoundEnabled ( ) && ( ! prefs . isSpamFilterEnabled ( ) || new Date ( ) . getTime ( ) > lastSoundDate + <num> ) ) {
notification . defaults |= Notification . DEFAULT_SOUND ;
lastSoundDate = new Date ( ) . getTime ( ) ;
}
Intent toLaunch = new Intent ( context , IrssiNotifierActivity . class ) ;
PendingIntent contentIntent = PendingIntent . getActivity ( context , <num> , toLaunch , <num> ) ;
notification . setLatestEventInfo ( context , titleText , notificationMessage , contentIntent ) ;
notificationManager . notify ( notificationId , notification ) ;
}
private Object [ ] getValues ( IrcMessage msg , NotificationMode mode , IrcMessages ircMessages ) {
String text = null ;
String title = null ;
int id = <num> ;
int unreadCount = ircMessages . getUnreadCount ( ) + <num> ;
int channelUnreadCount = msg . isPrivate ( ) ? ircMessages . getUnreadCountForChannel ( msg . getNick ( ) ) : ircMessages . getUnreadCountForChannel ( msg . getChannel ( ) ) + <num> ;
switch ( mode ) {
case Single :
id = <num> ;
if ( msg . isPrivate ( ) ) {
if ( unreadCount == <num> ) {
title = " + msg . getNick ( ) ;
text = msg . getMessage ( ) ;
} else {
title = " + unreadCount + " ;
text = " + msg . getLogicalChannel ( ) + " + msg . getNick ( ) + " + msg . getMessage ( ) ;
}
} else {
if ( unreadCount == <num> ) {
title = " + msg . getChannel ( ) ;
text = " + msg . getNick ( ) + " + msg . getMessage ( ) ;
} else {
title = " + unreadCount + " ;
text = " + msg . getLogicalChannel ( ) + " + msg . getNick ( ) + " + msg . getMessage ( ) ;
}
}
break ;
case PerMessage :
id = perMessageNotificationId ++ ;
if ( msg . isPrivate ( ) ) {
title = " + msg . getNick ( ) ;
text = msg . getMessage ( ) ;
} else {
title = " + msg . getChannel ( ) ;
text = " + msg . getNick ( ) + " + msg . getMessage ( ) ;
}
break ;
case PerChannel :
id = msg . getNick ( ) . hashCode ( ) ;
if ( msg . isPrivate ( ) ) {
if ( channelUnreadCount == <num> ) {
title = " + msg . getNick ( ) ;
text = msg . getMessage ( ) ;
} else {
title = " + channelUnreadCount + " + msg . getNick ( ) ;
text = " + msg . getMessage ( ) ;
}
} else {
if ( channelUnreadCount == <num> ) {
title = " + msg . getChannel ( ) ;
text = " + msg . getNick ( ) + " + msg . getMessage ( ) ;
} else {
title = " + unreadCount + " + msg . getChannel ( ) ;
text = " + msg . getNick ( ) + " + msg . getMessage ( ) ;
}
}
break ;
}
return new Object [ ] { text , title , id } ;
}
}
package fi . iki . murgo . irssinotifier ;
import org . json . JSONException ;
import org . json . JSONObject ;
import android . util . Log ;
public class MessageServerResponse extends ServerResponse {
private static final String TAG = MessageServerResponse . class . getSimpleName ( ) ;
private static final String MESSAGE = " ;
private String serverMessage ;
private JSONObject responseJson ;
public MessageServerResponse ( boolean success , String responseString ) {
super ( success , responseString ) ;
if ( ! wasSuccesful ( ) || getResponseString ( ) == null || getResponseString ( ) . length ( ) == <num> )
return ;
try {
responseJson = new JSONObject ( getResponseString ( ) ) ;
} catch ( Exception e ) {
this . success = false ;
return ;
}
try {
this . serverMessage = responseJson . getString ( MESSAGE ) ;
} catch ( JSONException e ) {
Log . e ( TAG , " + e ) ;
e . printStackTrace ( ) ;
}
}
public String getServerMessage ( ) {
return serverMessage ;
}
public JSONObject getJson ( ) {
return responseJson ;
}
}
package fi . iki . murgo . irssinotifier ;
public class CryptoException extends Exception {
private static final long serialVersionUID =  <num> ;
public CryptoException ( String msg , Exception innerException ) {
super ( msg , innerException ) ;
}
}
package fi . iki . murgo . irssinotifier ;
import java . io . IOException ;
import android . accounts . Account ;
import android . accounts . AccountManager ;
import android . accounts . AccountManagerFuture ;
import android . accounts . AuthenticatorException ;
import android . accounts . OperationCanceledException ;
import android . app . Activity ;
import android . content . Context ;
import android . os . Bundle ;
public class UserHelper {
public Account [ ] getAccounts ( Context context )
{
AccountManager manager = AccountManager . get ( context ) ;
Account [ ] accounts = manager . getAccountsByType ( " ) ;
return accounts ;
}
public String getAuthToken ( Activity activity , Account account ) throws OperationCanceledException , AuthenticatorException , IOException {
AccountManager manager = AccountManager . get ( activity ) ;
String token = buildToken ( manager , account , activity ) ;
manager . <unk> ( account . type , token ) ;
return buildToken ( manager , account , activity ) ;
}
private String buildToken ( AccountManager manager , Account account , Activity activity ) throws OperationCanceledException , AuthenticatorException , IOException {
AccountManagerFuture < Bundle > future = manager . getAuthToken ( account , " , null , activity , null , null ) ;
Bundle token = future . getResult ( ) ;
return token . get ( AccountManager . KEY_AUTHTOKEN ) . toString ( ) ;
}
}
package fi . iki . murgo . irssinotifier ;
import java . util . HashMap ;
import org . apache . http . auth . AuthenticationException ;
import org . json . JSONArray ;
import org . json . JSONObject ;
import fi . iki . murgo . irssinotifier . Server . ServerTarget ;
import android . os . AsyncTask ;
import android . util . Log ;
public class DataFetcherTask extends AsyncTask < Void , Void , DataFetchResult > {
private static final String TAG = DataFetcherTask . class . getSimpleName ( ) ;
private final String authToken ;
private final Callback < DataFetchResult > callback ;
private final String encryptionKey ;
private final long lastFetchTime ;
public DataFetcherTask ( String authToken , String encryptionKey , long lastFetchTime , Callback < DataFetchResult > callback ) {
this . authToken = authToken ;
this . lastFetchTime = lastFetchTime ;
this . callback = callback ;
this . encryptionKey = encryptionKey ;
}
@Override
protected DataFetchResult doInBackground ( Void . . . params ) {
DataFetchResult result = new DataFetchResult ( ) ;
try {
Server server = new Server ( ) ;
boolean authenticated = server . authenticate ( authToken ) ;
if ( ! authenticated ) {
throw new AuthenticationException ( ) ;
}
HashMap < String , String > map = new HashMap < String , String > ( ) ;
map . put ( " , Long . toString ( lastFetchTime / <num> ) ) ;
MessageServerResponse response = ( MessageServerResponse ) server . get ( new MessageToServer ( map ) , ServerTarget . Message ) ;
result . setResponse ( response ) ;
if ( ! response . wasSuccesful ( ) ) {
throw new ServerException ( ) ;
}
Log . d ( TAG , response . getResponseString ( ) ) ;
JSONArray arr = response . getJson ( ) . getJSONArray ( " ) ;
if ( arr . length ( ) == <num> )
return result ;
for ( int i = <num> ; i < arr . length ( ) ; i ++ ) {
JSONObject object = new JSONObject ( arr . getString ( i ) ) ;
IrcMessage message = new IrcMessage ( ) ;
message . Deserialize ( object ) ;
message . Decrypt ( encryptionKey ) ;
result . getMessages ( ) . add ( message ) ;
}
} catch ( Exception e ) {
e . printStackTrace ( ) ;
result . setException ( e ) ;
}
return result ;
}
@Override
protected void onPostExecute ( DataFetchResult result ) {
if ( callback != null ) {
callback . doStuff ( result ) ;
}
}
}
package fi . iki . murgo . irssinotifier ;
import android . app . Activity ;
import android . util . Log ;
public class C2DMRegistrationTask extends BackgroundAsyncTask < Void , Void , String [ ] > {
private static final String TAG = InitialSettingsActivity . class . getSimpleName ( ) ;
public C2DMRegistrationTask ( Activity activity , String titleText , String text ) {
super ( activity , titleText , text ) ;
}
@Override
protected String [ ] doInBackground ( Void . . . params ) {
Log . d ( TAG , " ) ;
C2DMReceiver . setRegistrationCallback ( getCallback ( ) ) ;
C2DMReceiver . registerToC2DM ( activity ) ;
return null ;
}
@Override
protected void onPostExecute ( String [ ] result ) {
}
}
package fi . iki . murgo . irssinotifier ;
import java . util . Date ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
import org . apache . http . auth . AuthenticationException ;
import com . google . android . apps . analytics . GoogleAnalyticsTracker ;
import android . app . Activity ;
import android . content . Context ;
import android . content . Intent ;
import android . content . pm . PackageManager . NameNotFoundException ;
import android . os . Bundle ;
import android . support . v4 . view . ViewPager ;
import android . util . Log ;
import android . view . Menu ;
import android . view . MenuInflater ;
import android . view . MenuItem ;
import android . view . View ;
import android . widget . ProgressBar ;
public class IrssiNotifierActivity extends Activity {
private static final String TAG = IrssiNotifierActivity . class . getSimpleName ( ) ;
private Preferences preferences ;
private GoogleAnalyticsTracker tracker ;
private final String googleAnalyticsCode = " ;
private MessagePagerAdapter adapter ;
private ViewPager pager ;
@Override
public void onCreate ( Bundle savedInstanceState ) {
Log . i ( TAG , " ) ;
super . onCreate ( savedInstanceState ) ;
tracker = GoogleAnalyticsTracker . getInstance ( ) ;
tracker . startNewSession ( googleAnalyticsCode , this ) ;
try {
MessageToServer . setVersion ( getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , <num> ) . versionCode ) ;
} catch ( NameNotFoundException e ) {
e . printStackTrace ( ) ;
}
preferences = new Preferences ( this ) ;
if ( preferences . getAuthToken ( ) == null || preferences . getRegistrationId ( ) == null ) {
Log . d ( TAG , " ) ;
preferences . clear ( ) ;
Intent i = new Intent ( IrssiNotifierActivity . this , InitialSettingsActivity . class ) ;
startActivity ( i ) ;
tracker . dispatch ( ) ;
finish ( ) ;
return ;
}
startMainApp ( ) ;
}
@Override
protected void onDestroy ( ) {
super . onDestroy ( ) ;
tracker . stopSession ( ) ;
}
private void startMainApp ( ) {
Log . d ( TAG , " ) ;
createUi ( new HashMap < Channel , List < IrcMessage >> ( ) ) ;
if ( preferences . settingsNeedSending ( ) ) {
Log . d ( TAG , " ) ;
sendSettings ( ) ;
}
final Activity ctx = this ;
final Callback < Map < Channel , List < IrcMessage >>> dataAccessCallback = new Callback < Map < Channel , List < IrcMessage >>> ( ) {
public void doStuff ( Map < Channel , List < IrcMessage >> param ) {
setProgressBarVisibility ( View . GONE ) ;
createUi ( param ) ;
}
} ;
final long now = new Date ( ) . getTime ( ) ;
DataFetcherTask task = new DataFetcherTask ( preferences . getAuthToken ( ) , preferences . getEncryptionPassword ( ) , preferences . getLastFetchTime ( ) , new Callback < DataFetchResult > ( ) {
public void doStuff ( DataFetchResult param ) {
if ( param . getException ( ) != null ) {
if ( param . getException ( ) instanceof AuthenticationException ) {
MessageBox . Show ( ctx , " , " , null ) ;
} else if ( param . getException ( ) instanceof ServerException ) {
MessageBox . Show ( ctx , " , " , null ) ;
} else {
MessageBox . Show ( ctx , " , " , null ) ;
}
return ;
}
preferences . setLastFetchTime ( now ) ;
if ( param . getResponse ( ) . getServerMessage ( ) != null && param . getResponse ( ) . getServerMessage ( ) . length ( ) > <num> ) {
MessageBox . Show ( ctx , null , param . getResponse ( ) . getServerMessage ( ) , null ) ;
}
if ( param . getMessages ( ) . isEmpty ( ) ) {
setProgressBarVisibility ( View . GONE ) ;
return ;
}
DataAccessTask task = new DataAccessTask ( ctx , dataAccessCallback ) ;
task . execute ( param . getMessages ( ) . toArray ( new IrcMessage [ <num> ] ) ) ;
}
} ) ;
setProgressBarVisibility ( View . VISIBLE ) ;
task . execute ( ) ;
tracker . dispatch ( ) ;
DataAccessTask datask = new DataAccessTask ( ctx , dataAccessCallback ) ;
datask . execute ( ) ;
}
private void setProgressBarVisibility ( int visibility ) {
ProgressBar pb = ( ProgressBar ) findViewById ( R . id . progressBar1 ) ;
if ( pb == null )
return ;
pb . setVisibility ( visibility ) ;
}
private void createUi ( Map < Channel , List < IrcMessage >> param ) {
setContentView ( R . layout . main ) ;
if ( adapter == null )
adapter = new MessagePagerAdapter ( this , getLayoutInflater ( ) ) ;
adapter . setIrcMessages ( param ) ;
pager = ( ViewPager ) findViewById ( R . id . pager ) ;
pager . setAdapter ( adapter ) ;
}
private void sendSettings ( ) {
SettingsSendingTask task = new SettingsSendingTask ( this , " , " ) ;
final Context ctx = this ;
task . setCallback ( new Callback < ServerResponse > ( ) {
public void doStuff ( ServerResponse result ) {
if ( result == null || ! result . wasSuccesful ( ) ) {
MessageBox . Show ( ctx , null , " , new Callback < Void > ( ) {
public void doStuff ( Void param ) {
finish ( ) ;
}
} ) ;
}
}
} ) ;
task . execute ( ) ;
}
@Override
public boolean onCreateOptionsMenu ( Menu menu ) {
MenuInflater inflater = getMenuInflater ( ) ;
inflater . inflate ( R . menu . mainmenu , menu ) ;
return super . onCreateOptionsMenu ( menu ) ;
}
@Override
public boolean onOptionsItemSelected ( MenuItem item ) {
if ( item . getItemId ( ) == R . id . settings ) {
Intent settingsActivity = new Intent ( getBaseContext ( ) , SettingsActivity . class ) ;
startActivity ( settingsActivity ) ;
return true ;
}
return super . onOptionsItemSelected ( item ) ;
}
}
package fi . iki . murgo . irssinotifier ;
import android . app . Activity ;
import android . app . ProgressDialog ;
import android . os . AsyncTask ;
public abstract class BackgroundAsyncTask < A , B , C > extends AsyncTask < A , B , C > {
private ProgressDialog dialog ;
protected final Activity activity ;
private final String titleText ;
private final String text ;
private Callback < C > callback ;
public BackgroundAsyncTask ( Activity activity , String titleText , String text ) {
this . activity = activity ;
this . titleText = titleText ;
this . text = text ;
}
@Override
protected void onPreExecute ( ) {
if ( dialog == null )
setDialog ( ProgressDialog . show ( activity , titleText , text , true ) ) ;
}
@Override
protected void onPostExecute ( C result ) {
getDialog ( ) . dismiss ( ) ;
if ( callback != null ) {
callback . doStuff ( result ) ;
}
}
public Callback < C > getCallback ( ) {
return callback ;
}
public void setCallback ( Callback < C > callback ) {
this . callback = callback ;
}
public ProgressDialog getDialog ( ) {
return dialog ;
}
public void setDialog ( ProgressDialog dialog ) {
this . dialog = dialog ;
} ;
}
package fi . iki . murgo . irssinotifier ;
package fi . iki . murgo . irssinotifier ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Map ;
import java . util . Map . Entry ;
import android . content . Context ;
import android . graphics . Typeface ;
import android . os . Parcelable ;
import android . support . v4 . view . PagerAdapter ;
import android . support . v4 . view . ViewPager ;
import android . view . LayoutInflater ;
import android . view . View ;
import android . widget . LinearLayout ;
import android . widget . TextView ;
public class MessagePagerAdapter extends PagerAdapter {
private Context ctx ;
private List < Entry < Channel , List < IrcMessage >>> ircMessages ;
private final LayoutInflater layoutInflater ;
public MessagePagerAdapter ( Context ctx , LayoutInflater layoutInflater ) {
super ( ) ;
this . ctx = ctx ;
this . layoutInflater = layoutInflater ;
}
@Override
public int getCount ( ) {
if ( ircMessages == null )
return <num> ;
return ircMessages . size ( ) ;
}
@Override
public Object instantiateItem ( View collection , int position ) {
Channel channel = ircMessages . get ( position ) . getKey ( ) ;
List < IrcMessage > messages = ircMessages . get ( position ) . getValue ( ) ;
View channelView = layoutInflater . inflate ( R . layout . channel , null ) ;
TextView name = ( TextView ) channelView . findViewById ( R . id . <unk> ) ;
name . setText ( channel . getName ( ) ) ;
LinearLayout messageContainer = ( LinearLayout ) channelView . findViewById ( R . id . <unk> ) ;
for ( IrcMessage message : messages ) {
TextView tv = new TextView ( ctx ) ;
tv . setText ( message . getServerTimestampAsString ( ) + " + message . getNick ( ) + " + message . getMessage ( ) ) ;
tv . setTypeface ( Typeface . MONOSPACE ) ;
messageContainer . addView ( tv ) ;
}
( ( ViewPager ) collection ) . addView ( channelView ) ;
return channelView ;
}
@Override
public void destroyItem ( View collection , int position , Object view ) {
( ( ViewPager ) collection ) . removeView ( ( LinearLayout ) view ) ;
}
@Override
public boolean isViewFromObject ( View view , Object object ) {
return view == ( ( LinearLayout ) object ) ;
}
@Override
public void finishUpdate ( View arg0 ) {
}
@Override
public void restoreState ( Parcelable arg0 , ClassLoader arg1 ) {
}
@Override
public Parcelable saveState ( ) {
return null ;
}
public void setIrcMessages ( Map < Channel , List < IrcMessage >> ircMessages ) {
this . ircMessages = new ArrayList < Map . Entry < Channel , List < IrcMessage >>> ( ) ;
for ( Entry < Channel , List < IrcMessage >> entry : ircMessages . entrySet ( ) ) {
this . ircMessages . add ( entry ) ;
}
}
}
package fi . iki . murgo . irssinotifier ;
public class Channel {
private long id ;
private String name ;
public long getId ( ) {
return id ;
}
public void setId ( long id ) {
this . id = id ;
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
}
package fi . iki . murgo . irssinotifier . test ;
import fi . iki . murgo . irssinotifier . Crypto ;
import fi . iki . murgo . irssinotifier . IrssiNotifierActivity ;
import android . test . ActivityInstrumentationTestCase2 ;
import android . util . Log ;
public class CryptoTests extends ActivityInstrumentationTestCase2 < IrssiNotifierActivity > {
public CryptoTests ( ) {
super ( " , IrssiNotifierActivity . class ) ;
}
public void <unk> ( ) {
String decrypted = null ;
try {
decrypted = Crypto . decrypt ( " , " ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
assertNotNull ( " + e . getMessage ( ) + Log . getStackTraceString ( e ) ) ;
}
assertEquals ( " , decrypted ) ;
}
}
package fi . iki . murgo . irssinotifier ;
import java . util . ArrayList ;
import java . util . List ;
import android . content . ContentValues ;
import android . content . Context ;
import android . database . Cursor ;
import android . database . sqlite . SQLiteDatabase ;
import android . database . sqlite . SQLiteOpenHelper ;
public class DataAccess extends SQLiteOpenHelper {
private static final String DATABASE_NAME = " ;
private static final int DATABASE_VERSION = <num> ;
public DataAccess ( Context context ) {
super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ;
}
@Override
public void onCreate ( SQLiteDatabase db ) {
db . execSQL ( " ) ;
db . execSQL ( " ) ;
}
@Override
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) {
}
public void HandleMessage ( IrcMessage message ) {
try {
SQLiteDatabase database = getWritableDatabase ( ) ;
Cursor cur = database . query ( " , new String [ ] { " } , " , new String [ ] { message . getExternalId ( ) } , null , null , null , " ) ;
if ( ! cur . isAfterLast ( ) ) {
cur . close ( ) ;
database . close ( ) ;
return ;
}
String channelName = message . getLogicalChannel ( ) ;
long channelId = <num> ;
Cursor cursor = database . query ( " , new String [ ] { " } , " , new String [ ] { channelName } , null , null , null , " ) ;
cursor . moveToFirst ( ) ;
if ( ! cursor . isAfterLast ( ) ) {
channelId = cursor . getInt ( cursor . getColumnIndex ( " ) ) ;
}
cursor . close ( ) ;
if ( channelId == <num> ) {
ContentValues values = new ContentValues ( ) ;
values . put ( " , channelName ) ;
channelId = database . insert ( " , null , values ) ;
}
ContentValues messageValues = new ContentValues ( ) ;
messageValues . put ( " , channelId ) ;
messageValues . put ( " , message . getMessage ( ) ) ;
messageValues . put ( " , message . getNick ( ) ) ;
messageValues . put ( " , message . getServerTimestamp ( ) . getTime ( ) ) ;
messageValues . put ( " , message . getTimestamp ( ) ) ;
messageValues . put ( " , message . getExternalId ( ) ) ;
database . insert ( " , null , messageValues ) ;
database . close ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
public void <unk> ( Channel channel ) {
SQLiteDatabase database = getWritableDatabase ( ) ;
database . delete ( " , " , new String [ ] { Long . toString ( channel . getId ( ) ) } ) ;
database . close ( ) ;
}
public void clearAll ( ) {
SQLiteDatabase database = getWritableDatabase ( ) ;
database . delete ( " , null , null ) ;
database . delete ( " , null , null ) ;
database . close ( ) ;
}
public List < Channel > getChannels ( ) {
SQLiteDatabase database = getReadableDatabase ( ) ;
Cursor cursor = database . query ( " , new String [ ] { " , " } , null , null , null , null , null ) ;
cursor . moveToFirst ( ) ;
List < Channel > list = new ArrayList < Channel > ( ) ;
while ( ! cursor . isAfterLast ( ) ) {
Channel ch = new Channel ( ) ;
ch . setId ( cursor . getLong ( cursor . getColumnIndex ( " ) ) ) ;
ch . setName ( cursor . getString ( cursor . getColumnIndex ( " ) ) ) ;
list . add ( ch ) ;
cursor . moveToNext ( ) ;
}
cursor . close ( ) ;
database . close ( ) ;
return list ;
}
public List < IrcMessage > getMessagesForChannel ( Channel channel ) {
SQLiteDatabase database = getReadableDatabase ( ) ;
Cursor cursor = database . query ( " , new String [ ] { " , " , " , " , " } , " , new String [ ] { Long . toString ( channel . getId ( ) ) } , null , null , null ) ;
cursor . moveToFirst ( ) ;
List < IrcMessage > list = new ArrayList < IrcMessage > ( ) ;
int colMessage = cursor . getColumnIndex ( " ) ;
int colNick = cursor . getColumnIndex ( " ) ;
int colServerTimestamp = cursor . getColumnIndex ( " ) ;
int colTimestamp = cursor . getColumnIndex ( " ) ;
int colExternalId = cursor . getColumnIndex ( " ) ;
while ( ! cursor . isAfterLast ( ) ) {
IrcMessage message = new IrcMessage ( ) ;
message . setMessage ( cursor . getString ( colMessage ) ) ;
message . setNick ( cursor . getString ( colNick ) ) ;
message . setServerTimestamp ( cursor . getLong ( colServerTimestamp ) ) ;
message . setTimestamp ( cursor . getString ( colTimestamp ) ) ;
message . setExternalId ( cursor . getString ( colExternalId ) ) ;
message . setChannel ( channel . getName ( ) ) ;
list . add ( message ) ;
cursor . moveToNext ( ) ;
}
cursor . close ( ) ;
database . close ( ) ;
return list ;
}
}
package fi . iki . murgo . irssinotifier ;
import android . accounts . Account ;
import android . app . Activity ;
import android . util . Log ;
public class TokenGenerationTask extends BackgroundAsyncTask < Account , Void , String > {
private static final String TAG = TokenGenerationTask . class . getSimpleName ( ) ;
public TokenGenerationTask ( Activity activity , String titleText ,
String text ) {
super ( activity , titleText , text ) ;
}
@Override
protected String doInBackground ( Account . . . params ) {
try {
UserHelper uf = new UserHelper ( ) ;
String token = uf . getAuthToken ( activity , params [ <num> ] ) ;
Preferences prefs = new Preferences ( activity ) ;
prefs . setAuthToken ( token ) ;
return token ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
Log . e ( TAG , " + e . toString ( ) ) ;
return null ;
}
}
}
package fi . iki . murgo . irssinotifier ;
public class ServerException extends Exception {
private static final long serialVersionUID =  <num> ;
}
package fi . iki . murgo . irssinotifier ;
public enum NotificationMode {
Single ,
PerMessage ,
PerChannel ,
}
package fi . iki . murgo . irssinotifier ;
public class ServerResponse {
protected boolean success ;
private final String responseString ;
public ServerResponse ( boolean success , String responseString ) {
this . success = success ;
this . responseString = responseString ;
}
public boolean wasSuccesful ( ) {
return success ;
}
public String getResponseString ( ) {
return responseString ;
}
package fi . iki . murgo . irssinotifier ;
import android . content . Context ;
import android . os . Bundle ;
import android . preference . ListPreference ;
import android . preference . Preference ;
import android . preference . Preference . OnPreferenceChangeListener ;
import android . preference . Preference . OnPreferenceClickListener ;
import android . preference . PreferenceActivity ;
import android . util . Log ;
public class SettingsActivity extends PreferenceActivity {
private static final String TAG = SettingsActivity . class . getSimpleName ( ) ;
@Override
protected void onCreate ( Bundle savedInstanceState ) {
Log . d ( TAG , " ) ;
super . onCreate ( savedInstanceState ) ;
addPreferencesFromResource ( R . xml . <unk> ) ;
final Context ctx = this ;
Preference clearPref = ( Preference ) findPreference ( " ) ;
clearPref . setOnPreferenceClickListener ( new OnPreferenceClickListener ( ) {
public boolean onPreferenceClick ( Preference preference ) {
Preferences p = new Preferences ( ctx ) ;
p . clear ( ) ;
finish ( ) ;
return true ;
}
} ) ;
ListPreference mode = ( ListPreference ) findPreference ( " ) ;
mode . setOnPreferenceChangeListener ( new OnPreferenceChangeListener ( ) {
public boolean onPreferenceChange ( Preference preference , Object newValue ) {
NotificationMode m = NotificationMode . PerChannel ;
String v = ( String ) newValue ;
if ( v . equals ( ctx . getResources ( ) . getStringArray ( R . array . notification_modes ) [ <num> ] ) )
m = NotificationMode . Single ;
if ( v . equals ( ctx . getResources ( ) . getStringArray ( R . array . notification_modes ) [ <num> ] ) )
m = NotificationMode . PerChannel ;
if ( v . equals ( ctx . getResources ( ) . getStringArray ( R . array . notification_modes ) [ <num> ] ) )
m = NotificationMode . PerMessage ;
Preferences p = new Preferences ( ctx ) ;
p . setNotificationMode ( m ) ;
return true ;
}
} ) ;
}
}
package fi . iki . murgo . irssinotifier ;
import javax . crypto . Cipher ;
import javax . crypto . SecretKeyFactory ;
import javax . crypto . spec . PBEKeySpec ;
import android . util . Base64 ;
import android . util . Log ;
public class Crypto {
private static final String TAG = Crypto . class . getSimpleName ( ) ;
public static String decrypt ( String key , String payload ) throws CryptoException {
try {
byte [ ] payloadBytes = Base64 . decode ( payload , Base64 . <unk> ) ;
Cipher c = Cipher . getInstance ( " , " ) ;
byte [ ] salt = new byte [ <num> ] ;
System . arraycopy ( payloadBytes , <num> , salt , <num> , <num> ) ;
SecretKeyFactory fact = SecretKeyFactory . getInstance ( " , " ) ;
c . init ( Cipher . DECRYPT_MODE , fact . generateSecret ( new PBEKeySpec ( key . toCharArray ( ) , salt , <num> ) ) ) ;
byte [ ] data = c . doFinal ( payloadBytes , <num> , payloadBytes . length  <num> ) ;
String decrypted = new String ( data , " ) ;
return decrypted . substring ( <num> , decrypted . length ( )  <num> ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
Log . e ( TAG , " , e ) ;
throw new CryptoException ( " , e ) ;
}
}
}
package fi . iki . murgo . irssinotifier ;
import java . util . ArrayList ;
import java . util . List ;
public class DataFetchResult {
private Exception exception ;
private List < IrcMessage > messages ;
private MessageServerResponse response ;
public DataFetchResult ( ) {
messages = new ArrayList < IrcMessage > ( ) ;
}
public Exception getException ( ) {
return exception ;
}
public void setException ( Exception exception ) {
this . exception = exception ;
}
public List < IrcMessage > getMessages ( ) {
return messages ;
}
public void setMessages ( List < IrcMessage > messages ) {
this . messages = messages ;
}
public MessageServerResponse getResponse ( ) {
return response ;
}
public void setResponse ( MessageServerResponse response ) {
this . response = response ;
}
}
package fi . iki . murgo . irssinotifier ;
import android . app . AlertDialog ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . content . DialogInterface . OnClickListener ;
import android . content . DialogInterface . OnDismissListener ;
import android . text . SpannableString ;
import android . text . method . LinkMovementMethod ;
import android . text . util . Linkify ;
import android . widget . TextView ;
public class MessageBox {
public static void Show ( Context context , String title , String contents , final Callback < Void > callback ) {
Show ( context , title , contents , callback , false ) ;
}
public static void Show ( Context context , String title , String contents , final Callback < Void > callback , boolean linkify ) {
CharSequence msg = contents ;
if ( linkify ) {
final SpannableString s = new SpannableString ( contents ) ;
Linkify . addLinks ( s , Linkify . ALL ) ;
msg = s ;
}
AlertDialog dialog = new AlertDialog . Builder ( context ) . setMessage ( msg ) . setTitle ( title ) . setNeutralButton ( " , new OnClickListener ( ) {
public void onClick ( DialogInterface dialog , int which ) {
dialog . dismiss ( ) ;
}
} ) . create ( ) ;
dialog . setOnDismissListener ( new OnDismissListener ( ) {
public void onDismiss ( DialogInterface dialog ) {
if ( callback != null )
callback . doStuff ( null ) ;
}
} ) ;
dialog . show ( ) ;
if ( linkify ) {
( ( TextView ) dialog . findViewById ( android . R . id . message ) ) . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ;
}
}
}
package fi . iki . murgo . irssinotifier ;
import java . text . SimpleDateFormat ;
import java . util . Date ;
import org . json . JSONException ;
import org . json . JSONObject ;
public class IrcMessage {
public static final String PRIVATE = " ;
private String message ;
private String channel ;
private String nick ;
private String timestamp ;
private Date serverTimestamp ;
private String externalId ;
public void Deserialize ( String payload ) throws JSONException {
Deserialize ( new JSONObject ( payload ) ) ;
}
public void Deserialize ( JSONObject obj ) {
try {
setMessage ( obj . getString ( " ) ) ;
setChannel ( obj . getString ( " ) ) ;
setNick ( obj . getString ( " ) ) ;
setTimestamp ( obj . getString ( " ) ) ;
setServerTimestamp ( ( long ) ( Double . parseDouble ( obj . getString ( " ) ) * <num> ) ) ;
setExternalId ( obj . getString ( " ) ) ;
} catch ( JSONException e ) {
e . printStackTrace ( ) ;
}
}
public String getMessage ( ) {
return message ;
}
public void setMessage ( String message ) {
this . message = message ;
}
public String getChannel ( ) {
return channel ;
}
public void setChannel ( String channel ) {
this . channel = channel ;
}
public String getNick ( ) {
return nick ;
}
public void setNick ( String sender ) {
this . nick = sender ;
}
public String getTimestamp ( ) {
return timestamp ;
}
public void setTimestamp ( String timestamp ) {
this . timestamp = timestamp ;
}
public Date getServerTimestamp ( ) {
return serverTimestamp ;
}
public void setServerTimestamp ( long serverTimestamp ) {
this . serverTimestamp = new Date ( serverTimestamp ) ;
}
public String getServerTimestampAsString ( ) {
SimpleDateFormat dateFormat = new SimpleDateFormat ( " ) ;
return dateFormat . format ( serverTimestamp ) ;
}
public void Decrypt ( String encryptionKey ) throws CryptoException {
message = Crypto . decrypt ( encryptionKey , message ) ;
channel = Crypto . decrypt ( encryptionKey , channel ) ;
nick = Crypto . decrypt ( encryptionKey , nick ) ;
message = message . replace ( ' , \'' ) ;
channel = channel . replace ( ' , \'' ) ;
nick = nick . replace ( ' , \'' ) ;
}
public boolean isPrivate ( ) {
return channel . equals ( PRIVATE ) ;
}
public String getLogicalChannel ( ) {
return isPrivate ( ) ? getNick ( ) : getChannel ( ) ;
}
public void setExternalId ( String externalId ) {
this . externalId = externalId ;
}
public String getExternalId ( ) {
return externalId ;
}
}
package fi . iki . murgo . irssinotifier ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
import java . util . Map . Entry ;
import org . apache . http . HttpResponse ;
import org . apache . http . NameValuePair ;
import org . apache . http . client . ClientProtocolException ;
import org . apache . http . client . methods . HttpGet ;
import org . apache . http . client . methods . HttpPost ;
import org . apache . http . client . params . ClientPNames ;
import org . apache . http . client . utils . URLEncodedUtils ;
import org . apache . http . cookie . Cookie ;
import org . apache . http . entity . StringEntity ;
import org . apache . http . impl . client . DefaultHttpClient ;
import org . apache . http . message . BasicNameValuePair ;
import org . apache . http . params . BasicHttpParams ;
import org . apache . http . params . HttpParams ;
import org . apache . http . util . EntityUtils ;
public class Server {
public enum ServerTarget {
SaveSettings ,
Test ,
<unk> ,
Authenticate ,
Message ,
}
private Map < ServerTarget , String > serverUrls = new HashMap < ServerTarget , String > ( ) ;
private static final String SERVER_BASE_URL = " ;
private DefaultHttpClient http_client = new DefaultHttpClient ( ) ;
public Server ( ) {
serverUrls . put ( ServerTarget . SaveSettings , SERVER_BASE_URL + " ) ;
serverUrls . put ( ServerTarget . Message , SERVER_BASE_URL + " ) ;
serverUrls . put ( ServerTarget . Authenticate , " ) ;
}
public boolean authenticate ( String token ) {
for ( Cookie c : http_client . getCookieStore ( ) . getCookies ( ) )
if ( c . getName ( ) . equals ( " ) )
return true ;
try {
http_client . getParams ( ) . setBooleanParameter ( ClientPNames . HANDLE_REDIRECTS , false ) ;
HttpGet http_get = new HttpGet ( serverUrls . get ( ServerTarget . Authenticate ) + token ) ;
HttpResponse response ;
response = http_client . execute ( http_get ) ;
if ( response . getStatusLine ( ) . getStatusCode ( ) != <num> )
return false ;
for ( Cookie cookie : http_client . getCookieStore ( ) . getCookies ( ) ) {
if ( cookie . getName ( ) . equals ( " ) )
return true ;
}
} catch ( ClientProtocolException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
} finally {
if ( http_client != null )
http_client . getParams ( ) . setBooleanParameter ( ClientPNames . HANDLE_REDIRECTS , true ) ;
}
return false ;
}
public ServerResponse send ( MessageToServer message , ServerTarget target ) throws IOException {
HttpPost httpPost = new HttpPost ( serverUrls . get ( target ) ) ;
HttpParams params = new BasicHttpParams ( ) ;
Map < String , String > map = message . getMap ( ) ;
for ( Map . Entry < String , String > entry : map . entrySet ( ) ) {
params . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ;
}
httpPost . setParams ( params ) ;
httpPost . setEntity ( new StringEntity ( message . getHttpString ( ) ) ) ;
HttpResponse response = http_client . execute ( httpPost ) ;
int statusCode = response . getStatusLine ( ) . getStatusCode ( ) ;
String responseString = EntityUtils . toString ( response . getEntity ( ) ) ;
ServerResponse serverResponse ;
serverResponse = new ServerResponse ( statusCode == <num> , responseString ) ;
return serverResponse ;
}
public ServerResponse get ( MessageToServer message , ServerTarget target ) throws IOException {
String url = serverUrls . get ( target ) ;
url = buildUrlWithParameters ( url , message . getMap ( ) ) ;
HttpGet httpGet = new HttpGet ( url ) ;
HttpResponse response = http_client . execute ( httpGet ) ;
int statusCode = response . getStatusLine ( ) . getStatusCode ( ) ;
String responseString = EntityUtils . toString ( response . getEntity ( ) ) ;
ServerResponse serverResponse ;
if ( target == ServerTarget . Message )
serverResponse = new MessageServerResponse ( statusCode == <num> , responseString ) ;
else
serverResponse = new ServerResponse ( statusCode == <num> , responseString ) ;
return serverResponse ;
}
private static String buildUrlWithParameters ( String url , Map < String , String > parameters ) {
if ( ! url . endsWith ( " ) )
url += " ;
List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ;
for ( Entry < String , String > entry : parameters . entrySet ( ) ) {
params . add ( new BasicNameValuePair ( entry . getKey ( ) , entry . getValue ( ) ) ) ;
}
String paramString = URLEncodedUtils . format ( params , " ) ;
url += paramString ;
return url ;
}
}
package com . mycompany . mywebapp . shared ;
public class FieldVerifier {
public static boolean isValidName ( String name ) {
if ( name == null ) {
return false ;
}
return name . length ( ) > <num> ;
}
}
package com . mycompany . mywebapp . client ;
import com . mycompany . mywebapp . shared . FieldVerifier ;
import com . google . gwt . core . client . EntryPoint ;
import com . google . gwt . core . client . GWT ;
import com . google . gwt . event . dom . client . ClickEvent ;
import com . google . gwt . event . dom . client . ClickHandler ;
import com . google . gwt . event . dom . client . KeyCodes ;
import com . google . gwt . event . dom . client . KeyUpEvent ;
import com . google . gwt . event . dom . client . KeyUpHandler ;
import com . google . gwt . user . client . rpc . AsyncCallback ;
import com . google . gwt . user . client . ui . Button ;
import com . google . gwt . user . client . ui . DialogBox ;
import com . google . gwt . user . client . ui . HTML ;
import com . google . gwt . user . client . ui . Label ;
import com . google . gwt . user . client . ui . RootPanel ;
import com . google . gwt . user . client . ui . TextBox ;
import com . google . gwt . user . client . ui . VerticalPanel ;
import com . google . gwt . jsonp . client . JsonpRequestBuilder ;
import com . google . gwt . json . client . JSONObject ;
import com . google . gwt . json . client . * ;
import com . google . gwt . core . client . JavaScriptObject ;
import com . google . gwt . user . client . ui . DockLayoutPanel ;
import com . google . gwt . user . client . ui . RootLayoutPanel ;
import com . google . gwt . dom . client . Style . Unit ;
public class <unk> implements EntryPoint {
final TextBox queryField = new TextBox ( ) ;
final VerticalPanel resultsPanel = new VerticalPanel ( ) ;
public void onModuleLoad ( ) {
Label header = new Label ( " ) ;
header . addStyleName ( " ) ;
VerticalPanel panel = new VerticalPanel ( ) ;
panel . addStyleName ( " ) ;
queryField . setText ( " ) ;
panel . add ( queryField ) ;
final Button searchButton = new Button ( " ) ;
panel . add ( searchButton ) ;
final Label errorLabel = new Label ( ) ;
panel . add ( errorLabel ) ;
panel . add ( resultsPanel ) ;
RootPanel . get ( " ) . add ( header ) ;
RootPanel . get ( " ) . add ( panel ) ;
searchButton . addClickHandler ( new TwitterHandler ( ) ) ;
}
class TwitterHandler implements ClickHandler {
public void onClick ( ClickEvent event ) {
String url = " + queryField . getText ( ) ;
JsonpRequestBuilder jsonp = new JsonpRequestBuilder ( ) ;
jsonp . requestObject ( url , new AsyncCallback < JavaScriptObject > ( ) {
public void onFailure ( Throwable throwable ) {
System . out . println ( " + throwable ) ;
}
public void onSuccess ( JavaScriptObject o ) {
JSONObject js = new JSONObject ( o ) ;
JSONArray results = js . get ( " ) . isArray ( ) ;
resultsPanel . clear ( ) ;
for ( int i = <num> ; i < results . size ( ) ; i ++ ) {
String text = ( results . get ( i ) . isObject ( ) ) . get ( " ) . toString ( ) ;
Label label = new Label ( text ) ;
label . addStyleName ( " ) ;
resultsPanel . add ( label ) ;
}
}
} ) ;
}
} ;
public static void p ( String s ) {
System . out . println ( s ) ;
}
package com . mycompany . mywebapp . client ;
import com . google . gwt . user . client . rpc . RemoteService ;
import com . google . gwt . user . client . rpc . RemoteServiceRelativePath ;
@RemoteServiceRelativePath("greet")
public interface GreetingService extends RemoteService {
String greetServer ( String name ) throws IllegalArgumentException ;
}
package com . mycompany . mywebapp . server ;
import com . mycompany . mywebapp . client . GreetingService ;
import com . mycompany . mywebapp . shared . FieldVerifier ;
import com . google . gwt . user . server . rpc . RemoteServiceServlet ;
@SuppressWarnings("serial")
public class GreetingServiceImpl extends RemoteServiceServlet implements
GreetingService {
public String greetServer ( String input ) throws IllegalArgumentException {
if ( ! FieldVerifier . isValidName ( input ) ) {
throw new IllegalArgumentException (
" ) ;
}
String serverInfo = getServletContext ( ) . getServerInfo ( ) ;
String userAgent = getThreadLocalRequest ( ) . getHeader ( " ) ;
input = escapeHtml ( input ) ;
userAgent = escapeHtml ( userAgent ) ;
return " + input + " + serverInfo
+ " + userAgent ;
}
private String escapeHtml ( String html ) {
if ( html == null ) {
return null ;
}
return html . replaceAll ( " , " ) . replaceAll ( " , " ) . replaceAll (
" , " ) ;
}
}
package com . mycompany . mywebapp . client ;
import com . google . gwt . user . client . rpc . AsyncCallback ;
public interface GreetingServiceAsync {
void greetServer ( String input , AsyncCallback < String > callback )
throws IllegalArgumentException ;
}
package com . example . jdbcdemo . domain ;
public class Company {
private Long id ;
private String name ;
public Company ( ) {
}
public Company ( String name ) {
super ( ) ;
this . name = name ;
}
public Long getId ( ) {
return id ;
}
public void setId ( Long id ) {
this . id = id ;
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
}
package com . example . jdbcdemo . service ;
import static org . junit . Assert . * ;
import java . util . List ;
import org . junit . Test ;
import com . example . jdbcdemo . domain . Person ;
public class <unk> {
PersonManager personManager = new PersonManager ( ) ;
private final static String NAME_1 = " ;
private final static int YOB_1 = <num> ;
@Test
public void checkConnection ( ) {
assertNotNull ( personManager . getConnection ( ) ) ;
}
@Test
public void checkAdding ( ) {
Person person = new Person ( NAME_1 , YOB_1 ) ;
personManager . clearPersons ( ) ;
assertEquals ( <num> , personManager . addPerson ( person ) ) ;
List < Person > persons = personManager . getAllPersons ( ) ;
Person personRetrieved = persons . get ( <num> ) ;
assertEquals ( NAME_1 , personRetrieved . getName ( ) ) ;
assertEquals ( YOB_1 , personRetrieved . getYob ( ) ) ;
}
}
package com . example . jdbcdemo . service ;
import java . sql . * ;
import java . util . ArrayList ;
import java . util . List ;
import com . example . jdbcdemo . domain . Company ;
import com . example . jdbcdemo . domain . Person ;
public class CompanyManager {
private Connection connection ;
private Statement statement ;
private String url = " ;
private String createTableCompany = " ;
private PreparedStatement addCompanyStmt ;
private PreparedStatement updateCompanyStmt ;
private PreparedStatement deleteAllCompaniesStmt ;
private PreparedStatement getAllCompaniesStmt ;
private PreparedStatement getCompanyWorkersStmt ;
private PreparedStatement getCompanyByNameStmt ;
public CompanyManager ( ) {
try {
connection = DriverManager . getConnection ( url ) ;
statement = connection . createStatement ( ) ;
ResultSet rs = connection . getMetaData ( ) . getTables ( null , null , null ,
null ) ;
boolean tableExists = false ;
while ( rs . next ( ) ) {
if ( " . equalsIgnoreCase ( rs . getString ( " ) ) ) {
tableExists = true ;
break ;
}
}
if ( ! tableExists )
statement . executeUpdate ( createTableCompany ) ;
addCompanyStmt = connection
. prepareStatement ( " ) ;
deleteAllCompaniesStmt = connection
. prepareStatement ( " ) ;
getAllCompaniesStmt = connection
. prepareStatement ( " ) ;
getCompanyWorkersStmt = connection
. prepareStatement ( " ) ;
updateCompanyStmt = connection
. prepareStatement ( " ) ;
getCompanyByNameStmt = connection
. prepareStatement ( " ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
}
Connection getConnection ( ) {
return connection ;
}
public List < Person > getCompanyWorkers ( long company_id ) {
List < Person > persons = new ArrayList < Person > ( ) ;
try {
getCompanyWorkersStmt . setLong ( <num> , company_id ) ;
ResultSet rs = getCompanyWorkersStmt . executeQuery ( ) ;
while ( rs . next ( ) ) {
Person p = new Person ( ) ;
p . setId ( rs . getInt ( " ) ) ;
p . setName ( rs . getString ( " ) ) ;
p . setYob ( rs . getInt ( " ) ) ;
persons . add ( p ) ;
}
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
return persons ;
}
public void addWorkers ( long company_id , List < Person > workers ) throws SQLException {
PersonManager personManager = new PersonManager ( ) ;
try {
connection . setAutoCommit ( false ) ;
for ( Person worker : workers ) {
worker . setCompanyId ( company_id ) ;
personManager . addPerson ( worker ) ;
connection . commit ( ) ;
}
} catch ( SQLException e ) {
if ( connection != null ) {
connection . rollback ( ) ;
}
}
}
public int updateCompany ( Company c ) {
int count = <num> ;
try {
updateCompanyStmt . setString ( <num> , c . getName ( ) ) ;
updateCompanyStmt . setLong ( <num> , c . getId ( ) ) ;
count = updateCompanyStmt . executeUpdate ( ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
return count ;
}
public int addCompany ( Company company ) {
int count = <num> ;
try {
addCompanyStmt . setString ( <num> , company . getName ( ) ) ;
count = addCompanyStmt . executeUpdate ( ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
return count ;
}
void clearCompanies ( ) {
try {
deleteAllCompaniesStmt . executeUpdate ( ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
}
public Company getCompanyByName ( String name ) {
try {
getCompanyByNameStmt . setString ( <num> , name ) ;
ResultSet rs = getCompanyByNameStmt . executeQuery ( ) ;
Company comp = new Company ( ) ;
while ( rs . next ( ) ) {
comp . setId ( rs . getLong ( " ) ) ;
comp . setName ( rs . getString ( " ) ) ;
}
return comp ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
return null ;
}
public List < Company > getAllCompanies ( ) {
List < Company > companies = new ArrayList < Company > ( ) ;
try {
ResultSet rs = getAllCompaniesStmt . executeQuery ( ) ;
while ( rs . next ( ) ) {
Company c = new Company ( ) ;
c . setId ( rs . getLong ( " ) ) ;
c . setName ( rs . getString ( " ) ) ;
companies . add ( c ) ;
}
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
return companies ;
}
}
package com . example . jdbcdemo . service ;
import java . sql . Connection ;
import java . sql . DriverManager ;
import java . sql . PreparedStatement ;
import java . sql . ResultSet ;
import java . sql . SQLException ;
import java . sql . Statement ;
import java . util . ArrayList ;
import java . util . List ;
import com . example . jdbcdemo . domain . Person ;
public class PersonManager {
private Connection connection ;
private String url = " ;
private String createTablePerson = " ;
private PreparedStatement addPersonStmt ;
private PreparedStatement deleteAllPersonsStmt ;
private PreparedStatement getAllPersonsStmt ;
private Statement statement ;
public PersonManager ( ) {
try {
connection = DriverManager . getConnection ( url ) ;
statement = connection . createStatement ( ) ;
ResultSet rs = connection . getMetaData ( ) . getTables ( null , null , null ,
null ) ;
boolean tableExists = false ;
while ( rs . next ( ) ) {
if ( " . equalsIgnoreCase ( rs . getString ( " ) ) ) {
tableExists = true ;
break ;
}
}
if ( ! tableExists )
statement . executeUpdate ( createTablePerson ) ;
addPersonStmt = connection
. prepareStatement ( " ) ;
deleteAllPersonsStmt = connection
. prepareStatement ( " ) ;
getAllPersonsStmt = connection
. prepareStatement ( " ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
}
Connection getConnection ( ) {
return connection ;
}
void clearPersons ( ) {
try {
deleteAllPersonsStmt . executeUpdate ( ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
}
public int addPerson ( Person person ) {
int count = <num> ;
try {
addPersonStmt . setLong ( <num> , person . getCompanyId ( ) ) ;
addPersonStmt . setString ( <num> , person . getName ( ) ) ;
addPersonStmt . setInt ( <num> , person . getYob ( ) ) ;
count = addPersonStmt . executeUpdate ( ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
return count ;
}
public List < Person > getAllPersons ( ) {
List < Person > persons = new ArrayList < Person > ( ) ;
try {
ResultSet rs = getAllPersonsStmt . executeQuery ( ) ;
while ( rs . next ( ) ) {
Person p = new Person ( ) ;
p . setId ( rs . getInt ( " ) ) ;
p . setName ( rs . getString ( " ) ) ;
p . setYob ( rs . getInt ( " ) ) ;
persons . add ( p ) ;
}
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
return persons ;
}
}
package com . example . jdbcdemo . service ;
import static org . junit . Assert . * ;
import java . sql . SQLException ;
import java . util . ArrayList ;
import java . util . List ;
import org . junit . Test ;
import com . example . jdbcdemo . domain . Company ;
import com . example . jdbcdemo . domain . Person ;
public class <unk> {
CompanyManager companyManager = new CompanyManager ( ) ;
PersonManager personManager = new PersonManager ( ) ;
private final static String NAME = " ;
private final static String NAME_2 = " ;
@Test
public void checkConnection ( ) {
assertNotNull ( companyManager . getConnection ( ) ) ;
}
@Test
public void checkAdding ( ) {
Company company = new Company ( NAME ) ;
companyManager . clearCompanies ( ) ;
assertEquals ( <num> , companyManager . addCompany ( company ) ) ;
List < Company > companies = companyManager . getAllCompanies ( ) ;
Company companyRetrieved = companies . get ( <num> ) ;
assertEquals ( NAME , companyRetrieved . getName ( ) ) ;
}
@Test
public void <unk> ( ) {
Company company = new Company ( NAME ) ;
companyManager . clearCompanies ( ) ;
assertEquals ( <num> , companyManager . addCompany ( company ) ) ;
Company companyRetrieved = companyManager . getCompanyByName ( NAME ) ;
assertEquals ( NAME , companyRetrieved . getName ( ) ) ;
companyRetrieved . setName ( NAME_2 ) ;
companyManager . updateCompany ( companyRetrieved ) ;
companyRetrieved = companyManager . getCompanyByName ( NAME_2 ) ;
assertNotNull ( companyRetrieved ) ;
}
@Test
public void <unk> ( ) throws SQLException {
companyManager . clearCompanies ( ) ;
personManager . clearPersons ( ) ;
Company company = new Company ( NAME ) ;
assertEquals ( <num> , companyManager . addCompany ( company ) ) ;
List < Person > persons = new ArrayList < Person > ( ) ;
persons . add ( new Person ( " , <num> ) ) ;
persons . add ( new Person ( " , <num> ) ) ;
persons . add ( new Person ( " , <num> ) ) ;
companyManager . addWorkers ( <num> , persons ) ;
List < Person > personsReceived = companyManager . getCompanyWorkers ( <num> ) ;
assertEquals ( persons . size ( ) , personsReceived . size ( ) ) ;
}
@Test
public void <unk> ( ) {
companyManager . clearCompanies ( ) ;
personManager . clearPersons ( ) ;
Company company = new Company ( NAME ) ;
Person person = new Person ( " , <num> , <num> ) ;
assertEquals ( <num> , companyManager . addCompany ( company ) ) ;
assertEquals ( <num> , personManager . addPerson ( person ) ) ;
List < Person > persons = companyManager . getCompanyWorkers ( <num> ) ;
assertEquals ( <num> , persons . size ( ) ) ;
}
}
package com . example . jdbcdemo . domain ;
public class Person {
private long id ;
private String name ;
private int yob ;
private long company_id ;
public Person ( ) {
}
public Person ( String name , int yob ) {
super ( ) ;
this . name = name ;
this . yob = yob ;
}
public Person ( String name , int yob , long company_id ) {
super ( ) ;
this . name = name ;
this . yob = yob ;
this . company_id = company_id ;
}
public long getId ( ) {
return id ;
}
public long getCompanyId ( ) {
return company_id ;
}
public void setCompanyId ( long company_id ) {
this . company_id = company_id ;
}
public void setId ( long id ) {
this . id = id ;
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
public int getYob ( ) {
return yob ;
}
public void setYob ( int yob ) {
this . yob = yob ;
}
}
package column . validation . impl . plugin ;
import java . util . List ;
import java . util . Properties ;
import column . validation . api . ValidationPlugin ;
import column . validation . impl . bean . Table ;
import column . validation . impl . context . ValidationContext ;
public class AttributeCountValidator implements ValidationPlugin {
private ValidationContext validationContext ;
private StringBuffer report ;
private Boolean passed ;
public AttributeCountValidator ( ) {
this . setPassed ( true ) ;
}
@Override
public void execute ( ) {
ValidationContext context = this . getValidationContext ( ) ;
List < Table > tables = context . getTables ( ) ;
StringBuffer validationReport = new StringBuffer ( ) ;
Properties properties = context . getValidationProperties ( ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
validationReport . append ( \n' ) ;
for ( Table table : tables ) {
int columnCount = table . getColumns ( ) . size ( ) ;
int columnReferenceCount = table . getColumnsReference ( ) . size ( ) ;
validationReport . append ( table . getName ( ) + " ) ;
validationReport . append ( columnCount ) ;
validationReport . append ( " ) ;
validationReport . append ( columnReferenceCount ) ;
if ( columnCount == columnReferenceCount ) {
validationReport . append ( properties . getProperty ( " ) ) ;
} else {
this . setPassed ( false ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
}
validationReport . append ( \n' ) ;
}
if ( getPassed ( ) == true ) {
validationReport . append ( \n' ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
} else {
validationReport . append ( \n' ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
}
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
this . setReport ( validationReport ) ;
}
@Override
public void loadValidationContext ( ValidationContext validationContext ) {
setValidationContext ( validationContext ) ;
}
private ValidationContext getValidationContext ( ) {
return validationContext ;
}
private void setValidationContext ( ValidationContext validationContext ) {
this . validationContext = validationContext ;
}
public StringBuffer getReport ( ) {
return report ;
}
public void setReport ( StringBuffer report ) {
this . report = report ;
}
public Boolean getPassed ( ) {
return passed ;
}
public void setPassed ( Boolean passed ) {
this . passed = passed ;
}
}
package column . validation . impl ;
import java . util . ArrayList ;
import java . util . List ;
import column . validation . api . ValidationPlugin ;
import column . validation . api . Validator ;
import column . validation . impl . context . ValidationContext ;
public class ColumnValidator implements Validator {
private ValidationContext validationContext ;
private List < StringBuffer > validationReport ;
public ColumnValidator ( ValidationContext validationContext ) {
setValidationContext ( validationContext ) ;
}
@Override
public void validate ( ) {
ValidationContext validationContext = getValidationContext ( ) ;
List < ValidationPlugin > plugins = validationContext . getValidationPlugins ( ) ;
List < StringBuffer > reports = new ArrayList < StringBuffer > ( ) ;
for ( ValidationPlugin plugin : plugins ) {
plugin . loadValidationContext ( validationContext ) ;
plugin . execute ( ) ;
reports . add ( plugin . getReport ( ) ) ;
}
this . setValidationReport ( reports ) ;
}
private ValidationContext getValidationContext ( ) {
return validationContext ;
}
private void setValidationContext ( ValidationContext validationContext ) {
this . validationContext = validationContext ;
}
public List < StringBuffer > getValidationReport ( ) {
return validationReport ;
}
public void setValidationReport ( List < StringBuffer > validationReport ) {
this . validationReport = validationReport ;
}
@Override
public void printReport ( ) {
List < StringBuffer > reports = this . getValidationReport ( ) ;
for ( int i = <num> ; i < reports . size ( ) ; i ++ ) {
System . out . println ( reports . get ( i ) . toString ( ) ) ;
}
}
}
package column . validation . api ;
import column . validation . impl . context . ValidationContext ;
public interface ValidationPlugin {
public void loadValidationContext ( ValidationContext validationContext ) ;
public void execute ( ) ;
public StringBuffer getReport ( ) ;
}
package column . validation . impl . bean ;
import java . util . List ;
import org . jdom . Element ;
public class Table {
private String name ;
private List < Element > columns ;
private List < Element > columnsReference ;
public List < Element > getColumns ( ) {
return columns ;
}
public void setColumns ( List < Element > columns ) {
this . columns = columns ;
}
public List < Element > getColumnsReference ( ) {
return columnsReference ;
}
public void setColumnsReference ( List < Element > columnsReference ) {
this . columnsReference = columnsReference ;
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
}
package column . validation . impl . plugin ;
import java . util . List ;
import java . util . Properties ;
import org . jdom . Element ;
import column . validation . api . ValidationPlugin ;
import column . validation . impl . bean . Table ;
import column . validation . impl . context . ValidationContext ;
public class AttributeOccurenceValidator implements ValidationPlugin {
private ValidationContext validationContext ;
private StringBuffer report ;
private Boolean passed ;
public AttributeOccurenceValidator ( ) {
this . setPassed ( true ) ;
}
@Override
public void execute ( ) {
ValidationContext context = this . getValidationContext ( ) ;
List < Table > tables = context . getTables ( ) ;
StringBuffer validationReport = new StringBuffer ( ) ;
Properties properties = context . getValidationProperties ( ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
validationReport . append ( \n' ) ;
for ( Table table : tables ) {
validationReport . append ( table . getName ( ) ) ;
validationReport . append ( \n' ) ;
List < Element > xmlElements = table . getColumns ( ) ;
List < Element > xsdElements = table . getColumnsReference ( ) ;
if ( xmlElements . size ( ) == xsdElements . size ( ) ) {
int i = <num> ;
while ( i < xmlElements . size ( ) ) {
Element xmlElement = xmlElements . get ( i ) ;
Element xsdElement = xsdElements . get ( i ) ;
String leftSide = xmlElement . getChild ( " , context . getXmlNamespace ( ) ) . getValue ( ) ;
String rightSide = xsdElement . getAttributeValue ( " ) ;
String elementName = xmlElement . getChild ( " , context . getXmlNamespace ( ) ) . getValue ( ) ;
validationReport . append ( elementName ) ;
validationReport . append ( " ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( leftSide ) ;
validationReport . append ( " ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( rightSide ) ;
try {
if ( leftSide . equalsIgnoreCase ( " ) && rightSide == null ) {
this . setPassed ( false ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
} else if ( leftSide . equalsIgnoreCase ( " ) && rightSide . equalsIgnoreCase ( " ) ) {
validationReport . append ( properties . getProperty ( " ) ) ;
} else if ( leftSide . equalsIgnoreCase ( " ) && rightSide == null ) {
validationReport . append ( properties . getProperty ( " ) ) ;
} else {
this . setPassed ( false ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
}
validationReport . append ( \n' ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
} finally {
i = i + <num> ;
}
}
} else {
this . setPassed ( false ) ;
}
}
if ( getPassed ( ) == true ) {
validationReport . append ( \n' ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
} else {
validationReport . append ( \n' ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
}
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
this . setReport ( validationReport ) ;
}
@Override
public void loadValidationContext ( ValidationContext validationContext ) {
setValidationContext ( validationContext ) ;
}
public ValidationContext getValidationContext ( ) {
return validationContext ;
}
public void setValidationContext ( ValidationContext validationContext ) {
this . validationContext = validationContext ;
}
@Override
public StringBuffer getReport ( ) {
return this . report ;
}
public void setReport ( StringBuffer report ) {
this . report = report ;
}
public Boolean getPassed ( ) {
return passed ;
}
public void setPassed ( Boolean passed ) {
this . passed = passed ;
}
}
package column . validation . impl ;
import java . io . File ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Properties ;
import org . jaxen . JaxenException ;
import org . jaxen . SimpleNamespaceContext ;
import org . jaxen . jdom . JDOMXPath ;
import org . jdom . Document ;
import org . jdom . Element ;
import org . jdom . JDOMException ;
import org . jdom . Namespace ;
import org . jdom . input . SAXBuilder ;
import column . validation . impl . bean . Table ;
import column . validation . impl . context . ValidationContext ;
public class <unk> {
private ValidationContext validationContext ;
private String xmlPrefix ;
private String xsdPrefix ;
private Namespace xmlNamespace ;
private Namespace xsdNamespace ;
private Document metadataXML ;
private Document columnSchema ;
private List < Element > databaseSchemata ;
private List < Table > tables ;
private Table table ;
public void startup ( String pathToSiardMountPoint ) {
setValidationContext ( new ValidationContext ( pathToSiardMountPoint ) ) ;
setMetadataXML ( loadXMLRessource ( getValidationContext ( ) . getMetadataXML ( ) ) ) ;
setXmlPrefix ( getValidationContext ( ) . getValidationProperties ( ) . getProperty ( " ) ) ;
setXsdPrefix ( getValidationContext ( ) . getValidationProperties ( ) . getProperty ( " ) ) ;
setXmlNamespace ( createNamespace ( getValidationContext ( ) . getValidationProperties ( ) . getProperty ( " ) , getMetadataXML ( ) . getRootElement ( ) . getNamespaceURI ( ) ) ) ;
setXsdNamespace ( createNamespace ( getValidationContext ( ) . getValidationProperties ( ) . getProperty ( " ) , getMetadataXML ( ) . getRootElement ( ) . getNamespaceURI ( ) ) ) ;
}
private Namespace createNamespace ( String prefix , String namespaceURI ) {
Namespace namespace = Namespace . getNamespace ( prefix , namespaceURI ) ;
return namespace ;
}
private Document loadXMLRessource ( File file ) {
try {
SAXBuilder builder = new SAXBuilder ( ) ;
Document document = builder . build ( file ) ;
return document ;
} catch ( JDOMException e ) {
e . printStackTrace ( ) ;
return null ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
private List < Element > loadXMLElements ( String xpathString ,
String prefix , String namespaceURI , Document document ) {
try {
JDOMXPath xpath = new JDOMXPath ( xpathString ) ;
SimpleNamespaceContext simpleNamespaceContext = new SimpleNamespaceContext ( ) ;
simpleNamespaceContext . addNamespace ( prefix , namespaceURI ) ;
xpath . setNamespaceContext ( simpleNamespaceContext ) ;
List < Element > elements = ( ( List < Element > ) xpath . selectNodes ( document ) ) ;
return elements ;
} catch ( JaxenException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
private void extractDatabaseSchemata ( ) {
String xpath = getValidationContext ( ) . getValidationProperties ( ) . getProperty ( " ) ;
String prefix = getXmlPrefix ( ) ;
String namespaceURI = getMetadataXML ( ) . getRootElement ( ) . getNamespaceURI ( ) ;
Document document = getMetadataXML ( ) ;
setDatabaseSchemata ( loadXMLElements ( xpath , prefix , namespaceURI , document ) ) ;
}
private void extractTables ( ) {
Namespace xmlNamespace = getXmlNamespace ( ) ;
ValidationContext context = getValidationContext ( ) ;
Properties properties = getValidationContext ( ) . getValidationProperties ( ) ;
List < Element > schemaElements = getDatabaseSchemata ( ) ;
List < Table > tables = new ArrayList < Table > ( ) ;
for ( Element a : schemaElements ) {
StringBuffer schemaFolder = new StringBuffer ( ) ;
schemaFolder . append ( context . getPathToContent ( ) ) ;
schemaFolder . append ( " ) ;
schemaFolder . append ( a . getChild ( " , xmlNamespace ) . getValue ( ) ) ;
Element tablesElement = a . getChild ( " , xmlNamespace ) ;
List < Element > tableElements = tablesElement . getChildren ( " , xmlNamespace ) ;
for ( Element tableElement : tableElements ) {
StringBuffer tableFolder = new StringBuffer ( ) ;
tableFolder . append ( schemaFolder . toString ( ) ) ;
tableFolder . append ( " ) ;
tableFolder . append ( tableElement . getChild ( " , xmlNamespace ) . getValue ( ) ) ;
tableFolder . append ( " ) ;
tableFolder . append ( tableElement . getChild ( " , xmlNamespace ) . getValue ( ) ) ;
tableFolder . append ( " ) ;
Document columnSchema = loadXMLRessource ( new File ( tableFolder . toString ( ) ) ) ;
String xpath = properties . getProperty ( " ) ;
String xsdPrefix = getXsdPrefix ( ) ;
String namespaceURI = columnSchema . getRootElement ( ) . getNamespaceURI ( ) ;
Element columnsElement = tableElement . getChild ( " , xmlNamespace ) ;
List < Element > columns = columnsElement . getChildren ( " , xmlNamespace ) ;
List < Element > xsdElements = loadXMLElements ( xpath , xsdPrefix , namespaceURI , columnSchema ) ;
Table table = new Table ( ) ;
table . setColumns ( columns ) ;
table . setColumnsReference ( xsdElements ) ;
tables . add ( table ) ;
}
}
setTables ( tables ) ;
}
private Document getColumnSchema ( ) {
return null ;
}
private void setColumnSchema ( Document <unk> ) {
}
public void validate ( ) {
StringBuffer report = new StringBuffer ( ) ;
extractDatabaseSchemata ( ) ;
extractTables ( ) ;
report . append ( validateAttributeNumber ( ) ) ;
System . out . println ( report . toString ( ) ) ;
}
private StringBuffer validateAttributeNumber ( ) {
List < Table > tables = getTables ( ) ;
StringBuffer validationReport = new StringBuffer ( ) ;
for ( Table table : tables ) {
int columnCount = table . getColumns ( ) . size ( ) ;
int columnReferenceCount = table . getColumnsReference ( ) . size ( ) ;
if ( columnCount == columnReferenceCount ) {
validationReport . append ( " + \n' ) ;
validationReport . append ( " ) ;
validationReport . append ( columnCount ) ;
validationReport . append ( " ) ;
validationReport . append ( " ) ;
validationReport . append ( columnReferenceCount ) ;
validationReport . append ( \n' ) ;
validationReport . append ( \n' ) ;
} else {
validationReport . append ( " + \n' ) ;
validationReport . append ( " ) ;
validationReport . append ( columnCount ) ;
validationReport . append ( " ) ;
validationReport . append ( " ) ;
validationReport . append ( columnReferenceCount ) ;
validationReport . append ( \n' ) ;
validationReport . append ( \n' ) ;
}
}
return validationReport ;
}
private void <unk> ( ) {
}
private void <unk> ( ) {
}
private void <unk> ( ) {
}
public ValidationContext getValidationContext ( ) {
return validationContext ;
}
private void setValidationContext ( ValidationContext validationContext ) {
this . validationContext = validationContext ;
}
private Document getMetadataXML ( ) {
return metadataXML ;
}
private void setMetadataXML ( Document metadataXML ) {
this . metadataXML = metadataXML ;
}
public String getXsdPrefix ( ) {
return xsdPrefix ;
}
public void setXsdPrefix ( String xsdPrefix ) {
this . xsdPrefix = xsdPrefix ;
}
public String getXmlPrefix ( ) {
return xmlPrefix ;
}
public void setXmlPrefix ( String xmlPrefix ) {
this . xmlPrefix = xmlPrefix ;
}
public Namespace getXmlNamespace ( ) {
return xmlNamespace ;
}
public void setXmlNamespace ( Namespace xmlNamespace ) {
this . xmlNamespace = xmlNamespace ;
}
public Namespace getXsdNamespace ( ) {
return xsdNamespace ;
}
public void setXsdNamespace ( Namespace xsdNamespace ) {
this . xsdNamespace = xsdNamespace ;
}
public List < Element > getDatabaseSchemata ( ) {
return databaseSchemata ;
}
public void setDatabaseSchemata ( List < Element > databaseSchemata ) {
this . databaseSchemata = databaseSchemata ;
}
public Table getTable ( ) {
return table ;
}
public void setTable ( Table table ) {
this . table = table ;
}
public List < Table > getTables ( ) {
return tables ;
}
public void setTables ( List < Table > tables ) {
this . tables = tables ;
}
}
package column . validation . impl . plugin ;
import java . util . List ;
import java . util . Properties ;
import org . jdom . Element ;
import column . validation . api . ValidationPlugin ;
import column . validation . impl . bean . Table ;
import column . validation . impl . context . ValidationContext ;
public class AttributeTypeValidator implements ValidationPlugin {
private ValidationContext validationContext ;
private StringBuffer report ;
private Boolean passed ;
public AttributeTypeValidator ( ) {
this . setPassed ( true ) ;
}
@Override
public void execute ( ) {
ValidationContext context = this . getValidationContext ( ) ;
List < Table > tables = context . getTables ( ) ;
StringBuffer validationReport = new StringBuffer ( ) ;
Properties properties = context . getValidationProperties ( ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
validationReport . append ( \n' ) ;
for ( Table table : tables ) {
validationReport . append ( table . getName ( ) ) ;
validationReport . append ( \n' ) ;
List < Element > xmlElements = table . getColumns ( ) ;
List < Element > xsdElements = table . getColumnsReference ( ) ;
if ( xmlElements . size ( ) == xsdElements . size ( ) ) {
int i = <num> ;
while ( i < xmlElements . size ( ) ) {
Element xmlElement = xmlElements . get ( i ) ;
Element xsdElement = xsdElements . get ( i ) ;
String leftSide = xmlElement . getChild ( " , context . getXmlNamespace ( ) ) . getValue ( ) ;
String rightSide = xsdElement . getAttributeValue ( " ) ;
String elementName = xmlElement . getChild ( " , context . getXmlNamespace ( ) ) . getValue ( ) ;
String delimiter = properties . getProperty ( " ) ;
String trimmedExpectedType = trimLeftSideType ( leftSide , delimiter ) ;
String expectedType = properties . getProperty ( trimmedExpectedType ) ;
validationReport . append ( elementName ) ;
validationReport . append ( " ) ;
validationReport . append ( " ) ;
validationReport . append ( leftSide ) ;
validationReport . append ( " ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( " ) ;
validationReport . append ( expectedType ) ;
validationReport . append ( " ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( " ) ;
validationReport . append ( rightSide ) ;
validationReport . append ( " ) ;
if ( expectedType . equalsIgnoreCase ( rightSide ) ) {
validationReport . append ( properties . getProperty ( " ) ) ;
} else {
this . setPassed ( false ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
}
i = i + <num> ;
validationReport . append ( \n' ) ;
}
} else {
this . setPassed ( false ) ;
}
}
if ( getPassed ( ) == true ) {
validationReport . append ( \n' ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
} else {
validationReport . append ( \n' ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
}
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
this . setReport ( validationReport ) ;
}
private String trimLeftSideType ( String leftside , String delimiter ) {
int i = leftside . indexOf ( delimiter ) ;
if ( i >  <num> ) {
String trimmedLeftSideType = leftside . substring ( <num> , i ) ;
return trimmedLeftSideType ;
} else {
return leftside ;
}
}
@Override
public void loadValidationContext ( ValidationContext validationContext ) {
setValidationContext ( validationContext ) ;
}
public ValidationContext getValidationContext ( ) {
return validationContext ;
}
public void setValidationContext ( ValidationContext validationContext ) {
this . validationContext = validationContext ;
}
@Override
public StringBuffer getReport ( ) {
return this . report ;
}
public void setReport ( StringBuffer report ) {
this . report = report ;
}
public Boolean getPassed ( ) {
return passed ;
}
public void setPassed ( Boolean passed ) {
this . passed = passed ;
}
}
package column . validation . api ;
public interface Validator {
public void validate ( ) ;
public void printReport ( ) ;
}
package column . validation . impl ;
import java . io . File ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Properties ;
import org . jaxen . JaxenException ;
import org . jaxen . SimpleNamespaceContext ;
import org . jaxen . jdom . JDOMXPath ;
import org . jdom . Document ;
import org . jdom . Element ;
import org . jdom . JDOMException ;
import org . jdom . Namespace ;
import org . jdom . input . SAXBuilder ;
import column . validation . api . PreValidator ;
import column . validation . api . ValidationPlugin ;
import column . validation . impl . bean . Table ;
import column . validation . impl . context . ValidationContext ;
public class PreColumnValidator implements PreValidator {
private ValidationContext validationContext ;
@Override
public void loadValidationContext ( String entryPath ) {
ValidationContext context = new ValidationContext ( entryPath ) ;
Properties properties = context . getValidationProperties ( ) ;
Document columns = loadXMLRessource ( context . getMetadataXML ( ) ) ;
Element columnsRootElement = columns . getRootElement ( ) ;
String namespaceURI = columnsRootElement . getNamespaceURI ( ) ;
String xmlPrefix = properties . getProperty ( " ) ;
String xsdPrefix = properties . getProperty ( " ) ;
Namespace xmlNamespace = createNamespace ( xmlPrefix , namespaceURI ) ;
Namespace xsdNamespace = createNamespace ( xsdPrefix , namespaceURI ) ;
context . setNamespaceURI ( namespaceURI ) ;
context . setXmlPrefix ( xmlPrefix ) ;
context . setXsdPrefix ( xsdPrefix ) ;
context . setXmlNamespace ( xmlNamespace ) ;
context . setXsdNamespace ( xsdNamespace ) ;
context . setColumns ( columns ) ;
this . setValidationContext ( context ) ;
}
@Override
public void loadValidationSource ( ) {
ValidationContext context = getValidationContext ( ) ;
Namespace xmlNamespace = context . getXmlNamespace ( ) ;
Properties properties = context . getValidationProperties ( ) ;
extractDatabaseSchemata ( ) ;
List < Element > schemaElements = context . getDatabaseSchemata ( ) ;
List < Table > tables = new ArrayList < Table > ( ) ;
for ( Element schemaElement : schemaElements ) {
StringBuffer schemaFolder = new StringBuffer ( ) ;
schemaFolder . append ( context . getPathToContent ( ) ) ;
schemaFolder . append ( " ) ;
schemaFolder . append ( schemaElement . getChild ( " , xmlNamespace ) . getValue ( ) ) ;
Element tablesElement = schemaElement . getChild ( " , xmlNamespace ) ;
List < Element > tableElements = tablesElement . getChildren ( " , xmlNamespace ) ;
for ( Element tableElement : tableElements ) {
StringBuffer tableFolder = new StringBuffer ( ) ;
tableFolder . append ( schemaFolder . toString ( ) ) ;
tableFolder . append ( " ) ;
tableFolder . append ( tableElement . getChild ( " , xmlNamespace ) . getValue ( ) ) ;
tableFolder . append ( " ) ;
tableFolder . append ( tableElement . getChild ( " , xmlNamespace ) . getValue ( ) ) ;
tableFolder . append ( " ) ;
Document columnSchema = loadXMLRessource ( new File ( tableFolder . toString ( ) ) ) ;
String xpath = properties . getProperty ( " ) ;
String xsdPrefix = context . getXsdPrefix ( ) ;
String namespaceURI = columnSchema . getRootElement ( ) . getNamespaceURI ( ) ;
Element columnsElement = tableElement . getChild ( " , xmlNamespace ) ;
List < Element > columns = columnsElement . getChildren ( " , xmlNamespace ) ;
List < Element > xsdElements = loadXMLElements ( xpath , xsdPrefix , namespaceURI , columnSchema ) ;
Table table = new Table ( ) ;
table . setName ( tableElement . getChild ( " , xmlNamespace ) . getValue ( ) ) ;
table . setColumns ( columns ) ;
table . setColumnsReference ( xsdElements ) ;
tables . add ( table ) ;
}
}
context . setTables ( tables ) ;
this . setValidationContext ( context ) ;
}
@Override
public void loadValidationPlugins ( List < ValidationPlugin > plugins ) {
ValidationContext context = getValidationContext ( ) ;
context . setValidationPlugins ( plugins ) ;
}
private Document loadXMLRessource ( File file ) {
try {
SAXBuilder builder = new SAXBuilder ( ) ;
Document document = builder . build ( file ) ;
return document ;
} catch ( JDOMException e ) {
e . printStackTrace ( ) ;
return null ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
private Namespace createNamespace ( String prefix , String namespaceURI ) {
Namespace namespace = Namespace . getNamespace ( prefix , namespaceURI ) ;
return namespace ;
}
private List < Element > loadXMLElements ( String xpathString ,
String prefix , String namespaceURI , Document document ) {
try {
JDOMXPath xpath = new JDOMXPath ( xpathString ) ;
SimpleNamespaceContext simpleNamespaceContext = new SimpleNamespaceContext ( ) ;
simpleNamespaceContext . addNamespace ( prefix , namespaceURI ) ;
xpath . setNamespaceContext ( simpleNamespaceContext ) ;
List < Element > elements = ( ( List < Element > ) xpath . selectNodes ( document ) ) ;
return elements ;
} catch ( JaxenException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
private void extractDatabaseSchemata ( ) {
ValidationContext context = getValidationContext ( ) ;
Properties properties = context . getValidationProperties ( ) ;
String prefix = context . getXmlPrefix ( ) ;
String xpath = properties . getProperty ( " ) ;
String namespaceURI = context . getNamespaceURI ( ) ;
Document document = context . getColumns ( ) ;
context . setDatabaseSchemata ( loadXMLElements ( xpath , prefix , namespaceURI , document ) ) ;
}
public ValidationContext getValidationContext ( ) {
return validationContext ;
}
public void setValidationContext ( ValidationContext validationContext ) {
this . validationContext = validationContext ;
}
}
package column . validation . api ;
import java . util . List ;
import column . validation . impl . context . ValidationContext ;
public interface PreValidator {
public void loadValidationContext ( String entryPath ) ;
public void loadValidationSource ( ) ;
public void loadValidationPlugins ( List < ValidationPlugin > plugins ) ;
public ValidationContext getValidationContext ( ) ;
}
package column . validation . impl . plugin ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Properties ;
import org . jdom . Element ;
import column . validation . api . ValidationPlugin ;
import column . validation . impl . bean . Table ;
import column . validation . impl . context . ValidationContext ;
public class AttributeSequenceValidator implements ValidationPlugin {
private ValidationContext validationContext ;
private StringBuffer report ;
private Boolean passed ;
public AttributeSequenceValidator ( ) {
this . setPassed ( true ) ;
}
@Override
public void execute ( ) {
ValidationContext context = this . getValidationContext ( ) ;
List < Table > tables = context . getTables ( ) ;
StringBuffer validationReport = new StringBuffer ( ) ;
Properties properties = context . getValidationProperties ( ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
validationReport . append ( \n' ) ;
validationReport . append ( \n' ) ;
for ( Table table : tables ) {
validationReport . append ( table . getName ( ) ) ;
validationReport . append ( \n' ) ;
List < Element > xmlElements = table . getColumns ( ) ;
List < Element > xsdElements = table . getColumnsReference ( ) ;
List < String > xmlTypeSequence = new ArrayList < String > ( ) ;
List < String > xsdTypeSequence = new ArrayList < String > ( ) ;
if ( xmlElements . size ( ) == xsdElements . size ( ) ) {
int i = <num> ;
while ( i < xmlElements . size ( ) ) {
Element xmlElement = xmlElements . get ( i ) ;
Element xsdElement = xsdElements . get ( i ) ;
String leftSide = xmlElement . getChild ( " , context . getXmlNamespace ( ) ) . getValue ( ) ;
String rightSide = xsdElement . getAttributeValue ( " ) ;
String delimiter = properties . getProperty ( " ) ;
String trimmedExpectedType = trimLeftSideType ( leftSide , delimiter ) ;
xmlTypeSequence . add ( properties . getProperty ( trimmedExpectedType ) ) ;
xsdTypeSequence . add ( rightSide ) ;
validationReport . append ( properties . getProperty ( trimmedExpectedType ) ) ;
validationReport . append ( " ) ;
validationReport . append ( rightSide ) ;
i = i + <num> ;
if ( properties . getProperty ( trimmedExpectedType ) . equalsIgnoreCase ( rightSide ) ) {
validationReport . append ( properties . getProperty ( " ) ) ;
} else {
this . setPassed ( false ) ;
validationReport . append ( properties . getProperty ( " ) ) ;
}
validationReport . append ( \n' ) ;
}
validationReport . append ( \n' ) ;
} else {
this . setPassed ( false ) ;
}
}
if ( this . getPassed ( ) == true ) {
validationReport . append ( properties . getProperty ( " ) ) ;
} else {
validationReport . append ( properties . getProperty ( " ) ) ;
}
validationReport . append ( \n' ) ;
validationReport . append ( \n' ) ;
this . setReport ( validationReport ) ;
}
private String trimLeftSideType ( String leftside , String delimiter ) {
int i = leftside . indexOf ( delimiter ) ;
if ( i >  <num> ) {
String trimmedLeftSideType = leftside . substring ( <num> , i ) ;
return trimmedLeftSideType ;
} else {
return leftside ;
}
}
@Override
public void loadValidationContext ( ValidationContext validationContext ) {
setValidationContext ( validationContext ) ;
}
public ValidationContext getValidationContext ( ) {
return validationContext ;
}
public void setValidationContext ( ValidationContext validationContext ) {
this . validationContext = validationContext ;
}
@Override
public StringBuffer getReport ( ) {
return this . report ;
}
public Boolean getPassed ( ) {
return passed ;
}
public void setPassed ( Boolean passed ) {
this . passed = passed ;
}
public void setReport ( StringBuffer report ) {
this . report = report ;
}
}
package column . validation . impl . bean ;
public class Column {
private String name ;
private String type ;
private String typeOriginal ;
private String nullable ;
public String <unk> ( ) {
return nullable ;
}
public void <unk> ( String nullable ) {
this . nullable = nullable ;
}
public String <unk> ( ) {
return typeOriginal ;
}
public void <unk> ( String typeOriginal ) {
this . typeOriginal = typeOriginal ;
}
public String getType ( ) {
return type ;
}
public void setType ( String type ) {
this . type = type ;
}
public String getName ( ) {
return name ;
}
public void setName ( String name ) {
this . name = name ;
}
}
package column . validation . impl ;
import java . util . ArrayList ;
import java . util . List ;
import column . validation . api . PreValidator ;
import column . validation . api . ValidationPlugin ;
import column . validation . api . Validator ;
import column . validation . impl . context . ValidationContext ;
import column . validation . impl . plugin . AttributeCountValidator ;
import column . validation . impl . plugin . AttributeOccurenceValidator ;
import column . validation . impl . plugin . AttributeSequenceValidator ;
import column . validation . impl . plugin . AttributeTypeValidator ;
public class <unk> {
public static void main ( String [ ] args ) {
String path = " ;
PreValidator preValidator = new PreColumnValidator ( ) ;
List < ValidationPlugin > plugins = new ArrayList < ValidationPlugin > ( ) ;
ValidationPlugin attributeCountValidator = new AttributeCountValidator ( ) ;
ValidationPlugin attributeOccurenceValidator = new AttributeOccurenceValidator ( ) ;
ValidationPlugin attributeTypeValidator = new AttributeTypeValidator ( ) ;
ValidationPlugin attributeSequenceValidator = new AttributeSequenceValidator ( ) ;
plugins . add ( attributeCountValidator ) ;
plugins . add ( attributeOccurenceValidator ) ;
plugins . add ( attributeTypeValidator ) ;
plugins . add ( attributeSequenceValidator ) ;
preValidator . loadValidationContext ( path ) ;
preValidator . loadValidationSource ( ) ;
preValidator . loadValidationPlugins ( plugins ) ;
ValidationContext validationContext = preValidator . getValidationContext ( ) ;
Validator validator = new ColumnValidator ( validationContext ) ;
validator . validate ( ) ;
validator . printReport ( ) ;
}
}
package column . validation . impl . context ;
import java . io . File ;
import java . io . FileInputStream ;
import java . io . FileNotFoundException ;
import java . util . List ;
import java . util . Properties ;
import org . jdom . Document ;
import org . jdom . Element ;
import org . jdom . Namespace ;
import column . validation . api . ValidationPlugin ;
import column . validation . impl . bean . Table ;
public class ValidationContext {
private String SiardMountPoint ;
private String pathToContent ;
private String pathToHeader ;
private String pathToMetadataXML ;
private File metadataXML ;
private String xmlPrefix ;
private String xsdPrefix ;
private String namespaceURI ;
private Namespace xmlNamespace ;
private Namespace xsdNamespace ;
private Properties validationProperties ;
private FileInputStream metadataXMLFis ;
private Document columns ;
private Document columnSchema ;
private Table validationData ;
private List < Element > databaseSchemata ;
private List < Table > tables ;
private List < ValidationPlugin > validationPlugins ;
public ValidationContext ( String pathToSiardMountPoint ) {
try {
Properties properties = new Properties ( ) ;
properties . load ( getClass ( ) . getResourceAsStream ( " ) ) ;
setValidationProperties ( properties ) ;
setSiardMountPoint ( pathToSiardMountPoint ) ;
setPathToContent ( pathToSiardMountPoint
+ getValidationProperties ( ) . getProperty ( " ) ) ;
setPathToHeader ( pathToSiardMountPoint
+ getValidationProperties ( ) . getProperty ( " ) ) ;
setPathToMetadataXML ( getPathToHeader ( )
+ getValidationProperties ( ) . getProperty ( " ) ) ;
setMetadataXML ( new File ( getPathToMetadataXML ( ) ) ) ;
setMetadataXMLFis ( new FileInputStream ( getMetadataXML ( ) ) ) ;
} catch ( FileNotFoundException e ) {
e . printStackTrace ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
public void <unk> ( ) {
System . out . println ( getValidationProperties ( ) . getProperty ( " )
+ getSiardMountPoint ( ) ) ;
System . out . println ( getValidationProperties ( ) . getProperty ( " )
+ getPathToContent ( ) ) ;
System . out . println ( getValidationProperties ( ) . getProperty ( " )
+ getPathToHeader ( ) ) ;
System . out . println ( getValidationProperties ( ) . getProperty ( " )
+ getPathToMetadataXML ( ) ) ;
System . out . println ( getValidationProperties ( ) . getProperty ( " )
+ getValidationProperties ( ) . size ( ) ) ;
System . out . println ( getValidationProperties ( ) . getProperty ( " )
+ getMetadataXMLFis ( ) . toString ( ) ) ;
}
public String getSiardMountPoint ( ) {
return SiardMountPoint ;
}
private void setSiardMountPoint ( String mountPoint ) {
this . SiardMountPoint = mountPoint ;
}
public String getPathToContent ( ) {
return pathToContent ;
}
private void setPathToContent ( String pathToContent ) {
this . pathToContent = pathToContent ;
}
public String getPathToHeader ( ) {
return pathToHeader ;
}
private void setPathToHeader ( String pathToHeader ) {
this . pathToHeader = pathToHeader ;
}
public File getMetadataXML ( ) {
return metadataXML ;
}
private void setMetadataXML ( File metadataXML ) {
this . metadataXML = metadataXML ;
}
public Properties getValidationProperties ( ) {
return validationProperties ;
}
private void setValidationProperties ( Properties validationProperties ) {
this . validationProperties = validationProperties ;
}
public FileInputStream getMetadataXMLFis ( ) {
return metadataXMLFis ;
}
private void setMetadataXMLFis ( FileInputStream metadataXMLFis ) {
this . metadataXMLFis = metadataXMLFis ;
}
public String getPathToMetadataXML ( ) {
return pathToMetadataXML ;
}
private void setPathToMetadataXML ( String pathToMetadataXML ) {
this . pathToMetadataXML = pathToMetadataXML ;
}
public Table <unk> ( ) {
return validationData ;
}
public void <unk> ( Table validationData ) {
this . validationData = validationData ;
}
public Document getColumns ( ) {
return columns ;
}
public void setColumns ( Document columns ) {
this . columns = columns ;
}
public Document getColumnSchema ( ) {
return columnSchema ;
}
public void setColumnSchema ( Document columnSchema ) {
this . columnSchema = columnSchema ;
}
public String getXmlPrefix ( ) {
return xmlPrefix ;
}
public void setXmlPrefix ( String xmlPrefix ) {
this . xmlPrefix = xmlPrefix ;
}
public String getXsdPrefix ( ) {
return xsdPrefix ;
}
public void setXsdPrefix ( String xsdPrefix ) {
this . xsdPrefix = xsdPrefix ;
}
public Namespace getXmlNamespace ( ) {
return xmlNamespace ;
}
public void setXmlNamespace ( Namespace xmlNamespace ) {
this . xmlNamespace = xmlNamespace ;
}
public Namespace getXsdNamespace ( ) {
return xsdNamespace ;
}
public void setXsdNamespace ( Namespace xsdNamespace ) {
this . xsdNamespace = xsdNamespace ;
}
public String getNamespaceURI ( ) {
return namespaceURI ;
}
public void setNamespaceURI ( String namespaceURI ) {
this . namespaceURI = namespaceURI ;
}
public List < Element > getDatabaseSchemata ( ) {
return databaseSchemata ;
}
public void setDatabaseSchemata ( List < Element > databaseSchemata ) {
this . databaseSchemata = databaseSchemata ;
}
public List < Table > getTables ( ) {
return tables ;
}
public void setTables ( List < Table > tables ) {
this . tables = tables ;
}
public List < ValidationPlugin > getValidationPlugins ( ) {
return validationPlugins ;
}
public void setValidationPlugins ( List < ValidationPlugin > validationPlugins ) {
this . validationPlugins = validationPlugins ;
}
}
package edu . <unk> . cs . acm . WandsNStuff ;
import org . bukkit . plugin . java . JavaPlugin ;
public class WandsNStuff extends JavaPlugin {
public void onDisable ( ) {
}
public void onEnable ( ) {
}
}
package org . fogbeam . hatteras . camel ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Set ;
import org . fogbeam . hatteras . subscription . Subscriber ;
import org . fogbeam . hatteras . subscription . SubscriptionService ;
import org . fogbeam . quoddy . EventSubscription ;
import com . google . common . collect . HashMultimap ;
import com . google . common . collect . Multimap ;
public class CamelSubscriptionProvider
{
private final List < CamelSubscription > subscriptions = new ArrayList < CamelSubscription > ( ) ;
private SubscriptionService subscriptionService ;
public CamelSubscriptionProvider ( )
{
}
public void <unk> ( )
{
System . out . println ( " ) ;
List < EventSubscription > extSubscriptions = subscriptionService . getExternalSubscriptions ( ) ;
List < CamelSubscription > c = new ArrayList < CamelSubscription > ( ) ;
Multimap < String , Subscriber > mapper = HashMultimap . create ( ) ;
for ( EventSubscription sub : extSubscriptions )
{
Subscriber subscriber = new Subscriber ( ) ;
subscriber . setSubscriberUserId ( sub . getOwner ( ) . getUserId ( ) ) ;
subscriber . setSubscriberUuid ( sub . getOwner ( ) . getUuid ( ) ) ;
subscriber . setSubscriptionUuid ( sub . getUuid ( ) ) ;
mapper . put ( sub . getxQueryExpression ( ) , subscriber ) ;
}
Set < String > xQueryExpressions = mapper . keySet ( ) ;
for ( String xQuery : xQueryExpressions )
{
CamelSubscription newSub = new CamelSubscription ( ) ;
newSub . setXQueryExpression ( xQuery ) ;
newSub . addAllSubscribers ( mapper . get ( xQuery ) ) ;
c . add ( newSub ) ;
}
synchronized ( subscriptions )
{
subscriptions . clear ( ) ;
subscriptions . addAll ( c ) ;
}
System . out . println ( " ) ;
for ( CamelSubscription cs : subscriptions )
{
System . out . println ( " + cs . getXQueryExpression ( ) + " ) ;
List < Subscriber > subOwners = cs . getSubscribers ( ) ;
for ( Subscriber subscriber : subOwners )
{
System . out . println ( subscriber . getSubscriberUserId ( )
+ "
+ subscriber . getSubscriberUuid ( ) ) ;
}
System . out . println ( " ) ;
}
}
public List < CamelSubscription > getSubscriptions ( )
{
synchronized ( subscriptions )
{
return subscriptions ;
}
}
public SubscriptionService <unk> ( )
{
return subscriptionService ;
}
public void <unk> ( SubscriptionService subscriptionService )
{
this . subscriptionService = subscriptionService ;
}
@SuppressWarnings("unused")
private List < CamelSubscription > <unk> ( )
{
List < CamelSubscription > dummyData = new ArrayList < CamelSubscription > ( ) ;
Subscriber prhodes = new Subscriber ( " , " , " ) ;
Subscriber mtwain = new Subscriber ( " , " , " ) ;
Subscriber dawnlove = new Subscriber ( " , " , " ) ;
Subscriber tinman = new Subscriber ( " , " , " ) ;
Subscriber pinman = new Subscriber ( " , " , " ) ;
Subscriber mstanley = new Subscriber ( " , " , " ) ;
Subscriber dlemos = new Subscriber ( " , " , " ) ;
CamelSubscription sub1 = new CamelSubscription ( ) ;
sub1 . setXQueryExpression ( " ) ;
sub1 . addSubscriber ( prhodes ) ;
sub1 . addSubscriber ( mtwain ) ;
dummyData . add ( sub1 ) ;
CamelSubscription sub2 = new CamelSubscription ( ) ;
sub2 . setXQueryExpression ( " ) ;
sub2 . addSubscriber ( dawnlove ) ;
sub2 . addSubscriber ( tinman ) ;
sub2 . addSubscriber ( pinman ) ;
dummyData . add ( sub2 ) ;
CamelSubscription sub3 = new CamelSubscription ( ) ;
sub3 . setXQueryExpression ( " ) ;
sub3 . addSubscriber ( mstanley ) ;
sub3 . addSubscriber ( dlemos ) ;
dummyData . add ( sub3 ) ;
return dummyData ;
}
package org . fogbeam . hatteras . camel ;
import java . util . ArrayList ;
import java . util . Collection ;
import java . util . List ;
import org . fogbeam . hatteras . subscription . Subscriber ;
public class CamelSubscription
{
private String xQueryExpression ;
private List < Subscriber > subscribers = new ArrayList < Subscriber > ( ) ;
public String getXQueryExpression ( ) {
return xQueryExpression ;
}
public void setXQueryExpression ( final String xQueryExpression ) {
this . xQueryExpression = xQueryExpression ;
}
public List < Subscriber > getSubscribers ( )
{
return subscribers ;
}
public void <unk> ( final List < Subscriber > subscribers )
{
this . subscribers = subscribers ;
}
public void addAllSubscribers ( final Collection < Subscriber > subscribers )
{
this . subscribers . addAll ( subscribers ) ;
}
public void addSubscriber ( final Subscriber subscriber )
{
this . subscribers . add ( subscriber ) ;
}
}
package org . fogbeam . hatteras . camel ;
import org . apache . camel . Processor ;
import org . apache . camel . builder . RouteBuilder ;
public class <unk> extends RouteBuilder
{
private Processor downloadLogger ;
private Processor existDBProcessor ;
private CamelDynamicPredicate subscriptionPredicate ;
public void configure ( ) throws Exception
{
from ( " )
. process ( this . downloadLogger )
. process ( this . existDBProcessor )
. choice ( )
. when ( this . subscriptionPredicate )
. bean ( CamelRecipientList . class ) ;
}
public void <unk> ( Processor downloadLogger )
{
this . downloadLogger = downloadLogger ;
}
public void <unk> ( CamelDynamicPredicate subscriptionPredicate )
{
this . subscriptionPredicate = subscriptionPredicate ;
}
public void <unk> ( Processor existDBProcessor )
{
this . existDBProcessor = existDBProcessor ;
}
}
package org . fogbeam . hatteras . subscription ;
public class Subscriber
{
private String subscriberUserId ;
private String subscriberUuid ;
private String subscriptionUuid ;
public Subscriber ( )
{ }
public Subscriber ( final String subscriberUserId ,
final String subscriberUuid ,
final String subscriptionUuid )
{
this . subscriberUserId = subscriberUserId ;
this . subscriberUuid = subscriberUuid ;
this . subscriptionUuid = subscriptionUuid ;
}
public String getSubscriberUserId ( )
{
return subscriberUserId ;
}
public void setSubscriberUserId ( String subscriberUserId )
{
this . subscriberUserId = subscriberUserId ;
}
public String getSubscriberUuid ( )
{
return subscriberUuid ;
}
public void setSubscriberUuid ( String subscriberUuid )
{
this . subscriberUuid = subscriberUuid ;
}
public String getSubscriptionUuid ( )
{
return subscriptionUuid ;
}
public void setSubscriptionUuid ( String subscriptionUuid )
{
this . subscriptionUuid = subscriptionUuid ;
}
}
package org . fogbeam . hatteras . camel ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Map ;
import java . util . Set ;
import org . apache . camel . Exchange ;
import org . apache . camel . <unk> ;
import org . fogbeam . hatteras . subscription . Subscriber ;
public class CamelRecipientList
{
<unk>
public List < String > <unk> ( String body , Exchange exchange )
{
ArrayList < String > recipients = new ArrayList < String > ( ) ;
Map headers = exchange . getIn ( ) . getHeaders ( ) ;
Set < Map . Entry > entries = headers . entrySet ( ) ;
for ( Map . Entry entry : entries )
{
System . out . println ( " + entry . getKey ( ) + " + entry . getValue ( ) ) ;
}
Map < String , Object > props = exchange . getProperties ( ) ;
for ( String key : props . keySet ( ) )
{
System . out . println ( " + key + " + props . get ( key ) ) ;
}
List < Subscriber > subscribers = ( List < Subscriber > ) exchange . getProperty ( " ) ;
try
{
StringBuilder subscriberIds = new StringBuilder ( ) ;
StringBuilder subscribersWithSubId = new StringBuilder ( ) ;
for ( Subscriber subscriber : subscribers )
{
subscriberIds . append ( subscriber + " ) ;
subscribersWithSubId . append ( subscriber . getSubscriberUuid ( )
+ "
+ subscriber . getSubscriptionUuid ( ) + " ) ;
}
String strSubHeader = subscriberIds . toString ( ) . trim ( ) ;
String strSubscribersWithSubId = subscribersWithSubId . toString ( ) . trim ( ) ;
exchange . getIn ( ) . setHeader ( " , strSubHeader ) ;
exchange . getIn ( ) . setHeader ( " , strSubscribersWithSubId ) ;
String xmlUuid = exchange . getProperty ( " ) . toString ( ) ;
System . out . println ( " + xmlUuid + " ) ;
exchange . getIn ( ) . setHeader ( " , xmlUuid ) ;
String matchedExpression = exchange . getProperty ( " ) . toString ( ) ;
System . out . println ( " + matchedExpression + " ) ;
exchange . getIn ( ) . setHeader ( " , matchedExpression ) ;
}
catch ( Exception e )
{
e . printStackTrace ( ) ;
}
recipients . add ( " ) ;
return recipients ;
}
}
package org . fogbeam . hatteras . camel ;
import java . io . Reader ;
import java . io . StringReader ;
import java . util . ArrayList ;
import java . util . List ;
import javax . xml . stream . XMLInputFactory ;
import javax . xml . stream . XMLStreamReader ;
import javax . xml . xquery . XQConnection ;
import javax . xml . xquery . XQDataSource ;
import javax . xml . xquery . XQPreparedExpression ;
import javax . xml . xquery . XQResultSequence ;
import javax . xml . xquery . XQSequence ;
import javax . xml . xquery . XQStaticContext ;
import org . apache . camel . Exchange ;
import org . apache . camel . Predicate ;
import org . fogbeam . hatteras . subscription . Subscriber ;
import ch . ethz . mxquery . xqj . MXQueryXQDataSource ;
public class CamelDynamicPredicate implements Predicate
{
private CamelSubscriptionProvider subscriptionProvider ;
@Override
public boolean matches ( Exchange exchange )
{
try
{
String body = exchange . getIn ( ) . getBody ( String . class ) ;
System . out . println ( " + body ) ;
XQDataSource ds = new MXQueryXQDataSource ( ) ;
XQConnection conn = ds . getConnection ( ) ;
XMLInputFactory factory = XMLInputFactory . newInstance ( ) ;
Reader reader = new StringReader ( body ) ;
XMLStreamReader streamReader = factory . createXMLStreamReader ( reader ) ;
javax . xml . namespace . QName rns = new javax . xml . namespace . QName ( " ) ;
List < CamelSubscription > subs = subscriptionProvider . getSubscriptions ( ) ;
XQStaticContext cntxt = conn . getStaticContext ( ) ;
cntxt . declareNamespace ( " , " ) ;
conn . setStaticContext ( cntxt ) ;
String dec = " ;
boolean first = true ;
List < Subscriber > allSubscribers = new ArrayList < Subscriber > ( ) ;
for ( CamelSubscription sub : subs )
{
String query ;
if ( first )
{
query = dec + " ;
}
else
{
query = " ;
}
first = false ;
query = query + sub . getXQueryExpression ( ) ;
System . out . println ( " + query ) ;
XQPreparedExpression exp = conn . <unk> ( query , cntxt ) ;
exp . <unk> ( rns , streamReader , null ) ;
XQResultSequence result = exp . executeQuery ( ) ;
XQSequence sequence = conn . createSequence ( result ) ;
if ( sequence . isBeforeFirst ( ) )
{
System . out . println ( " ) ;
allSubscribers . addAll ( sub . getSubscribers ( ) ) ;
exchange . setProperty ( " , sub . getXQueryExpression ( ) ) ;
}
else
{
System . out . println ( " ) ;
}
result . close ( ) ;
}
exchange . setProperty ( " , allSubscribers ) ;
exchange . getOut ( ) . setHeader ( " , allSubscribers ) ;
}
catch ( Exception e )
{
e . printStackTrace ( ) ;
}
return true ;
}
public void <unk> ( CamelSubscriptionProvider subscriptionProvider )
{
this . subscriptionProvider = subscriptionProvider ;
}
}
package org . fogbeam . hatteras . camel ;
import org . apache . camel . CamelContext ;
import org . apache . camel . builder . RouteBuilder ;
import org . apache . camel . model . <unk> ;
import org . springframework . context . ApplicationContext ;
import org . springframework . context . support . ClassPathXmlApplicationContext ;
public class <unk>
{
public static void main ( String [ ] args ) throws Exception
{
ApplicationContext appContext = new ClassPathXmlApplicationContext ( " ) ;
CamelContext context = ( CamelContext ) appContext . getBean ( " ) ;
context . start ( ) ;
Thread . sleep ( <num> ) ;
context . stop ( ) ;
System . out . println ( " ) ;
}
}
package org . fogbeam . hatteras ;
import java . util . List ;
import org . apache . camel . CamelContext ;
import org . fogbeam . hatteras . subscription . SubscriptionService ;
import org . fogbeam . quoddy . EventSubscription ;
import org . springframework . context . ApplicationContext ;
import org . springframework . context . support . ClassPathXmlApplicationContext ;
public class EclipseMain implements Runnable
{
private ApplicationContext appContext ;
@SuppressWarnings("unused")
public static void main ( String [ ] args )
{
System . out . println ( " ) ;
EclipseMain main = new EclipseMain ( ) ;
main . init ( ) ;
try
{
Thread . sleep ( <num> ) ;
main . startCamel ( ) ;
}
catch ( Exception e )
{
e . printStackTrace ( ) ;
}
System . out . println ( " ) ;
}
public void init ( )
{
this . appContext = new ClassPathXmlApplicationContext ( " ) ;
}
private void startCamel ( ) throws Exception {
CamelContext context = ( CamelContext ) appContext . getBean ( " ) ;
context . start ( ) ;
}
public void run ( )
{
while ( true )
{
try
{
Thread . sleep ( <num> ) ;
SubscriptionService subService = appContext . getBean ( " , SubscriptionService . class ) ;
List < EventSubscription > subscriptions = subService . getExternalSubscriptions ( ) ;
for ( EventSubscription sub : subscriptions )
{
System . out . println ( sub ) ;
}
System . out . println ( " ) ;
}
catch ( InterruptedException e )
{
}
System . out . println ( " ) ;
}
}
}
package org . fogbeam . hatteras . persistence ;
import java . util . UUID ;
import org . apache . camel . Exchange ;
import org . apache . camel . Processor ;
import org . exist . storage . DBBroker ;
import org . xmldb . api . DatabaseManager ;
import org . xmldb . api . base . Collection ;
import org . xmldb . api . base . Database ;
import org . xmldb . api . modules . CollectionManagementService ;
import org . xmldb . api . modules . XMLResource ;
public class <unk> implements Processor
{
public final static String URI = " ;
@Override
public void process ( Exchange exchange ) throws Exception
{
String msgXML = exchange . getIn ( ) . getBody ( String . class ) ;
String collection = " ;
System . out . println ( " + collection ) ;
String driver = " ;
Class cl = Class . forName ( driver ) ;
Database database = ( Database ) cl . newInstance ( ) ;
database . setProperty ( " , " ) ;
DatabaseManager . <unk> ( database ) ;
String colURI = URI + collection ;
System . out . println ( " + colURI ) ;
Collection col = DatabaseManager . getCollection ( colURI ) ;
if ( col == null ) {
System . out . println ( " + colURI + " ) ;
try
{
Collection root = DatabaseManager . getCollection ( URI + DBBroker . ROOT_COLLECTION ) ;
if ( root == null )
{
System . err . println ( " ) ;
return ;
}
CollectionManagementService mgtService = ( CollectionManagementService ) root . getService ( " , " ) ;
String foo = collection . substring ( ( DBBroker . ROOT_COLLECTION + " ) . length ( ) ) ;
System . out . println ( " + foo ) ;
col = mgtService . <unk> ( foo ) ;
}
catch ( Exception e )
{
e . printStackTrace ( ) ;
}
}
else {
System . out . println ( " + collection + " ) ;
}
String uuid = UUID . randomUUID ( ) . toString ( ) ;
XMLResource document = ( XMLResource ) col . createResource ( uuid , " ) ;
document . setContent ( msgXML ) ;
System . out . print ( " + document . getId ( ) + " ) ;
try
{
col . <unk> ( document ) ;
exchange . setProperty ( " , uuid ) ;
}
catch ( Exception e )
{
e . printStackTrace ( ) ;
}
System . out . println ( " ) ;
}
}
package org . fogbeam . hatteras . camel ;
import org . apache . camel . Exchange ;
import org . apache . camel . Processor ;
public class <unk> implements Processor
{
@Override
public void process ( Exchange exchange )
throws Exception
{
System . out . println ( " + exchange . getIn ( ) . getHeader ( " ) ) ;
}
}
package org . fogbeam . hatteras ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . Set ;
import org . fogbeam . hatteras . camel . CamelSubscription ;
import org . fogbeam . hatteras . subscription . Subscriber ;
import org . fogbeam . quoddy . EventSubscription ;
import org . fogbeam . quoddy . User ;
import com . google . common . collect . HashMultimap ;
import com . google . common . collect . Multimap ;
public class <unk>
{
public static void main ( String [ ] args )
{
List < EventSubscription > extSubscriptions = new ArrayList < EventSubscription > ( ) ;
User u1 = new User ( ) ;
u1 . setUserId ( " ) ;
u1 . setUuid ( " ) ;
User u2 = new User ( ) ;
u2 . setUserId ( " ) ;
u2 . setUuid ( " ) ;
User u3 = new User ( ) ;
u3 . setUserId ( " ) ;
u3 . setUuid ( " ) ;
User u4 = new User ( ) ;
u4 . setUserId ( " ) ;
u4 . setUuid ( " ) ;
EventSubscription e1 = new EventSubscription ( ) ;
e1 . setxQueryExpression ( " ) ;
e1 . setOwner ( u1 ) ;
EventSubscription e2 = new EventSubscription ( ) ;
e2 . setxQueryExpression ( " ) ;
e2 . setOwner ( u2 ) ;
EventSubscription e3 = new EventSubscription ( ) ;
e3 . setxQueryExpression ( " ) ;
e3 . setOwner ( u3 ) ;
EventSubscription e4 = new EventSubscription ( ) ;
e4 . setxQueryExpression ( " ) ;
e4 . setOwner ( u4 ) ;
EventSubscription e5 = new EventSubscription ( ) ;
e5 . setxQueryExpression ( " ) ;
e5 . setOwner ( u2 ) ;
EventSubscription e6 = new EventSubscription ( ) ;
e6 . setxQueryExpression ( " ) ;
e6 . setOwner ( u2 ) ;
EventSubscription e7 = new EventSubscription ( ) ;
e7 . setxQueryExpression ( " ) ;
e7 . setOwner ( u3 ) ;
EventSubscription e8 = new EventSubscription ( ) ;
e8 . setxQueryExpression ( " ) ;
e8 . setOwner ( u1 ) ;
EventSubscription e9 = new EventSubscription ( ) ;
e9 . setxQueryExpression ( " ) ;
e9 . setOwner ( u2 ) ;
EventSubscription e10 = new EventSubscription ( ) ;
e10 . setxQueryExpression ( " ) ;
e10 . setOwner ( u3 ) ;
EventSubscription e11 = new EventSubscription ( ) ;
e11 . setxQueryExpression ( " ) ;
e11 . setOwner ( u4 ) ;
EventSubscription e12 = new EventSubscription ( ) ;
e12 . setxQueryExpression ( " ) ;
e12 . setOwner ( u4 ) ;
extSubscriptions . add ( e1 ) ;
extSubscriptions . add ( e2 ) ;
extSubscriptions . add ( e3 ) ;
extSubscriptions . add ( e4 ) ;
extSubscriptions . add ( e5 ) ;
extSubscriptions . add ( e6 ) ;
extSubscriptions . add ( e7 ) ;
extSubscriptions . add ( e8 ) ;
extSubscriptions . add ( e9 ) ;
extSubscriptions . add ( e10 ) ;
extSubscriptions . add ( e12 ) ;
extSubscriptions . add ( e11 ) ;
List < CamelSubscription > c = new ArrayList < CamelSubscription > ( ) ;
Multimap < String , Subscriber > mapper = HashMultimap . create ( ) ;
for ( EventSubscription sub : extSubscriptions )
{
Subscriber subscriber = new Subscriber ( sub . getOwner ( ) . getUserId ( ) ,
sub . getOwner ( ) . getUuid ( ) ,
sub . getUuid ( ) ) ;
mapper . put ( sub . getxQueryExpression ( ) , subscriber ) ;
}
Set < String > xQueryExpressions = mapper . keySet ( ) ;
for ( String xQuery : xQueryExpressions )
{
CamelSubscription newSub = new CamelSubscription ( ) ;
newSub . setXQueryExpression ( xQuery ) ;
newSub . addAllSubscribers ( mapper . get ( xQuery ) ) ;
c . add ( newSub ) ;
}
for ( CamelSubscription aSub : c )
{
System . out . println ( aSub . getXQueryExpression ( ) + " ) ;
List < Subscriber > subscribers = aSub . getSubscribers ( ) ;
for ( Subscriber subscriber : subscribers )
{
System . out . println ( subscriber . getSubscriberUserId ( ) + " + subscriber . getSubscriberUuid ( ) ) ;
}
System . out . println ( " ) ;
}
}
}
package org . fogbeam . hatteras . subscription ;
import java . util . ArrayList ;
import java . util . HashMap ;
import java . util . List ;
import java . util . Map ;
import org . fogbeam . quoddy . EventSubscription ;
import org . fogbeam . quoddy . <unk> . collection . EventSubscriptionCollection ;
import org . springframework . http . ResponseEntity ;
import org . springframework . web . client . RestTemplate ;
public class SubscriptionService
{
private RestTemplate restTemplate ;
public List < EventSubscription > getExternalSubscriptions ( )
{
List < EventSubscription > subscriptions = new ArrayList < EventSubscription > ( ) ;
Map < String , String > urlVariables = new HashMap < String , String > ( ) ;
ResponseEntity < EventSubscriptionCollection > response = null ;
try
{
response =
restTemplate . <unk> ( " , EventSubscriptionCollection . class , urlVariables ) ;
}
catch ( Exception e )
{
e . printStackTrace ( ) ;
System . out . println ( " ) ;
System . err . println ( " ) ;
}
if ( response != null )
{
EventSubscriptionCollection subscriptionCollection = response . getBody ( ) ;
List < EventSubscription > subscriptionsColl = subscriptionCollection . getSubscriptions ( ) ;
subscriptions . addAll ( subscriptionsColl ) ;
}
return subscriptions ;
}
public void <unk> ( RestTemplate restTemplate )
{
this . restTemplate = restTemplate ;
}
public RestTemplate <unk> ( )
{
return restTemplate ;
}
}
package org . fogbeam . hatteras ;
import java . util . List ;
import org . apache . camel . CamelContext ;
import org . fogbeam . hatteras . subscription . SubscriptionService ;
import org . fogbeam . quoddy . EventSubscription ;
import org . springframework . context . ApplicationContext ;
import org . springframework . context . support . FileSystemXmlApplicationContext ;
public class Main implements Runnable
{
private ApplicationContext appContext ;
@SuppressWarnings("unused")
public static void main ( String [ ] args )
{
System . out . println ( " ) ;
Main main = new Main ( ) ;
main . init ( ) ;
try
{
Thread . sleep ( <num> ) ;
main . startCamel ( ) ;
}
catch ( Exception e )
{
e . printStackTrace ( ) ;
}
System . out . println ( " ) ;
}
public void init ( )
{
this . appContext = new FileSystemXmlApplicationContext ( " ) ;
}
private void startCamel ( ) throws Exception {
CamelContext context = ( CamelContext ) appContext . getBean ( " ) ;
context . start ( ) ;
}
public void run ( )
{
while ( true )
{
try
{
Thread . sleep ( <num> ) ;
SubscriptionService subService = appContext . getBean ( " , SubscriptionService . class ) ;
List < EventSubscription > subscriptions = subService . getExternalSubscriptions ( ) ;
for ( EventSubscription sub : subscriptions )
{
System . out . println ( sub ) ;
}
System . out . println ( " ) ;
}
catch ( InterruptedException e )
{
}
System . out . println ( " ) ;
}
}
}
package org . fogbeam . hatteras . summary ;
import java . io . File ;
import java . io . IOException ;
import java . io . Reader ;
import java . io . StringReader ;
import java . util . Scanner ;
import javax . xml . stream . XMLInputFactory ;
import javax . xml . stream . XMLStreamReader ;
import javax . xml . xquery . XQConnection ;
import javax . xml . xquery . XQDataSource ;
import javax . xml . xquery . XQStaticContext ;
import org . apache . camel . Exchange ;
import org . apache . camel . Processor ;
import ch . ethz . mxquery . xqj . MXQueryXQDataSource ;
public class <unk> implements Processor
{
@Override
public void process ( Exchange exchange ) throws Exception
{
String msgXML = exchange . getIn ( ) . getBody ( String . class ) ;
}
public static void main ( String [ ] args ) throws Exception
{
String body = readFile ( " ) ;
System . out . println ( " + body ) ;
XQDataSource ds = new MXQueryXQDataSource ( ) ;
XQConnection conn = ds . getConnection ( ) ;
XMLInputFactory factory = XMLInputFactory . newInstance ( ) ;
Reader reader = new StringReader ( body ) ;
XMLStreamReader streamReader = factory . createXMLStreamReader ( reader ) ;
javax . xml . namespace . QName rns = new javax . xml . namespace . QName ( " ) ;
XQStaticContext cntxt = conn . getStaticContext ( ) ;
cntxt . declareNamespace ( " , " ) ;
conn . setStaticContext ( cntxt ) ;
String dec = " ;
System . out . println ( " ) ;
}
private static String readFile ( String pathname ) throws IOException {
File file = new File ( pathname ) ;
StringBuilder fileContents = new StringBuilder ( ( int ) file . length ( ) ) ;
Scanner scanner = new Scanner ( file ) ;
String lineSeparator = System . getProperty ( " ) ;
try {
while ( scanner . hasNextLine ( ) ) {
fileContents . append ( scanner . nextLine ( ) + lineSeparator ) ;
}
return fileContents . toString ( ) ;
} finally {
scanner . close ( ) ;
}
}
}
package de . ub0r . android . smsdroid ;
import android . app . Activity ;
import android . content . Context ;
import android . content . Intent ;
import android . os . Bundle ;
import android . preference . PreferenceActivity ;
import android . view . MenuItem ;
import de . ub0r . android . lib . IPreferenceContainer ;
public final class <unk> extends PreferenceActivity implements
IPreferenceContainer {
@Override
public void onCreate ( final Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . addPreferencesFromResource ( R . xml . <unk> ) ;
PreferencesActivity . registerOnPreferenceClickListener ( this ) ;
}
@Override
public boolean onOptionsItemSelected ( final MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
Intent intent = new Intent ( this , ConversationListActivity . class ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
this . startActivity ( intent ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
@Override
public Activity getActivity ( ) {
return this ;
}
@Override
public Context getContext ( ) {
return this ;
}
}
package de . ub0r . android . smsdroid ;
import android . app . AlertDialog . Builder ;
import android . content . ActivityNotFoundException ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . content . pm . ActivityInfo ;
import android . content . pm . PackageManager ;
import android . database . Cursor ;
import android . graphics . drawable . Drawable ;
import android . net . Uri ;
import android . os . Bundle ;
import android . preference . PreferenceManager ;
import android . provider . CallLog . Calls ;
import android . support . v4 . app . FragmentActivity ;
import android . support . v4 . view . Menu ;
import android . support . v4 . view . MenuItem ;
import android . text . ClipboardManager ;
import android . text . TextUtils ;
import android . text . format . DateFormat ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . view . View . OnLongClickListener ;
import android . widget . AbsListView ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . AdapterView . OnItemLongClickListener ;
import android . widget . Button ;
import android . widget . EditText ;
import android . widget . ImageView ;
import android . widget . ListAdapter ;
import android . widget . ListView ;
import android . widget . TextView ;
import android . widget . Toast ;
import de . ub0r . android . lib . Log ;
import de . ub0r . android . lib . Utils ;
import de . ub0r . android . lib . apis . Contact ;
import de . ub0r . android . lib . apis . ContactsWrapper ;
public class MessageListActivity extends FragmentActivity implements OnItemClickListener ,
OnItemLongClickListener , OnClickListener , OnLongClickListener {
private static final String TAG = " ;
private static final ContactsWrapper WRAPPER = ContactsWrapper . getInstance ( ) ;
private static final int WHICH_N = <num> ;
private static final int WHICH_VIEW_CONTACT = <num> ;
private static final int WHICH_CALL = <num> ;
private static final int WHICH_MARK_UNREAD = <num> ;
private static final int WHICH_REPLY = <num> ;
private static final int WHICH_FORWARD = <num> ;
private static final int WHICH_COPY_TEXT = <num> ;
private static final int WHICH_VIEW_DETAILS = <num> ;
private static final int WHICH_DELETE = <num> ;
private static String chooserPackage = null ;
private Uri uri ;
private Conversation conv = null ;
static final String URI = " ;
private final String [ ] longItemClickDialog = new String [ WHICH_N ] ;
private boolean markedUnread = false ;
private EditText etText ;
@SuppressWarnings("deprecation")
private ClipboardManager cbmgr ;
private boolean enableAutosend = true ;
private boolean showTextField = true ;
private boolean showPhoto = false ;
private Drawable defaultContactAvatar = null ;
private MyTextWatcher textWatcher ;
private MenuItem contactItem = null ;
private boolean showContactItem = false ;
private boolean needContactUpdate = false ;
private ListView getListView ( ) {
return ( ListView ) this . findViewById ( android . R . id . list ) ;
}
private void setListAdapter ( final ListAdapter la ) {
this . getListView ( ) . setAdapter ( la ) ;
}
@SuppressWarnings("deprecation")
@Override
public final void onCreate ( final Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( this ) ;
this . enableAutosend = p . getBoolean ( PreferencesActivity . PREFS_ENABLE_AUTOSEND , true ) ;
this . showTextField = this . enableAutosend
|| p . getBoolean ( PreferencesActivity . PREFS_SHOWTEXTFIELD , true ) ;
this . showPhoto = p . getBoolean ( PreferencesActivity . PREFS_CONTACT_PHOTO , true ) ;
final boolean hideSend = p . getBoolean ( PreferencesActivity . PREFS_HIDE_SEND , false ) ;
this . setTheme ( PreferencesActivity . getTheme ( this ) ) ;
Utils . setLocale ( this ) ;
this . setContentView ( R . layout . messagelist ) ;
Log . d ( TAG , " ) ;
if ( this . showPhoto ) {
this . defaultContactAvatar = this . getResources ( ) . getDrawable (
R . drawable . ic_contact_picture ) ;
}
if ( hideSend ) {
this . findViewById ( R . id . send_ ) . setVisibility ( View . GONE ) ;
}
this . cbmgr = ( ClipboardManager ) this . getSystemService ( CLIPBOARD_SERVICE ) ;
this . etText = ( EditText ) this . findViewById ( R . id . text ) ;
if ( ! this . showTextField ) {
this . findViewById ( R . id . <unk> ) . setVisibility ( View . GONE ) ;
}
this . parseIntent ( this . getIntent ( ) ) ;
final ListView list = this . getListView ( ) ;
list . setOnItemLongClickListener ( this ) ;
list . setOnItemClickListener ( this ) ;
View v = this . findViewById ( R . id . send_ ) ;
v . setOnClickListener ( this ) ;
v . setOnLongClickListener ( this ) ;
this . findViewById ( R . id . text_paste ) . setOnClickListener ( this ) ;
this . textWatcher = new MyTextWatcher ( this , ( TextView ) this . findViewById ( R . id . text_paste ) ,
( TextView ) this . findViewById ( R . id . text_ ) ) ;
this . etText . addTextChangedListener ( this . textWatcher ) ;
this . textWatcher . afterTextChanged ( this . etText . <unk> ( ) ) ;
this . longItemClickDialog [ WHICH_MARK_UNREAD ] = this . getString ( R . string . <unk> ) ;
this . longItemClickDialog [ WHICH_REPLY ] = this . getString ( R . string . reply ) ;
this . longItemClickDialog [ WHICH_FORWARD ] = this . getString ( R . string . forward_ ) ;
this . longItemClickDialog [ WHICH_COPY_TEXT ] = this . getString ( R . string . <unk> ) ;
this . longItemClickDialog [ WHICH_VIEW_DETAILS ] = this . getString ( R . string . view_details_ ) ;
this . longItemClickDialog [ WHICH_DELETE ] = this . getString ( R . string . delete_message_ ) ;
}
@Override
protected final void onStart ( ) {
super . onStart ( ) ;
this . getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ;
}
@Override
protected final void onNewIntent ( final Intent intent ) {
super . onNewIntent ( intent ) ;
this . parseIntent ( intent ) ;
}
private void parseIntent ( final Intent intent ) {
Log . d ( TAG , " + intent + " ) ;
if ( intent == null ) {
return ;
}
Log . d ( TAG , " + intent . getAction ( ) ) ;
Log . d ( TAG , " + intent . getData ( ) ) ;
this . needContactUpdate = true ;
this . uri = intent . getData ( ) ;
if ( this . uri != null ) {
if ( ! this . uri . toString ( ) . startsWith ( URI ) ) {
this . uri = Uri . parse ( URI + this . uri . getLastPathSegment ( ) ) ;
}
} else {
final long tid = intent . getLongExtra ( " ,  <num> ) ;
this . uri = Uri . parse ( URI + tid ) ;
if ( tid < <num> ) {
try {
this . startActivity ( ConversationListActivity . getComposeIntent ( this , null ) ) ;
} catch ( ActivityNotFoundException e ) {
Log . e ( TAG , " , e ) ;
Toast . makeText ( this , R . string . error_conv_null , Toast . LENGTH_LONG ) . show ( ) ;
}
this . finish ( ) ;
return ;
}
}
final int threadId = Integer . parseInt ( this . uri . getLastPathSegment ( ) ) ;
final Conversation c = Conversation . getConversation ( this , threadId , true ) ;
this . conv = c ;
if ( c == null ) {
Toast . makeText ( this , R . string . error_conv_null , Toast . LENGTH_LONG ) . show ( ) ;
this . finish ( ) ;
return ;
}
final Contact contact = c . getContact ( ) ;
contact . update ( this , false , true ) ;
Log . d ( TAG , " + contact . getNumber ( ) ) ;
Log . d ( TAG , " + contact . getName ( ) ) ;
Log . d ( TAG , " + contact . getDisplayName ( ) ) ;
final ListView lv = this . getListView ( ) ;
lv . <unk> ( true ) ;
MessageAdapter adapter = new MessageAdapter ( this , this . uri ) ;
this . setListAdapter ( adapter ) ;
String displayName = contact . getDisplayName ( ) ;
this . setTitle ( displayName ) ;
String number = contact . getNumber ( ) ;
if ( displayName . equals ( number ) ) {
this . getSupportActionBar ( ) . setSubtitle ( null ) ;
} else {
this . getSupportActionBar ( ) . setSubtitle ( number ) ;
}
this . setContactIcon ( contact ) ;
final String body = intent . getStringExtra ( Intent . EXTRA_TEXT ) ;
if ( ! TextUtils . isEmpty ( body ) ) {
this . etText . setText ( body ) ;
}
this . setRead ( ) ;
}
private void setContactIcon ( final Contact contact ) {
if ( contact == null ) {
Log . w ( TAG , " ) ;
this . showContactItem = false ;
return ;
}
final String name = contact . getName ( ) ;
this . showContactItem = this . showPhoto && name != null ;
if ( this . contactItem == null ) {
Log . w ( TAG , " ) ;
return ;
}
if ( ! this . needContactUpdate ) {
Log . i ( TAG , " ) ;
return ;
}
if ( this . showPhoto && name != null ) {
ImageView ivPhoto = ( ImageView ) this . findViewById ( R . id . photo ) ;
if ( ivPhoto == null ) {
ivPhoto = ( ImageView ) this . contactItem . getActionView ( ) . findViewById ( R . id . photo ) ;
}
if ( ivPhoto == null ) {
Log . w ( TAG , " ) ;
} else {
ivPhoto . setImageDrawable ( contact . getAvatar ( this , this . defaultContactAvatar ) ) ;
ivPhoto . setOnClickListener ( WRAPPER . getQuickContact ( this , ivPhoto ,
contact . getLookUpUri ( this . getContentResolver ( ) ) , <num> , null ) ) ;
}
ImageView ivPresence = ( ImageView ) this . findViewById ( R . id . presence ) ;
if ( ivPresence == null ) {
ivPresence = ( ImageView ) this . contactItem . getActionView ( ) . findViewById (
R . id . presence ) ;
}
if ( ivPresence == null ) {
Log . w ( TAG , " ) ;
} else {
if ( contact . getPresenceState ( ) > <num> ) {
ivPresence . setImageResource ( Contact . getPresenceRes ( contact . getPresenceState ( ) ) ) ;
ivPresence . setVisibility ( View . VISIBLE ) ;
} else {
ivPresence . setVisibility ( View . INVISIBLE ) ;
}
}
}
this . contactItem . setVisible ( this . showContactItem ) ;
this . needContactUpdate = false ;
}
@Override
protected final void onResume ( ) {
super . onResume ( ) ;
final ListView lv = this . getListView ( ) ;
lv . <unk> ( AbsListView . <unk> ) ;
lv . setAdapter ( new MessageAdapter ( this , this . uri ) ) ;
this . markedUnread = false ;
final Button btn = ( Button ) this . findViewById ( R . id . send_ ) ;
if ( this . showTextField ) {
final Intent i = this . buildIntent ( this . enableAutosend , false ) ;
final PackageManager pm = this . getPackageManager ( ) ;
ActivityInfo ai = null ;
if ( PreferenceManager . getDefaultSharedPreferences ( this ) . getBoolean (
PreferencesActivity . PREFS_SHOWTARGETAPP , true ) ) {
ai = i . resolveActivityInfo ( pm , <num> ) ;
}
if ( ai == null ) {
btn . setText ( null ) ;
this . etText . setMinLines ( <num> ) ;
} else {
if ( chooserPackage == null ) {
final ActivityInfo cai = this . buildIntent ( this . enableAutosend , true )
. resolveActivityInfo ( pm , <num> ) ;
if ( cai != null ) {
chooserPackage = cai . packageName ;
}
}
if ( ai . packageName . equals ( chooserPackage ) ) {
btn . setText ( R . string . <unk> ) ;
} else {
Log . d ( TAG , " + ai . packageName ) ;
btn . setText ( ai . loadLabel ( pm ) ) ;
}
this . etText . setMinLines ( <num> ) ;
}
} else {
btn . setText ( null ) ;
}
}
@Override
protected final void onPause ( ) {
super . onPause ( ) ;
if ( ! this . markedUnread ) {
this . setRead ( ) ;
}
}
private void setRead ( ) {
if ( this . conv != null ) {
ConversationListActivity . markRead ( this , this . conv . getUri ( ) , <num> ) ;
}
}
@Override
public final boolean onCreateOptionsMenu ( final Menu menu ) {
this . getMenuInflater ( ) . inflate ( R . menu . messagelist , menu ) ;
this . contactItem = menu . findItem ( R . id . item_contact ) ;
if ( this . conv != null ) {
this . setContactIcon ( this . conv . getContact ( ) ) ;
}
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( this ) ;
if ( p . getBoolean ( PreferencesActivity . PREFS_HIDE_RESTORE , false ) ) {
menu . removeItem ( R . id . item_restore ) ;
}
return true ;
}
@Override
public final boolean onOptionsItemSelected ( final MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
Intent intent = new Intent ( this , ConversationListActivity . class ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
this . startActivity ( intent ) ;
return true ;
case R . id . <unk> :
ConversationListActivity . deleteMessages ( this , this . uri , R . string . delete_thread_ ,
R . string . delete_thread_question , this ) ;
return true ;
case R . id . <unk> :
this . send ( true , false ) ;
return true ;
case R . id . <unk> :
this . startActivity ( new Intent ( Intent . ACTION_VIEW , Uri . parse ( "
+ this . conv . getContact ( ) . getNumber ( ) ) ) ) ;
return true ;
case R . id . item_restore :
this . etText . setText ( PreferenceManager . getDefaultSharedPreferences ( this ) . getString (
PreferencesActivity . PREFS_BACKUPLASTTEXT , null ) ) ;
return true ;
case R . id . item_contact :
if ( this . conv != null && this . contactItem != null ) {
WRAPPER . <unk> ( this , this . contactItem . getActionView ( ) , this . conv
. getContact ( ) . getLookUpUri ( this . getContentResolver ( ) ) , <num> , null ) ;
}
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
public final void onItemClick ( final AdapterView < ? > parent , final View view , final int position ,
final long id ) {
this . onItemLongClick ( parent , view , position , id ) ;
}
public final boolean onItemLongClick ( final AdapterView < ? > parent , final View view ,
final int position , final long id ) {
final Context context = this ;
final Message m = Message . getMessage ( this , ( Cursor ) parent . getItemAtPosition ( position ) ) ;
final Uri target = m . getUri ( ) ;
final int read = m . getRead ( ) ;
final int type = m . getType ( ) ;
Builder builder = new Builder ( context ) ;
builder . setTitle ( R . string . <unk> ) ;
final Contact contact = this . conv . getContact ( ) ;
final String a = contact . getNumber ( ) ;
Log . d ( TAG , " + a ) ;
final String n = contact . getName ( ) ;
String [ ] items = this . longItemClickDialog ;
if ( TextUtils . isEmpty ( n ) ) {
items [ WHICH_VIEW_CONTACT ] = this . getString ( R . string . add_contact_ ) ;
} else {
items [ WHICH_VIEW_CONTACT ] = this . getString ( R . string . view_contact_ ) ;
}
items [ WHICH_CALL ] = this . getString ( R . string . call ) + " + contact . getDisplayName ( ) ;
if ( read == <num> ) {
items = items . clone ( ) ;
items [ WHICH_MARK_UNREAD ] = context . getString ( R . string . <unk> ) ;
}
if ( type == Message . SMS_DRAFT ) {
items = items . clone ( ) ;
items [ WHICH_FORWARD ] = context . getString ( R . string . send_draft_ ) ;
}
builder . setItems ( items , new DialogInterface . OnClickListener ( ) {
@SuppressWarnings("deprecation")
@Override
public void onClick ( final DialogInterface dialog , final int which ) {
Intent i = null ;
switch ( which ) {
case WHICH_VIEW_CONTACT :
if ( n == null ) {
i = ContactsWrapper . getInstance ( ) . getInsertPickIntent ( a ) ;
Conversation . flushCache ( ) ;
} else {
final Uri u = MessageListActivity . this . conv . getContact ( ) . getUri ( ) ;
i = new Intent ( Intent . ACTION_VIEW , u ) ;
}
MessageListActivity . this . startActivity ( i ) ;
break ;
case WHICH_CALL :
MessageListActivity . this . startActivity ( new Intent ( Intent . ACTION_VIEW , Uri
. parse ( " + a ) ) ) ;
break ;
case WHICH_MARK_UNREAD :
ConversationListActivity . markRead ( context , target , <num>  read ) ;
MessageListActivity . this . markedUnread = true ;
break ;
case WHICH_REPLY :
MessageListActivity . this . startActivity ( ConversationListActivity
. getComposeIntent ( MessageListActivity . this , a ) ) ;
break ;
case WHICH_FORWARD :
int resId ;
if ( type == Message . SMS_DRAFT ) {
resId = R . string . send_draft_ ;
i = ConversationListActivity . getComposeIntent ( MessageListActivity . this ,
MessageListActivity . this . conv . getContact ( ) . getNumber ( ) ) ;
} else {
resId = R . string . forward_ ;
i = new Intent ( Intent . ACTION_SEND ) ;
i . setType ( " ) ;
i . putExtra ( " , true ) ;
}
CharSequence text = null ;
if ( PreferencesActivity . decodeDecimalNCR ( context ) ) {
text = Converter . convertDecNCR2Char ( m . getBody ( ) ) ;
} else {
text = m . getBody ( ) ;
}
i . putExtra ( Intent . EXTRA_TEXT , text ) ;
i . putExtra ( " , text ) ;
context . startActivity ( Intent . createChooser ( i , context . getString ( resId ) ) ) ;
break ;
case WHICH_COPY_TEXT :
final ClipboardManager cm = ( ClipboardManager ) context
. getSystemService ( Context . CLIPBOARD_SERVICE ) ;
if ( PreferencesActivity . decodeDecimalNCR ( context ) ) {
cm . setText ( Converter . convertDecNCR2Char ( m . getBody ( ) ) ) ;
} else {
cm . setText ( m . getBody ( ) ) ;
}
break ;
case WHICH_VIEW_DETAILS :
final int t = m . getType ( ) ;
Builder b = new Builder ( context ) ;
b . setTitle ( R . string . view_details_ ) ;
b . setCancelable ( true ) ;
StringBuilder sb = new StringBuilder ( ) ;
final String a = m . getAddress ( context ) ;
final long d = m . getDate ( ) ;
final String ds = DateFormat . format (
context . getString ( R . string . <unk> ) , d ) . toString ( ) ;
String sentReceived ;
String fromTo ;
if ( t == Calls . INCOMING_TYPE ) {
sentReceived = context . getString ( R . string . <unk> ) ;
fromTo = context . getString ( R . string . <unk> ) ;
} else if ( t == Calls . OUTGOING_TYPE ) {
sentReceived = context . getString ( R . string . <unk> ) ;
fromTo = context . getString ( R . string . <unk> ) ;
} else {
sentReceived = " ;
fromTo = " ;
}
sb . append ( sentReceived + " ) ;
sb . append ( ds ) ;
sb . append ( " ) ;
sb . append ( fromTo + " ) ;
sb . append ( a ) ;
sb . append ( " ) ;
sb . append ( context . getString ( R . string . <unk> ) ) ;
if ( m . isMMS ( ) ) {
sb . append ( " ) ;
} else {
sb . append ( " ) ;
}
b . setMessage ( sb . toString ( ) ) ;
b . setPositiveButton ( android . R . string . ok , null ) ;
b . show ( ) ;
break ;
case WHICH_DELETE :
ConversationListActivity . deleteMessages ( context , target ,
R . string . delete_message_ , R . string . <unk> , null ) ;
break ;
default :
break ;
}
}
} ) ;
builder . show ( ) ;
return true ;
}
@SuppressWarnings("deprecation")
public final void onClick ( final View v ) {
switch ( v . getId ( ) ) {
case R . id . send_ :
this . send ( true , false ) ;
return ;
case R . id . text_paste :
final CharSequence s = this . cbmgr . getText ( ) ;
this . etText . setText ( s ) ;
return ;
default :
return ;
}
}
public final boolean onLongClick ( final View v ) {
switch ( v . getId ( ) ) {
case R . id . send_ :
this . send ( false , true ) ;
return true ;
default :
return true ;
}
}
private Intent buildIntent ( final boolean autosend , final boolean showChooser ) {
final String text = this . etText . getText ( ) . toString ( ) . trim ( ) ;
final Intent i = ConversationListActivity . getComposeIntent ( this , this . conv . getContact ( )
. getNumber ( ) ) ;
i . putExtra ( Intent . EXTRA_TEXT , text ) ;
i . putExtra ( " , text ) ;
if ( autosend && this . enableAutosend && text . length ( ) > <num> ) {
i . putExtra ( " , " ) ;
}
if ( showChooser ) {
return Intent . createChooser ( i , this . getString ( R . string . reply ) ) ;
} else {
return i ;
}
}
private void send ( final boolean autosend , final boolean showChooser ) {
final Intent i = this . buildIntent ( autosend , showChooser ) ;
this . startActivity ( i ) ;
PreferenceManager
. getDefaultSharedPreferences ( this )
. edit ( )
. putString ( PreferencesActivity . PREFS_BACKUPLASTTEXT ,
this . etText . getText ( ) . toString ( ) ) . commit ( ) ;
this . etText . setText ( " ) ;
}
}
package de . ub0r . android . smsdroid ;
import android . app . Activity ;
import android . content . Context ;
import android . content . Intent ;
import android . os . Bundle ;
import android . preference . PreferenceActivity ;
import android . view . MenuItem ;
import de . ub0r . android . lib . IPreferenceContainer ;
public final class <unk> extends PreferenceActivity implements
IPreferenceContainer {
@Override
public void onCreate ( final Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . addPreferencesFromResource ( R . xml . <unk> ) ;
PreferencesActivity . registerOnPreferenceClickListener ( this ) ;
}
@Override
public boolean onOptionsItemSelected ( final MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
Intent intent = new Intent ( this , ConversationListActivity . class ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
this . startActivity ( intent ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
@Override
public Activity getActivity ( ) {
return this ;
}
@Override
public Context getContext ( ) {
return this ;
}
}
package de . ub0r . android . smsdroid ;
import android . app . Application ;
import android . content . ActivityNotFoundException ;
import android . content . ComponentName ;
import android . content . Context ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . content . pm . PackageManager ;
import android . database . Cursor ;
import android . preference . PreferenceManager ;
import android . telephony . SmsManager ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . view . View . OnLongClickListener ;
import android . widget . Toast ;
import de . ub0r . android . lib . Log ;
public final class SMSdroid extends Application {
private static final String TAG = " ;
private static final String [ ] PROJECTION = new String [ ] { " } ;
@Override
public void onCreate ( ) {
super . onCreate ( ) ;
Log . init ( " ) ;
Log . i ( TAG , " + this . getString ( R . string . app_version ) ) ;
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( this ) ;
int state = PackageManager . COMPONENT_ENABLED_STATE_DISABLED ;
if ( p . getBoolean ( PreferencesActivity . PREFS_ACTIVATE_SENDER , true ) ) {
try {
Cursor c = this . getContentResolver ( ) . query ( SenderActivity . URI_SENT , PROJECTION ,
null , null , " ) ;
if ( c == null ) {
Log . i ( TAG , " ) ;
} else if ( SmsManager . getDefault ( ) == null ) {
Log . i ( TAG , " ) ;
} else {
state = PackageManager . COMPONENT_ENABLED_STATE_ENABLED ;
Log . d ( TAG , " ) ;
}
if ( c != null && ! c . isClosed ( ) ) {
c . close ( ) ;
}
} catch ( IllegalArgumentException e ) {
Log . e ( TAG , " + e . getMessage ( ) , e ) ;
}
} else {
Log . i ( TAG , " ) ;
}
this . getPackageManager ( ) . setComponentEnabledSetting (
new ComponentName ( this , SenderActivity . class ) , state , PackageManager . DONT_KILL_APP ) ;
}
static OnClickListener getOnClickStartActivity ( final Context context , final Intent intent ) {
if ( intent == null ) {
return null ;
}
return new OnClickListener ( ) {
@Override
public void onClick ( final View v ) {
try {
context . startActivity ( intent ) ;
} catch ( ActivityNotFoundException e ) {
Log . w ( TAG , " , e ) ;
Toast . makeText ( context , " + intent . getType ( ) ,
Toast . LENGTH_LONG ) . show ( ) ;
}
}
} ;
}
static OnLongClickListener <unk> ( final Context context ,
final Intent intent ) {
if ( intent == null ) {
return null ;
}
return new OnLongClickListener ( ) {
@Override
public boolean onLongClick ( final View v ) {
try {
context . startActivity ( intent ) ;
return true ;
} catch ( ActivityNotFoundException e ) {
Log . w ( TAG , " , e ) ;
Toast . makeText ( context , " + intent . getType ( ) ,
Toast . LENGTH_LONG ) . show ( ) ;
}
return false ;
}
} ;
}
}
package de . ub0r . android . smsdroid ;
import android . content . Context ;
import android . preference . PreferenceManager ;
import android . text . ClipboardManager ;
import android . text . Editable ;
import android . text . TextWatcher ;
import android . view . View ;
import android . widget . TextView ;
import de . ub0r . android . lib . apis . TelephonyWrapper ;
public final class MyTextWatcher implements TextWatcher {
public static final TelephonyWrapper TWRAPPER = TelephonyWrapper . getInstance ( ) ;
private static final int TEXT_LABLE_MIN_LEN = <num> ;
private final Context context ;
private final ClipboardManager cbmgr ;
private final TextView tvTextLabel ;
private final TextView tvPaste ;
public MyTextWatcher ( final Context ctx , final TextView paste , final TextView label ) {
this . context = ctx ;
this . tvTextLabel = label ;
this . tvPaste = paste ;
this . cbmgr = ( ClipboardManager ) this . context . getSystemService ( Context . CLIPBOARD_SERVICE ) ;
}
public void afterTextChanged ( final Editable s ) {
final int len = s . length ( ) ;
if ( len == <num> ) {
if ( this . cbmgr . hasText ( )
&& ! PreferenceManager . getDefaultSharedPreferences ( this . context ) . getBoolean (
PreferencesActivity . PREFS_HIDE_PASTE , false ) ) {
this . tvPaste . setVisibility ( View . VISIBLE ) ;
} else {
this . tvPaste . setVisibility ( View . GONE ) ;
}
this . tvTextLabel . setVisibility ( View . GONE ) ;
} else {
this . tvPaste . setVisibility ( View . GONE ) ;
if ( len > TEXT_LABLE_MIN_LEN ) {
this . tvTextLabel . setVisibility ( View . VISIBLE ) ;
int [ ] l = TWRAPPER . calculateLength ( s . toString ( ) , false ) ;
this . tvTextLabel . setText ( l [ <num> ] + " + l [ <num> ] ) ;
} else {
this . tvTextLabel . setVisibility ( View . GONE ) ;
}
}
}
public void beforeTextChanged ( final CharSequence s , final int start , final int count ,
final int after ) {
}
public void onTextChanged ( final CharSequence s , final int start , final int before ,
final int count ) {
}
}
package de . ub0r . android . smsdroid ;
import java . util . HashMap ;
import java . util . regex . Matcher ;
import java . util . regex . Pattern ;
import android . content . Context ;
import android . text . SpannableStringBuilder ;
import android . text . Spanned ;
import android . text . style . ImageSpan ;
public final class SmileyParser {
private static SmileyParser sInstance ;
public static SmileyParser getInstance ( final Context context ) {
if ( sInstance == null ) {
sInstance = new SmileyParser ( context ) ;
}
return sInstance ;
}
private final Context mContext ;
private final String [ ] mSmileyTexts ;
private final Pattern mPattern ;
private final HashMap < String , Integer > mSmileyToRes ;
private SmileyParser ( final Context context ) {
this . mContext = context ;
this . mSmileyTexts = this . mContext . getResources ( ) . getStringArray ( R . array . <unk> ) ;
this . mSmileyToRes = this . buildSmileyToRes ( ) ;
this . mPattern = this . buildPattern ( ) ;
}
public static final int [ ] DEFAULT_SMILEY_RES_IDS = { R . drawable . emo_im_angel ,
R . drawable . emo_im_cool ,
R . drawable . emo_im_cool ,
R . drawable . emo_im_crying ,
R . drawable . emo_im_crying ,
R . drawable . emo_im_foot_in_mouth ,
R . drawable . emo_im_happy ,
R . drawable . emo_im_happy ,
R . drawable . emo_im_kissing ,
R . drawable . emo_im_kissing ,
R . drawable . emo_im_laughing ,
R . drawable . emo_im_laughing ,
R . drawable . emo_im_lips_are_sealed ,
R . drawable . emo_im_lips_are_sealed ,
R . drawable . emo_im_lips_are_sealed ,
R . drawable . emo_im_money_mouth ,
R . drawable . emo_im_sad ,
R . drawable . emo_im_sad ,
R . drawable . emo_im_surprised ,
R . drawable . emo_im_tongue_sticking_out ,
R . drawable . emo_im_tongue_sticking_out ,
R . drawable . emo_im_tongue_sticking_out ,
R . drawable . emo_im_undecided ,
R . drawable . emo_im_winking ,
R . drawable . emo_im_winking ,
R . drawable . emo_im_wtf ,
R . drawable . emo_im_yelling ,
} ;
private HashMap < String , Integer > buildSmileyToRes ( ) {
if ( DEFAULT_SMILEY_RES_IDS . length != this . mSmileyTexts . length ) {
throw new IllegalStateException ( " ) ;
}
HashMap < String , Integer > smileyToRes = new HashMap < String , Integer > (
this . mSmileyTexts . length ) ;
for ( int i = <num> ; i < this . mSmileyTexts . length ; i ++ ) {
smileyToRes . put ( this . mSmileyTexts [ i ] , DEFAULT_SMILEY_RES_IDS [ i ] ) ;
}
return smileyToRes ;
}
private Pattern buildPattern ( ) {
StringBuilder patternString = new StringBuilder ( this . mSmileyTexts . length * <num> ) ;
patternString . append ( (' ) ;
for ( String s : this . mSmileyTexts ) {
patternString . append ( Pattern . quote ( s ) ) ;
patternString . append ( |' ) ;
}
patternString . replace ( patternString . length ( )  <num> , patternString . length ( ) , " ) ;
return Pattern . compile ( patternString . toString ( ) ) ;
}
public CharSequence addSmileySpans ( final CharSequence text ) {
SpannableStringBuilder builder = new SpannableStringBuilder ( text ) ;
Matcher matcher = this . mPattern . matcher ( text ) ;
while ( matcher . find ( ) ) {
int resId = this . mSmileyToRes . get ( matcher . group ( ) ) ;
builder . setSpan ( new ImageSpan ( this . mContext , resId ) , matcher . start ( ) , matcher . end ( ) ,
Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ;
}
return builder ;
}
}
package de . ub0r . android . smsdroid ;
import java . util . List ;
import android . app . Activity ;
import android . content . Context ;
import android . os . Bundle ;
import android . preference . PreferenceActivity ;
import de . ub0r . android . lib . IPreferenceContainer ;
import de . ub0r . android . lib . Utils ;
public final class Preferences11Activity extends PreferenceActivity implements IPreferenceContainer {
@Override
public void onCreate ( final Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . setTitle ( R . string . settings ) ;
Utils . setLocale ( this ) ;
}
@Override
public void onBuildHeaders ( final List < Header > target ) {
this . loadHeadersFromResource ( R . xml . <unk> , target ) ;
}
@Override
public Activity getActivity ( ) {
return this ;
}
@Override
public Context getContext ( ) {
return this ;
}
}
package de . ub0r . android . smsdroid ;
import java . util . concurrent . RejectedExecutionException ;
import android . content . Context ;
import android . os . AsyncTask ;
import de . ub0r . android . lib . Log ;
public final class AsyncHelper extends AsyncTask < Void , Void , Void > {
static final String TAG = " ;
private static ConversationAdapter adapter = null ;
private final Context context ;
private final Conversation conv ;
private boolean changed = false ;
private AsyncHelper ( final Context c , final Conversation con ) {
this . context = c ;
this . conv = con ;
}
public static void fillConversation ( final Context context , final Conversation c ,
final boolean sync ) {
Log . d ( TAG , " + sync + " ) ;
if ( context == null || c == null || c . getThreadId ( ) < <num> ) {
return ;
}
AsyncHelper helper = new AsyncHelper ( context , c ) ;
if ( sync ) {
helper . doInBackground ( ( Void ) null ) ;
} else {
try {
helper . execute ( ( Void ) null ) ;
} catch ( RejectedExecutionException e ) {
Log . e ( TAG , " , e ) ;
}
}
}
@Override
protected Void doInBackground ( final Void . . . arg0 ) {
if ( this . conv == null ) {
return null ;
}
Log . d ( TAG , " ) ;
this . changed = this . conv . getContact ( ) . update ( this . context , true ,
ConversationListActivity . showContactPhoto ) ;
return null ;
}
@Override
protected void onPostExecute ( final Void result ) {
if ( this . changed && adapter != null ) {
adapter . notifyDataSetChanged ( ) ;
}
}
public static void setAdapter ( final ConversationAdapter a ) {
adapter = a ;
}
}
package de . ub0r . android . smsdroid ;
import android . content . ContentValues ;
import android . content . Context ;
import android . database . Cursor ;
import android . database . sqlite . SQLiteDatabase ;
import android . database . sqlite . SQLiteOpenHelper ;
import de . ub0r . android . lib . Log ;
public final class SpamDB {
private static final String TAG = " ;
private static final String DATABASE_NAME = " ;
private static final int DATABASE_VERSION = <num> ;
private static final String DATABASE_TABLE = " ;
public static final String KEY_NR = " ;
public static final String [ ] PROJECTION = new String [ ] { KEY_NR } ;
private static final String DATABASE_CREATE = " ;
private DatabaseHelper dbHelper ;
private SQLiteDatabase db ;
public SpamDB ( final Context context ) {
this . dbHelper = new DatabaseHelper ( context ) ;
}
private static class DatabaseHelper extends SQLiteOpenHelper {
DatabaseHelper ( final Context context ) {
super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ;
}
@Override
public void onCreate ( final SQLiteDatabase db ) {
db . execSQL ( DATABASE_CREATE ) ;
}
@Override
public void onUpgrade ( final SQLiteDatabase db , final int oldVersion , final int newVersion ) {
Log . w ( TAG , " + oldVersion + " + newVersion
+ " ) ;
db . execSQL ( " ) ;
this . onCreate ( db ) ;
}
}
public SpamDB open ( ) {
this . db = this . dbHelper . getWritableDatabase ( ) ;
return this ;
}
public void close ( ) {
this . dbHelper . close ( ) ;
}
public long insertNr ( final String nr ) {
if ( nr == null ) {
return  <num> ;
}
ContentValues initialValues = new ContentValues ( ) ;
initialValues . put ( KEY_NR , nr ) ;
return this . db . insert ( DATABASE_TABLE , null , initialValues ) ;
}
public boolean isInDB ( final String nr ) {
Log . d ( TAG , " + nr + " ) ;
if ( nr == null ) {
return false ;
}
final Cursor cursor = this . db . query ( DATABASE_TABLE , PROJECTION , KEY_NR + " ,
new String [ ] { nr } , null , null , null ) ;
final boolean ret = cursor . moveToFirst ( ) ;
if ( ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
return ret ;
}
public int <unk> ( ) {
final Cursor cursor = this . db . rawQuery ( " + DATABASE_TABLE , null ) ;
Log . d ( TAG , cursor . toString ( ) ) ;
int ret = <num> ;
if ( cursor . moveToFirst ( ) ) {
ret = cursor . getInt ( <num> ) ;
}
if ( ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
return ret ;
}
public String [ ] getAllEntries ( ) {
final Cursor cursor = this . db . query ( DATABASE_TABLE , PROJECTION , null , null , null , null ,
null ) ;
if ( cursor == null ) {
return null ;
}
final String [ ] ret = new String [ cursor . getCount ( ) ] ;
if ( cursor . moveToFirst ( ) ) {
int i = <num> ;
do {
ret [ i ] = cursor . getString ( <num> ) ;
Log . d ( TAG , " + ret [ i ] ) ;
++ i ;
} while ( cursor . moveToNext ( ) ) ;
}
if ( ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
return ret ;
}
public void removeNr ( final String nr ) {
if ( nr == null ) {
return ;
}
this . db . delete ( DATABASE_TABLE , KEY_NR + " , new String [ ] { nr } ) ;
}
}
package de . ub0r . android . smsdroid ;
import java . util . Calendar ;
import java . util . HashSet ;
import java . util . List ;
import android . app . Activity ;
import android . app . AlertDialog . Builder ;
import android . content . ActivityNotFoundException ;
import android . content . ContentResolver ;
import android . content . ContentValues ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . content . pm . ResolveInfo ;
import android . database . Cursor ;
import android . net . Uri ;
import android . os . Build ;
import android . os . Bundle ;
import android . preference . PreferenceManager ;
import android . support . v4 . app . FragmentActivity ;
import android . text . TextUtils ;
import android . text . format . DateFormat ;
import android . view . Menu ;
import android . view . MenuItem ;
import android . view . View ;
import android . view . Window ;
import android . widget . AbsListView ;
import android . widget . AdapterView ;
import android . widget . AdapterView . OnItemClickListener ;
import android . widget . AdapterView . OnItemLongClickListener ;
import android . widget . GridView ;
import android . widget . ListAdapter ;
import android . widget . ListView ;
import android . widget . Toast ;
import de . ub0r . android . lib . ChangelogHelper ;
import de . ub0r . android . lib . DonationHelper ;
import de . ub0r . android . lib . Log ;
import de . ub0r . android . lib . Market ;
import de . ub0r . android . lib . Utils ;
import de . ub0r . android . lib . apis . Contact ;
import de . ub0r . android . lib . apis . ContactsWrapper ;
public final class ConversationListActivity extends FragmentActivity implements
OnItemClickListener , OnItemLongClickListener {
public static final String TAG = " ;
private static final String AD_UNITID = " ;
public static final HashSet < String > AD_KEYWORDS = new HashSet < String > ( ) ;
static {
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
AD_KEYWORDS . add ( " ) ;
}
static final Uri URI = Uri . parse ( " ) ;
private static final int WHICH_N = <num> ;
private static final int WHICH_ANSWER = <num> ;
private static final int WHICH_CALL = <num> ;
private static final int WHICH_VIEW_CONTACT = <num> ;
private static final int WHICH_VIEW = <num> ;
private static final int WHICH_DELETE = <num> ;
private static final int WHICH_MARK_SPAM = <num> ;
private static boolean prefsNoAds = false ;
public static final long MIN_DATE = <num> ;
public static final long MILLIS = <num> ;
public static boolean showContactPhoto = false ;
public static boolean showEmoticons = false ;
private String [ ] longItemClickDialog = null ;
private ConversationAdapter adapter = null ;
private static final Calendar CAL_DAYAGO = Calendar . getInstance ( ) ;
static {
CAL_DAYAGO . add ( Calendar . DAY_OF_MONTH ,  <num> ) ;
}
@Override
public void onStart ( ) {
super . onStart ( ) ;
AsyncHelper . setAdapter ( this . adapter ) ;
}
@Override
public void onStop ( ) {
super . onStop ( ) ;
AsyncHelper . setAdapter ( null ) ;
}
private AbsListView getListView ( ) {
return ( AbsListView ) this . findViewById ( android . R . id . list ) ;
}
private void setListAdapter ( final ListAdapter la ) {
AbsListView v = this . getListView ( ) ;
if ( v instanceof GridView ) {
( ( GridView ) v ) . setAdapter ( la ) ;
} else if ( v instanceof ListView ) {
( ( ListView ) v ) . setAdapter ( la ) ;
}
}
static void showRows ( final Context context , final Uri u ) {
Log . d ( TAG , " ) ;
Log . d ( TAG , " + u . toString ( ) + " ) ;
Cursor c = context . getContentResolver ( ) . query ( u , null , null , null , null ) ;
if ( c != null ) {
int l = c . getColumnCount ( ) ;
StringBuilder buf = new StringBuilder ( ) ;
for ( int i = <num> ; i < l ; i ++ ) {
buf . append ( i + " ) ;
buf . append ( c . getColumnName ( i ) ) ;
buf . append ( " ) ;
}
Log . d ( TAG , buf . toString ( ) ) ;
}
}
static void showRows ( final Context context ) {
}
@Override
public void onNewIntent ( final Intent intent ) {
final Intent i = intent ;
if ( i != null ) {
Log . d ( TAG , " + i . getAction ( ) ) ;
Log . d ( TAG , " + i . getData ( ) ) ;
final Bundle b = i . getExtras ( ) ;
if ( b != null ) {
Log . d ( TAG , " + b . get ( " ) ) ;
Log . d ( TAG , " + b ) ;
}
final String query = i . getStringExtra ( " ) ;
Log . d ( TAG , " + query ) ;
}
}
@Override
public void onCreate ( final Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . requestWindowFeature ( Window . FEATURE_INDETERMINATE_PROGRESS ) ;
final Intent i = this . getIntent ( ) ;
Log . d ( TAG , " + i . getAction ( ) ) ;
Log . d ( TAG , " + i . getData ( ) ) ;
Log . d ( TAG , " + i . getExtras ( ) ) ;
this . setTheme ( PreferencesActivity . getTheme ( this ) ) ;
Utils . setLocale ( this ) ;
if ( PreferenceManager . getDefaultSharedPreferences ( this ) . getBoolean ( " , false ) ) {
this . setContentView ( R . layout . <unk> ) ;
} else {
this . setContentView ( R . layout . conversationlist ) ;
}
ChangelogHelper . <unk> ( this , true ) ;
final List < ResolveInfo > ri = this . getPackageManager ( ) . queryBroadcastReceivers (
new Intent ( " ) , <num> ) ;
if ( ri . size ( ) == <num> ) {
final Intent intent = Market . <unk> ( this , " ,
Market . <unk> ) ;
ChangelogHelper . showNotes ( this , true , " , null , intent ) ;
} else {
ChangelogHelper . showNotes ( this , true , null , null , null ) ;
}
showRows ( this ) ;
final AbsListView list = this . getListView ( ) ;
this . adapter = new ConversationAdapter ( this ) ;
this . setListAdapter ( this . adapter ) ;
list . setOnItemClickListener ( this ) ;
list . setOnItemLongClickListener ( this ) ;
this . longItemClickDialog = new String [ WHICH_N ] ;
this . longItemClickDialog [ WHICH_ANSWER ] = this . getString ( R . string . reply ) ;
this . longItemClickDialog [ WHICH_CALL ] = this . getString ( R . string . call ) ;
this . longItemClickDialog [ WHICH_VIEW_CONTACT ] = this . getString ( R . string . view_contact_ ) ;
this . longItemClickDialog [ WHICH_VIEW ] = this . getString ( R . string . <unk> ) ;
this . longItemClickDialog [ WHICH_DELETE ] = this . getString ( R . string . delete_thread_ ) ;
this . longItemClickDialog [ WHICH_MARK_SPAM ] = this . getString ( R . string . <unk> ) ;
}
@Override
protected void onResume ( ) {
super . onResume ( ) ;
prefsNoAds = DonationHelper . <unk> ( this ) ;
if ( ! prefsNoAds ) {
Ads . loadAd ( this , R . id . ad , AD_UNITID , AD_KEYWORDS ) ;
}
CAL_DAYAGO . setTimeInMillis ( System . currentTimeMillis ( ) ) ;
CAL_DAYAGO . add ( Calendar . DAY_OF_MONTH ,  <num> ) ;
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( this ) ;
showContactPhoto = p . getBoolean ( PreferencesActivity . PREFS_CONTACT_PHOTO , true ) ;
showEmoticons = p . getBoolean ( PreferencesActivity . PREFS_EMOTICONS , false ) ;
this . adapter . startMsgListQuery ( ) ;
}
@Override
public boolean onCreateOptionsMenu ( final Menu menu ) {
this . getMenuInflater ( ) . inflate ( R . menu . conversationlist , menu ) ;
if ( prefsNoAds ) {
menu . removeItem ( R . id . item_donate ) ;
}
return true ;
}
static void markRead ( final Context context , final Uri uri , final int read ) {
Log . d ( TAG , " + uri + " + read + " ) ;
if ( uri == null ) {
return ;
}
String [ ] sel = Message . SELECTION_UNREAD ;
if ( read == <num> ) {
sel = Message . SELECTION_READ ;
}
final ContentResolver cr = context . getContentResolver ( ) ;
final ContentValues cv = new ContentValues ( ) ;
cv . put ( Message . PROJECTION [ Message . INDEX_READ ] , read ) ;
try {
cr . update ( uri , cv , Message . SELECTION_READ_UNREAD , sel ) ;
} catch ( IllegalArgumentException e ) {
Log . e ( TAG , " , e ) ;
Toast . makeText ( context , e . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ;
}
SmsReceiver . updateNewMessageNotification ( context , null ) ;
}
static void deleteMessages ( final Context context , final Uri uri , final int title ,
final int message , final Activity activity ) {
Log . i ( TAG , " + uri + " ) ;
final Builder builder = new Builder ( context ) ;
builder . setTitle ( title ) ;
builder . setMessage ( message ) ;
builder . setNegativeButton ( android . R . string . no , null ) ;
builder . setPositiveButton ( android . R . string . yes , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( final DialogInterface dialog , final int which ) {
final int ret = context . getContentResolver ( ) . delete ( uri , null , null ) ;
Log . d ( TAG , " + ret ) ;
if ( activity != null && ! activity . isFinishing ( ) ) {
activity . finish ( ) ;
}
if ( ret > <num> ) {
Conversation . flushCache ( ) ;
Message . flushCache ( ) ;
SmsReceiver . updateNewMessageNotification ( context , null ) ;
}
}
} ) ;
builder . show ( ) ;
}
private static void addToOrRemoveFromSpamlist ( final Context context , final String addr ) {
final SpamDB db = new SpamDB ( context ) ;
db . open ( ) ;
if ( ! db . isInDB ( addr ) ) {
db . insertNr ( addr ) ;
Log . d ( TAG , " + addr + " ) ;
} else {
db . removeNr ( addr ) ;
Log . d ( TAG , " + addr + " ) ;
}
db . close ( ) ;
}
@Override
public boolean onOptionsItemSelected ( final MenuItem item ) {
switch ( item . getItemId ( ) ) {
case R . id . <unk> :
final Intent i = getComposeIntent ( this , null ) ;
try {
this . startActivity ( i ) ;
} catch ( ActivityNotFoundException e ) {
Log . e ( TAG , " + i . getAction ( ) + " + i . getData ( ) ) ;
Toast . makeText ( this ,
" + " ,
Toast . LENGTH_LONG ) . show ( ) ;
}
return true ;
case R . id . <unk> :
if ( Utils . isApi ( Build . VERSION_CODES . HONEYCOMB ) ) {
this . startActivity ( new Intent ( this , Preferences11Activity . class ) ) ;
} else {
this . startActivity ( new Intent ( this , PreferencesActivity . class ) ) ;
}
return true ;
case R . id . item_donate :
DonationHelper . <unk> ( this , true ) ;
return true ;
case R . id . <unk> :
deleteMessages ( this , Uri . parse ( " ) , R . string . <unk> ,
R . string . <unk> , null ) ;
return true ;
case R . id . <unk> :
markRead ( this , Uri . parse ( " ) , <num> ) ;
markRead ( this , Uri . parse ( " ) , <num> ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
static Intent getComposeIntent ( final Context context , final String address ) {
final Intent i = new Intent ( Intent . ACTION_SENDTO ) ;
i . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ;
if ( address == null ) {
i . setData ( Uri . parse ( " ) ) ;
} else {
i . setData ( Uri . parse ( " + PreferencesActivity . fixNumber ( context , address ) ) ) ;
}
return i ;
}
public void onItemClick ( final AdapterView < ? > parent , final View view , final int position ,
final long id ) {
final Conversation c = Conversation . getConversation ( this ,
( Cursor ) parent . getItemAtPosition ( position ) , false ) ;
final Uri target = c . getUri ( ) ;
final Intent i = new Intent ( this , MessageListActivity . class ) ;
i . setData ( target ) ;
try {
this . startActivity ( i ) ;
} catch ( ActivityNotFoundException e ) {
Log . e ( TAG , " + i . getAction ( ) + " + i . getData ( ) ) ;
Toast . makeText ( this ,
" + " ,
Toast . LENGTH_LONG ) . show ( ) ;
}
}
public boolean onItemLongClick ( final AdapterView < ? > parent , final View view ,
final int position , final long id ) {
final Conversation c = Conversation . getConversation ( this ,
( Cursor ) parent . getItemAtPosition ( position ) , true ) ;
final Uri target = c . getUri ( ) ;
Builder builder = new Builder ( this ) ;
String [ ] items = this . longItemClickDialog ;
final Contact contact = c . getContact ( ) ;
final String a = contact . getNumber ( ) ;
Log . d ( TAG , " + a ) ;
final String n = contact . getName ( ) ;
if ( TextUtils . isEmpty ( n ) ) {
builder . setTitle ( a ) ;
items = items . clone ( ) ;
items [ WHICH_VIEW_CONTACT ] = this . getString ( R . string . add_contact_ ) ;
} else {
builder . setTitle ( n ) ;
}
final SpamDB db = new SpamDB ( this . getApplicationContext ( ) ) ;
db . open ( ) ;
if ( db . isInDB ( a ) ) {
items = items . clone ( ) ;
items [ WHICH_MARK_SPAM ] = this . getString ( R . string . <unk> ) ;
}
db . close ( ) ;
builder . setItems ( items , new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( final DialogInterface dialog , final int which ) {
Intent i = null ;
switch ( which ) {
case WHICH_ANSWER :
ConversationListActivity . this . startActivity ( getComposeIntent (
ConversationListActivity . this , a ) ) ;
break ;
case WHICH_CALL :
i = new Intent ( Intent . ACTION_VIEW , Uri . parse ( " + a ) ) ;
ConversationListActivity . this . startActivity ( i ) ;
break ;
case WHICH_VIEW_CONTACT :
if ( n == null ) {
i = ContactsWrapper . getInstance ( ) . getInsertPickIntent ( a ) ;
Conversation . flushCache ( ) ;
} else {
final Uri uri = c . getContact ( ) . getUri ( ) ;
i = new Intent ( Intent . ACTION_VIEW , uri ) ;
}
ConversationListActivity . this . startActivity ( i ) ;
break ;
case WHICH_VIEW :
i = new Intent ( ConversationListActivity . this , MessageListActivity . class ) ;
i . setData ( target ) ;
ConversationListActivity . this . startActivity ( i ) ;
break ;
case WHICH_DELETE :
ConversationListActivity . deleteMessages ( ConversationListActivity . this , target ,
R . string . delete_thread_ , R . string . delete_thread_question , null ) ;
break ;
case WHICH_MARK_SPAM :
ConversationListActivity . addToOrRemoveFromSpamlist (
ConversationListActivity . this , c . getContact ( ) . getNumber ( ) ) ;
break ;
default :
break ;
}
}
} ) ;
builder . create ( ) . show ( ) ;
return true ;
}
static String getDate ( final Context context , final long time ) {
long t = time ;
if ( t < MIN_DATE ) {
t *= MILLIS ;
}
if ( PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean (
PreferencesActivity . PREFS_FULL_DATE , false ) ) {
return DateFormat . getTimeFormat ( context ) . format ( t ) + "
+ DateFormat . getDateFormat ( context ) . format ( t ) ;
} else if ( t < CAL_DAYAGO . getTimeInMillis ( ) ) {
return DateFormat . getDateFormat ( context ) . format ( t ) ;
} else {
return DateFormat . getTimeFormat ( context ) . format ( t ) ;
}
}
}
package de . ub0r . android . smsdroid ;
import android . app . SearchManager ;
import android . content . ContentProvider ;
import android . content . ContentValues ;
import android . database . Cursor ;
import android . database . MergeCursor ;
import android . net . Uri ;
import android . text . TextUtils ;
import de . ub0r . android . lib . Log ;
import de . ub0r . android . lib . Utils ;
public final class <unk> extends ContentProvider {
static final String TAG = " ;
private static final String AUTHORITY = " ;
private static final Uri SMS_URI = Uri . parse ( " ) ;
@Override
public String getType ( final Uri uri ) {
Log . d ( TAG , " + uri + " ) ;
throw new UnsupportedOperationException ( " ) ;
}
@Override
public Cursor query ( final Uri uri , final String [ ] projection , final String selection ,
final String [ ] selectionArgs , final String sortOrder ) {
Log . d ( TAG , " + uri + " ) ;
if ( uri == null ) {
return null ;
}
final String query = uri . getLastPathSegment ( ) ;
Log . d ( TAG , " + query ) ;
if ( TextUtils . isEmpty ( query ) || query . equals ( SearchManager . <unk> ) ) {
return null ;
}
final int limit = Utils . parseInt ( uri . getQueryParameter ( " ) ,  <num> ) ;
Log . d ( TAG , " + limit ) ;
final String [ ] proj = new String [ ] { " ,
" + SearchManager . <unk> ,
" + SearchManager . <unk> } ;
final String where = " + query + " ;
return new MergeCursor ( new Cursor [ ] { this . getContext ( ) . getContentResolver ( )
. query ( SMS_URI , proj , where , null , null ) } ) ;
}
@Override
public boolean onCreate ( ) {
return true ;
}
@Override
public int delete ( final Uri uri , final String selection , final String [ ] selectionArgs ) {
throw new UnsupportedOperationException ( " ) ;
}
@Override
public Uri insert ( final Uri uri , final ContentValues values ) {
throw new UnsupportedOperationException ( " ) ;
}
@Override
public int update ( final Uri uri , final ContentValues values , final String selection ,
final String [ ] selectionArgs ) {
throw new UnsupportedOperationException ( " ) ;
}
}
package de . ub0r . android . smsdroid ;
import java . util . LinkedHashMap ;
import android . content . Context ;
import android . database . Cursor ;
import android . graphics . Bitmap ;
import android . net . Uri ;
import android . provider . BaseColumns ;
import android . provider . CallLog . Calls ;
import de . ub0r . android . lib . Log ;
import de . ub0r . android . lib . apis . Contact ;
public final class Conversation {
static final String TAG = " ;
private static final int CAHCESIZE = <num> ;
private static final LinkedHashMap < Integer , Conversation > CACHE = new LinkedHashMap < Integer , Conversation > (
26 , <num> , true ) ;
public static final Bitmap <unk> = Bitmap . createBitmap ( <num> , <num> , Bitmap . Config . RGB_565 ) ;
static final Uri URI_SIMPLE = Uri . parse ( " ) . buildUpon ( )
. appendQueryParameter ( " , " ) . build ( ) ;
public static final String ID = BaseColumns . _ID ;
public static final String DATE = Calls . DATE ;
public static final String COUNT = " ;
public static final String NID = " ;
public static final String BODY = " ;
public static final String READ = " ;
public static final int INDEX_SIMPLE_ID = <num> ;
public static final int INDEX_SIMPLE_DATE = <num> ;
public static final int INDEX_SIMPLE_COUNT = <num> ;
public static final int INDEX_SIMPLE_NID = <num> ;
public static final int INDEX_SIMPLE_BODY = <num> ;
public static final int INDEX_SIMPLE_READ = <num> ;
public static final String [ ] PROJECTION_SIMPLE = {
ID ,
DATE ,
COUNT ,
NID ,
BODY ,
READ ,
} ;
static final String DATE_FORMAT = " ;
private static long validCache = <num> ;
private int id ;
private int threadId ;
private Contact contact ;
private long date ;
private String body ;
private int read ;
private int count =  <num> ;
private long lastUpdate = <num> ;
private Conversation ( final Context context , final Cursor cursor , final boolean sync ) {
this . threadId = cursor . getInt ( INDEX_SIMPLE_ID ) ;
this . date = cursor . getLong ( INDEX_SIMPLE_DATE ) ;
this . body = cursor . getString ( INDEX_SIMPLE_BODY ) ;
this . read = cursor . getInt ( INDEX_SIMPLE_READ ) ;
this . count = cursor . getInt ( INDEX_SIMPLE_COUNT ) ;
this . contact = new Contact ( cursor . getInt ( INDEX_SIMPLE_NID ) ) ;
AsyncHelper . fillConversation ( context , this , sync ) ;
this . lastUpdate = System . currentTimeMillis ( ) ;
}
private void update ( final Context context , final Cursor cursor , final boolean sync ) {
Log . d ( TAG , " + this . threadId + " + sync + " ) ;
long d = cursor . getLong ( INDEX_SIMPLE_DATE ) ;
if ( d != this . date ) {
this . id = cursor . getInt ( INDEX_SIMPLE_ID ) ;
this . date = d ;
this . body = cursor . getString ( INDEX_SIMPLE_BODY ) ;
}
this . count = cursor . getInt ( INDEX_SIMPLE_COUNT ) ;
this . read = cursor . getInt ( INDEX_SIMPLE_READ ) ;
final int nid = cursor . getInt ( INDEX_SIMPLE_NID ) ;
if ( nid != this . contact . <unk> ( ) ) {
this . contact = new Contact ( nid ) ;
}
if ( this . lastUpdate < validCache ) {
AsyncHelper . fillConversation ( context , this , sync ) ;
this . lastUpdate = System . currentTimeMillis ( ) ;
}
}
public static Conversation getConversation ( final Context context , final Cursor cursor ,
final boolean sync ) {
Log . d ( TAG , " + sync + " ) ;
synchronized ( CACHE ) {
Conversation ret = CACHE . get ( cursor . getInt ( INDEX_SIMPLE_ID ) ) ;
if ( ret == null ) {
ret = new Conversation ( context , cursor , sync ) ;
CACHE . put ( ret . getThreadId ( ) , ret ) ;
Log . d ( TAG , " + CACHE . size ( ) ) ;
while ( CACHE . size ( ) > CAHCESIZE ) {
Integer i = CACHE . keySet ( ) . iterator ( ) . next ( ) ;
Log . d ( TAG , " + i ) ;
Conversation cc = CACHE . remove ( i ) ;
if ( cc == null ) {
Log . w ( TAG , " ) ;
break ;
}
}
} else {
ret . update ( context , cursor , sync ) ;
}
return ret ;
}
}
public static Conversation getConversation ( final Context context , final int threadId ,
final boolean forceUpdate ) {
Log . d ( TAG , " + threadId + " ) ;
synchronized ( CACHE ) {
Conversation ret = CACHE . get ( threadId ) ;
if ( ret == null || ret . getContact ( ) . getNumber ( ) == null || forceUpdate ) {
Cursor cursor = context . getContentResolver ( ) . query ( URI_SIMPLE , PROJECTION_SIMPLE ,
ID + " , new String [ ] { String . valueOf ( threadId ) } , null ) ;
if ( cursor . moveToFirst ( ) ) {
ret = getConversation ( context , cursor , true ) ;
} else {
Log . e ( TAG , " + threadId ) ;
}
cursor . close ( ) ;
}
return ret ;
}
}
public static void flushCache ( ) {
synchronized ( CACHE ) {
CACHE . clear ( ) ;
}
}
public static void <unk> ( final int threadId ) {
synchronized ( CACHE ) {
final Conversation c = CACHE . get ( threadId ) ;
if ( c == null ) {
CACHE . remove ( c ) ;
}
}
}
public static void invalidate ( ) {
validCache = System . currentTimeMillis ( ) ;
}
public int getId ( ) {
return this . id ;
}
public void <unk> ( final long nid ) {
this . contact = new Contact ( nid ) ;
}
public int getThreadId ( ) {
return this . threadId ;
}
public long getDate ( ) {
return this . date ;
}
public Contact getContact ( ) {
return this . contact ;
}
public String getBody ( ) {
return this . body ;
}
public void setBody ( final String b ) {
this . body = b ;
}
public int getRead ( ) {
return this . read ;
}
public void setRead ( final int status ) {
this . read = status ;
}
public int getCount ( ) {
return this . count ;
}
public void setCount ( final int c ) {
this . count = c ;
}
public Uri getUri ( ) {
return Uri . withAppendedPath ( ConversationListActivity . URI , String . valueOf ( this . threadId ) ) ;
}
}
package de . ub0r . android . smsdroid ;
import java . net . URLDecoder ;
import java . util . ArrayList ;
import android . app . PendingIntent ;
import android . app . PendingIntent . CanceledException ;
import android . content . ContentResolver ;
import android . content . ContentValues ;
import android . content . Intent ;
import android . database . Cursor ;
import android . database . sqlite . SQLiteException ;
import android . net . Uri ;
import android . os . Bundle ;
import android . provider . BaseColumns ;
import android . support . v4 . app . FragmentActivity ;
import android . support . v4 . view . Menu ;
import android . support . v4 . view . MenuItem ;
import android . telephony . SmsManager ;
import android . telephony . SmsMessage ;
import android . text . ClipboardManager ;
import android . text . TextUtils ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . EditText ;
import android . widget . MultiAutoCompleteTextView ;
import android . widget . TextView ;
import de . ub0r . android . lib . Log ;
import de . ub0r . android . lib . apis . ContactsWrapper ;
public final class SenderActivity extends FragmentActivity implements OnClickListener {
private static final String TAG = " ;
private static final Uri URI_SMS = Uri . parse ( " ) ;
public static final Uri URI_SENT = Uri . parse ( " ) ;
private static final String [ ] PROJECTION_ID = new String [ ] { BaseColumns . _ID } ;
private static final String ADDRESS = " ;
private static final String READ = " ;
public static final String TYPE = " ;
private static final String BODY = " ;
private static final String DATE = " ;
public static final String MESSAGE_SENT_ACTION = " ;
private String to , text ;
@SuppressWarnings("deprecation")
private ClipboardManager cbmgr ;
@Override
public void onCreate ( final Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . handleIntent ( this . getIntent ( ) ) ;
}
@Override
protected void onNewIntent ( final Intent intent ) {
super . onNewIntent ( intent ) ;
this . handleIntent ( intent ) ;
}
@SuppressWarnings("deprecation")
private void handleIntent ( final Intent intent ) {
if ( this . parseIntent ( intent ) ) {
this . setTheme ( android . R . style . <unk> ) ;
this . send ( ) ;
this . finish ( ) ;
} else {
this . setTheme ( PreferencesActivity . getTheme ( this ) ) ;
this . setContentView ( R . layout . sender ) ;
this . findViewById ( R . id . text_paste ) . setOnClickListener ( this ) ;
final EditText et = ( EditText ) this . findViewById ( R . id . text ) ;
et . addTextChangedListener ( new MyTextWatcher ( this , ( TextView ) this
. findViewById ( R . id . text_paste ) , ( TextView ) this . findViewById ( R . id . text_ ) ) ) ;
et . setText ( this . text ) ;
final MultiAutoCompleteTextView mtv = ( MultiAutoCompleteTextView ) this
. findViewById ( R . id . to ) ;
mtv . setAdapter ( new MobilePhoneAdapter ( this ) ) ;
mtv . setTokenizer ( new MultiAutoCompleteTextView . <unk> ( ) ) ;
mtv . setText ( this . to ) ;
if ( ! TextUtils . isEmpty ( this . to ) ) {
this . to = this . to . trim ( ) ;
if ( this . to . endsWith ( " ) ) {
this . to = this . to . substring ( <num> , this . to . length ( )  <num> ) . trim ( ) ;
}
if ( this . to . indexOf ( <' ) < <num> ) {
String n = ContactsWrapper . getInstance ( ) . <unk> (
this . getContentResolver ( ) , this . to ) ;
if ( n != null ) {
this . to = n + " + this . to + " ;
}
}
mtv . setText ( this . to ) ;
et . requestFocus ( ) ;
} else {
mtv . requestFocus ( ) ;
}
this . cbmgr = ( ClipboardManager ) this . getSystemService ( CLIPBOARD_SERVICE ) ;
}
}
private boolean parseIntent ( final Intent intent ) {
Log . d ( TAG , " + intent + " ) ;
if ( intent == null ) {
return false ;
}
Log . d ( TAG , " + intent . getAction ( ) ) ;
this . to = null ;
String u = intent . getDataString ( ) ;
try {
if ( ! TextUtils . isEmpty ( u ) && u . contains ( " ) ) {
String t = u . split ( " ) [ <num> ] ;
if ( t . startsWith ( " ) ) {
this . to = " + URLDecoder . decode ( t . substring ( <num> ) ) ;
} else {
this . to = URLDecoder . decode ( t ) ;
}
}
} catch ( IndexOutOfBoundsException e ) {
Log . w ( TAG , " , e ) ;
}
u = null ;
CharSequence cstext = intent . <unk> ( Intent . EXTRA_TEXT ) ;
this . text = null ;
if ( cstext != null ) {
this . text = cstext . toString ( ) ;
cstext = null ;
}
if ( TextUtils . isEmpty ( this . text ) ) {
Log . i ( TAG , " ) ;
return false ;
}
if ( TextUtils . isEmpty ( this . to ) ) {
Log . i ( TAG , " ) ;
return false ;
}
return true ;
}
private void send ( final String recipient , final String message ) {
Log . d ( TAG , " + recipient ) ;
int [ ] l = SmsMessage . calculateLength ( message , false ) ;
Log . i ( TAG , " + message . length ( ) + " + l [ <num> ] + " + l [ <num> ] + " + l [ <num> ] + "
+ l [ <num> ] ) ;
l = SmsMessage . calculateLength ( message , true ) ;
Log . i ( TAG , " + message . length ( ) + " + l [ <num> ] + " + l [ <num> ] + " + l [ <num> ] + "
+ l [ <num> ] ) ;
final ContentResolver cr = this . getContentResolver ( ) ;
ContentValues values = new ContentValues ( ) ;
values . put ( TYPE , Message . SMS_DRAFT ) ;
values . put ( BODY , message ) ;
values . put ( READ , <num> ) ;
values . put ( ADDRESS , recipient ) ;
Uri draft = null ;
Cursor cursor = cr . query ( URI_SMS , PROJECTION_ID ,
TYPE + " + Message . SMS_DRAFT + " + ADDRESS + " + recipient
+ " + BODY + " + message . replace ( " , " ) + " , null , DATE
+ " ) ;
if ( cursor != null && cursor . moveToFirst ( ) ) {
draft = URI_SENT . buildUpon ( ) . appendPath ( cursor . getString ( <num> ) ) . build ( ) ;
Log . d ( TAG , " + draft ) ;
} else {
try {
draft = cr . insert ( URI_SENT , values ) ;
Log . d ( TAG , " + draft ) ;
} catch ( SQLiteException e ) {
Log . e ( TAG , " , e ) ;
}
}
values = null ;
if ( cursor != null && ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
cursor = null ;
SmsManager smsmgr = SmsManager . getDefault ( ) ;
final ArrayList < String > messages = smsmgr . <unk> ( message ) ;
final int c = messages . size ( ) ;
ArrayList < PendingIntent > sentIntents = new ArrayList < PendingIntent > ( c ) ;
try {
Log . d ( TAG , " + recipient ) ;
for ( int i = <num> ; i < c ; i ++ ) {
final String m = messages . get ( i ) ;
Log . d ( TAG , " + m ) ;
final Intent sent = new Intent ( MESSAGE_SENT_ACTION , draft , this , SmsReceiver . class ) ;
sentIntents . add ( PendingIntent . getBroadcast ( this , <num> , sent , <num> ) ) ;
}
smsmgr . <unk> ( recipient , null , messages , sentIntents , null ) ;
Log . i ( TAG , " ) ;
} catch ( Exception e ) {
Log . e ( TAG , " , e ) ;
for ( PendingIntent pi : sentIntents ) {
if ( pi != null ) {
try {
pi . send ( ) ;
} catch ( CanceledException e1 ) {
Log . e ( TAG , " , e1 ) ;
}
}
}
}
}
private boolean send ( ) {
if ( TextUtils . isEmpty ( this . to ) || TextUtils . isEmpty ( this . text ) ) {
return false ;
}
for ( String r : this . to . split ( " ) ) {
r = MobilePhoneAdapter . cleanRecipient ( r ) ;
if ( TextUtils . isEmpty ( r ) ) {
Log . w ( TAG , " + r ) ;
continue ;
}
this . send ( r , this . text ) ;
}
return true ;
}
@SuppressWarnings("deprecation")
@Override
public void onClick ( final View v ) {
switch ( v . getId ( ) ) {
case R . id . text_paste :
final CharSequence s = this . cbmgr . getText ( ) ;
( ( EditText ) this . findViewById ( R . id . text ) ) . setText ( s ) ;
return ;
default :
break ;
}
}
@Override
public boolean onCreateOptionsMenu ( final Menu menu ) {
this . getMenuInflater ( ) . inflate ( R . menu . sender , menu ) ;
return true ;
}
@Override
public boolean onOptionsItemSelected ( final MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
Intent intent = new Intent ( this , ConversationListActivity . class ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
this . startActivity ( intent ) ;
return true ;
case R . id . <unk> :
EditText et = ( EditText ) this . findViewById ( R . id . text ) ;
this . text = et . getText ( ) . toString ( ) ;
et = ( MultiAutoCompleteTextView ) this . findViewById ( R . id . to ) ;
this . to = et . getText ( ) . toString ( ) ;
if ( this . send ( ) ) {
this . finish ( ) ;
}
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
}
package de . ub0r . android . smsdroid ;
import android . content . Intent ;
import android . os . Bundle ;
import android . support . v4 . app . FragmentActivity ;
import android . support . v4 . view . MenuItem ;
public final class AboutActivity extends FragmentActivity {
@Override
public void onCreate ( final Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . setContentView ( R . layout . about ) ;
this . setTitle ( this . getString ( R . string . <unk> ) + " + this . getString ( R . string . app_name )
+ " + this . getString ( R . string . app_version ) ) ;
}
@Override
public boolean onOptionsItemSelected ( final MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
Intent intent = new Intent ( this , ConversationListActivity . class ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
this . startActivity ( intent ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
}
package de . ub0r . android . smsdroid ;
import android . app . Activity ;
import android . app . Notification ;
import android . app . NotificationManager ;
import android . app . PendingIntent ;
import android . appwidget . AppWidgetManager ;
import android . content . BroadcastReceiver ;
import android . content . ComponentName ;
import android . content . ContentResolver ;
import android . content . ContentValues ;
import android . content . Context ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . database . Cursor ;
import android . graphics . drawable . BitmapDrawable ;
import android . graphics . drawable . Drawable ;
import android . net . Uri ;
import android . os . Build ;
import android . os . Bundle ;
import android . os . PowerManager ;
import android . preference . PreferenceManager ;
import android . provider . CallLog . Calls ;
import android . telephony . gsm . SmsMessage ;
import de . ub0r . android . lib . Log ;
import de . ub0r . android . lib . Utils ;
import de . ub0r . android . lib . apis . NotificationBuilderWrapper ;
@SuppressWarnings("deprecation")
public class SmsReceiver extends BroadcastReceiver {
static final String TAG = " ;
private static final Uri URI_SMS = Uri . parse ( " ) ;
private static final Uri URI_MMS = Uri . parse ( " ) ;
private static final String ACTION_SMS = " ;
private static final String ACTION_MMS = " ;
private static final String MMS_BODY = " ;
private static final int ID_TID = <num> ;
private static final int ID_COUNT = <num> ;
private static final String SORT = Calls . DATE + " ;
private static final long SLEEP = <num> ;
private static final int MAX_SPINS = <num> ;
private static final int NOTIFICATION_ID_NEW = <num> ;
private static long lastUnreadDate = <num> ;
private static String lastUnreadBody = null ;
static final int RED = <num> ;
@Override
public final void onReceive ( final Context context , final Intent intent ) {
Log . d ( TAG , " ) ;
final PowerManager pm = ( PowerManager ) context . getSystemService ( Context . POWER_SERVICE ) ;
final PowerManager . WakeLock wakelock = pm . newWakeLock ( PowerManager . PARTIAL_WAKE_LOCK , TAG ) ;
wakelock . acquire ( ) ;
Log . i ( TAG , " ) ;
final String action = intent . getAction ( ) ;
Log . d ( TAG , " + action ) ;
try {
Log . d ( TAG , " + SLEEP + " ) ;
Thread . sleep ( SLEEP ) ;
} catch ( InterruptedException e ) {
Log . d ( TAG , " , e ) ;
e . printStackTrace ( ) ;
}
String t = null ;
if ( action . equals ( SenderActivity . MESSAGE_SENT_ACTION ) ) {
this . handleSent ( context , intent , this . getResultCode ( ) ) ;
} else {
boolean silent = false ;
if ( action . equals ( ACTION_SMS ) ) {
Bundle b = intent . getExtras ( ) ;
Object [ ] messages = ( Object [ ] ) b . get ( " ) ;
SmsMessage [ ] smsMessage = new SmsMessage [ messages . length ] ;
int l = messages . length ;
for ( int i = <num> ; i < l ; i ++ ) {
smsMessage [ i ] = SmsMessage . createFromPdu ( ( byte [ ] ) messages [ i ] ) ;
}
t = null ;
if ( l > <num> ) {
t = smsMessage [ <num> ] . <unk> ( ) ;
final String s = smsMessage [ <num> ] . getOriginatingAddress ( ) ;
final SpamDB db = new SpamDB ( context ) ;
db . open ( ) ;
if ( db . isInDB ( smsMessage [ <num> ] . getOriginatingAddress ( ) ) ) {
Log . d ( TAG , " + s + " ) ;
silent = true ;
} else {
Log . d ( TAG , " + s + " ) ;
}
db . close ( ) ;
}
} else if ( action . equals ( ACTION_MMS ) ) {
t = MMS_BODY ;
}
if ( ! silent ) {
Log . d ( TAG , " + t ) ;
int count = MAX_SPINS ;
do {
Log . d ( TAG , " + count ) ;
try {
Log . d ( TAG , " + SLEEP + " ) ;
Thread . sleep ( SLEEP ) ;
} catch ( InterruptedException e ) {
Log . d ( TAG , " , e ) ;
e . printStackTrace ( ) ;
}
count ;
} while ( updateNewMessageNotification ( context , t ) <= <num> && count > <num> ) ;
if ( count == <num> ) {
updateNewMessageNotification ( context , null ) ;
}
}
}
wakelock . release ( ) ;
Log . i ( TAG , " ) ;
}
private static int [ ] getUnreadSMS ( final ContentResolver cr , final String text ) {
Log . d ( TAG , " + text + " ) ;
Cursor cursor = cr . query ( URI_SMS , Message . PROJECTION , Message . SELECTION_READ_UNREAD ,
Message . SELECTION_UNREAD , SORT ) ;
if ( cursor == null || cursor . isClosed ( ) || cursor . getCount ( ) == <num> || ! cursor . moveToFirst ( ) ) {
if ( text != null ) {
if ( cursor != null && ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
return new int [ ] {  <num> ,  <num> } ;
} else {
if ( cursor != null && ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
return new int [ ] { <num> , <num> } ;
}
}
final String t = cursor . getString ( Message . INDEX_BODY ) ;
if ( text != null && ( t == null || ! t . startsWith ( text ) ) ) {
if ( cursor != null && ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
return new int [ ] {  <num> ,  <num> } ;
}
final long d = cursor . getLong ( Message . INDEX_DATE ) ;
if ( d > lastUnreadDate ) {
lastUnreadDate = d ;
lastUnreadBody = t ;
}
int tid = cursor . getInt ( Message . INDEX_THREADID ) ;
while ( cursor . moveToNext ( ) && tid >  <num> ) {
if ( tid != cursor . getInt ( Message . INDEX_THREADID ) ) {
tid =  <num> ;
}
}
final int count = cursor . getCount ( ) ;
if ( cursor != null && ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
return new int [ ] { tid , count } ;
}
private static int [ ] getUnreadMMS ( final ContentResolver cr , final String text ) {
Log . d ( TAG , " + text + " ) ;
Cursor cursor = cr . query ( URI_MMS , Message . PROJECTION_READ , Message . SELECTION_READ_UNREAD ,
Message . SELECTION_UNREAD , null ) ;
if ( cursor == null || cursor . isClosed ( ) || cursor . getCount ( ) == <num> || ! cursor . moveToFirst ( ) ) {
if ( text == MMS_BODY ) {
if ( cursor != null && ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
return new int [ ] {  <num> ,  <num> } ;
} else {
if ( cursor != null && ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
return new int [ ] { <num> , <num> } ;
}
}
int tid = cursor . getInt ( Message . INDEX_THREADID ) ;
long d = cursor . getLong ( Message . INDEX_DATE ) ;
if ( d < ConversationListActivity . MIN_DATE ) {
d *= ConversationListActivity . MILLIS ;
}
if ( d > lastUnreadDate ) {
lastUnreadDate = d ;
lastUnreadBody = null ;
}
while ( cursor . moveToNext ( ) && tid >  <num> ) {
if ( tid != cursor . getInt ( Message . INDEX_THREADID ) ) {
tid =  <num> ;
}
}
final int count = cursor . getCount ( ) ;
if ( cursor != null && ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
return new int [ ] { tid , count } ;
}
private static int [ ] getUnread ( final ContentResolver cr , final String text ) {
Log . d ( TAG , " + text + " ) ;
lastUnreadBody = null ;
lastUnreadDate = <num> ;
String t = text ;
if ( t == MMS_BODY ) {
t = null ;
}
final int [ ] retSMS = getUnreadSMS ( cr , t ) ;
if ( retSMS [ ID_COUNT ] ==  <num> ) {
return new int [ ] {  <num> ,  <num> } ;
}
final int [ ] retMMS = getUnreadMMS ( cr , text ) ;
if ( retMMS [ ID_COUNT ] ==  <num> ) {
return new int [ ] {  <num> ,  <num> } ;
}
final int [ ] ret = new int [ ] {  <num> , retSMS [ ID_COUNT ] + retMMS [ ID_COUNT ] } ;
if ( retMMS [ ID_TID ] <= <num> || retSMS [ ID_TID ] == retMMS [ ID_TID ] ) {
ret [ ID_TID ] = retSMS [ ID_TID ] ;
} else if ( retSMS [ ID_TID ] <= <num> ) {
ret [ ID_TID ] = retMMS [ ID_TID ] ;
}
return ret ;
}
static final int updateNewMessageNotification ( final Context context , final String text ) {
Log . d ( TAG , " + context + " + text + " ) ;
final NotificationManager mNotificationMgr = ( NotificationManager ) context
. getSystemService ( Context . NOTIFICATION_SERVICE ) ;
final SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final boolean enableNotifications = prefs . getBoolean (
PreferencesActivity . PREFS_NOTIFICATION_ENABLE , true ) ;
final boolean privateNotification = prefs . getBoolean (
PreferencesActivity . PREFS_NOTIFICATION_PRIVACY , false ) ;
final boolean showPhoto = ! privateNotification
&& prefs . getBoolean ( PreferencesActivity . PREFS_CONTACT_PHOTO , true ) ;
if ( ! enableNotifications ) {
mNotificationMgr . cancelAll ( ) ;
Log . d ( TAG , " ) ;
}
final int [ ] status = getUnread ( context . getContentResolver ( ) , text ) ;
final int l = status [ ID_COUNT ] ;
final int tid = status [ ID_TID ] ;
Log . d ( TAG , " + l ) ;
if ( l < <num> ) {
return l ;
}
int ret = l ;
if ( enableNotifications && ( text != null || l == <num> ) ) {
mNotificationMgr . cancel ( NOTIFICATION_ID_NEW ) ;
}
Uri uri = null ;
PendingIntent pIntent ;
if ( l == <num> ) {
final Intent i = new Intent ( context , ConversationListActivity . class ) ;
i . setFlags ( i . getFlags ( ) | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
pIntent = PendingIntent . getActivity ( context , <num> , i , PendingIntent . FLAG_CANCEL_CURRENT ) ;
} else {
NotificationBuilderWrapper . Builder nb = NotificationBuilderWrapper
. <unk> ( context ) ;
boolean showNotification = true ;
Intent i ;
if ( tid >= <num> ) {
uri = Uri . parse ( MessageListActivity . URI + tid ) ;
i = new Intent ( Intent . ACTION_VIEW , uri , context , MessageListActivity . class ) ;
pIntent = PendingIntent . getActivity ( context , <num> , i ,
PendingIntent . FLAG_UPDATE_CURRENT ) ;
if ( enableNotifications ) {
final Conversation conv = Conversation . getConversation ( context , tid , true ) ;
if ( conv != null ) {
String a ;
if ( privateNotification ) {
if ( l == <num> ) {
a = context . getString ( R . string . <unk> ) ;
} else {
a = context . getString ( R . string . new_messages_ ) ;
}
} else {
a = conv . getContact ( ) . getDisplayName ( ) ;
}
showNotification = true ;
nb . setSmallIcon ( PreferencesActivity . getNotificationIcon ( context ) ) ;
nb . setTicker ( a ) ;
nb . setWhen ( lastUnreadDate ) ;
if ( l == <num> ) {
String body ;
if ( privateNotification ) {
body = context . getString ( R . string . <unk> ) ;
} else {
body = lastUnreadBody ;
}
if ( body == null ) {
body = context . getString ( R . string . mms_conversation ) ;
}
nb . setLatestEventInfo ( context , a , body , pIntent ) ;
} else {
nb . setLatestEventInfo ( context , a ,
String . format ( context . getString ( R . string . new_messages ) , l ) ,
pIntent ) ;
}
if ( showPhoto
&& Utils . isApi ( Build . VERSION_CODES . HONEYCOMB ) ) {
conv . getContact ( ) . update ( context , false , true ) ;
Drawable d = conv . getContact ( ) . getAvatar ( context , null ) ;
if ( d instanceof BitmapDrawable ) {
nb . setLargeIcon ( ( ( BitmapDrawable ) d ) . getBitmap ( ) ) ;
}
}
}
}
} else {
uri = Uri . parse ( MessageListActivity . URI ) ;
i = new Intent ( Intent . ACTION_VIEW , uri , context , ConversationListActivity . class ) ;
pIntent = PendingIntent . getActivity ( context , <num> , i ,
PendingIntent . FLAG_UPDATE_CURRENT ) ;
if ( enableNotifications ) {
showNotification = true ;
nb . setSmallIcon ( PreferencesActivity . getNotificationIcon ( context ) ) ;
nb . setTicker ( context . getString ( R . string . new_messages_ ) ) ;
nb . setWhen ( lastUnreadDate ) ;
nb . setLatestEventInfo ( context , context . getString ( R . string . new_messages_ ) ,
String . format ( context . getString ( R . string . new_messages ) , l ) , pIntent ) ;
nb . setNumber ( l ) ;
}
}
i . setFlags ( i . getFlags ( ) | Intent . FLAG_ACTIVITY_NEW_TASK ) ;
if ( enableNotifications && showNotification ) {
int [ ] ledFlash = PreferencesActivity . getLEDflash ( context ) ;
nb . <unk> ( PreferencesActivity . getLEDcolor ( context ) , ledFlash [ <num> ] , ledFlash [ <num> ] ) ;
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
if ( text != null ) {
final boolean vibrate = p . getBoolean ( PreferencesActivity . PREFS_VIBRATE , false ) ;
final String s = p . getString ( PreferencesActivity . PREFS_SOUND , null ) ;
Uri sound ;
if ( s == null || s . length ( ) <= <num> ) {
sound = null ;
} else {
sound = Uri . parse ( s ) ;
}
if ( vibrate ) {
final long [ ] pattern = PreferencesActivity . getVibratorPattern ( context ) ;
if ( pattern . length == <num> && pattern [ <num> ] == <num> ) {
nb . setDefaults ( Notification . DEFAULT_VIBRATE ) ;
} else {
nb . setVibrate ( pattern ) ;
}
}
nb . setSound ( sound ) ;
}
}
Log . d ( TAG , " + uri ) ;
mNotificationMgr . cancel ( NOTIFICATION_ID_NEW ) ;
if ( enableNotifications && showNotification ) {
mNotificationMgr . notify ( NOTIFICATION_ID_NEW , nb . getNotification ( ) ) ;
}
}
Log . d ( TAG , " + ret + " ) ;
AppWidgetManager . getInstance ( context ) . updateAppWidget (
new ComponentName ( context , WidgetProvider . class ) ,
WidgetProvider . getRemoteViews ( context , l , pIntent ) ) ;
return ret ;
}
private void updateFailedNotification ( final Context context , final Uri uri ) {
Log . d ( TAG , " + uri ) ;
final Cursor c = context . getContentResolver ( ) . query ( uri , Message . PROJECTION_SMS , null ,
null , null ) ;
if ( c != null && c . moveToFirst ( ) ) {
final int id = c . getInt ( Message . INDEX_ID ) ;
final int tid = c . getInt ( Message . INDEX_THREADID ) ;
final String body = c . getString ( Message . INDEX_BODY ) ;
final long date = c . getLong ( Message . INDEX_DATE ) ;
Conversation conv = Conversation . getConversation ( context , tid , true ) ;
final NotificationManager mNotificationMgr = ( NotificationManager ) context
. getSystemService ( Context . NOTIFICATION_SERVICE ) ;
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final boolean privateNotification = p . getBoolean (
PreferencesActivity . PREFS_NOTIFICATION_PRIVACY , false ) ;
Intent intent ;
if ( conv == null ) {
intent = new Intent ( Intent . ACTION_VIEW , null , context , SenderActivity . class ) ;
} else {
intent = new Intent ( Intent . ACTION_VIEW , conv . getUri ( ) , context ,
MessageListActivity . class ) ;
}
intent . putExtra ( Intent . EXTRA_TEXT , body ) ;
String title = context . getString ( R . string . <unk> ) ;
String text = null ;
final Notification n = new Notification ( android . R . drawable . <unk> , title ,
date ) ;
if ( privateNotification ) {
title += " ;
} else if ( conv == null ) {
title += " ;
text = body ;
} else {
title += " + conv . getContact ( ) . getDisplayName ( ) ;
text = body ;
}
n . setLatestEventInfo ( context , title , text , PendingIntent . getActivity ( context , <num> ,
intent , PendingIntent . FLAG_CANCEL_CURRENT ) ) ;
n . flags |= Notification . FLAG_AUTO_CANCEL ;
n . flags |= Notification . FLAG_SHOW_LIGHTS ;
n . ledARGB = RED ;
int [ ] ledFlash = PreferencesActivity . getLEDflash ( context ) ;
n . ledOnMS = ledFlash [ <num> ] ;
n . ledOffMS = ledFlash [ <num> ] ;
final boolean vibrate = p . getBoolean ( PreferencesActivity . PREFS_VIBRATE , false ) ;
final String s = p . getString ( PreferencesActivity . PREFS_SOUND , null ) ;
Uri sound ;
if ( s == null || s . length ( ) <= <num> ) {
sound = null ;
} else {
sound = Uri . parse ( s ) ;
}
if ( vibrate ) {
final long [ ] pattern = PreferencesActivity . getVibratorPattern ( context ) ;
if ( pattern . length == <num> && pattern [ <num> ] == <num> ) {
n . defaults |= Notification . DEFAULT_VIBRATE ;
} else {
n . vibrate = pattern ;
}
}
n . sound = sound ;
mNotificationMgr . notify ( id , n ) ;
}
if ( c != null && ! c . isClosed ( ) ) {
c . close ( ) ;
}
}
private void handleSent ( final Context context , final Intent intent , final int resultCode ) {
final Uri uri = intent . getData ( ) ;
Log . d ( TAG , " + uri + " + resultCode ) ;
if ( uri == null ) {
Log . w ( TAG , " ) ;
return ;
}
if ( resultCode == Activity . RESULT_OK ) {
final ContentValues cv = new ContentValues ( <num> ) ;
cv . put ( SenderActivity . TYPE , Message . SMS_OUT ) ;
context . getContentResolver ( ) . update ( uri , cv , null , null ) ;
} else {
this . updateFailedNotification ( context , uri ) ;
}
}
}
package de . ub0r . android . smsdroid ;
import java . util . ArrayList ;
import java . util . HashMap ;
import yuku . ambilwarna . AmbilWarnaDialog ;
import yuku . ambilwarna . AmbilWarnaDialog . OnAmbilWarnaListener ;
import android . app . Activity ;
import android . app . AlertDialog . Builder ;
import android . content . Context ;
import android . content . DialogInterface ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . os . Build ;
import android . os . Bundle ;
import android . preference . Preference ;
import android . preference . Preference . OnPreferenceClickListener ;
import android . preference . PreferenceActivity ;
import android . preference . PreferenceManager ;
import android . text . TextUtils ;
import android . view . MenuItem ;
import android . widget . SimpleAdapter ;
import de . ub0r . android . lib . IPreferenceContainer ;
import de . ub0r . android . lib . Log ;
import de . ub0r . android . lib . Market ;
import de . ub0r . android . lib . Utils ;
public class PreferencesActivity extends PreferenceActivity implements IPreferenceContainer {
static final String TAG = " ;
static final String PREFS_VIBRATE = " ;
static final String PREFS_SOUND = " ;
private static final String PREFS_LED_COLOR = " ;
private static final String PREFS_LED_FLASH = " ;
private static final String PREFS_VIBRATOR_PATTERN = " ;
static final String PREFS_NOTIFICATION_ENABLE = " ;
static final String PREFS_NOTIFICATION_PRIVACY = " ;
private static final String PREFS_NOTIFICATION_ICON = " ;
static final String PREFS_CONTACT_PHOTO = " ;
static final String PREFS_EMOTICONS = " ;
static final String <unk> = " ;
private static final String PREFS_BUBBLES_IN = " ;
private static final String PREFS_BUBBLES_OUT = " ;
static final String PREFS_FULL_DATE = " ;
static final String PREFS_HIDE_SEND = " ;
static final String PREFS_HIDE_RESTORE = " ;
static final String PREFS_HIDE_PASTE = " ;
static final String PREFS_HIDE_WIDGET_LABEL = " ;
private static final String PREFS_THEME = " ;
private static final String THEME_BLACK = " ;
private static final String THEME_LIGHT = " ;
private static final String PREFS_TEXTSIZE = " ;
private static final String PREFS_TEXTCOLOR = " ;
private static final String PREFS_TEXTCOLOR_IGNORE_CONV = " ;
public static final String PREFS_ENABLE_AUTOSEND = " ;
public static final String PREFS_SHOWTEXTFIELD = " ;
public static final String PREFS_SHOWTARGETAPP = " ;
public static final String PREFS_BACKUPLASTTEXT = " ;
public static final String PREFS_DECODE_DECIMAL_NCR = " ;
public static final String PREFS_ACTIVATE_SENDER = " ;
private static final String PREFS_REGEX = " ;
private static final String PREFS_REPLACE = " ;
private static final int PREFS_REGEX_COUNT = <num> ;
private static final int BLACK = <num> ;
private static final int [ ] NOTIFICAION_IMG = new int [ ] { R . drawable . stat_notify_sms ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , } ;
private static final int [ ] NOTIFICAION_STR = new int [ ] { R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , } ;
private static final int [ ] BUBBLES_IMG = new int [ ] { <num> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . bubble_old_green_right , R . drawable . bubble_old_turquoise_left ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , R . drawable . <unk> ,
R . drawable . <unk> , } ;
private static final int [ ] BUBBLES_STR = new int [ ] { R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , R . string . <unk> ,
R . string . <unk> , } ;
private static class OnNotificationIconClickListener implements
Preference . OnPreferenceClickListener {
private final Context ctx ;
public OnNotificationIconClickListener ( final Context context ) {
this . ctx = context ;
}
@Override
public boolean onPreferenceClick ( final Preference preference ) {
final Builder b = new Builder ( this . ctx ) ;
final int l = NOTIFICAION_STR . length ;
final String [ ] cols = new String [ ] { " , " } ;
final ArrayList < HashMap < String , Object >> rows = new ArrayList < HashMap < String , Object >> ( ) ;
for ( int i = <num> ; i < l ; i ++ ) {
final HashMap < String , Object > m = new HashMap < String , Object > ( <num> ) ;
m . put ( cols [ <num> ] , NOTIFICAION_IMG [ i ] ) ;
m . put ( cols [ <num> ] , this . ctx . getString ( NOTIFICAION_STR [ i ] ) ) ;
rows . add ( m ) ;
}
b . setAdapter ( new SimpleAdapter ( this . ctx , rows , R . layout . <unk> , cols ,
new int [ ] { android . R . id . icon , android . R . id . text1 } ) ,
new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( final DialogInterface dialog , final int which ) {
preference . getEditor ( ) . putInt ( preference . getKey ( ) , which ) . commit ( ) ;
}
} ) ;
b . setNegativeButton ( android . R . string . cancel , null ) ;
b . show ( ) ;
return true ;
}
} ;
private static class OnBubblesClickListener implements Preference . OnPreferenceClickListener {
private final Context ctx ;
public OnBubblesClickListener ( final Context context ) {
this . ctx = context ;
}
@Override
public boolean onPreferenceClick ( final Preference preference ) {
final Builder b = new Builder ( this . ctx ) ;
final int l = BUBBLES_STR . length ;
final String [ ] cols = new String [ ] { " , " } ;
final ArrayList < HashMap < String , Object >> rows = new ArrayList < HashMap < String , Object >> ( ) ;
for ( int i = <num> ; i < l ; i ++ ) {
final HashMap < String , Object > m = new HashMap < String , Object > ( <num> ) ;
m . put ( cols [ <num> ] , BUBBLES_IMG [ i ] ) ;
m . put ( cols [ <num> ] , this . ctx . getString ( BUBBLES_STR [ i ] ) ) ;
rows . add ( m ) ;
}
b . setAdapter ( new SimpleAdapter ( this . ctx , rows , R . layout . <unk> , cols , new int [ ] {
android . R . id . icon , android . R . id . text1 } ) ,
new DialogInterface . OnClickListener ( ) {
@Override
public void onClick ( final DialogInterface dialog , final int which ) {
preference . getEditor ( ) . putInt ( preference . getKey ( ) , which ) . commit ( ) ;
}
} ) ;
b . setNegativeButton ( android . R . string . cancel , null ) ;
b . show ( ) ;
return true ;
}
} ;
@Override
public final void onCreate ( final Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . addPreferencesFromResource ( R . xml . <unk> ) ;
this . addPreferencesFromResource ( R . xml . <unk> ) ;
this . addPreferencesFromResource ( R . xml . <unk> ) ;
registerOnPreferenceClickListener ( this ) ;
}
static final void registerOnPreferenceClickListener ( final IPreferenceContainer pc ) {
Preference p = pc . findPreference ( PREFS_NOTIFICATION_ICON ) ;
if ( p != null ) {
p . setOnPreferenceClickListener ( new OnNotificationIconClickListener ( pc . getContext ( ) ) ) ;
}
Preference pbi = pc . findPreference ( PREFS_BUBBLES_IN ) ;
Preference pbo = pc . findPreference ( PREFS_BUBBLES_OUT ) ;
if ( pbi != null || pbo != null ) {
final OnBubblesClickListener obcl = new OnBubblesClickListener ( pc . getContext ( ) ) ;
if ( pbi != null ) {
pbi . setOnPreferenceClickListener ( obcl ) ;
}
if ( pbo != null ) {
pbo . setOnPreferenceClickListener ( obcl ) ;
}
}
pbi = null ;
pbo = null ;
p = pc . findPreference ( PREFS_TEXTCOLOR ) ;
if ( p != null ) {
p . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) {
@Override
public boolean onPreferenceClick ( final Preference preference ) {
final SharedPreferences prefs = PreferenceManager
. getDefaultSharedPreferences ( pc . getContext ( ) ) ;
int c = prefs . getInt ( PREFS_TEXTCOLOR , <num> ) ;
if ( c == <num> ) {
c = BLACK ;
}
final AmbilWarnaDialog dialog = new AmbilWarnaDialog ( pc . getContext ( ) , c ,
new OnAmbilWarnaListener ( ) {
@Override
public void <unk> ( final AmbilWarnaDialog dialog , final int color ) {
prefs . edit ( ) . putInt ( PREFS_TEXTCOLOR , color ) . commit ( ) ;
}
@Override
public void onCancel ( final AmbilWarnaDialog dialog ) {
}
public void onReset ( final AmbilWarnaDialog dialog ) {
prefs . edit ( ) . putInt ( PREFS_TEXTCOLOR , <num> ) . commit ( ) ;
}
} ) ;
dialog . show ( ) ;
return true ;
}
} ) ;
}
Market . setOnPreferenceClickListener ( pc . getActivity ( ) , pc . findPreference ( " ) , null ,
Market . <unk> , Market . <unk> ) ;
p = pc . findPreference ( " ) ;
if ( p != null ) {
p . setOnPreferenceClickListener ( new Preference . OnPreferenceClickListener ( ) {
public boolean onPreferenceClick ( final Preference preference ) {
Log . <unk> ( pc . getActivity ( ) ) ;
return true ;
}
} ) ;
}
}
static final int getTheme ( final Context context ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final String s = p . getString ( PREFS_THEME , null ) ;
if ( s != null && THEME_LIGHT . equals ( s ) ) {
return R . style . Theme_SherlockUb0r_Light ;
} else if ( s != null && THEME_BLACK . equals ( s ) ) {
return R . style . Theme_SherlockUb0r ;
} else if ( Utils . isApi ( Build . VERSION_CODES . ICE_CREAM_SANDWICH ) ) {
return R . style . Theme_SherlockUb0r_Light ;
} else {
return R . style . Theme_SherlockUb0r ;
}
}
static final int getTextsize ( final Context context ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final String s = p . getString ( PREFS_TEXTSIZE , null ) ;
Log . d ( TAG , " + s ) ;
return Utils . parseInt ( s , <num> ) ;
}
static final int getTextcolor ( final Context context ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
if ( context instanceof ConversationListActivity
&& p . getBoolean ( PREFS_TEXTCOLOR_IGNORE_CONV , false ) ) {
return <num> ;
}
final int ret = p . getInt ( PREFS_TEXTCOLOR , <num> ) ;
Log . d ( TAG , " + ret ) ;
return ret ;
}
static final int getLEDcolor ( final Context context ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final String s = p . getString ( PREFS_LED_COLOR , " ) ;
return Integer . parseInt ( s ) ;
}
static final int [ ] getLEDflash ( final Context context ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final String s = p . getString ( PREFS_LED_FLASH , " ) ;
final String [ ] ss = s . split ( " ) ;
final int [ ] ret = new int [ <num> ] ;
ret [ <num> ] = Integer . parseInt ( ss [ <num> ] ) ;
ret [ <num> ] = Integer . parseInt ( ss [ <num> ] ) ;
return ret ;
}
static final long [ ] getVibratorPattern ( final Context context ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final String s = p . getString ( PREFS_VIBRATOR_PATTERN , " ) ;
final String [ ] ss = s . split ( " ) ;
final int l = ss . length ;
final long [ ] ret = new long [ l ] ;
for ( int i = <num> ; i < l ; i ++ ) {
ret [ i ] = Long . parseLong ( ss [ i ] ) ;
}
return ret ;
}
static final int getNotificationIcon ( final Context context ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final int i = p . getInt ( PREFS_NOTIFICATION_ICON , R . drawable . stat_notify_sms ) ;
if ( i >= <num> && i < NOTIFICAION_IMG . length ) {
return NOTIFICAION_IMG [ i ] ;
}
return R . drawable . stat_notify_sms ;
}
static final int getBubblesIn ( final Context context ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final int i = p . getInt ( PREFS_BUBBLES_IN , R . drawable . bubble_old_turquoise_left ) ;
if ( i >= <num> && i < BUBBLES_IMG . length ) {
return BUBBLES_IMG [ i ] ;
}
return R . drawable . bubble_old_turquoise_left ;
}
static final int getBubblesOut ( final Context context ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final int i = p . getInt ( PREFS_BUBBLES_OUT , R . drawable . bubble_old_green_right ) ;
if ( i >= <num> && i < BUBBLES_IMG . length ) {
return BUBBLES_IMG [ i ] ;
}
return R . drawable . bubble_old_green_right ;
}
static final boolean decodeDecimalNCR ( final Context context ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
final boolean b = p . getBoolean ( PREFS_DECODE_DECIMAL_NCR , true ) ;
Log . d ( TAG , " + b ) ;
return b ;
}
static final String fixNumber ( final Context context , final String number ) {
String ret = number ;
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
for ( int i = <num> ; i <= PREFS_REGEX_COUNT ; i ++ ) {
final String regex = p . getString ( PREFS_REGEX + i , null ) ;
if ( ! TextUtils . isEmpty ( regex ) ) {
Log . d ( TAG , " + regex + " + ret ) ;
ret = ret . replaceAll ( regex , p . getString ( PREFS_REPLACE + i , " ) ) ;
Log . d ( TAG , " + ret ) ;
}
}
return ret ;
}
@Override
public final boolean onOptionsItemSelected ( final MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
Intent intent = new Intent ( this , ConversationListActivity . class ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
this . startActivity ( intent ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
@Override
public final Activity getActivity ( ) {
return this ;
}
@Override
public final Context getContext ( ) {
return this ;
}
}
package de . ub0r . android . smsdroid ;
import android . content . ActivityNotFoundException ;
import android . content . ComponentName ;
import android . content . ContentResolver ;
import android . content . ContentUris ;
import android . content . Context ;
import android . content . Intent ;
import android . database . Cursor ;
import android . database . MergeCursor ;
import android . graphics . Bitmap ;
import android . net . Uri ;
import android . view . View ;
import android . view . View . OnClickListener ;
import android . widget . Button ;
import android . widget . ImageView ;
import android . widget . ResourceCursorAdapter ;
import android . widget . TextView ;
import android . widget . Toast ;
import de . ub0r . android . lib . Log ;
import de . ub0r . android . lib . apis . Contact ;
public class MessageAdapter extends ResourceCursorAdapter {
static final String TAG = " ;
private final int backgroundDrawableIn , backgroundDrawableOut ;
private static final String WHERE = " + Message . PROJECTION_JOIN [ Message . INDEX_TYPE ] + "
+ Message . SMS_DRAFT + " + Message . PROJECTION_JOIN [ Message . INDEX_TYPE ]
+ " ;
private static final String WHERE_DRAFT = " + Message . PROJECTION_SMS [ Message . INDEX_THREADID ]
+ " + Message . PROJECTION_SMS [ Message . INDEX_TYPE ] + " + Message . SMS_DRAFT
+ " ;
private int threadId =  <num> ;
private String address = null ;
private String name = null ;
private String displayName = null ;
private final int textSize , textColor ;
private final boolean convertNCR ;
public MessageAdapter ( final MessageListActivity c , final Uri u ) {
super ( c , R . layout . <unk> , getCursor ( c . getContentResolver ( ) , u ) , true ) ;
this . backgroundDrawableIn = PreferencesActivity . getBubblesIn ( c ) ;
this . backgroundDrawableOut = PreferencesActivity . getBubblesOut ( c ) ;
this . textSize = PreferencesActivity . getTextsize ( c ) ;
this . textColor = PreferencesActivity . getTextcolor ( c ) ;
this . convertNCR = PreferencesActivity . decodeDecimalNCR ( c ) ;
if ( u == null || u . getLastPathSegment ( ) == null ) {
this . threadId =  <num> ;
} else {
this . threadId = Integer . parseInt ( u . getLastPathSegment ( ) ) ;
}
final Conversation conv = Conversation . getConversation ( c , this . threadId , false ) ;
if ( conv == null ) {
this . address = null ;
this . name = null ;
this . displayName = null ;
} else {
final Contact contact = conv . getContact ( ) ;
this . address = contact . getNumber ( ) ;
this . name = contact . getName ( ) ;
this . displayName = contact . getDisplayName ( ) ;
}
Log . d ( TAG , " + this . address ) ;
Log . d ( TAG , " + this . name ) ;
Log . d ( TAG , " + this . displayName ) ;
}
private static Cursor getCursor ( final ContentResolver cr , final Uri u ) {
Log . d ( TAG , " + u + " ) ;
final Cursor [ ] c = new Cursor [ ] { null , null } ;
int tid =  <num> ;
try {
tid = Integer . parseInt ( u . getLastPathSegment ( ) ) ;
} catch ( Exception e ) {
Log . e ( TAG , " + u , e ) ;
}
try {
Log . d ( TAG , " + WHERE ) ;
c [ <num> ] = cr . query ( u , Message . PROJECTION_JOIN , WHERE , null , null ) ;
} catch ( NullPointerException e ) {
Log . e ( TAG , " + u + " + WHERE , e ) ;
c [ <num> ] = null ;
}
final String [ ] sel = new String [ ] { String . valueOf ( tid ) } ;
try {
Log . d ( TAG , " + WHERE_DRAFT + " + sel ) ;
c [ <num> ] = cr . query ( Uri . parse ( " ) , Message . PROJECTION_SMS , WHERE_DRAFT , sel ,
Message . SORT_USD ) ;
} catch ( NullPointerException e ) {
Log . e ( TAG , " + u + " + WHERE_DRAFT + " + sel , e ) ;
c [ <num> ] = null ;
}
if ( c [ <num> ] == null || c [ <num> ] . getCount ( ) == <num> ) {
return c [ <num> ] ;
}
if ( c [ <num> ] == null || c [ <num> ] . getCount ( ) == <num> ) {
return c [ <num> ] ;
}
return new MergeCursor ( c ) ;
}
@Override
public final void bindView ( final View view , final Context context , final Cursor cursor ) {
final Message m = Message . getMessage ( context , cursor ) ;
final TextView tvPerson = ( TextView ) view . findViewById ( R . id . addr ) ;
final TextView tvBody = ( TextView ) view . findViewById ( R . id . body ) ;
final TextView tvDate = ( TextView ) view . findViewById ( R . id . date ) ;
if ( this . textSize > <num> ) {
tvBody . setTextSize ( this . textSize ) ;
}
final int col = this . textColor ;
if ( col != <num> ) {
tvPerson . setTextColor ( col ) ;
tvBody . setTextColor ( col ) ;
tvDate . setTextColor ( col ) ;
}
int t = m . getType ( ) ;
String subject = m . getSubject ( ) ;
if ( subject == null ) {
subject = " ;
} else {
subject = " + subject ;
}
final View pending = view . findViewById ( R . id . pending ) ;
int pendingvisability = View . GONE ;
switch ( t ) {
case Message . SMS_DRAFT :
pendingvisability = View . VISIBLE ;
case Message . SMS_OUT :
case Message . MMS_OUT :
tvPerson . setText ( context . getString ( R . string . me ) + subject ) ;
try {
view . findViewById ( R . id . layout ) . setBackgroundResource ( this . backgroundDrawableOut ) ;
} catch ( OutOfMemoryError e ) {
Log . e ( TAG , " , e ) ;
}
( ( ImageView ) view . findViewById ( R . id . inout ) )
. setImageResource ( R . drawable . <unk> ) ;
break ;
case Message . SMS_IN :
case Message . MMS_IN :
default :
tvPerson . setText ( this . displayName + subject ) ;
try {
view . findViewById ( R . id . layout ) . setBackgroundResource ( this . backgroundDrawableIn ) ;
} catch ( OutOfMemoryError e ) {
Log . e ( TAG , " , e ) ;
}
( ( ImageView ) view . findViewById ( R . id . inout ) )
. setImageResource ( R . drawable . <unk> ) ;
pending . setVisibility ( View . GONE ) ;
break ;
}
pending . setVisibility ( pendingvisability ) ;
if ( m . getRead ( ) == <num> ) {
view . findViewById ( R . id . read ) . setVisibility ( View . VISIBLE ) ;
} else {
view . findViewById ( R . id . read ) . setVisibility ( View . INVISIBLE ) ;
}
final long time = m . getDate ( ) ;
tvDate . setText ( ConversationListActivity . getDate ( context , time ) ) ;
ImageView ivPicture = ( ImageView ) view . findViewById ( R . id . picture ) ;
final Bitmap pic = m . getPicture ( ) ;
if ( pic != null ) {
if ( pic == Message . BITMAP_PLAY ) {
ivPicture . setImageResource ( R . drawable . <unk> ) ;
} else {
ivPicture . setImageBitmap ( pic ) ;
}
ivPicture . setVisibility ( View . VISIBLE ) ;
final Intent i = m . getContentIntent ( ) ;
ivPicture . setOnClickListener ( SMSdroid . getOnClickStartActivity ( context , i ) ) ;
ivPicture . setOnLongClickListener ( m . getSaveAttachmentListener ( context ) ) ;
} else {
ivPicture . setVisibility ( View . GONE ) ;
ivPicture . setOnClickListener ( null ) ;
}
CharSequence text = m . getBody ( ) ;
if ( text == null && pic == null ) {
final Button btn = ( Button ) view . findViewById ( R . id . btn_download_msg ) ;
btn . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( final View v ) {
Intent i = new Intent ( ) ;
i . setClassName ( " ,
" ) ;
i . putExtra ( " , m . getUri ( ) . toString ( ) ) ;
i . putExtra ( " , <num> ) ;
ComponentName cn = context . startService ( i ) ;
if ( cn != null ) {
btn . setEnabled ( false ) ;
btn . setText ( R . string . <unk> ) ;
} else {
i = new Intent ( Intent . ACTION_VIEW , Uri . parse ( MessageListActivity . URI
+ m . getThreadId ( ) ) ) ;
context . startActivity ( Intent . createChooser ( i ,
context . getString ( R . string . <unk> ) ) ) ;
}
}
} ) ;
btn . setVisibility ( View . VISIBLE ) ;
btn . setEnabled ( true ) ;
} else {
view . findViewById ( R . id . btn_download_msg ) . setVisibility ( View . GONE ) ;
}
if ( text == null ) {
tvBody . setVisibility ( View . INVISIBLE ) ;
view . findViewById ( R . id . btn_import_contact ) . setVisibility ( View . GONE ) ;
} else {
if ( this . convertNCR ) {
tvBody . setText ( Converter . convertDecNCR2Char ( text ) ) ;
} else {
tvBody . setText ( text ) ;
}
tvBody . setVisibility ( View . VISIBLE ) ;
String stext = text . toString ( ) ;
if ( stext . contains ( " ) && stext . contains ( " ) ) {
stext = stext . replaceAll ( " , " ) ;
stext = stext . replaceAll ( " , " ) ;
final Button btn = ( Button ) view . findViewById ( R . id . btn_import_contact ) ;
btn . setVisibility ( View . VISIBLE ) ;
btn . setOnClickListener ( new OnClickListener ( ) {
@Override
public void onClick ( final View v ) {
final Intent i = new Intent ( Intent . ACTION_VIEW ) ;
Uri uri = ContentUris . withAppendedId ( MessageProvider . CONTENT_URI , m . getId ( ) ) ;
i . setDataAndType ( uri , " ) ;
try {
context . startActivity ( i ) ;
} catch ( ActivityNotFoundException e ) {
Log . e ( TAG , " + i . getAction ( ) , e ) ;
Toast . makeText ( context , " ,
Toast . LENGTH_LONG ) . show ( ) ;
}
}
} ) ;
} else {
view . findViewById ( R . id . btn_import_contact ) . setVisibility ( View . GONE ) ;
}
}
}
}
package de . ub0r . android . smsdroid ;
import java . util . Set ;
import android . app . Activity ;
import android . os . Build ;
import android . view . View ;
import android . webkit . WebViewDatabase ;
import android . widget . LinearLayout ;
import com . google . ads . Ad ;
import com . google . ads . AdListener ;
import com . google . ads . AdRequest ;
import com . google . ads . AdRequest . ErrorCode ;
import com . google . ads . AdSize ;
import com . google . ads . AdView ;
import de . ub0r . android . lib . Log ;
import de . ub0r . android . lib . Utils ;
public final class Ads {
private static final String TAG = " ;
private Ads ( ) {
}
public static void loadAd ( final Activity activity , final int adBase , final String unitId ,
final Set < String > keywords ) {
Log . d ( TAG , " + unitId + " ) ;
final LinearLayout adframe = ( LinearLayout ) activity . findViewById ( adBase ) ;
if ( adframe == null ) {
Log . e ( TAG , " ) ;
return ;
} else if ( ! Utils . isApi ( Build . VERSION_CODES . GINGERBREAD ) ) {
Log . d ( TAG , " + Build . VERSION . SDK + " ) ;
WebViewDatabase webViewDB = WebViewDatabase . getInstance ( activity ) ;
if ( webViewDB == null ) {
Log . e ( TAG , " ) ;
return ;
}
}
AdView adv ;
View v = adframe . getChildAt ( <num> ) ;
if ( v != null && v instanceof AdView ) {
adv = ( AdView ) v ;
} else {
AdSize as = AdSize . BANNER ;
adv = new AdView ( activity , as , unitId ) ;
adframe . addView ( adv ) ;
}
final AdRequest ar = new AdRequest ( ) ;
if ( keywords != null ) {
ar . setKeywords ( keywords ) ;
}
adv . <unk> ( new AdListener ( ) {
@Override
public void <unk> ( final Ad ad ) {
Log . d ( TAG , " + ad . toString ( ) ) ;
adframe . setVisibility ( View . VISIBLE ) ;
}
@Override
public void <unk> ( final Ad ad ) {
}
@Override
public void <unk> ( final Ad ad ) {
}
@Override
public void <unk> ( final Ad ad , final ErrorCode err ) {
Log . i ( TAG , " + err ) ;
}
@Override
public void <unk> ( final Ad arg0 ) {
}
} ) ;
Log . d ( TAG , " ) ;
adv . loadAd ( ar ) ;
Log . d ( TAG , " ) ;
}
}
package de . ub0r . android . smsdroid ;
import android . app . Activity ;
import android . content . Context ;
import android . os . Bundle ;
import android . preference . PreferenceFragment ;
import de . ub0r . android . lib . IPreferenceContainer ;
public final class <unk> extends PreferenceFragment implements
IPreferenceContainer {
@Override
public void onCreate ( final Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
final Activity a = this . getActivity ( ) ;
int res = a . getResources ( ) . getIdentifier ( this . getArguments ( ) . getString ( " ) , " ,
a . getPackageName ( ) ) ;
this . addPreferencesFromResource ( res ) ;
PreferencesActivity . registerOnPreferenceClickListener ( this ) ;
}
@Override
public Context getContext ( ) {
return this . getActivity ( ) ;
}
}
package de . ub0r . android . smsdroid ;
import android . app . PendingIntent ;
import android . appwidget . AppWidgetManager ;
import android . appwidget . AppWidgetProvider ;
import android . content . Context ;
import android . content . SharedPreferences ;
import android . preference . PreferenceManager ;
import android . view . View ;
import android . widget . RemoteViews ;
import de . ub0r . android . lib . Log ;
public final class WidgetProvider extends AppWidgetProvider {
private static final String TAG = " ;
@Override
public void onUpdate ( final Context context , final AppWidgetManager appWidgetManager ,
final int [ ] appWidgetIds ) {
Log . d ( TAG , " ) ;
SmsReceiver . updateNewMessageNotification ( context , null ) ;
}
static RemoteViews getRemoteViews ( final Context context , final int count ,
final PendingIntent pIntent ) {
final SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( context ) ;
RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . widget ) ;
views . setTextViewText ( R . id . text1 , String . valueOf ( count ) ) ;
if ( count == <num> ) {
views . setViewVisibility ( R . id . text1 , View . GONE ) ;
} else {
views . setViewVisibility ( R . id . text1 , View . VISIBLE ) ;
}
if ( p . getBoolean ( PreferencesActivity . PREFS_HIDE_WIDGET_LABEL , false ) ) {
views . setViewVisibility ( R . id . label , View . GONE ) ;
} else {
views . setViewVisibility ( R . id . label , View . VISIBLE ) ;
}
if ( pIntent != null ) {
views . setOnClickPendingIntent ( R . id . widget , pIntent ) ;
Log . d ( TAG , " + pIntent . toString ( ) ) ;
}
return views ;
}
}
package de . ub0r . android . smsdroid ;
import android . content . ContentResolver ;
import android . content . Context ;
import android . database . Cursor ;
import android . net . Uri ;
import android . text . TextUtils ;
import android . view . View ;
import android . widget . ResourceCursorAdapter ;
import android . widget . TextView ;
import de . ub0r . android . lib . DbUtils ;
import de . ub0r . android . lib . apis . ContactsWrapper ;
public class MobilePhoneAdapter extends ResourceCursorAdapter {
private static boolean prefsMobilesOnly ;
private ContentResolver mContentResolver ;
private static final ContactsWrapper WRAPPER = ContactsWrapper . getInstance ( ) ;
private static final Uri URI = WRAPPER . getContentUri ( ) ;
private static final String [ ] PROJECTION = WRAPPER . <unk> ( ) ;
private static final String SORT = WRAPPER . <unk> ( ) ;
private final String [ ] types ;
public MobilePhoneAdapter ( final Context context ) {
super ( context , R . layout . <unk> , null ) ;
this . mContentResolver = context . getContentResolver ( ) ;
this . types = context . getResources ( ) . getStringArray ( android . R . array . phoneTypes ) ;
}
@Override
public final void bindView ( final View view , final Context context , final Cursor cursor ) {
( ( TextView ) view . findViewById ( R . id . text1 ) ) . setText ( cursor
. getString ( ContactsWrapper . CONTENT_INDEX_NAME ) ) ;
( ( TextView ) view . findViewById ( R . id . text2 ) ) . setText ( cursor
. getString ( ContactsWrapper . CONTENT_INDEX_NUMBER ) ) ;
final int i = cursor . getInt ( ContactsWrapper . <unk> )  <num> ;
if ( i >= <num> && i < this . types . length ) {
( ( TextView ) view . findViewById ( R . id . text3 ) ) . setText ( this . types [ i ] ) ;
} else {
( ( TextView ) view . findViewById ( R . id . text3 ) ) . setText ( " ) ;
}
}
@Override
public final String <unk> ( final Cursor cursor ) {
final String name = cursor . getString ( ContactsWrapper . CONTENT_INDEX_NAME ) ;
final String number = cursor . getString ( ContactsWrapper . CONTENT_INDEX_NUMBER ) ;
if ( name == null || name . length ( ) == <num> ) {
return cleanRecipient ( number ) ;
}
return name + " + cleanRecipient ( number ) + >' ;
}
@Override
public final Cursor <unk> ( final CharSequence constraint ) {
String where = null ;
if ( constraint != null ) {
where = WRAPPER . <unk> ( constraint . toString ( ) ) ;
if ( prefsMobilesOnly ) {
where = DbUtils . <unk> ( where , WRAPPER . <unk> ( ) ) ;
}
}
final Cursor cursor = this . mContentResolver . query ( URI , PROJECTION , where , null , SORT ) ;
return cursor ;
}
static final void <unk> ( final boolean b ) {
prefsMobilesOnly = b ;
}
public static String cleanRecipient ( final String recipient ) {
if ( TextUtils . isEmpty ( recipient ) ) {
return " ;
}
String n ;
if ( recipient . indexOf ( " ) < recipient . indexOf ( " ) ) {
n = recipient . substring ( recipient . indexOf ( " ) , recipient . indexOf ( " ) ) ;
} else {
n = recipient ;
}
return n . replaceAll ( " , " ) . replaceAll ( " , " ) ;
}
}
package de . ub0r . android . smsdroid ;
package de . ub0r . android . smsdroid ;
import java . io . ByteArrayOutputStream ;
import java . io . File ;
import java . io . FileOutputStream ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . OutputStream ;
import java . util . LinkedHashMap ;
import org . apache . commons . io . IOUtils ;
import android . content . ContentResolver ;
import android . content . ContentUris ;
import android . content . Context ;
import android . content . Intent ;
import android . database . Cursor ;
import android . graphics . Bitmap ;
import android . graphics . Bitmap . Config ;
import android . graphics . BitmapFactory ;
import android . net . Uri ;
import android . os . Environment ;
import android . provider . CallLog . Calls ;
import android . view . View ;
import android . view . View . OnLongClickListener ;
import android . widget . Toast ;
import de . ub0r . android . lib . Log ;
public final class Message {
static final String TAG = " ;
public static final Bitmap BITMAP_PLAY = Bitmap . createBitmap ( <num> , <num> , Config . RGB_565 ) ;
public static final String ATTACHMENT_FILE = " ;
private static final int CAHCESIZE = <num> ;
private static final LinkedHashMap < Integer , Message > CACHE = new LinkedHashMap < Integer , Message > (
26 , <num> , true ) ;
public static final int INDEX_ID = <num> ;
public static final int INDEX_READ = <num> ;
public static final int INDEX_DATE = <num> ;
public static final int INDEX_THREADID = <num> ;
public static final int INDEX_TYPE = <num> ;
public static final int INDEX_ADDRESS = <num> ;
public static final int INDEX_BODY = <num> ;
public static final int INDEX_SUBJECT = <num> ;
public static final int INDEX_MTYPE = <num> ;
public static final int INDEX_MID = <num> ;
public static final int INDEX_CT = <num> ;
public static final String [ ] PROJECTION = {
" ,
" ,
Calls . DATE ,
" ,
Calls . TYPE ,
" ,
" ,
} ;
public static final String [ ] PROJECTION_SMS = {
PROJECTION [ INDEX_ID ] ,
PROJECTION [ INDEX_READ ] ,
PROJECTION [ INDEX_DATE ] ,
PROJECTION [ INDEX_THREADID ] ,
PROJECTION [ INDEX_TYPE ] ,
PROJECTION [ INDEX_ADDRESS ] ,
PROJECTION [ INDEX_BODY ] ,
} ;
public static final String [ ] <unk> = {
PROJECTION [ INDEX_ID ] ,
PROJECTION [ INDEX_READ ] ,
PROJECTION [ INDEX_DATE ] ,
PROJECTION [ INDEX_THREADID ] ,
" ,
PROJECTION [ INDEX_ID ] ,
PROJECTION [ INDEX_ID ] ,
" ,
" ,
} ;
public static final String [ ] PROJECTION_JOIN = {
PROJECTION [ INDEX_ID ] ,
PROJECTION [ INDEX_READ ] ,
PROJECTION [ INDEX_DATE ] ,
PROJECTION [ INDEX_THREADID ] ,
PROJECTION [ INDEX_TYPE ] ,
PROJECTION [ INDEX_ADDRESS ] ,
PROJECTION [ INDEX_BODY ] ,
" ,
" ,
} ;
public static final String [ ] PROJECTION_READ = {
PROJECTION [ INDEX_ID ] ,
PROJECTION [ INDEX_READ ] ,
PROJECTION [ INDEX_DATE ] ,
PROJECTION [ INDEX_THREADID ] ,
} ;
private static final Uri URI_PARTS = Uri . parse ( " ) ;
public static final String [ ] PROJECTION_PARTS = {
" ,
" ,
" ,
} ;
static final String SELECTION_READ_UNREAD = " ;
static final String [ ] SELECTION_UNREAD = new String [ ] { " } ;
static final String [ ] SELECTION_READ = new String [ ] { " } ;
public static final String SORT_USD = Calls . DATE + " ;
public static final String <unk> = Calls . DATE + " ;
public static final int SMS_IN = Calls . INCOMING_TYPE ;
public static final int SMS_OUT = Calls . OUTGOING_TYPE ;
public static final int SMS_DRAFT = <num> ;
public static final int MMS_IN = <num> ;
public static final int MMS_OUT = <num> ;
public static final int <unk> = <num> ;
private long id ;
private long threadId ;
private long date ;
private String address ;
private CharSequence body ;
private int type ;
private int read ;
private String subject = null ;
private Bitmap picture = null ;
private Intent contentIntent = null ;
private final boolean isMms ;
private Message ( final Context context , final Cursor cursor ) {
this . id = cursor . getLong ( INDEX_ID ) ;
this . threadId = cursor . getLong ( INDEX_THREADID ) ;
this . date = cursor . getLong ( INDEX_DATE ) ;
if ( this . date < ConversationListActivity . MIN_DATE ) {
this . date *= ConversationListActivity . MILLIS ;
}
if ( cursor . getColumnIndex ( PROJECTION_JOIN [ INDEX_TYPE ] ) >= <num> ) {
this . address = cursor . getString ( INDEX_ADDRESS ) ;
this . body = cursor . getString ( INDEX_BODY ) ;
if ( ConversationListActivity . showEmoticons && this . body != null ) {
this . body = SmileyParser . getInstance ( context ) . addSmileySpans ( this . body ) ;
}
} else {
this . body = null ;
this . address = null ;
}
this . type = cursor . getInt ( INDEX_TYPE ) ;
this . read = cursor . getInt ( INDEX_READ ) ;
if ( this . body == null ) {
this . isMms = true ;
try {
this . fetchMmsParts ( context ) ;
} catch ( OutOfMemoryError e ) {
Log . e ( TAG , " , e ) ;
try {
Toast . makeText ( context , e . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ;
} catch ( Exception e1 ) {
Log . e ( TAG , " , e1 ) ;
}
}
} else {
this . isMms = false ;
}
try {
this . subject = cursor . getString ( INDEX_SUBJECT ) ;
} catch ( IllegalStateException e ) {
this . subject = null ;
}
try {
if ( cursor . getColumnCount ( ) > INDEX_MTYPE ) {
final int t = cursor . getInt ( INDEX_MTYPE ) ;
if ( t != <num> ) {
this . type = t ;
}
}
} catch ( IllegalStateException e ) {
this . subject = null ;
}
Log . d ( TAG , " + this . threadId ) ;
Log . d ( TAG , " + this . address ) ;
}
public void update ( final Cursor cursor ) {
this . read = cursor . getInt ( INDEX_READ ) ;
this . type = cursor . getInt ( INDEX_TYPE ) ;
try {
if ( cursor . getColumnCount ( ) > INDEX_MTYPE ) {
final int t = cursor . getInt ( INDEX_MTYPE ) ;
if ( t != <num> ) {
this . type = t ;
}
}
} catch ( IllegalStateException e ) {
Log . e ( TAG , " , e ) ;
}
}
private CharSequence fetchPart ( final InputStream is ) {
Log . d ( TAG , " ) ;
String ret = null ;
final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ;
try {
byte [ ] buffer = new byte [ <num> ] ;
int len = is . read ( buffer ) ;
while ( len >= <num> ) {
baos . write ( buffer , <num> , len ) ;
len = is . read ( buffer ) ;
}
ret = new String ( baos . toByteArray ( ) ) ;
Log . d ( TAG , ret ) ;
} catch ( IOException e ) {
Log . e ( TAG , " , e ) ;
} finally {
if ( is != null ) {
try {
is . close ( ) ;
} catch ( IOException e ) {
Log . e ( TAG , " , e ) ;
}
}
}
return ret ;
}
private void fetchMmsParts ( final Context context ) {
final ContentResolver cr = context . getContentResolver ( ) ;
Cursor cursor = cr . query ( URI_PARTS , null , PROJECTION_PARTS [ INDEX_MID ] + " ,
new String [ ] { String . valueOf ( this . id ) } , null ) ;
if ( cursor == null || ! cursor . moveToFirst ( ) ) {
return ;
}
final int iID = cursor . getColumnIndex ( PROJECTION_PARTS [ INDEX_ID ] ) ;
final int iCT = cursor . getColumnIndex ( PROJECTION_PARTS [ INDEX_CT ] ) ;
final int iText = cursor . getColumnIndex ( " ) ;
do {
final int pid = cursor . getInt ( iID ) ;
final String ct = cursor . getString ( iCT ) ;
Log . d ( TAG , " + pid + " + ct ) ;
InputStream is = null ;
final Uri uri = ContentUris . withAppendedId ( URI_PARTS , pid ) ;
try {
is = cr . openInputStream ( uri ) ;
} catch ( IOException e ) {
Log . e ( TAG , " , e ) ;
}
if ( is == null ) {
Log . i ( TAG , " + pid + " ) ;
if ( iText >= <num> && ct . startsWith ( " ) ) {
this . body = cursor . getString ( iText ) ;
}
continue ;
}
if ( ct == null ) {
continue ;
}
if ( ct . startsWith ( " ) ) {
this . picture = BitmapFactory . decodeStream ( is ) ;
final Intent i = new Intent ( Intent . ACTION_VIEW ) ;
i . setDataAndType ( uri , ct ) ;
i . addFlags ( Intent . <unk> ) ;
this . contentIntent = i ;
continue ;
} else if ( ct . startsWith ( " ) || ct . startsWith ( " ) ) {
this . picture = BITMAP_PLAY ;
final Intent i = new Intent ( Intent . ACTION_VIEW ) ;
i . setDataAndType ( uri , ct ) ;
this . contentIntent = i ;
continue ;
} else if ( ct . startsWith ( " ) ) {
this . body = this . fetchPart ( is ) ;
}
if ( is != null ) {
try {
is . close ( ) ;
} catch ( IOException e ) {
Log . e ( TAG , " , e ) ;
}
}
} while ( cursor . moveToNext ( ) ) ;
}
public static Message getMessage ( final Context context , final Cursor cursor ) {
synchronized ( CACHE ) {
String body = cursor . getString ( INDEX_BODY ) ;
int id = cursor . getInt ( INDEX_ID ) ;
if ( body == null ) {
id *=  <num> ;
}
Message ret = CACHE . get ( id ) ;
if ( ret == null ) {
ret = new Message ( context , cursor ) ;
CACHE . put ( id , ret ) ;
Log . d ( TAG , " + CACHE . size ( ) ) ;
while ( CACHE . size ( ) > CAHCESIZE ) {
Integer i = CACHE . keySet ( ) . iterator ( ) . next ( ) ;
Log . d ( TAG , " + i ) ;
Message cc = CACHE . remove ( i ) ;
if ( cc == null ) {
Log . w ( TAG , " ) ;
break ;
}
}
} else {
ret . update ( cursor ) ;
}
return ret ;
}
}
public static void flushCache ( ) {
synchronized ( CACHE ) {
CACHE . clear ( ) ;
}
}
public long getId ( ) {
return this . id ;
}
public long getThreadId ( ) {
return this . threadId ;
}
public long getDate ( ) {
return this . date ;
}
public String getAddress ( final Context context ) {
if ( this . address == null && context != null ) {
final String select = Message . PROJECTION [ Message . INDEX_THREADID ] + "
+ this . getThreadId ( ) + " + Message . PROJECTION [ Message . INDEX_ADDRESS ]
+ " ;
Log . d ( TAG , " + select ) ;
final Cursor cur = context . getContentResolver ( ) . query ( Uri . parse ( " ) ,
Message . PROJECTION , select , null , null ) ;
if ( cur != null && cur . moveToFirst ( ) ) {
this . address = cur . getString ( Message . INDEX_ADDRESS ) ;
Log . d ( TAG , " + this . address ) ;
}
cur . close ( ) ;
}
return this . address ;
}
public CharSequence getBody ( ) {
return this . body ;
}
public int getType ( ) {
return this . type ;
}
public int getRead ( ) {
return this . read ;
}
public boolean isMMS ( ) {
return this . isMms ;
}
public String getSubject ( ) {
return this . subject ;
}
public Bitmap getPicture ( ) {
return this . picture ;
}
public Intent getContentIntent ( ) {
return this . contentIntent ;
}
public OnLongClickListener getSaveAttachmentListener ( final Context context ) {
if ( this . contentIntent == null ) {
return null ;
}
return new OnLongClickListener ( ) {
@Override
public boolean onLongClick ( final View v ) {
try {
Log . d ( TAG , " + Message . this . id ) ;
String fn = ATTACHMENT_FILE ;
final Intent ci = Message . this . contentIntent ;
final String ct = ci . getType ( ) ;
Log . d ( TAG , " + ct ) ;
if ( ct . startsWith ( " ) ) {
if ( ct . equals ( " ) ) {
fn += " ;
} else if ( ct . equals ( " ) ) {
fn += " ;
} else {
fn += " ;
}
} else if ( ct . startsWith ( " ) ) {
if ( ct . equals ( " ) ) {
fn += " ;
} else if ( ct . equals ( " ) ) {
fn += " ;
} else if ( ct . equals ( " ) ) {
fn += " ;
} else {
fn += " ;
}
} else if ( ct . startsWith ( " ) ) {
if ( ct . equals ( " ) ) {
fn += " ;
} else {
fn += " ;
}
} else {
fn += " ;
}
final File file = Message . this . createUniqueFile (
Environment . getExternalStorageDirectory ( ) , fn ) ;
InputStream in = context . getContentResolver ( ) . openInputStream ( ci . getData ( ) ) ;
OutputStream out = new FileOutputStream ( file ) ;
IOUtils . copy ( in , out ) ;
out . flush ( ) ;
out . close ( ) ;
in . close ( ) ;
Log . i ( TAG , " + file . getPath ( ) ) ;
Toast . makeText ( context ,
context . getString ( R . string . <unk> ) + " + fn ,
Toast . LENGTH_LONG ) . show ( ) ;
return true ;
} catch ( IOException e ) {
Log . e ( TAG , " , e ) ;
Toast . makeText ( context , R . string . <unk> , Toast . LENGTH_LONG )
. show ( ) ;
}
return true ;
}
} ;
}
public Uri getUri ( ) {
if ( this . isMms ) {
return Uri . parse ( " + this . id ) ;
} else {
return Uri . parse ( " + this . id ) ;
}
}
private File createUniqueFile ( final File directory , final String filename ) {
File file = new File ( directory , filename ) ;
if ( ! file . exists ( ) ) {
return file ;
}
int index = filename . lastIndexOf ( .' ) ;
String format ;
if ( index !=  <num> ) {
String name = filename . substring ( <num> , index ) ;
String extension = filename . substring ( index ) ;
format = name + " + extension ;
} else {
format = filename + " ;
}
for ( int i = <num> ; i < Integer . MAX_VALUE ; i ++ ) {
file = new File ( directory , String . format ( format , i ) ) ;
if ( ! file . exists ( ) ) {
return file ;
}
}
return null ;
}
}
package de . ub0r . android . smsdroid ;
import android . app . Activity ;
import android . content . AsyncQueryHandler ;
import android . content . ContentResolver ;
import android . content . Context ;
import android . content . SharedPreferences ;
import android . database . ContentObserver ;
import android . database . Cursor ;
import android . database . sqlite . SQLiteException ;
import android . graphics . drawable . Drawable ;
import android . os . Handler ;
import android . preference . PreferenceManager ;
import android . provider . CallLog . Calls ;
import android . support . v4 . widget . ResourceCursorAdapter ;
import android . view . View ;
import android . view . ViewGroup ;
import android . widget . ImageView ;
import android . widget . LinearLayout ;
import android . widget . TextView ;
import de . ub0r . android . lib . Log ;
import de . ub0r . android . lib . apis . Contact ;
import de . ub0r . android . lib . apis . ContactsWrapper ;
public class ConversationAdapter extends ResourceCursorAdapter {
static final String TAG = " ;
public static final String SORT = Calls . DATE + " ;
private final int textSize , textColor ;
private final Cursor origCursor ;
private final BackgroundQueryHandler queryHandler ;
private static final int MESSAGE_LIST_QUERY_TOKEN = <num> ;
private final Activity activity ;
private final String [ ] blacklist ;
private static final ContactsWrapper WRAPPER = ContactsWrapper . getInstance ( ) ;
private Drawable defaultContactAvatar = null ;
private final boolean convertNCR ;
private boolean useGridLayout ;
static class ViewHolder {
TextView tvBody ;
TextView tvPerson ;
TextView tvCount ;
TextView tvDate ;
ImageView ivPhoto ;
View vRead ;
}
private final class BackgroundQueryHandler extends AsyncQueryHandler {
public BackgroundQueryHandler ( final ContentResolver contentResolver ) {
super ( contentResolver ) ;
}
@Override
protected void onQueryComplete ( final int token , final Object cookie , final Cursor cursor ) {
switch ( token ) {
case MESSAGE_LIST_QUERY_TOKEN :
ConversationAdapter . this . changeCursor ( cursor ) ;
ConversationAdapter . this . activity
. setProgressBarIndeterminateVisibility ( Boolean . FALSE ) ;
return ;
default :
return ;
}
}
}
public ConversationAdapter ( final Activity c ) {
super ( c , R . layout . <unk> , null , true ) ;
this . activity = c ;
SharedPreferences p = PreferenceManager . getDefaultSharedPreferences ( activity ) ;
this . useGridLayout = p . getBoolean ( " , false ) ;
if ( useGridLayout ) {
super . <unk> ( R . layout . <unk> ) ;
}
final ContentResolver cr = c . getContentResolver ( ) ;
this . queryHandler = new BackgroundQueryHandler ( cr ) ;
SpamDB spam = new SpamDB ( c ) ;
spam . open ( ) ;
this . blacklist = spam . getAllEntries ( ) ;
spam . close ( ) ;
spam = null ;
this . defaultContactAvatar = c . getResources ( ) . getDrawable ( R . drawable . ic_contact_picture ) ;
this . convertNCR = PreferencesActivity . decodeDecimalNCR ( c ) ;
this . textSize = PreferencesActivity . getTextsize ( c ) ;
this . textColor = PreferencesActivity . getTextcolor ( c ) ;
this . origCursor = cr . query ( Conversation . URI_SIMPLE , Conversation . PROJECTION_SIMPLE , null ,
null , null ) ;
if ( this . origCursor != null ) {
this . origCursor . registerContentObserver ( new ContentObserver ( new Handler ( ) ) {
@Override
public void onChange ( final boolean selfChange ) {
super . onChange ( selfChange ) ;
if ( ! selfChange ) {
Log . d ( TAG , " ) ;
ConversationAdapter . this . startMsgListQuery ( ) ;
Log . d ( TAG , " ) ;
Conversation . invalidate ( ) ;
}
}
} ) ;
}
}
public final void startMsgListQuery ( ) {
this . queryHandler . <unk> ( MESSAGE_LIST_QUERY_TOKEN ) ;
try {
this . activity . setProgressBarIndeterminateVisibility ( Boolean . TRUE ) ;
this . queryHandler . startQuery ( MESSAGE_LIST_QUERY_TOKEN , null , Conversation . URI_SIMPLE ,
Conversation . PROJECTION_SIMPLE , null , null , SORT ) ;
} catch ( SQLiteException e ) {
Log . e ( TAG , " , e ) ;
}
}
@Override
public View getView ( int pos , View convertView , ViewGroup parent ) {
return super . getView ( pos , convertView , parent ) ;
}
@Override
public final void bindView ( final View view , final Context context , final Cursor cursor ) {
final Conversation c = Conversation . getConversation ( context , cursor , false ) ;
final Contact contact = c . getContact ( ) ;
ViewHolder holder = ( ViewHolder ) view . getTag ( ) ;
if ( holder == null ) {
holder = new ViewHolder ( ) ;
holder . tvPerson = ( TextView ) view . findViewById ( R . id . addr ) ;
holder . tvCount = ( TextView ) view . findViewById ( R . id . count ) ;
holder . tvBody = ( TextView ) view . findViewById ( R . id . body ) ;
holder . tvDate = ( TextView ) view . findViewById ( R . id . date ) ;
holder . ivPhoto = ( ImageView ) view . findViewById ( R . id . photo ) ;
holder . vRead = ( View ) view . findViewById ( R . id . read ) ;
view . setTag ( holder ) ;
}
if ( useGridLayout ) {
holder . tvCount . setVisibility ( View . GONE ) ;
} else {
final int count = c . getCount ( ) ;
if ( count < <num> ) {
holder . tvCount . setText ( " ) ;
} else {
holder . tvCount . setText ( " + c . getCount ( ) + " ) ;
}
}
if ( this . textSize > <num> ) {
holder . tvBody . setTextSize ( this . textSize ) ;
}
final int col = this . textColor ;
if ( col != <num> ) {
holder . tvPerson . setTextColor ( col ) ;
holder . tvBody . setTextColor ( col ) ;
holder . tvCount . setTextColor ( col ) ;
holder . tvDate . setTextColor ( col ) ;
}
if ( useGridLayout || ConversationListActivity . showContactPhoto ) {
holder . ivPhoto . setImageDrawable ( contact . getAvatar ( this . activity ,
this . defaultContactAvatar ) ) ;
holder . ivPhoto . setVisibility ( View . VISIBLE ) ;
if ( ! useGridLayout ) {
holder . ivPhoto . setOnClickListener ( WRAPPER . getQuickContact ( context , holder . ivPhoto ,
contact . getLookUpUri ( context . getContentResolver ( ) ) , <num> , null ) ) ;
}
} else {
holder . ivPhoto . setVisibility ( View . GONE ) ;
}
if ( this . isBlocked ( contact . getNumber ( ) ) ) {
holder . tvPerson . setText ( " + contact . getDisplayName ( ) + " ) ;
} else {
holder . tvPerson . setText ( contact . getDisplayName ( ) ) ;
}
if ( c . getRead ( ) == <num> ) {
holder . vRead . setVisibility ( View . VISIBLE ) ;
} else {
holder . vRead . setVisibility ( View . INVISIBLE ) ;
}
String text = c . getBody ( ) ;
if ( text == null ) {
text = context . getString ( R . string . mms_conversation ) ;
}
if ( this . convertNCR ) {
holder . tvBody . setText ( Converter . convertDecNCR2Char ( text ) ) ;
} else {
holder . tvBody . setText ( text ) ;
}
long time = c . getDate ( ) ;
holder . tvDate . setText ( ConversationListActivity . getDate ( context , time ) ) ;
ImageView ivPresence = ( ImageView ) view . findViewById ( R . id . presence ) ;
if ( contact . getPresenceState ( ) > <num> ) {
ivPresence . setImageResource ( Contact . getPresenceRes ( contact . getPresenceState ( ) ) ) ;
ivPresence . setVisibility ( View . VISIBLE ) ;
} else {
ivPresence . setVisibility ( View . GONE ) ;
}
}
private boolean isBlocked ( final String addr ) {
if ( addr == null ) {
return false ;
}
final int l = this . blacklist . length ;
for ( int i = <num> ; i < l ; i ++ ) {
if ( addr . equals ( this . blacklist [ i ] ) ) {
return true ;
}
}
return false ;
}
}
package de . ub0r . android . smsdroid ;
import java . util . regex . Matcher ;
import java . util . regex . Pattern ;
import android . text . TextUtils ;
public final class Converter {
private Converter ( ) {
}
private static final Pattern PATTERN = Pattern . compile ( " ) ;
public static CharSequence convertDecNCR2Char ( final CharSequence str ) {
if ( TextUtils . isEmpty ( str ) ) {
return str ;
}
Matcher m = PATTERN . matcher ( str ) ;
StringBuffer sb = new StringBuffer ( ) ;
while ( m . find ( ) ) {
String c = m . group ( ) ;
m . <unk> ( sb , dec2char ( c . substring ( <num> , c . length ( )  <num> ) ) ) ;
}
m . <unk> ( sb ) ;
return sb . toString ( ) ;
}
private static String dec2char ( final String str ) {
try {
int n = Integer . valueOf ( str ) ;
if ( n <= <num> ) {
return String . valueOf ( ( char ) n ) ;
} else if ( n <= <num> ) {
n -= <num> ;
return String . valueOf ( ( char ) ( <num> | ( n >> <num> ) ) )
+ String . valueOf ( ( char ) ( <num> | ( n & <num> ) ) ) ;
}
} catch ( NumberFormatException nfe ) {
return str ;
}
return str ;
}
}
package de . ub0r . android . smsdroid ;
import java . io . File ;
import java . io . FileNotFoundException ;
import java . io . FileWriter ;
import java . io . IOException ;
import android . content . ContentProvider ;
import android . content . ContentUris ;
import android . content . ContentValues ;
import android . database . Cursor ;
import android . net . Uri ;
import android . os . ParcelFileDescriptor ;
import android . widget . Toast ;
import de . ub0r . android . lib . Log ;
public final class MessageProvider extends ContentProvider {
static final String TAG = " ;
public static final Uri CONTENT_URI = Uri . parse ( " ) ;
@Override
public int delete ( final Uri uri , final String selection , final String [ ] selectionArgs ) {
throw new UnsupportedOperationException ( " ) ;
}
@Override
public String getType ( final Uri uri ) {
throw new UnsupportedOperationException ( " ) ;
}
@Override
public Uri insert ( final Uri uri , final ContentValues values ) {
throw new UnsupportedOperationException ( " ) ;
}
@Override
public boolean onCreate ( ) {
return true ;
}
@Override
public Cursor query ( final Uri uri , final String [ ] projection , final String selection ,
final String [ ] selectionArgs , final String sortOrder ) {
throw new UnsupportedOperationException ( " ) ;
}
@Override
public int update ( final Uri uri , final ContentValues values , final String selection ,
final String [ ] selectionArgs ) {
throw new UnsupportedOperationException ( " ) ;
}
@Override
public ParcelFileDescriptor openFile ( final Uri uri , final String mode )
throws FileNotFoundException {
Log . d ( TAG , " + uri + " ) ;
final long mid = ContentUris . parseId ( uri ) ;
String body = null ;
final Cursor cursor = this . getContext ( ) . getContentResolver ( )
. query ( Uri . parse ( " + mid ) , Message . PROJECTION_SMS , null , null , null ) ;
if ( cursor != null && cursor . moveToFirst ( ) ) {
body = cursor . getString ( Message . INDEX_BODY ) ;
}
if ( cursor != null && ! cursor . isClosed ( ) ) {
cursor . close ( ) ;
}
if ( body != null ) {
try {
File f = File . createTempFile ( " + mid , " ) ;
f . createNewFile ( ) ;
FileWriter fw = new FileWriter ( f ) ;
fw . append ( body ) ;
fw . close ( ) ;
return ParcelFileDescriptor . open ( f , ParcelFileDescriptor . <unk> ) ;
} catch ( IOException e ) {
Log . e ( TAG , " , e ) ;
Toast . makeText ( this . getContext ( ) , " , Toast . LENGTH_LONG ) . show ( ) ;
}
}
return null ;
}
}
package org . apache . commons . io ;
import java . io . File ;
import java . io . IOException ;
import java . io . InputStream ;
import java . io . OutputStream ;
import java . io . PrintWriter ;
import java . io . StringWriter ;
public class IOUtils {
public static final char <unk> = /' ;
public static final char <unk> = \\' ;
public static final char <unk> = File . separatorChar ;
public static final String <unk> = " ;
public static final String <unk> = " ;
public static final String LINE_SEPARATOR ;
static {
StringWriter buf = new StringWriter ( <num> ) ;
PrintWriter out = new PrintWriter ( buf ) ;
out . println ( ) ;
LINE_SEPARATOR = buf . toString ( ) ;
}
private static final int DEFAULT_BUFFER_SIZE = <num> * <num> ;
public IOUtils ( ) {
super ( ) ;
}
public static int copy ( final InputStream input , final OutputStream output )
throws IOException {
long count = copyLarge ( input , output ) ;
if ( count > Integer . MAX_VALUE ) {
return  <num> ;
}
return ( int ) count ;
}
public static long copyLarge ( final InputStream input ,
final OutputStream output ) throws IOException {
byte [ ] buffer = new byte [ DEFAULT_BUFFER_SIZE ] ;
long count = <num> ;
int n = <num> ;
while (  <num> != ( n = input . read ( buffer ) ) ) {
output . write ( buffer , <num> , n ) ;
count += n ;
}
return count ;
}
}
package de . ub0r . android . smsdroid ;
import android . app . Activity ;
import android . content . Context ;
import android . content . Intent ;
import android . os . Bundle ;
import android . preference . PreferenceActivity ;
import android . view . MenuItem ;
import de . ub0r . android . lib . IPreferenceContainer ;
public final class <unk> extends PreferenceActivity implements
IPreferenceContainer {
@Override
public void onCreate ( final Bundle savedInstanceState ) {
super . onCreate ( savedInstanceState ) ;
this . addPreferencesFromResource ( R . xml . <unk> ) ;
PreferencesActivity . registerOnPreferenceClickListener ( this ) ;
}
@Override
public boolean onOptionsItemSelected ( final MenuItem item ) {
switch ( item . getItemId ( ) ) {
case android . R . id . home :
Intent intent = new Intent ( this , ConversationListActivity . class ) ;
intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ;
this . startActivity ( intent ) ;
return true ;
default :
return super . onOptionsItemSelected ( item ) ;
}
}
@Override
public Activity getActivity ( ) {
return this ;
}
@Override
public Context getContext ( ) {
return this ;
}
}
package novara_xpug . MineSweeperKataFixture ;
import org . junit . Assert ;
import org . junit . Test ;
public class MineSweeperKataFixture {
@Test
public void <unk> ( ) {
String [ ] [ ] configurazione = { { " , " , " , " } ,
{ " , " , " , " } ,
{ " , " , " , " } ,
{ " , " , " , " }
} ;
Campo campo = new Campo ( configurazione ) ;
String [ ] [ ] soluzione = campo . getSoluzione ( ) ;
Assert . assertEquals ( Cella . SIMBOLO_BOMBA , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( Cella . SIMBOLO_BOMBA , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
Assert . assertEquals ( " , soluzione [ <num> ] [ <num> ] ) ;
}
}
package novara_xpug . MineSweeperKataFixture ;
import java . util . List ;
public class Cella {
public static final String SIMBOLO_BOMBA = " ;
private boolean bomba = false ;
private Campo campo ;
private List < Cella > vicini ;
private int x ;
private int y ;
public Cella ( String string , int x , int y , Campo campo ) {
this . setBomba ( string . equals ( SIMBOLO_BOMBA ) ) ;
this . x = x ;
this . y = y ;
this . campo = campo ;
}
public void setBomba ( boolean bomba ) {
this . bomba = bomba ;
}
public boolean isBomba ( ) {
return bomba ;
}
public String getSoluzione ( ) {
int bombe = <num> ;
if ( isBomba ( ) ) {
return SIMBOLO_BOMBA ;
}
vicini = campo . getVicini ( this ) ;
for ( Cella vicino : vicini ) {
if ( vicino . isBomba ( ) ) {
bombe ++ ;
}
}
return Integer . toString ( bombe ) ;
}
public int getY ( ) {
return this . y ;
}
public int getX ( ) {
return this . x ;
}
}
package novara_xpug . MineSweeperKataFixture ;
import java . util . ArrayList ;
import java . util . List ;
public class Campo {
private Cella [ ] [ ] celle ;
public Campo ( String [ ] [ ] configurazione ) {
celle = new Cella [ configurazione . length ] [ configurazione [ <num> ] . length ] ;
for ( int i = <num> ; i < configurazione . length ; i ++ ) {
for ( int j = <num> ; j < configurazione [ i ] . length ; j ++ ) {
celle [ i ] [ j ] = new Cella ( configurazione [ i ] [ j ] , i , j , this ) ;
}
}
}
public String [ ] [ ] getSoluzione ( ) {
String [ ] [ ] soluzione = new String [ celle . length ] [ celle [ <num> ] . length ] ;
for ( int i = <num> ; i < celle . length ; i ++ ) {
for ( int j = <num> ; j < celle [ i ] . length ; j ++ ) {
soluzione [ i ] [ j ] = celle [ i ] [ j ] . getSoluzione ( ) ;
}
}
return soluzione ;
}
public List < Cella > getVicini ( Cella cella ) {
int x = cella . getX ( ) ;
int y = cella . getY ( ) ;
int startX = getStartX ( cella . getX ( ) ) ;
int endX = getEndX ( cella . getX ( ) ) ;
int startY = getStartX ( cella . getY ( ) ) ;
int endY = getEndX ( cella . getY ( ) ) ;
List < Cella > vicini = new ArrayList < Cella > ( ) ;
for ( int i = startX ; i <= endX ; i ++ ) {
for ( int j = startY ; j <= endY ; j ++ ) {
vicini . add ( celle [ x + i ] [ y + j ] ) ;
}
}
return vicini ;
}
private int getEndX ( int x ) {
return x == celle . length  <num> ? <num> : <num> ;
}
private int getStartX ( int x ) {
return x == <num> ? <num> :  <num> ;
}
}
package org . springframework . http . embedded ;
import org . apache . commons . logging . Log ;
import org . apache . commons . logging . LogFactory ;
import org . junit . Test ;
import org . junit . runner . RunWith ;
import org . springframework . test . context . ContextConfiguration ;
import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ;
@RunWith(SpringJUnit4ClassRunner.class)
<unk>
public class EmbeddedServerNamespaceTest {
private Log logger = LogFactory . getLog ( EmbeddedServerNamespaceTest . class ) ;
@Test
public void sleep ( ) throws Exception {
logger . info ( " ) ;
Thread . sleep ( <num> ) ;
}
}
package org . springframework . http . embedded . config ;
import java . util . List ;
import org . springframework . beans . factory . BeanDefinitionStoreException ;
import org . springframework . beans . factory . config . BeanDefinition ;
import org . springframework . beans . factory . support . AbstractBeanDefinition ;
import org . springframework . beans . factory . support . BeanDefinitionBuilder ;
import org . springframework . beans . factory . support . ManagedList ;
import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ;
import org . springframework . beans . factory . xml . ParserContext ;
import org . springframework . http . embedded . EmbeddedServerFactory ;
import org . springframework . http . embedded . ServerConfig ;
import org . springframework . http . embedded . ServletMapping ;
import org . springframework . http . embedded . WebApplication ;
import org . springframework . util . StringUtils ;
import org . springframework . util . xml . DomUtils ;
import org . w3c . dom . Element ;
public class EmbeddedHttpServerParser extends
AbstractBeanDefinitionParser {
private static final String TYPE = " ;
private static final String CONFIG = " ;
private static final String PORT_NUMBER_ATTRIBUTE = " ;
private static final String PORT_NUMBER_PROPERTY = " ;
private static final String WEB_APP = " ;
private static final String CONTEXT_PATH_ATTRIUTE = " ;
private static final String CONTEXT_PATH = " ;
private static final String WAR_ELEMENT = " ;
private static final String WEBAPP_DIR_ELEMENT = " ;
private static final String SERVLET_MAPPING_ELEMENT = " ;
private static final String LOCATION_ATTRIBUTE = " ;
private static final String WAR_PATH_PROPERTY = " ;
private static final String WEB_APP_ROOT_PROPERTY = " ;
private static final String SERVLET_MAPPING_PROPERTY = " ;
private static final String SERVLET_REF_ATTRIBUTE = " ;
private static final String URL_PATTERN_ATTRIBUTE = " ;
@Override
protected AbstractBeanDefinition parseInternal ( Element element ,
ParserContext context ) {
BeanDefinitionBuilder builder = BeanDefinitionBuilder . genericBeanDefinition ( EmbeddedServerFactory . class ) ;
String type = element . getAttribute ( TYPE ) ;
builder . addPropertyValue ( " , getConfigBeanDefinition ( element ) ) ;
builder . addPropertyValue ( " , getWebApplications ( element ) ) ;
builder . addPropertyValue ( TYPE , type ) ;
return builder . getBeanDefinition ( ) ;
}
private AbstractBeanDefinition getConfigBeanDefinition ( Element element ) {
Element node = DomUtils . getChildElementByTagName ( element , CONFIG ) ;
BeanDefinitionBuilder builder = BeanDefinitionBuilder . genericBeanDefinition ( ServerConfig . class ) ;
String portNumber = node . getAttribute ( PORT_NUMBER_ATTRIBUTE ) ;
if ( StringUtils . hasText ( portNumber ) )
builder . addPropertyValue ( PORT_NUMBER_PROPERTY , Integer . valueOf ( portNumber ) ) ;
return builder . getBeanDefinition ( ) ;
}
private ManagedList < BeanDefinition > getWebApplications ( Element element ) {
List < Element > webAppElements = DomUtils . getChildElementsByTagName ( element , WEB_APP ) ;
ManagedList < BeanDefinition > beanDefs = new ManagedList < BeanDefinition > ( ) ;
if ( ! webAppElements . isEmpty ( ) ) {
for ( Element webAppElem : webAppElements ) {
beanDefs . add ( createWebApplicationDefinition ( webAppElem ) ) ;
}
} else {
throw new BeanDefinitionStoreException ( " ) ;
}
return beanDefs ;
}
private BeanDefinition createWebApplicationDefinition ( Element elem ) {
String contextPath = elem . getAttribute ( CONTEXT_PATH_ATTRIUTE ) ;
BeanDefinitionBuilder builder = BeanDefinitionBuilder . genericBeanDefinition ( WebApplication . class ) ;
builder . addPropertyValue ( CONTEXT_PATH , contextPath ) ;
Element warElement = DomUtils . getChildElementByTagName ( elem , WAR_ELEMENT ) ;
if ( warElement != null ) {
String warLocation = warElement . getAttribute ( LOCATION_ATTRIBUTE ) ;
builder . addPropertyValue ( WAR_PATH_PROPERTY , warLocation ) ;
} else {
Element webAppDirElem = DomUtils . getChildElementByTagName ( elem , WEBAPP_DIR_ELEMENT ) ;
if ( webAppDirElem != null ) {
String webAppRoot = webAppDirElem . getAttribute ( LOCATION_ATTRIBUTE ) ;
builder . addPropertyValue ( WEB_APP_ROOT_PROPERTY , webAppRoot ) ;
} else {
List < Element > servletMappings = DomUtils . getChildElementsByTagName ( elem , SERVLET_MAPPING_ELEMENT ) ;
ManagedList < BeanDefinition > servletMappingList = new ManagedList < BeanDefinition > ( ) ;
for ( Element servletMapElem : servletMappings ) {
BeanDefinitionBuilder servletMapping = BeanDefinitionBuilder . genericBeanDefinition ( ServletMapping . class ) ;
String servletRef = servletMapElem . getAttribute ( SERVLET_REF_ATTRIBUTE ) ;
String urlPattern = servletMapElem . getAttribute ( URL_PATTERN_ATTRIBUTE ) ;
servletMapping . <unk> ( servletRef ) ;
servletMapping . <unk> ( urlPattern ) ;
servletMappingList . add ( servletMapping . getBeanDefinition ( ) ) ;
}
builder . addPropertyValue ( SERVLET_MAPPING_PROPERTY , servletMappingList ) ;
}
}
return builder . getBeanDefinition ( ) ;
}
@Override
protected boolean <unk> ( ) {
return true ;
}
}
package org . springframework . http . embedded ;
public enum EmbeddedServerType {
JETTY ;
}
package org . springframework . http . embedded ;
public class DeploymentException extends RuntimeException {
private static final long serialVersionUID = <num> ;
public DeploymentException ( String message , Throwable cause ) {
super ( message , cause ) ;
}
public DeploymentException ( String message ) {
super ( message ) ;
}
}
package org . springframework . http . embedded ;
public class ServerConfig {
private int startupPort = <num> ;
private boolean sslSupported ;
public int getStartupPort ( ) {
return startupPort ;
}
public void <unk> ( int startupPort ) {
this . startupPort = startupPort ;
}
public boolean <unk> ( ) {
return sslSupported ;
}
public void <unk> ( boolean sslSupported ) {
this . sslSupported = sslSupported ;
}
}
package org . springframework . http . embedded ;
import java . util . concurrent . ConcurrentHashMap ;
import java . util . concurrent . atomic . AtomicBoolean ;
import org . apache . commons . logging . Log ;
import org . apache . commons . logging . LogFactory ;
public abstract class AbstractEmbeddedServer implements EmbeddedServer {
protected final Log logger = LogFactory . getLog ( getClass ( ) ) ;
protected ServerConfig config ;
private AtomicBoolean initialized = new AtomicBoolean ( false ) ;
private AtomicBoolean started = new AtomicBoolean ( false ) ;
private ServerRunStatus runStatus = ServerRunStatus . STOPPED ;
private ConcurrentHashMap < String , Object > deployedContexts = new ConcurrentHashMap < String , Object > ( ) ;
private static final Object STATIC_VALUE = new Object ( ) ;
@Override
public final void initialize ( ServerConfig config ) {
if ( logger . isDebugEnabled ( ) )
logger . debug ( " + config . getStartupPort ( ) ) ;
if ( initialized . compareAndSet ( false , true ) ) {
this . config = config ;
} else {
logger . warn ( " ) ;
}
}
@Override
public final void start ( ) {
if ( config == null )
throw new IllegalStateException ( " ) ;
if ( logger . isDebugEnabled ( ) )
logger . debug ( " ) ;
if ( started . compareAndSet ( false , true ) ) {
runStatus = ServerRunStatus . STARTING ;
try {
doStart ( ) ;
} catch ( Exception e ) {
logger . error ( " , e ) ;
runStatus = ServerRunStatus . FAILED ;
return ;
}
runStatus = ServerRunStatus . RUNNING ;
} else {
if ( logger . isInfoEnabled ( ) )
logger . info ( " + getStatus ( ) ) ;
}
}
protected abstract void doStart ( ) throws Exception ;
@Override
public final void stop ( ) {
if ( logger . isDebugEnabled ( ) )
logger . debug ( " ) ;
if ( started . compareAndSet ( true , false ) ) {
runStatus = ServerRunStatus . STOPPING ;
try {
doStop ( ) ;
} catch ( Exception e ) {
logger . error ( " , e ) ;
runStatus = ServerRunStatus . UNKNOWN ;
return ;
}
runStatus = ServerRunStatus . STOPPED ;
} else {
logger . info ( " + runStatus + " ) ;
}
}
protected abstract void doStop ( ) throws Exception ;
@Override
public final void deployApplication ( WebApplication webapp ) {
String contextPath = webapp . getContextPath ( ) ;
if ( logger . isDebugEnabled ( ) )
logger . debug ( " + contextPath + " ) ;
if ( deployedContexts . putIfAbsent ( contextPath , STATIC_VALUE ) == null ) {
boolean appDeploymentStatus ;
try {
appDeploymentStatus = doDeployApplication ( webapp ) ;
if ( appDeploymentStatus )
return ;
} catch ( Exception e ) {
logger . error ( " + contextPath + " ) ;
appDeploymentStatus = false ;
}
if ( ! appDeploymentStatus ) {
logger . info ( " + contextPath + " ) ;
deployedContexts . remove ( contextPath , STATIC_VALUE ) ;
return ;
}
}
throw new DuplicateContextPathException ( contextPath ) ;
}
protected abstract boolean doDeployApplication ( WebApplication webapp ) ;
@Override
public final ServerRunStatus getStatus ( ) {
return runStatus ;
}
}
package org . springframework . http . embedded ;
public class DuplicateContextPathException extends RuntimeException {
private static final long serialVersionUID = <num> ;
private String contextPath ;
public DuplicateContextPathException ( String contextPath ) {
this . contextPath = contextPath ;
}
public String getContextPath ( ) {
return contextPath ;
}
@Override
public String getMessage ( ) {
return " + contextPath + " +
" ;
}
}
package org . springframework . http . embedded ;
public interface EmbeddedServer {
void initialize ( ServerConfig config ) ;
void start ( ) ;
void stop ( ) ;
void deployApplication ( WebApplication webapp ) ;
ServerRunStatus getStatus ( ) ;
}
package org . springframework . http . embedded ;
import java . io . File ;
import java . util . Collections ;
import org . junit . Test ;
public class <unk> {
public void <unk> ( ) throws Exception {
EmbeddedServer server = new EmbeddedJettyServer ( ) ;
ServerConfig config = new ServerConfig ( ) ;
server . initialize ( config ) ;
deployUsingServlet ( server ) ;
server . start ( ) ;
Thread . sleep ( <num> ) ;
server . stop ( ) ;
}
private void deployUsingServlet ( EmbeddedServer server ) throws Exception {
WebApplication webApp = new WebApplication ( ) ;
webApp . setServletMappings ( Collections . singletonList (
new ServletMapping ( new TestHttpServlet ( ) , " ) ) ) ;
webApp . setContextPath ( " ) ;
webApp . afterPropertiesSet ( ) ;
server . deployApplication ( webApp ) ;
}
public void <unk> ( ) throws Exception {
EmbeddedServer server = new EmbeddedJettyServer ( ) ;
ServerConfig config = new ServerConfig ( ) ;
server . initialize ( config ) ;
deployUsingWar ( server ) ;
server . start ( ) ;
Thread . sleep ( <num> ) ;
server . stop ( ) ;
}
private void deployUsingWar ( EmbeddedServer server ) throws Exception {
WebApplication webApp = new WebApplication ( ) ;
webApp . setWarPath ( " ) ;
webApp . setWarPath ( " ) ;
webApp . afterPropertiesSet ( ) ;
server . deployApplication ( webApp ) ;
}
@Test
public void <unk> ( ) throws Exception {
File file = new File ( " ) ;
System . out . println ( file . getAbsolutePath ( ) ) ;
EmbeddedServer server = new EmbeddedJettyServer ( ) ;
ServerConfig config = new ServerConfig ( ) ;
server . initialize ( config ) ;
deployUsingWebappRoot ( server ) ;
server . start ( ) ;
Thread . sleep ( <num> ) ;
server . stop ( ) ;
}
private void deployUsingWebappRoot ( EmbeddedServer server ) throws Exception {
WebApplication webApp = new WebApplication ( ) ;
webApp . setWebAppRoot ( " ) ;
webApp . setContextPath ( " ) ;
webApp . afterPropertiesSet ( ) ;
server . deployApplication ( webApp ) ;
}
}
package org . springframework . http . embedded ;
import java . util . List ;
import static org . springframework . http . embedded . EmbeddedServerType . * ;
import org . apache . commons . logging . Log ;
import org . apache . commons . logging . LogFactory ;
import org . springframework . beans . factory . DisposableBean ;
import org . springframework . beans . factory . FactoryBean ;
import org . springframework . beans . factory . InitializingBean ;
public class EmbeddedServerFactory implements FactoryBean < EmbeddedServer > , InitializingBean , DisposableBean {
private static final Log logger = LogFactory . getLog ( EmbeddedServerFactory . class ) ;
private ServerConfig config ;
private List < WebApplication > webApplications ;
private EmbeddedServerType type ;
private EmbeddedServer server ;
@Override
public void destroy ( ) throws Exception {
if ( server != null )
server . stop ( ) ;
}
@Override
public void afterPropertiesSet ( ) throws Exception {
if ( server == null ) {
if ( JETTY . equals ( type ) ) {
server = new EmbeddedJettyServer ( ) ;
}
if ( server != null ) {
server . initialize ( config ) ;
for ( WebApplication webApp : webApplications ) {
server . deployApplication ( webApp ) ;
}
server . start ( ) ;
} else {
logger . warn ( " + type + " ) ;
}
}
}
@Override
public EmbeddedServer getObject ( ) throws Exception {
return server ;
}
@Override
public Class < ? > getObjectType ( ) {
return EmbeddedServer . class ;
}
@Override
public boolean isSingleton ( ) {
return true ;
}
public void setConfig ( ServerConfig config ) {
this . config = config ;
}
public void <unk> ( List < WebApplication > webApplications ) {
this . webApplications = webApplications ;
}
public void setType ( EmbeddedServerType type ) {
this . type = type ;
}
}
package org . springframework . http . embedded ;
import javax . servlet . http . HttpServlet ;
import org . springframework . util . Assert ;
public class ServletMapping {
private HttpServlet servlet ;
private String urlPattern ;
public ServletMapping ( HttpServlet servlet , String urlPattern ) {
Assert . hasText ( urlPattern ) ;
Assert . notNull ( servlet ) ;
this . servlet = servlet ;
this . urlPattern = urlPattern ;
}
public HttpServlet getServlet ( ) {
return servlet ;
}
public String getUrlPattern ( ) {
return urlPattern ;
}
}
package org . springframework . http . embedded . config ;
import org . springframework . beans . factory . xml . NamespaceHandlerSupport ;
public class <unk> extends NamespaceHandlerSupport {
@Override
public void init ( ) {
this . registerBeanDefinitionParser ( " , new EmbeddedHttpServerParser ( ) ) ;
}
}
package org . springframework . http . embedded ;
import java . io . IOException ;
import java . util . ArrayList ;
import java . util . List ;
import org . eclipse . jetty . server . Handler ;
import org . eclipse . jetty . server . Server ;
import org . eclipse . jetty . server . handler . ContextHandlerCollection ;
import org . eclipse . jetty . servlet . ServletContextHandler ;
import org . eclipse . jetty . servlet . ServletHolder ;
import org . eclipse . jetty . webapp . WebAppContext ;
public class EmbeddedJettyServer extends AbstractEmbeddedServer {
private Server server ;
private List < Handler > handlers = new ArrayList < Handler > ( ) ;
@Override
protected void doStart ( ) throws Exception {
if ( server == null )
server = new Server ( config . getStartupPort ( ) ) ;
if ( ! handlers . isEmpty ( ) ) {
ContextHandlerCollection handlerCollection = new ContextHandlerCollection ( ) ;
handlerCollection . <unk> ( handlers . toArray ( new Handler [ ] { } ) ) ;
server . setHandler ( handlerCollection ) ;
}
server . start ( ) ;
}
@Override
protected void doStop ( ) throws Exception {
server . stop ( ) ;
}
@Override
protected boolean doDeployApplication ( WebApplication webapp ) {
String contextPath = webapp . getContextPath ( ) ;
List < ServletMapping > servletMappings = webapp . getServletMappings ( ) ;
if ( webapp . isServletMappingGiven ( ) ) {
ServletContextHandler sHandler = new ServletContextHandler ( ServletContextHandler . SESSIONS ) ;
sHandler . setContextPath ( contextPath ) ;
for ( ServletMapping mapping : servletMappings ) {
sHandler . addServlet ( new ServletHolder ( mapping . getServlet ( ) ) , mapping . getUrlPattern ( ) ) ;
}
handlers . add ( sHandler ) ;
} else if ( webapp . isWarPathGiven ( ) ) {
WebAppContext wContext = new WebAppContext ( ) ;
wContext . setContextPath ( contextPath ) ;
String fileWar ;
try {
fileWar = webapp . getResource ( ) . getFile ( ) . getAbsolutePath ( ) ;
} catch ( IOException e ) {
throw new DeploymentException ( " + webapp . getResource ( ) . getFilename ( ) + " , e ) ;
}
if ( logger . isInfoEnabled ( ) )
logger . info ( " + fileWar ) ;
wContext . setWar ( fileWar ) ;
handlers . add ( wContext ) ;
} else if ( webapp . isWebAppRootGiven ( ) ) {
WebAppContext wrContext = new WebAppContext ( ) ;
wrContext . setContextPath ( contextPath ) ;
String webappLocation ;
try {
webappLocation = webapp . getResource ( ) . getFile ( ) . getAbsolutePath ( ) ;
} catch ( IOException e ) {
throw new DeploymentException ( " + webapp . getResource ( ) . getFilename ( ) + " , e ) ;
}
wrContext . setResourceBase ( webappLocation ) ;
if ( logger . isInfoEnabled ( ) )
logger . info ( " + webappLocation ) ;
handlers . add ( wrContext ) ;
}
return true ;
}
}
package org . springframework . http . embedded ;
public enum ServerRunStatus {
STARTING ,
RUNNING ,
STOPPING ,
STOPPED ,
FAILED ,
UNKNOWN ;
}
package org . springframework . http . embedded ;
import java . io . IOException ;
import javax . servlet . ServletException ;
import javax . servlet . http . HttpServlet ;
import javax . servlet . http . HttpServletRequest ;
import javax . servlet . http . HttpServletResponse ;
public class TestHttpServlet extends HttpServlet {
private static final long serialVersionUID = <num> ;
@Override
protected void doGet ( HttpServletRequest req , HttpServletResponse resp )
throws ServletException , IOException {
String contextPath = req . getContextPath ( ) ;
String response = "
+ contextPath + " ;
resp . getWriter ( ) . write ( response ) ;
}
}
package org . springframework . http . embedded ;
import java . io . File ;
import java . util . List ;
import org . springframework . beans . factory . InitializingBean ;
import org . springframework . core . io . ClassPathResource ;
import org . springframework . core . io . FileSystemResource ;
import org . springframework . core . io . Resource ;
import org . springframework . util . StringUtils ;
public class WebApplication implements InitializingBean {
private List < ServletMapping > servletMappings ;
private String warPath ;
private String webAppRoot ;
private Resource resource ;
private boolean warPathGiven ;
private boolean servletMappingGiven ;
private boolean webAppRootGiven ;
private String contextPath ;
@Override
public void afterPropertiesSet ( ) throws Exception {
if ( ! StringUtils . hasText ( contextPath ) )
new IllegalArgumentException ( " ) ;
servletMappingGiven = servletMappings != null && ! servletMappings . isEmpty ( ) ;
warPathGiven = StringUtils . hasText ( warPath ) ;
webAppRootGiven = StringUtils . hasText ( webAppRoot ) ;
int count = <num> ;
if ( servletMappingGiven )
count ++ ;
if ( warPathGiven )
count ++ ;
if ( webAppRootGiven )
count ++ ;
if ( count > <num> )
throw new IllegalArgumentException ( " ) ;
if ( count == <num> )
throw new IllegalArgumentException ( " ) ;
if ( warPathGiven ) {
String lowerCaseName = warPath . toLowerCase ( ) ;
if ( lowerCaseName . startsWith ( " ) || lowerCaseName . startsWith ( " ) ) {
resource = new ClassPathResource ( warPath . substring ( warPath . indexOf ( " ) + <num> ) ) ;
File file = resource . getFile ( ) ;
if ( ! file . isFile ( ) ) {
throw new DeploymentException ( " + file . getAbsolutePath ( ) + " ) ;
}
} else {
File file = new File ( warPath ) ;
if ( ! file . exists ( ) )
throw new IllegalArgumentException ( " + warPath + " ) ;
if ( ! file . isFile ( ) ) {
throw new DeploymentException ( " + file . getAbsolutePath ( ) + " ) ;
}
resource = new FileSystemResource ( file ) ;
}
}
if ( webAppRootGiven ) {
File root = new File ( webAppRoot ) ;
if ( ! root . exists ( ) )
throw new IllegalArgumentException ( " + warPath + " ) ;
if ( ! root . isDirectory ( ) )
throw new IllegalArgumentException ( " + warPath + " ) ;
resource = new FileSystemResource ( root ) ;
}
}
public List < ServletMapping > getServletMappings ( ) {
return servletMappings ;
}
public void setServletMappings ( List < ServletMapping > servletMappings ) {
this . servletMappings = servletMappings ;
}
public String <unk> ( ) {
return warPath ;
}
public void setWarPath ( String warPath ) {
this . warPath = warPath ;
}
public void setWebAppRoot ( String webAppRoot ) {
this . webAppRoot = webAppRoot ;
}
public Resource getResource ( ) {
return resource ;
}
public boolean isWarPathGiven ( ) {
return warPathGiven ;
}
public boolean isServletMappingGiven ( ) {
return servletMappingGiven ;
}
public boolean isWebAppRootGiven ( ) {
return webAppRootGiven ;
}
public String getContextPath ( ) {
return contextPath ;
}
public void setContextPath ( String contextPath ) {
this . contextPath = contextPath ;
}
package com . lgposse . cards . database ;
import java . io . IOException ;
import java . io . ObjectInputStream ;
import java . sql . PreparedStatement ;
import java . sql . ResultSet ;
import java . sql . SQLException ;
import java . util . ArrayList ;
import com . lgposse . cards . models . CardGame ;
import com . lgposse . game . database . GameDatabase ;
import com . lgposse . game . models . Game ;
public class CardGameDatabase extends GameDatabase {
public CardGameDatabase ( String hostname , int port , String database ,
String username , String password ) {
super ( hostname , port , database , username , password ) ;
}
@Override
public CardGame getGame ( int id ) {
try {
super . connect ( ) ;
} catch ( SQLException e1 ) {
e1 . printStackTrace ( ) ;
}
CardGame g = null ;
ResultSet r = this . getOne ( " , " , " + id + " ) ;
try {
while ( r . next ( ) ) {
ObjectInputStream gameData =
new ObjectInputStream ( r . getBlob ( " )
. getBinaryStream ( ) ) ;
g = ( CardGame ) gameData . readObject ( ) ;
}
} catch ( SQLException | IOException | ClassNotFoundException e ) {
e . printStackTrace ( ) ;
} finally {
super . close ( ) ;
}
return g ;
}
public int listGame ( CardGame g ) {
try {
super . connect ( ) ;
PreparedStatement s = this . connection . prepareStatement ( " +
this . database + " ) ;
s . setString ( <num> , g . name ) ;
s . setBlob ( <num> , g . getInputStream ( ) ) ;
s . execute ( ) ;
ResultSet r = this . getOne ( " , " , " + g . name + " ) ;
int id =  <num> ;
if ( r . next ( ) ) {
id = r . getInt ( <num> ) ;
g . id = id ;
this . updateGame ( g ) ;
}
this . close ( ) ;
super . close ( ) ;
return id ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
return  <num> ;
}
}
public int updateGame ( CardGame g ) {
try {
super . close ( ) ;
super . connect ( ) ;
PreparedStatement s = this . connection . prepareStatement ( " +
this . database + " ) ;
s . setBlob ( <num> , g . getInputStream ( ) ) ;
s . setInt ( <num> , g . id ) ;
s . execute ( ) ;
ResultSet r = this . getOne ( " , " , " + g . name + " ) ;
int id =  <num> ;
if ( r . next ( ) ) {
id = r . getInt ( <num> ) ;
}
super . close ( ) ;
return id ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
return  <num> ;
}
}
@Override
public ArrayList < Game > getAllGames ( ) {
ArrayList < Game > games = new ArrayList < Game > ( ) ;
try {
this . connect ( ) ;
ResultSet r = this . getAll ( " ) ;
while ( r . next ( ) ) {
ObjectInputStream gameData =
new ObjectInputStream ( r . getBlob ( " )
. getBinaryStream ( ) ) ;
CardGame g = ( CardGame ) gameData . readObject ( ) ;
games . add ( g ) ;
}
this . close ( ) ;
} catch ( SQLException | IOException | ClassNotFoundException e ) {
e . printStackTrace ( ) ;
} finally {
this . close ( ) ;
}
return games ;
}
}
package com . lgposse . jumper . views ;
import java . awt . Color ;
import javax . swing . event . ChangeEvent ;
import javax . swing . event . ChangeListener ;
import acm . graphics . GOval ;
import com . lgposse . common . Colors ;
import com . lgposse . game . views . View ;
import com . lgposse . jumper . models . Peg ;
public class PegView extends GOval implements View , ChangeListener {
public Peg peg ;
public PegView ( Peg peg ) {
super ( <num> , <num> ) ;
this . peg = peg ;
peg . addChangeListener ( this ) ;
}
@Override
public void update ( ) {
switch ( peg . type ) {
case EMPTY :
this . setColor ( Colors . LIGHT_GRAY ) ;
this . setFillColor ( Colors . LIGHT_GRAY ) ;
break ;
case PLAYER_ONE :
this . setColor ( Color . ORANGE ) ;
this . setFillColor ( Color . ORANGE ) ;
break ;
case PLAYER_TWO :
this . setColor ( Color . BLUE ) ;
this . setFillColor ( Color . BLUE ) ;
break ;
}
this . setFilled ( true ) ;
}
@Override
public void stateChanged ( ChangeEvent e ) {
update ( ) ;
}
}
package com . lgposse . user . controllers ;
import javax . swing . JOptionPane ;
import java . awt . event . ActionListener ;
import java . awt . event . ActionEvent ;
public class UserControlForm extends javax . swing . JPanel {
private static final long serialVersionUID = <num> ;
private UserControl userControl ;
public UserControlForm ( UserControl userControl ) {
this . userControl = userControl ;
initComponents ( ) ;
}
public UserControlForm ( ) {
initComponents ( ) ;
}
private void initComponents ( ) {
tabbedPane = new javax . swing . JTabbedPane ( ) ;
tabbedPane . setEnabled ( false ) ;
loginPanel = new javax . swing . JPanel ( ) ;
lblUsername = new javax . swing . JLabel ( ) ;
jLabel1 = new javax . swing . JLabel ( ) ;
txtLoginUsername = new javax . swing . JTextField ( ) ;
txtLoginPassword = new javax . swing . JPasswordField ( ) ;
txtLoginPassword . setEnabled ( false ) ;
btnLogin = new javax . swing . JButton ( ) ;
registerPanel = new javax . swing . JPanel ( ) ;
lblRegisterUsername = new javax . swing . JLabel ( ) ;
txtRegisterUsername = new javax . swing . JTextField ( ) ;
txtRegisterPassword = new javax . swing . JPasswordField ( ) ;
lblRegisterPassword = new javax . swing . JLabel ( ) ;
jLabel2 = new javax . swing . JLabel ( ) ;
txtRegisterEmail = new javax . swing . JTextField ( ) ;
txtRegisterPassword2 = new javax . swing . JPasswordField ( ) ;
lblRegisterPassword1 = new javax . swing . JLabel ( ) ;
btnRegister = new javax . swing . JButton ( ) ;
setLayout ( new java . awt . BorderLayout ( ) ) ;
lblUsername . setText ( " ) ;
jLabel1 . setText ( " ) ;
btnLogin . setText ( " ) ;
javax . swing . GroupLayout loginPanelLayout = new javax . swing . GroupLayout ( loginPanel ) ;
loginPanel . setLayout ( loginPanelLayout ) ;
loginPanelLayout . setHorizontalGroup (
loginPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( loginPanelLayout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( loginPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( loginPanelLayout . createSequentialGroup ( )
. addGroup ( loginPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addComponent ( lblUsername )
. addComponent ( jLabel1 ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addGroup ( loginPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addComponent ( txtLoginUsername )
. addComponent ( txtLoginPassword ) ) )
. addGroup ( loginPanelLayout . createSequentialGroup ( )
. addComponent ( btnLogin )
. addGap ( <num> , <num> , Short . MAX_VALUE ) ) )
. addContainerGap ( ) )
) ;
loginPanelLayout . setVerticalGroup (
loginPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( loginPanelLayout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( loginPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( lblUsername )
. addComponent ( txtLoginUsername , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED )
. addGroup ( loginPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( jLabel1 )
. addComponent ( txtLoginPassword , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addComponent ( btnLogin )
. addContainerGap ( <num> , Short . MAX_VALUE ) )
) ;
tabbedPane . addTab ( " , loginPanel ) ;
lblRegisterUsername . setText ( " ) ;
lblRegisterPassword . setText ( " ) ;
jLabel2 . setText ( " ) ;
lblRegisterPassword1 . setText ( " ) ;
btnRegister . setText ( " ) ;
btnRegister . addActionListener ( new java . awt . event . ActionListener ( ) {
public void actionPerformed ( java . awt . event . ActionEvent evt ) {
btnRegisterActionPerformed ( evt ) ;
}
} ) ;
btnLogin . addActionListener ( new ActionListener ( ) {
public void actionPerformed ( ActionEvent e ) {
btnLoginActionPerformed ( e ) ;
}
} ) ;
javax . swing . GroupLayout registerPanelLayout = new javax . swing . GroupLayout ( registerPanel ) ;
registerPanel . setLayout ( registerPanelLayout ) ;
registerPanelLayout . setHorizontalGroup (
registerPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( registerPanelLayout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( registerPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( registerPanelLayout . createSequentialGroup ( )
. addGroup ( registerPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addComponent ( lblRegisterUsername )
. addComponent ( lblRegisterPassword )
. addComponent ( jLabel2 )
. addComponent ( lblRegisterPassword1 ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED )
. addGroup ( registerPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addComponent ( txtRegisterPassword2 )
. addComponent ( txtRegisterUsername , javax . swing . GroupLayout . DEFAULT_SIZE , <num> , Short . MAX_VALUE )
. addComponent ( txtRegisterPassword )
. addComponent ( txtRegisterEmail ) ) )
. addGroup ( registerPanelLayout . createSequentialGroup ( )
. addComponent ( btnRegister )
. addGap ( <num> , <num> , Short . MAX_VALUE ) ) )
. addContainerGap ( ) )
) ;
registerPanelLayout . setVerticalGroup (
registerPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING )
. addGroup ( registerPanelLayout . createSequentialGroup ( )
. addContainerGap ( )
. addGroup ( registerPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( lblRegisterUsername )
. addComponent ( txtRegisterUsername , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED )
. addGroup ( registerPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( lblRegisterPassword )
. addComponent ( txtRegisterPassword , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED )
. addGroup ( registerPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( lblRegisterPassword1 )
. addComponent ( txtRegisterPassword2 , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED )
. addGroup ( registerPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE )
. addComponent ( jLabel2 )
. addComponent ( txtRegisterEmail , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) )
. addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED )
. addComponent ( btnRegister )
. addContainerGap ( <num> , Short . MAX_VALUE ) )
) ;
tabbedPane . addTab ( " , registerPanel ) ;
add ( tabbedPane , java . awt . BorderLayout . CENTER ) ;
}
private void btnRegisterActionPerformed ( java . awt . event . ActionEvent evt ) {
if ( ( txtRegisterPassword . toString ( ) . equals ( txtRegisterPassword2 . toString ( ) ) ) &&
txtRegisterUsername . toString ( ) != " && txtRegisterPassword . toString ( ) != " && txtRegisterEmail . toString ( ) != " ) {
userControl . registerUser ( txtRegisterUsername . toString ( ) , txtRegisterPassword . toString ( ) , txtRegisterEmail . toString ( ) ) ;
} else {
JOptionPane . showMessageDialog ( this , " ) ;
}
}
private void btnLoginActionPerformed ( java . awt . event . ActionEvent evt ) {
if ( ( txtLoginPassword . toString ( ) != " ) &&
txtRegisterUsername . toString ( ) != " && txtRegisterPassword . toString ( ) != " && txtRegisterEmail . toString ( ) != " ) {
userControl . loginUser ( txtLoginUsername . toString ( ) , txtLoginPassword . toString ( ) ) ;
} else {
JOptionPane . showMessageDialog ( this , " ) ;
}
}
private javax . swing . JButton btnLogin ;
private javax . swing . JButton btnRegister ;
private javax . swing . JLabel jLabel1 ;
private javax . swing . JLabel jLabel2 ;
private javax . swing . JTabbedPane tabbedPane ;
private javax . swing . JLabel lblRegisterPassword ;
private javax . swing . JLabel lblRegisterPassword1 ;
private javax . swing . JLabel lblRegisterUsername ;
private javax . swing . JLabel lblUsername ;
private javax . swing . JPanel loginPanel ;
private javax . swing . JPanel registerPanel ;
private javax . swing . JPasswordField txtLoginPassword ;
private javax . swing . JTextField txtLoginUsername ;
private javax . swing . JTextField txtRegisterEmail ;
private javax . swing . JPasswordField txtRegisterPassword ;
private javax . swing . JPasswordField txtRegisterPassword2 ;
private javax . swing . JTextField txtRegisterUsername ;
package com . lgposse . jumper . app ;
import com . lgposse . game . app . GameApp ;
import com . lgposse . game . app . GameContainer ;
import com . lgposse . game . models . Game ;
import com . lgposse . game . models . Player ;
import com . lgposse . jumper . controllers . JumperGameControl ;
import com . lgposse . jumper . models . JumperGame ;
public class JumperGameApp extends GameApp {
public JumperGame game ;
public JumperGameApp ( GameContainer gameContainer ) {
super ( gameContainer ) ;
}
@Override
public void gotPlayer ( Player player ) {
this . player = player ;
JumperGame game = new JumperGame ( " ) ;
if ( game . addPlayer ( player ) ) {
game . addPlayer ( new Player ( " ) ) ;
this . gotGame ( game ) ;
}
}
@Override
public void gotGame ( Game game ) {
this . game = ( JumperGame ) game ;
this . gameContainer . setActiveComponent ( new JumperGameControl ( this ) ) ;
}
@Override
public boolean canMove ( ) {
if ( this . game . players . indexOf ( this . player ) == this . game . turn ) return true ;
else return false ;
}
}
package com . lgposse . cards . tests ;
import java . util . Random ;
import org . junit . Test ;
import com . lgposse . cards . database . CardGameDatabase ;
import com . lgposse . cards . models . CardGame ;
public class CardGameDatabaseTest {
private CardGameDatabase d ;
@Test
public void test ( ) {
}
public void <unk> ( ) {
CardGame g = ( CardGame ) d . getGame ( <num> ) ;
System . out . println ( g ) ;
g = CardGameTest . exampleCardGame ( ) ;
g . id = <num> ;
d . updateGame ( g ) ;
Random r = new Random ( ) ;
String name = Integer . toString ( r . nextInt ( <num> ) ) ;
CardGame g2 = CardGameTest . exampleCardGame ( name ) ;
int i = d . listGame ( g2 ) ;
System . out . println ( i ) ;
}
public void <unk> ( int numberOfGames ) {
d . removeAllGames ( ) ;
for ( int i = <num> ; i < numberOfGames ; i ++ ) {
System . out . println ( d . openConnections ) ;
CardGame g = CardGameTest . exampleCardGame ( " + Integer . toString ( i ) ) ;
d . listGame ( g ) ;
try {
Thread . sleep ( <num> ) ;
} catch ( InterruptedException e ) { e . printStackTrace ( ) ; }
}
}
}
package com . lgposse . cards . views ;
import java . util . ArrayList ;
import com . lgposse . cards . models . Card ;
import com . lgposse . cards . models . Hand ;
import com . lgposse . game . views . View ;
import acm . graphics . GCompound ;
public class HandView extends GCompound implements View {
public Hand h ;
public boolean horizontal ;
public ArrayList < CardView > cardViews ;
protected boolean flipped ;
private int x = <num> ;
public HandView ( Hand h , boolean horizontal , boolean flipped ) {
this . h = h ;
this . horizontal = horizontal ;
this . flipped = flipped ;
this . cardViews = new ArrayList < CardView > ( ) ;
this . update ( ) ;
}
public HandView ( Hand h , boolean flipped ) {
this . h = h ;
this . cardViews = new ArrayList < CardView > ( ) ;
}
public void update ( ) {
this . removeAll ( ) ;
this . cardViews . clear ( ) ;
for ( Card c : h . cards ) {
CardView cv = new CardView ( c , this . flipped ) ;
if ( horizontal ) {
this . add ( cv , x , <num> ) ;
} else {
this . add ( cv , <num> , x ) ;
}
this . cardViews . add ( cv ) ;
x += <num> ;
}
}
}
package com . lgposse . cards . tests ;
import javax . swing . JFrame ;
import acm . graphics . GCanvas ;
import com . lgposse . cards . models . Deck ;
import com . lgposse . cards . models . Hand ;
import com . lgposse . cards . views . HandView ;
public class HandViewTest implements Runnable {
public static void main ( String [ ] args ) {
new HandViewTest ( ) . run ( ) ;
}
public void run ( ) {
System . setProperty ( " , " ) ;
System . setProperty ( " , " ) ;
JFrame frame = new JFrame ( " ) ;
Deck d = new Deck ( false ) ;
Hand h1 = d . dealNewHand ( <num> ) ;
Hand h2 = d . dealNewHand ( <num> ) ;
Hand h3 = d . dealNewHand ( <num> ) ;
Hand h4 = d . dealNewHand ( <num> ) ;
HandView v1 = new HandView ( h1 , true , false ) ;
HandView v2 = new HandView ( h2 , true , false ) ;
HandView v3 = new HandView ( h3 , true , false ) ;
HandView v4 = new HandView ( h4 , true , true ) ;
GCanvas gc = new GCanvas ( ) ;
gc . add ( v1 , <num> , <num> ) ;
gc . add ( v2 , <num> , <num> ) ;
gc . add ( v3 , <num> , <num> ) ;
gc . add ( v4 , <num> , <num> ) ;
frame . add ( gc ) ;
frame . setSize ( <num> , <num> ) ;
frame . setLocation ( <num> , <num> ) ;
frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
frame . setVisible ( true ) ;
}
}
package com . lgposse . cards . controllers ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseListener ;
import com . lgposse . cards . models . Hand ;
import com . lgposse . cards . views . CardView ;
import com . lgposse . cards . views . HandView ;
public class HandControl extends HandView {
private boolean owned ;
public HandControl ( Hand h , boolean horizontal , boolean owned ) {
super ( h , horizontal , ! owned ) ;
this . owned = owned ;
this . update ( ) ;
}
@Override
public void update ( ) {
super . update ( ) ;
if ( owned ) {
addListeners ( ) ;
}
}
public void addListeners ( ) {
for ( CardView cv : this . cardViews ) {
cv . addMouseListener ( new CardListener ( cv ) ) ;
}
}
}
class CardListener implements MouseListener {
private CardView cv ;
boolean staged ;
public CardListener ( CardView cv ) {
this . cv = cv ;
}
public void stage ( ) {
if ( staged ) {
cv . setLocation ( cv . getX ( ) , cv . getY ( ) + <num> ) ;
staged = false ;
} else {
cv . setLocation ( cv . getX ( ) , cv . getY ( )  <num> ) ;
staged = true ;
}
}
@Override
public void mouseClicked ( MouseEvent e ) {
System . out . println ( e . getClickCount ( ) ) ;
this . stage ( ) ;
}
@Override
public void mouseEntered ( MouseEvent e ) {
}
@Override
public void mouseExited ( MouseEvent e ) {
}
@Override
public void mousePressed ( MouseEvent e ) {
}
@Override
public void mouseReleased ( MouseEvent e ) {
}
package com . lgposse . game . controllers ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseListener ;
import javax . swing . JOptionPane ;
import com . lgposse . game . app . GameApp ;
import com . lgposse . game . database . GameList ;
import com . lgposse . game . views . GameListView ;
public abstract class LobbyControl extends GameListView implements MouseListener {
private static final long serialVersionUID =  <num> ;
protected GameApp gameApp ;
public LobbyControl ( GameApp gameApp ) {
super ( new GameList ( ) ) ;
this . gameApp = gameApp ;
this . requestGameList ( ) ;
initializeComponents ( ) ;
}
public void requestGameList ( ) {
gameApp . netControl . requestGameList ( ) ;
}
private void initializeComponents ( ) {
this . setName ( " ) ;
this . infoPanel = new GameInfoControl ( gameApp ) ;
this . btnCreateGame . addMouseListener ( this ) ;
}
@Override
public void mouseClicked ( MouseEvent e ) {
if ( e . getSource ( ) == btnCreateGame ) {
String gameName = JOptionPane . showInputDialog ( " , gameApp . player . name + " ) ;
this . createGame ( gameName ) ;
}
}
protected abstract void createGame ( String gameName ) ;
public void gotGameList ( GameList list ) {
this . gameList = list ;
this . update ( ) ;
}
@Override
public void mouseEntered ( MouseEvent e ) { }
@Override
public void mouseExited ( MouseEvent e ) { }
@Override
public void mousePressed ( MouseEvent e ) { }
@Override
public void mouseReleased ( MouseEvent e ) { }
}
package com . lgposse . user . controllers ;
import javax . swing . JPanel ;
public abstract class UserControl extends JPanel {
private static final long serialVersionUID = <num> ;
protected UserControlForm form ;
public UserControl ( ) {
this . setName ( " ) ;
}
public abstract void registerUser ( String username , String password , String email ) ;
public abstract void loginUser ( String username , String password ) ;
}
package com . lgposse . tests ;
public class CircleCoordsTest {
public static void main ( String [ ] args ) {
new CircleCoordsTest ( ) . run ( ) ;
}
public void run ( ) {
int a = <num> / <num> ;
int b = <num> / <num> ;
int m = Math . min ( a , b ) ;
int r = <num> * m / <num> ;
int n = <num> ;
for ( int i = <num> ; i < n ; i ++ ) {
double t = <num> * Math . PI * i / n ;
int x = ( int ) Math . round ( a + r * Math . cos ( t ) ) ;
int y = ( int ) Math . round ( b + r * Math . sin ( t ) ) ;
System . out . println ( x ) ;
System . out . println ( y ) ;
}
}
}
package com . lgposse . cards . tests ;
import java . io . FileInputStream ;
import java . io . FileOutputStream ;
import java . io . ObjectOutputStream ;
import javax . crypto . SecretKey ;
import javax . crypto . spec . SecretKeySpec ;
import com . lgposse . cards . models . CardGame ;
import com . lgposse . thirdparty . DesEncrypter ;
public class DesEncrypterTest {
public static void main ( String [ ] args ) {
new DesEncrypterTest ( ) . run ( ) ;
}
public void run ( ) {
try {
CardGame g = CardGameTest . exampleCardGame ( ) ;
ObjectOutputStream o = new ObjectOutputStream ( new FileOutputStream ( " ) ) ;
o . writeObject ( g ) ;
o . close ( ) ;
byte [ ] keybyte = new byte [ <num> ] ;
FileInputStream fin = new FileInputStream ( " ) ;
fin . read ( keybyte ) ;
SecretKey skey = new SecretKeySpec ( keybyte , <num> , <num> , " ) ;
DesEncrypter encrypter = new DesEncrypter ( skey ) ;
encrypter . encrypt ( new FileInputStream ( " ) ,
new FileOutputStream ( " ) ) ;
encrypter . decrypt ( new FileInputStream ( " ) ,
new FileOutputStream ( " ) ) ;
} catch ( Exception e ) {
}
}
}
package com . lgposse . game . views ;
import java . awt . BorderLayout ;
import java . awt . Color ;
import java . awt . Font ;
import javax . swing . JButton ;
import javax . swing . JLabel ;
import javax . swing . JList ;
import javax . swing . JPanel ;
import javax . swing . JSplitPane ;
import javax . swing . ListSelectionModel ;
import javax . swing . event . ListSelectionEvent ;
import javax . swing . event . ListSelectionListener ;
import com . lgposse . common . Colors ;
import com . lgposse . common . Fonts ;
import com . lgposse . game . database . GameList ;
import com . lgposse . thirdparty . JSplitPaneWithZeroSizeDivider ;
public class GameListView extends JPanel implements View , ListSelectionListener {
private static final long serialVersionUID = <num> ;
protected GameList gameList ;
protected JSplitPaneWithZeroSizeDivider splitPane ;
protected JPanel listPanel ;
protected JPanel nullInfoPanel ;
protected GameInfoView infoPanel ;
protected JList < String > games ;
protected JButton btnCreateGame ;
public GameListView ( GameList gameList ) {
this . setLayout ( new BorderLayout ( ) ) ;
this . gameList = gameList ;
listPanel = new JPanel ( ) ;
nullInfoPanel = new NullInfoPanel ( ) ;
splitPane = new JSplitPaneWithZeroSizeDivider ( JSplitPane . HORIZONTAL_SPLIT ) ;
splitPane . setRightComponent ( nullInfoPanel ) ;
splitPane . setLeftComponent ( listPanel ) ;
this . initializeListPanel ( ) ;
this . add ( splitPane , BorderLayout . CENTER ) ;
}
protected void initializeListPanel ( ) {
games = new JList < String > ( gameList . toArray ( ) ) ;
games . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ;
games . addListSelectionListener ( this ) ;
btnCreateGame = new JButton ( " ) ;
btnCreateGame . setFont ( Fonts . LOBBY_BUTTON ) ;
btnCreateGame . setBackground ( Colors . LIGHT_BLUE ) ;
btnCreateGame . setForeground ( Color . BLACK ) ;
listPanel . setLayout ( new BorderLayout ( ) ) ;
listPanel . add ( games , BorderLayout . CENTER ) ;
listPanel . add ( btnCreateGame , BorderLayout . SOUTH ) ;
}
public void update ( ) {
games . setListData ( gameList . toArray ( ) ) ;
}
@Override
public void valueChanged ( ListSelectionEvent e ) {
JList < ? > list = ( JList < ? > ) e . getSource ( ) ;
if ( ! list . isSelectionEmpty ( ) ) {
infoPanel . setGame ( gameList . games . get ( list . getSelectedIndex ( ) ) ) ;
splitPane . setRightComponent ( infoPanel ) ;
} else {
splitPane . setRightComponent ( nullInfoPanel ) ;
}
}
}
class NullInfoPanel extends JPanel {
private static final long serialVersionUID = <num> ;
public JLabel lblSelect ;
public NullInfoPanel ( ) {
this . setLayout ( new BorderLayout ( ) ) ;
lblSelect = new JLabel ( " ) ;
lblSelect . setFont ( new Font ( " , Font . BOLD , <num> ) ) ;
this . add ( lblSelect , BorderLayout . CENTER ) ;
}
package com . lgposse . cards . tests ;
import javax . swing . JFrame ;
import com . lgposse . cards . models . CardGame ;
import com . lgposse . cards . views . PlayfieldView ;
import acm . graphics . GCanvas ;
public class PlayfieldViewTest implements Runnable {
public static void main ( String [ ] args ) {
new PlayfieldViewTest ( ) . run ( ) ;
}
public void run ( ) {
JFrame frame = new JFrame ( " ) ;
frame . setSize ( <num> , <num> ) ;
frame . setLocation ( <num> , <num> ) ;
frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
GCanvas gc = new GCanvas ( ) ;
CardGame game = CardGameTest . exampleCardGame ( ) ;
PlayfieldView pv = new PlayfieldView ( game , false ) ;
gc . add ( pv , frame . getWidth ( ) / <num>  pv . getWidth ( ) / <num> + <num> , frame . getHeight ( ) / <num>  pv . getHeight ( ) / <num> + <num> ) ;
frame . add ( gc ) ;
frame . setVisible ( true ) ;
}
}
package com . lgposse . cards . tests ;
import java . awt . BorderLayout ;
import java . awt . Component ;
import javax . swing . JFrame ;
import com . lgposse . cards . app . CardGameApp ;
import com . lgposse . cards . controllers . CardGameLobbyControl ;
import com . lgposse . game . app . GameContainer ;
public class CardGameLobbyControlTest extends JFrame implements GameContainer {
private static final long serialVersionUID = <num> ;
public static void main ( String [ ] args ) {
new CardGameLobbyControlTest ( ) . run ( ) ;
}
public void run ( ) {
this . setLayout ( new BorderLayout ( ) ) ;
this . setSize ( <num> , <num> ) ;
CardGameLobbyControl control = new CardGameLobbyControl ( new CardGameApp ( this ) ) ;
this . add ( control ) ;
this . setVisible ( true ) ;
}
@Override
public void setActiveComponent ( Component comp ) {
}
}
package com . lgposse . game . database ;
import java . io . Serializable ;
import java . util . ArrayList ;
import java . util . Arrays ;
import com . lgposse . game . models . Game ;
public class GameList implements Serializable {
private static final long serialVersionUID = <num> ;
public ArrayList < Game > games ;
public GameList ( ) {
this . games = new ArrayList < Game > ( ) ;
}
public String toString ( ) {
String out = " ;
for ( Game g : this . games ) {
out += GameList . gameToString ( g ) ;
}
return out ;
}
public static String gameToString ( Game g ) {
return String . format ( " , Integer . toString ( g . id ) , g . name , Integer . toString ( g . players . size ( ) ) , g . maxPlayers ) ;
}
public String [ ] toArray ( ) {
ArrayList < String > arrayList = new ArrayList < String > ( ) ;
for ( Game g : this . games ) {
arrayList . add ( g . name ) ;
}
String [ ] stringArray = Arrays . copyOf ( arrayList . toArray ( ) , arrayList . toArray ( ) . length , String [ ] . class ) ;
return stringArray ;
}
}
package com . lgposse . net . server ;
import java . io . IOException ;
import java . net . ServerSocket ;
import java . util . ArrayList ;
public class MultiServer extends Thread {
public static void main ( String args [ ] ) {
MultiServer theServer = new MultiServer ( ) ;
theServer . start ( ) ;
MultiServerControl control = new MultiServerControl ( ) ;
control . start ( ) ;
}
protected ServerSocket server ;
protected ArrayList < ServerThread > clients ;
public void run ( ) {
try {
clients = new ArrayList < ServerThread > ( ) ;
server = new ServerSocket ( <num> ) ;
while ( true ) {
new EchoServerThread ( this , server . accept ( ) ) . start ( ) ;
}
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
public int addClient ( ServerThread thread ) {
clients . add ( thread ) ;
return clients . indexOf ( thread ) ;
}
public void removeClient ( ServerThread thread ) {
clients . remove ( thread ) ;
}
package com . lgposse . net . tests ;
public class NetControlTest extends Thread {
public static void main ( String [ ] args ) {
new NetControlTest ( ) . start ( ) ;
}
public void run ( ) {
}
}
package com . lgposse . net . common ;
import java . io . Serializable ;
public class TextRequest implements Serializable {
private static final long serialVersionUID =  <num> ;
public String channel ;
public String text ;
public TextRequest ( String channel , String text ) {
this . channel = channel ;
this . text = text ;
}
public TextRequest ( String channel ) {
this . channel = channel ;
this . text = " ;
}
package com . lgposse . net . server ;
import java . util . Scanner ;
public class MultiServerControl extends Thread {
public void run ( ) {
System . out . println ( " ) ;
Scanner s = new Scanner ( System . in ) ;
s . next ( ) ;
System . exit ( <num> ) ;
}
package com . lgposse . net . common ;
public interface ObjectListener {
public void gotObject ( Object o ) ;
}
package com . lgposse . net . common ;
import java . io . Serializable ;
public class TextResponse implements Serializable {
private static final long serialVersionUID = <num> ;
public String channel ;
public String text ;
public TextResponse ( String channel , String text ) {
this . channel = channel ;
this . text = text ;
}
package com . lgposse . cards . app ;
import java . awt . Dimension ;
import com . lgposse . game . app . DesktopContainer ;
public class CardGameDesktop extends DesktopContainer {
private static final long serialVersionUID =  <num> ;
public CardGameDesktop ( ) {
super ( ) ;
this . gameApp = new CardGameApp ( this ) ;
run ( ) ;
}
public static void main ( String [ ] args ) {
new CardGameDesktop ( ) . run ( ) ;
}
@Override
public void run ( ) {
this . setProperties ( " , new Dimension ( <num> , <num> ) ) ;
this . setVisible ( true ) ;
}
}
package com . lgposse . game . net ;
import java . io . IOException ;
import com . lgposse . game . app . GameApp ;
import com . lgposse . game . models . Game ;
import com . lgposse . net . client . Client ;
import com . lgposse . net . common . ObjectListener ;
import com . lgposse . net . common . TextRequest ;
public class NetControl implements ObjectListener {
protected Client client ;
protected GameApp app ;
public NetControl ( GameApp app , String host , int port ) {
this . app = app ;
client = new Client ( this , host , port ) ;
client . start ( ) ;
}
public void requestGameList ( ) {
client . sendObject ( new TextRequest ( " ) ) ;
}
public void requestGame ( Game g ) {
client . sendObject ( new TextRequest ( " , g . name ) ) ;
}
public void requestGame ( String name ) {
client . sendObject ( new TextRequest ( " , name ) ) ;
}
public void <unk> ( Game g ) {
client . sendObject ( g ) ;
}
@Override
public void gotObject ( Object o ) {
System . out . println ( o ) ;
app . gotObject ( o ) ;
}
public void close ( ) {
client . sendObject ( " ) ;
try {
client . close ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
}
package com . lgposse . net . tests ;
import com . lgposse . game . models . Game ;
import com . lgposse . game . models . Player ;
public class ExampleGame extends Game {
public ExampleGame ( String name ) {
super ( name ) ;
this . type = " ;
this . maxPlayers = <num> ;
this . addPlayer ( new Player ( " ) ) ;
}
private static final long serialVersionUID =  <num> ;
@Override
public boolean addPlayer ( Player p ) {
this . players . add ( p ) ;
this . startGame ( ) ;
return true ;
}
@Override
public void dropPlayer ( Player p ) {
}
@Override
public void startGame ( ) {
this . state = Game . states . IN_PROGRESS ;
}
@Override
public void endGame ( ) {
}
}
package com . lgposse . jumper . models ;
import java . util . ArrayList ;
import com . lgposse . game . models . Model ;
public class Graveyard extends Model {
private static final long serialVersionUID = <num> ;
protected ArrayList < Peg > pegs ;
public Graveyard ( ) {
this . pegs = new ArrayList < Peg > ( ) ;
}
public void add ( Peg p ) {
this . pegs . add ( new Peg (  <num> , p . type ) ) ;
}
public void removeAll ( Peg p ) {
this . pegs . removeAll ( pegs ) ;
}
public ArrayList < Peg > getPegs ( ) {
return this . pegs ;
}
public String toString ( ) {
int count = <num> ;
String out = " ;
String empty = new Peg (  <num> , Peg . types . EMPTY ) . toString ( ) ;
for ( Peg p : pegs ) {
out += p . toString ( ) ;
if ( count == <num> ) out += " ;
count  ;
}
if ( count > <num> ) {
for ( int i = count ; i > <num> ; i  ) {
out += empty ;
}
out += " ;
for ( int i = <num> ; i > <num> ; i  ) {
out += empty ;
}
} else {
for ( int i = count ; i > <num> ; i  ) {
out += empty ;
}
}
return out ;
}
}
package com . lgposse . cards . views ;
import java . util . ArrayList ;
import com . lgposse . cards . models . CardGame ;
import com . lgposse . cards . models . Hand ;
import com . lgposse . game . models . Player ;
import com . lgposse . game . views . View ;
import acm . graphics . GCanvas ;
import acm . graphics . GPoint ;
public class CardGameView extends GCanvas implements View {
private static final long serialVersionUID = <num> ;
CardGame g ;
Player me ;
ArrayList < HandView > handViews ;
PlayfieldView playfieldView ;
public CardGameView ( CardGame g , Player me ) {
this . setSize ( <num> , <num> ) ;
this . me = me ;
this . g = g ;
handViews = new ArrayList < HandView > ( ) ;
playfieldView = new PlayfieldView ( g , false ) ;
this . update ( ) ;
}
public void update ( ) {
this . handViews . clear ( ) ;
this . removeAll ( ) ;
this . playfieldView . update ( ) ;
int i = <num> ;
int ime = g . players . indexOf ( me ) ;
for ( Player p : g . players ) {
boolean flipped ;
if ( p . equals ( me ) ) flipped = false ;
else flipped = true ;
boolean horizontal ;
if ( i % <num> == <num> ) horizontal = true ;
else horizontal = false ;
Hand h = g . getHand ( p ) ;
HandView hv = new HandView ( h , horizontal , flipped ) ;
handViews . add ( hv ) ;
String pos = decodePosition ( i , ime ) ;
this . add ( hv , this . getPosition ( hv , pos ) ) ;
i ++ ;
}
this . add ( playfieldView , this . getWidth ( ) / <num>  playfieldView . getWidth ( ) / <num> + <num> , this . getHeight ( ) / <num>  playfieldView . getHeight ( ) / <num> + <num> ) ;
}
private String decodePosition ( int i , int me ) {
if ( i == me ) return " ;
else if ( within ( <num> , i , me ) ) return " ;
else if ( within ( <num> , i , me ) ) return " ;
else if ( within ( <num> , i , me ) ) return " ;
else return null ;
}
private boolean within ( int steps , int i , int me ) {
if ( ( ( i + steps ) == me ) || ( ( i  steps ) == me ) ) return true ;
else return false ;
}
private GPoint getPosition ( HandView hv , String position ) {
int wt = this . getWidth ( ) ;
int ht = this . getHeight ( ) ;
int wh = wt / <num> ;
int hh = ht / <num> ;
int xt = ( int ) Math . round ( hv . getWidth ( ) ) ;
int yt = ( int ) Math . round ( hv . getHeight ( ) ) ;
int xh = xt / <num> ;
int yh = yt / <num> ;
GPoint d ;
switch ( position ) {
case " :
d = new GPoint ( wh  xh , <num> ) ;
break ;
case " :
d = new GPoint ( wh  xh , ht  yt ) ;
break ;
case " :
d = new GPoint ( wt  xt , hh  yh ) ;
break ;
case " :
d = new GPoint ( <num> , hh  yh ) ;
break ;
default :
d = null ;
break ;
}
return d ;
}
package com . lgposse . jumper . views ;
import javax . swing . event . ChangeEvent ;
import javax . swing . event . ChangeListener ;
import com . lgposse . game . views . View ;
import com . lgposse . jumper . models . Board ;
import com . lgposse . jumper . models . Peg ;
import acm . graphics . GCompound ;
public class BoardView extends GCompound implements View , ChangeListener {
protected Board board ;
protected PegView [ ] [ ] pegViews ;
public BoardView ( Board board ) {
this . board = board ;
pegViews = new PegView [ <num> ] [ <num> ] ;
int y = <num> ;
for ( Peg [ ] row : board . pegs ) {
int x = <num> ;
for ( Peg p : row ) {
PegView pv = new PegView ( p ) ;
this . add ( pv , x , y ) ;
this . pegViews [ board . getX ( pv . peg ) ] [ board . getY ( pv . peg ) ] = pv ;
x += <num> ;
}
y += <num> ;
}
board . addChangeListener ( this ) ;
this . scale ( <num> ) ;
update ( ) ;
}
@Override
public void stateChanged ( ChangeEvent e ) {
this . update ( ) ;
}
@Override
public void update ( ) {
for ( int row = <num> ; row < <num> ; row ++ ) {
for ( int col = <num> ; col < <num> ; col ++ ) {
pegViews [ row ] [ col ] . peg = board . pegByCoordinates ( row , col ) ;
pegViews [ row ] [ col ] . update ( ) ;
}
}
}
}
package com . lgposse . cards . controllers ;
import com . lgposse . cards . models . CardGame ;
import com . lgposse . game . app . GameApp ;
import com . lgposse . game . controllers . LobbyControl ;
public class CardGameLobbyControl extends LobbyControl {
private static final long serialVersionUID = <num> ;
public CardGameLobbyControl ( GameApp gameApp ) {
super ( gameApp ) ;
}
@Override
protected void createGame ( String gameName ) {
CardGame cardGame = new CardGame ( gameName ) ;
gameApp . gotGame ( cardGame ) ;
}
}
package com . lgposse . jumper . tests ;
import org . junit . Test ;
import com . lgposse . jumper . models . Board ;
public class BoardTest {
public Board b ;
@Test
public void test ( ) {
b = new Board ( ) ;
pb ( ) ;
b . jump ( b . pegByCoordinates ( <num> , <num> ) , b . pegByCoordinates ( <num> , <num> ) ) ;
b . jump ( b . pegByCoordinates ( <num> , <num> ) , b . pegByCoordinates ( <num> , <num> ) ) ;
b . jump ( b . pegByCoordinates ( <num> , <num> ) , b . pegByCoordinates ( <num> , <num> ) ) ;
b . jump ( b . pegByCoordinates ( <num> , <num> ) , b . pegByCoordinates ( <num> , <num> ) ) ;
b . jump ( b . pegByCoordinates ( <num> , <num> ) , b . pegByCoordinates ( <num> , <num> ) ) ;
b . jump ( b . pegByCoordinates ( <num> , <num> ) , b . pegByCoordinates ( <num> , <num> ) ) ;
b . jump ( b . pegByCoordinates ( <num> , <num> ) , b . pegByCoordinates ( <num> , <num> ) ) ;
pb ( ) ;
}
public void pb ( ) {
System . out . println ( b ) ;
}
}
package com . lgposse . cards . tests ;
import javax . swing . JFrame ;
import acm . graphics . GCanvas ;
import com . lgposse . cards . models . Deck ;
import com . lgposse . cards . views . DeckView ;
public class DeckViewTest implements Runnable {
public static void main ( String [ ] args ) {
new DeckViewTest ( ) . run ( ) ;
}
public void run ( ) {
System . setProperty ( " , " ) ;
System . setProperty ( " , " ) ;
JFrame frame = new JFrame ( " ) ;
Deck d = new Deck ( false ) ;
DeckView dv = new DeckView ( d , false ) ;
GCanvas gc = new GCanvas ( ) ;
gc . add ( dv , <num> , <num> ) ;
frame . add ( gc ) ;
frame . setSize ( <num> , <num> ) ;
frame . setLocation ( <num> , <num> ) ;
frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
frame . setVisible ( true ) ;
}
}
package com . lgposse . game . net ;
import java . io . IOException ;
import java . net . ServerSocket ;
import java . util . ArrayList ;
import java . util . Hashtable ;
import com . lgposse . game . models . Game ;
import com . lgposse . net . server . MultiServer ;
import com . lgposse . net . server . MultiServerControl ;
import com . lgposse . net . server . ServerThread ;
public class GameServer extends MultiServer {
public Hashtable < String , Game > games ;
public GameServer ( ) {
super ( ) ;
this . games = new Hashtable < String , Game > ( ) ;
}
public static void main ( String args [ ] ) {
GameServer server = new GameServer ( ) ;
server . start ( ) ;
MultiServerControl control = new MultiServerControl ( ) ;
control . start ( ) ;
}
@Override
public void run ( ) {
try {
clients = new ArrayList < ServerThread > ( ) ;
server = new ServerSocket ( <num> ) ;
while ( true ) {
new GameServerThread ( this , server . accept ( ) ) . start ( ) ;
}
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
}
package com . lgposse . net . tests ;
import com . lgposse . game . models . Game ;
import com . lgposse . net . client . Client ;
import com . lgposse . net . common . ObjectListener ;
public class NewClientTest implements ObjectListener {
@Override
public void gotObject ( Object o ) {
if ( o instanceof Game ) {
Game g = ( Game ) o ;
System . out . println ( g . players ) ;
System . exit ( <num> ) ;
}
}
public void run ( ) {
Client c = new Client ( this , " , <num> ) ;
c . start ( ) ;
ExampleGame g = new ExampleGame ( " ) ;
c . sendObject ( g ) ;
}
public static void main ( String [ ] args ) {
new NewClientTest ( ) . run ( ) ;
}
}
package com . lgposse . game . models ;
import java . io . Serializable ;
import javax . swing . event . ChangeEvent ;
import javax . swing . event . ChangeListener ;
import javax . swing . event . EventListenerList ;
public abstract class Model implements Serializable {
private static final long serialVersionUID =  <num> ;
private final EventListenerList listenerList = new EventListenerList ( ) ;
private final ChangeEvent stateChangeEvent = new ChangeEvent ( this ) ;
public void addChangeListener ( ChangeListener l ) {
listenerList . add ( ChangeListener . class , l ) ;
}
public void <unk> ( ChangeListener l ) {
listenerList . remove ( ChangeListener . class , l ) ;
}
protected void <unk> ( ) {
for ( ChangeListener l : listenerList . getListeners ( ChangeListener . class ) ) {
l . stateChanged ( stateChangeEvent ) ;
}
}
}
package com . lgposse . tests ;
import java . util . Hashtable ;
import org . junit . Test ;
public class <unk> {
@Test
public void test ( ) {
Hashtable < Integer , String > x = new Hashtable < Integer , String > ( ) ;
x . put ( <num> , " ) ;
System . out . println ( x . get ( <num> ) ) ;
x . put ( <num> , " ) ;
System . out . println ( x . get ( <num> ) ) ;
}
}
package com . lgposse . thirdparty ;
import java . sql . Connection ;
import java . sql . DriverManager ;
import java . sql . PreparedStatement ;
import java . sql . ResultSet ;
import java . sql . SQLException ;
import java . sql . Statement ;
public class MySQLDatabase {
protected Connection connection = null ;
private Statement statement = null ;
private ResultSet resultSet = null ;
protected String hostname ;
protected int port ;
protected String database ;
protected String username ;
protected String password ;
public int openConnections ;
public MySQLDatabase ( String hostname , int port , String database , String username , String password ) {
this . hostname = hostname ;
this . port = port ;
this . database = database ;
this . username = username ;
this . password = password ;
openConnections = <num> ;
}
public ResultSet getAll ( String table ) {
return this . getQuery ( " + database + " + table ) ;
}
public ResultSet getOne ( String table , String select , String where ) {
return this . getQuery ( " + select + " + database + " + table
+ " + where + " ) ;
}
public ResultSet getRows ( String table , String select , String where ) {
return this . getQuery ( " + select + " + database + " + table
+ " + where ) ;
}
public ResultSet getRows ( String table , String select ) {
return this . getQuery ( " + select + " + database + " + table ) ;
}
public void execute ( String q ) {
try {
this . connect ( ) ;
statement = connection . createStatement ( ) ;
statement . executeQuery ( q ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
}
public void execute ( PreparedStatement s ) {
try {
this . connect ( ) ;
s . execute ( ) ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
}
}
protected ResultSet getQuery ( String q ) {
try {
statement = connection . createStatement ( ) ;
resultSet = statement . executeQuery ( q ) ;
return resultSet ;
} catch ( SQLException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
protected void truncate ( String table ) {
this . execute ( " + table ) ;
}
protected void connect ( ) throws SQLException {
String host = " + hostname + " + Integer . toString ( port ) + " + database + " + username + " + password ;
System . out . println ( " ) ;
openConnections ++ ;
connection = DriverManager . getConnection ( host ) ;
}
protected void close ( ) {
System . out . println ( " ) ;
try {
if ( resultSet != null ) {
resultSet . close ( ) ;
}
if ( statement != null ) {
statement . close ( ) ;
}
if ( connection != null ) {
connection . close ( ) ;
}
System . out . println ( connection . isClosed ( ) ) ;
} catch ( Exception e ) { }
}
}
package com . lgposse . game . views ;
public interface View {
public void update ( ) ;
}
package com . lgposse . thirdparty ;
import java . awt . Graphics ;
import java . awt . Rectangle ;
import javax . swing . JSplitPane ;
import javax . swing . UIManager ;
import javax . swing . border . Border ;
import javax . swing . plaf . basic . BasicSplitPaneDivider ;
import javax . swing . plaf . basic . BasicSplitPaneUI ;
public class JSplitPaneWithZeroSizeDivider
extends JSplitPane
{
private static final long serialVersionUID = <num> ;
private int dividerDragSize = <num> ;
private int dividerDragOffset = <num> ;
public JSplitPaneWithZeroSizeDivider ( ) {
this ( HORIZONTAL_SPLIT ) ;
}
public JSplitPaneWithZeroSizeDivider ( int orientation ) {
super ( orientation ) ;
setContinuousLayout ( true ) ;
<unk> ( <num> ) ;
}
public int <unk> ( ) {
return dividerDragSize ;
}
public void <unk> ( int dividerDragSize ) {
this . dividerDragSize = dividerDragSize ;
revalidate ( ) ;
}
public int <unk> ( ) {
return dividerDragOffset ;
}
public void <unk> ( int dividerDragOffset ) {
this . dividerDragOffset = dividerDragOffset ;
revalidate ( ) ;
}
@Override
@SuppressWarnings("deprecation")
public void layout ( ) {
super . layout ( ) ;
BasicSplitPaneDivider divider = ( ( BasicSplitPaneUI ) getUI ( ) ) . <unk> ( ) ;
Rectangle bounds = divider . getBounds ( ) ;
if ( orientation == HORIZONTAL_SPLIT ) {
bounds . x -= dividerDragOffset ;
bounds . width = dividerDragSize ;
} else {
bounds . y -= dividerDragOffset ;
bounds . height = dividerDragSize ;
}
divider . setBounds ( bounds ) ;
}
@Override
public void updateUI ( ) {
<unk> ( new SplitPaneWithZeroSizeDividerUI ( ) ) ;
revalidate ( ) ;
}
private class SplitPaneWithZeroSizeDividerUI
extends BasicSplitPaneUI
{
@Override
public BasicSplitPaneDivider <unk> ( ) {
return new ZeroSizeDivider ( this ) ;
}
}
private class ZeroSizeDivider
extends BasicSplitPaneDivider
{
private static final long serialVersionUID =  <num> ;
public ZeroSizeDivider ( BasicSplitPaneUI ui ) {
super ( ui ) ;
super . setBorder ( null ) ;
setBackground ( UIManager . getColor ( " ) ) ;
}
@Override
public void setBorder ( Border border ) {
}
@Override
public void paint ( Graphics g ) {
g . setColor ( getBackground ( ) ) ;
if ( orientation == HORIZONTAL_SPLIT )
g . drawLine ( dividerDragOffset , <num> , dividerDragOffset , getHeight ( )  <num> ) ;
else
g . drawLine ( <num> , dividerDragOffset , getWidth ( )  <num> , dividerDragOffset ) ;
}
@Override
protected void dragDividerTo ( int location ) {
super . dragDividerTo ( location + dividerDragOffset ) ;
}
@Override
protected void finishDraggingTo ( int location ) {
super . finishDraggingTo ( location + dividerDragOffset ) ;
}
}
}
package com . lgposse . thirdparty ;
import java . awt . Color ;
import java . awt . Dimension ;
import java . awt . EventQueue ;
import java . awt . Graphics ;
import java . awt . Graphics2D ;
import java . awt . RenderingHints ;
import javax . swing . JFrame ;
import javax . swing . JPanel ;
public class CircleTest extends JPanel {
private static final long serialVersionUID = <num> ;
private static final int SIZE = <num> ;
private int a = SIZE / <num> ;
private int b = a ;
private int r = <num> * SIZE / <num> ;
private int n ;
public CircleTest ( int n ) {
super ( true ) ;
this . setPreferredSize ( new Dimension ( SIZE , SIZE ) ) ;
this . n = n ;
this . setBackground ( new Color ( <num> , <num> , <num> ) ) ;
}
@Override
protected void paintComponent ( Graphics g ) {
super . paintComponent ( g ) ;
Graphics2D g2d = ( Graphics2D ) g ;
g2d . setRenderingHint (
RenderingHints . KEY_ANTIALIASING ,
RenderingHints . VALUE_ANTIALIAS_ON ) ;
g2d . setColor ( Color . black ) ;
a = getWidth ( ) / <num> ;
b = getHeight ( ) / <num> ;
int m = Math . min ( a , b ) ;
r = <num> * m / <num> ;
int r2 = Math . abs ( m  r ) / <num> ;
int c = <num> ;
for ( int i = <num> ; i < n ; i ++ ) {
g2d . setColor ( new Color ( c , <num> , <num> ) ) ;
double t = <num> * Math . PI * i / n ;
int x = ( int ) Math . round ( a + r * Math . cos ( t ) ) ;
int y = ( int ) Math . round ( b + r * Math . sin ( t ) ) ;
System . out . println ( " + Integer . toString ( x ) + " + Integer . toString ( y ) ) ;
g2d . fillOval ( x  r2 , y  r2 , <num> * r2 , <num> * r2 ) ;
c -= <num> ;
}
}
private static void create ( ) {
JFrame f = new JFrame ( ) ;
f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
f . setVisible ( true ) ;
f . add ( new CircleTest ( <num> ) ) ;
f . pack ( ) ;
}
public static void main ( String [ ] args ) {
EventQueue . invokeLater ( new Runnable ( ) {
@Override
public void run ( ) {
create ( ) ;
}
} ) ;
}
package com . lgposse . cards . tests ;
import org . junit . Test ;
import com . lgposse . cards . models . Deck ;
public class <unk> {
@Test
public void test ( ) {
Deck d1 = new Deck ( false ) ;
System . out . println ( d1 ) ;
Deck d2 = new Deck ( true ) ;
System . out . println ( d2 ) ;
}
}
package com . lgposse . jumper . views ;
import javax . swing . event . ChangeEvent ;
import javax . swing . event . ChangeListener ;
import acm . graphics . GCanvas ;
import com . lgposse . game . views . View ;
import com . lgposse . jumper . models . Graveyard ;
import com . lgposse . jumper . models . JumperGame ;
public class JumperGameView extends GCanvas implements View , ChangeListener {
private static final long serialVersionUID = <num> ;
protected BoardView boardView ;
protected Graveyard [ ] graveyards = new Graveyard [ <num> ] ;
protected GraveyardView [ ] graveyardViews = new GraveyardView [ <num> ] ;
protected JumperGame game ;
public JumperGameView ( JumperGame game ) {
this . game = game ;
}
public void initComponents ( ) {
this . boardView = new BoardView ( game . board ) ;
this . graveyards [ <num> ] = new Graveyard ( ) ;
this . graveyards [ <num> ] = new Graveyard ( ) ;
this . graveyardViews [ <num> ] = new GraveyardView ( graveyards [ <num> ] ) ;
this . graveyardViews [ <num> ] = new GraveyardView ( graveyards [ <num> ] ) ;
this . add ( graveyardViews [ <num> ] ) ;
this . add ( boardView ) ;
this . add ( graveyardViews [ <num> ] ) ;
}
@Override
public void update ( ) {
}
@Override
public void stateChanged ( ChangeEvent e ) {
}
}
package com . lgposse . cards . tests ;
import java . io . IOException ;
import java . io . ObjectInputStream ;
import java . sql . Connection ;
import java . sql . DriverManager ;
import java . sql . ResultSet ;
import java . sql . SQLException ;
import java . sql . Statement ;
import com . lgposse . cards . models . CardGame ;
class MySQLTest {
public static void main ( String [ ] args ) throws Exception {
MySQLTest dao = new MySQLTest ( ) ;
dao . readDataBase ( ) ;
}
private Connection connect = null ;
private Statement statement = null ;
private ResultSet resultSet = null ;
public void readDataBase ( ) throws Exception {
try {
Class . forName ( " ) ;
connect = DriverManager
. getConnection ( "
+ " ) ;
statement = connect . createStatement ( ) ;
resultSet = statement . executeQuery ( " ) ;
writeResultSet ( resultSet ) ;
} catch ( Exception e ) {
throw e ;
} finally {
close ( ) ;
}
}
private void writeResultSet ( ResultSet resultSet ) throws SQLException , IOException , ClassNotFoundException {
while ( resultSet . next ( ) ) {
String id = resultSet . getString ( " ) ;
String name = resultSet . getString ( " ) ;
ObjectInputStream gamedata = new ObjectInputStream ( resultSet . getBlob ( " ) . getBinaryStream ( ) ) ;
CardGame g = ( CardGame ) gamedata . readObject ( ) ;
System . out . println ( " + id ) ;
System . out . println ( " + name ) ;
System . out . println ( g ) ;
}
}
private void close ( ) {
try {
if ( resultSet != null ) {
resultSet . close ( ) ;
}
if ( statement != null ) {
statement . close ( ) ;
}
if ( connect != null ) {
connect . close ( ) ;
}
} catch ( Exception e ) {
}
}
package com . lgposse . jumper . app ;
import java . awt . Dimension ;
import com . lgposse . game . app . DesktopContainer ;
public class JumperDesktop extends DesktopContainer {
private static final long serialVersionUID = <num> ;
public JumperDesktop ( ) {
this . gameApp = new JumperGameApp ( this ) ;
}
@Override
public void run ( ) {
this . setProperties ( " , new Dimension ( <num> , <num> ) ) ;
this . setVisible ( true ) ;
}
public static void main ( String [ ] args ) {
new JumperDesktop ( ) . run ( ) ;
}
}
package com . lgposse . game . app ;
import java . awt . BorderLayout ;
import java . awt . CardLayout ;
import java . awt . Component ;
import java . awt . Dimension ;
import javax . swing . JFrame ;
import javax . swing . JPanel ;
public abstract class DesktopContainer extends JFrame implements GameContainer , Runnable {
private static final long serialVersionUID = <num> ;
public GameApp gameApp ;
protected JPanel panel ;
protected CardLayout cardLayout ;
public DesktopContainer ( ) {
this . cardLayout = new CardLayout ( ) ;
this . panel = new JPanel ( cardLayout ) ;
}
public void setProperties ( String title , Dimension dimensions ) {
this . setSize ( dimensions ) ;
this . setLocation ( <num> , <num> ) ;
this . setLayout ( new BorderLayout ( ) ) ;
this . setDefaultCloseOperation ( EXIT_ON_CLOSE ) ;
this . add ( panel , BorderLayout . CENTER ) ;
}
@Override
public void setActiveComponent ( Component comp ) {
panel . add ( comp , comp . getName ( ) ) ;
System . out . println ( comp . getName ( ) ) ;
cardLayout . show ( panel , comp . getName ( ) ) ;
}
}
package com . lgposse . jumper . tests ;
import org . junit . Test ;
import com . lgposse . jumper . models . Board ;
import com . lgposse . jumper . models . Graveyard ;
public class <unk> {
@Test
public void test ( ) {
Board b = new Board ( ) ;
Graveyard g = new Graveyard ( ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
g . add ( b . pegByCoordinates ( <num> , <num> ) ) ;
System . out . println ( g ) ;
}
}
package com . lgposse . cards . models ;
import java . io . Serializable ;
import java . util . ArrayList ;
import java . util . Collections ;
import java . util . Random ;
public class Deck implements Serializable {
private static final long serialVersionUID = <num> ;
public int id ;
public ArrayList < Card > cards ;
public Deck ( boolean shuffled ) {
Random r = new Random ( ) ;
this . id = r . nextInt ( <num> ) ;
cards = new ArrayList < Card > ( ) ;
for ( int suit = <num> ; suit < <num> ; suit ++ ) {
for ( int rank = <num> ; rank < <num> ; rank ++ ) {
cards . add ( new Card ( suit , rank ) ) ;
}
}
if ( shuffled ) {
this . shuffle ( ) ;
}
for ( Card c : cards ) {
c . id = Integer . toString ( this . id ) + " + c . id ;
}
}
public Deck ( ) { }
public String toString ( ) {
String out = " ;
for ( Card c : cards ) {
out += c . toString ( ) + \n' ;
}
return out ;
}
public void shuffle ( ) {
Collections . shuffle ( cards ) ;
}
public Hand dealNewHand ( int cards ) {
ArrayList < Card > c = new ArrayList < Card > ( ) ;
for ( int i = <num> ; i < cards ; i ++ ) c . add ( this . pop_card ( ) ) ;
Hand h = new Hand ( c ) ;
return h ;
}
public Hand dealNewHand ( int cards , String owner ) {
Hand h = this . dealNewHand ( cards ) ;
h . setOwner ( owner ) ;
return h ;
}
private Card pop_card ( ) {
try {
int size = cards . size ( )  <num> ;
Card c = cards . get ( size ) ;
cards . remove ( size ) ;
return c ;
} catch ( IndexOutOfBoundsException e ) {
e . printStackTrace ( ) ;
}
return null ;
}
public Card pop_card ( int index ) {
try {
Card c = cards . get ( index ) ;
cards . remove ( index ) ;
return c ;
} catch ( IndexOutOfBoundsException e ) {
e . printStackTrace ( ) ;
}
return null ;
}
}
package com . lgposse . jumper . models ;
import java . io . Serializable ;
import com . lgposse . game . models . Model ;
public class Peg extends Model implements Serializable {
private static final long serialVersionUID =  <num> ;
public int id ;
public enum types { PLAYER_ONE , PLAYER_TWO , EMPTY } ;
public types type ;
public Peg ( int id , types type ) {
this . id = id ;
this . type = type ;
}
public Peg ( ) {
this . type = types . EMPTY ;
}
public String toString ( ) {
switch ( type ) {
case EMPTY :
return " ;
case PLAYER_ONE :
return " ;
case PLAYER_TWO :
return " ;
default :
return " ;
}
}
}
package com . lgposse . common ;
import java . awt . Color ;
public class Colors {
public final static Color DARK_GREEN = new Color ( <num> , <num> , <num> ) ;
public final static Color LIGHT_BLUE = new Color ( <num> , <num> , <num> ) ;
public final static Color LIGHT_GRAY = new Color ( <num> , <num> , <num> ) ;
}
package com . lgposse . user . models ;
import java . io . Serializable ;
public class User implements Serializable {
private static final long serialVersionUID =  <num> ;
public String name ;
public User ( String name ) {
this . name = name ;
}
public String toString ( ) {
return this . name + " ;
}
}
package com . lgposse . game . database ;
import java . util . ArrayList ;
import com . lgposse . game . models . Game ;
import com . lgposse . thirdparty . MySQLDatabase ;
public abstract class GameDatabase extends MySQLDatabase {
public GameDatabase ( String hostname , int port , String database ,
String username , String password ) {
super ( hostname , port , database , username , password ) ;
}
public abstract Game getGame ( int id ) ;
public abstract ArrayList < Game > getAllGames ( ) ;
public void removeAllGames ( ) {
super . truncate ( " ) ;
}
}
package com . lgposse . cards . app ;
import java . awt . Component ;
import com . lgposse . game . app . WebContainer ;
public class <unk> extends WebContainer {
private static final long serialVersionUID =  <num> ;
@Override
public void run ( ) {
}
@Override
public void setActiveComponent ( Component comp ) {
}
}
package com . lgposse . cards . views ;
import java . util . ArrayList ;
import com . lgposse . cards . models . Card ;
import com . lgposse . cards . models . Deck ;
import com . lgposse . game . views . View ;
import acm . graphics . GCompound ;
public class DeckView extends GCompound implements View {
public Deck d ;
public ArrayList < CardView > cardViews ;
private boolean flipped ;
public DeckView ( Deck d , boolean flipped ) {
this . flipped = flipped ;
this . d = d ;
this . cardViews = new ArrayList < CardView > ( ) ;
this . update ( ) ;
}
public void update ( ) {
cardViews . clear ( ) ;
this . removeAll ( ) ;
int x = <num> ;
int y = <num> ;
for ( Card c : d . cards ) {
if ( x >  <num> ) {
CardView cv = new CardView ( c , flipped ) ;
this . add ( cv , x , y ) ;
cardViews . add ( cv ) ;
x -= <num> ;
y -= <num> ;
}
}
}
}
package com . lgposse . game . controllers ;
import com . lgposse . game . app . GameApp ;
import com . lgposse . game . models . Player ;
import com . lgposse . user . controllers . UserControl ;
import com . lgposse . user . controllers . UserControlForm ;
public class PlayerControl extends UserControl {
private static final long serialVersionUID = <num> ;
private GameApp gameApp ;
public PlayerControl ( GameApp gameApp ) {
super ( ) ;
this . form = new UserControlForm ( this ) ;
this . add ( form ) ;
this . gameApp = gameApp ;
}
public void setUser ( Player p ) {
this . gameApp . gotPlayer ( p ) ;
}
@Override
public void registerUser ( String username , String password , String email ) {
}
@Override
public void loginUser ( String username , String password ) {
gameApp . gotPlayer ( new Player ( username ) ) ;
}
}
package com . lgposse . game . app ;
import java . awt . Component ;
public interface GameContainer {
public void setActiveComponent ( Component comp ) ;
}
package com . lgposse . net . server ;
import java . io . IOException ;
import java . io . ObjectInputStream ;
import java . io . ObjectOutputStream ;
import java . io . Serializable ;
import java . net . Socket ;
import java . net . SocketException ;
import com . lgposse . net . common . ObjectListener ;
import com . lgposse . net . common . TextRequest ;
import com . lgposse . net . common . TextResponse ;
public abstract class ServerThread extends Thread implements ObjectListener {
protected MultiServer parent ;
protected Socket socket ;
protected ObjectOutputStream out ;
protected ObjectInputStream in ;
protected boolean loggingEnabled = true ;
protected int loggingPriority = <num> ;
protected int id ;
protected String name ;
public ServerThread ( MultiServer parent , Socket socket ) throws IOException {
try {
log ( " , <num> ) ;
this . parent = parent ;
this . socket = socket ;
id = parent . addClient ( this ) ;
log ( " + Integer . toString ( id ) , <num> ) ;
log ( " , <num> ) ;
out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ;
log ( " , <num> ) ;
in = new ObjectInputStream ( socket . getInputStream ( ) ) ;
}
catch ( SocketException e ) { close ( ) ; }
}
@Override
public void run ( ) {
try {
Object input ;
while ( ( ( input = in . readObject ( ) ) != null ) ) {
if ( input instanceof String ) {
String i = ( String ) input ;
if ( i . equals ( " ) ) {
close ( ) ;
break ;
}
} else {
this . gotObject ( input ) ;
}
}
} catch ( ClassNotFoundException | IOException e ) {
}
}
public void sendObject ( Serializable obj ) {
try {
out . writeObject ( obj ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
private void close ( ) {
log ( " + Integer . toString ( id ) + " , <num> ) ;
parent . removeClient ( this ) ;
try {
out . close ( ) ;
in . close ( ) ;
socket . close ( ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
log ( " , <num> ) ;
}
private void log ( String message , int priority ) {
if ( loggingEnabled && ( priority <= loggingPriority ) ) {
System . out . println ( " + Long . toString ( this . getId ( ) ) + " +
message ) ;
}
}
public String <unk> ( String channel , String prompt ) {
log ( prompt , <num> ) ;
try {
out . writeObject ( new TextRequest ( channel , prompt ) ) ;
Object nameresp = in . readObject ( ) ;
if ( nameresp instanceof TextResponse ) {
String response = ( ( TextResponse ) nameresp ) . text ;
log ( " + response , <num> ) ;
return response ;
}
} catch ( ClassNotFoundException e1 ) {
e1 . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
return null ;
}
}
package com . lgposse . cards . tests ;
import javax . swing . JFrame ;
import com . lgposse . cards . models . CardGame ;
import com . lgposse . cards . views . CardGameView ;
import com . lgposse . game . models . Player ;
public class CardGameViewTest implements Runnable {
public static void main ( String [ ] args ) {
new CardGameViewTest ( ) . run ( ) ;
}
public void run ( ) {
JFrame frame = new JFrame ( " ) ;
CardGame g = CardGameTest . exampleCardGame ( ) ;
Player me = g . players . get ( <num> ) ;
CardGameView view = new CardGameView ( g , me ) ;
frame . setSize ( <num> , <num> ) ;
frame . add ( view ) ;
frame . setLocation ( <num> , <num> ) ;
frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
frame . setVisible ( true ) ;
}
}
package com . lgposse . cards . models ;
import java . util . ArrayList ;
public class Pile extends Hand {
private static final long serialVersionUID = <num> ;
public Pile ( ArrayList < Card > cards ) {
super ( cards ) ;
}
public Pile ( ) {
super ( new ArrayList < Card > ( ) ) ;
}
@Override
public void receiveCard ( Card c ) {
this . cards . add ( c ) ;
}
}
package com . lgposse . cards . models ;
import java . util . Collections ;
import java . util . Hashtable ;
import com . lgposse . game . models . Game ;
import com . lgposse . game . models . Player ;
public class CardGame extends Game {
private static final long serialVersionUID =  <num> ;
public Deck deck ;
public Hashtable < Player , Hand > hands ;
public Pile playfield ;
public Pile discard ;
public int cardsPerHand ;
public CardGame ( String id ) {
super ( id ) ;
this . type = " ;
this . deck = new Deck ( true ) ;
this . maxPlayers = <num> ;
this . cardsPerHand = <num> ;
this . turn = <num> ;
this . hands = new Hashtable < Player , Hand > ( ) ;
this . playfield = new Pile ( ) ;
this . discard = new Pile ( ) ;
}
@Override
public boolean addPlayer ( Player p ) {
if ( this . state == states . JOINABLE && this . players . size ( ) < this . maxPlayers ) {
this . players . add ( this . turn , p ) ;
this . turn ++ ;
this . hands . put ( p , this . deck . dealNewHand ( this . cardsPerHand , p . name ) ) ;
return true ;
}
return false ;
}
@Override
public void dropPlayer ( Player p ) {
this . players . remove ( this . players . indexOf ( p ) ) ;
discardAll ( p ) ;
this . hands . remove ( p ) ;
}
private void discardAll ( Player p ) {
for ( int i = <num> ; i < ( this . hands . get ( p ) . cards . size ( )  <num> ) ; i ++ ) {
deck . cards . add ( this . hands . get ( p ) . cards . get ( i ) ) ;
this . hands . get ( p ) . cards . remove ( this . hands . get ( i ) ) ;
}
deck . shuffle ( ) ;
}
@Override
public void startGame ( ) {
if ( this . players . size ( ) > <num> ) {
this . state = states . IN_PROGRESS ;
this . turn = <num> ;
}
}
@Override
public void endGame ( ) {
this . state = states . FINISHED ;
}
public String toString ( ) {
String out = " + this . id + " ;
out += " + this . deck + " ;
out += " + this . hands . toString ( ) + " ;
out += " + this . turn + " ;
out += " + this . state . toString ( ) + " ;
out += " + this . players . toString ( ) + " ;
out += " + this . playfield . toString ( ) + " ;
return out ;
}
public void playCard ( Player p , Card c ) {
if ( ( hands . get ( p ) . cards . contains ( c ) ) &&
( this . players . get ( turn ) == p ) &&
( this . inProgress ( ) ) )
{
hands . get ( p ) . giveCard ( c , playfield ) ;
this . endTurn ( ) ;
} else {
System . out . println ( " ) ;
}
}
public void playCard ( Player p , String cardId ) {
Card c = hands . get ( p ) . cardFromId ( cardId ) ;
if ( ( c != null ) && ( this . inProgress ( ) ) ) {
this . playCard ( p , c ) ;
} else {
System . out . println ( " ) ;
}
}
public Player scoreHand ( ) {
if ( this . inProgress ( ) && this . playfieldFull ( ) ) {
Collections . sort ( playfield . cards ) ;
Collections . reverse ( playfield . cards ) ;
Player p = this . playerFromName ( playfield . cards . get ( <num> ) . owner ) ;
this . playfieldCleanup ( ) ;
return p ;
} else return null ;
}
public Hand getHand ( Player p ) {
return this . hands . get ( p ) ;
}
private boolean inProgress ( ) {
if ( this . state == states . IN_PROGRESS ) return true ;
else return false ;
}
private boolean playfieldFull ( ) {
if ( this . playfield . cards . size ( ) == this . players . size ( ) ) {
return true ;
} else return false ;
}
private void playfieldCleanup ( ) {
discard . cards . addAll ( playfield . cards ) ;
playfield . cards . clear ( ) ;
}
}
package com . lgposse . game . controllers ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseListener ;
import com . lgposse . game . app . GameApp ;
import com . lgposse . game . views . GameInfoView ;
public class GameInfoControl extends GameInfoView implements MouseListener {
private static final long serialVersionUID =  <num> ;
private GameApp gameApp ;
public GameInfoControl ( GameApp gameApp ) {
super ( ) ;
this . gameApp = gameApp ;
btnJoinGame . addMouseListener ( this ) ;
}
@Override
public void mouseClicked ( MouseEvent e ) {
if ( e . getSource ( ) == btnJoinGame ) {
this . gameApp . gotGame ( this . game ) ;
}
}
@Override
public void mouseEntered ( MouseEvent e ) { }
@Override
public void mouseExited ( MouseEvent e ) { }
@Override
public void mousePressed ( MouseEvent e ) { }
@Override
public void mouseReleased ( MouseEvent e ) { }
}
package com . lgposse . user . database ;
import java . util . ArrayList ;
import com . lgposse . thirdparty . MySQLDatabase ;
import com . lgposse . user . models . User ;
public class UserDatabase extends MySQLDatabase {
public UserDatabase ( String hostname , int port , String database ,
String username , String password ) {
super ( hostname , port , database , username , password ) ;
}
public User getUser ( String username ) {
return new User ( username ) ;
}
public User getUser ( int id ) {
return null ;
}
public ArrayList < User > getAllUsers ( ) {
return null ;
}
public int registerUser ( User user , String password ) {
return <num> ;
}
public User loginUser ( String username , String password ) {
return null ;
}
}
package com . lgposse . thirdparty ;
import java . io . InputStream ;
import java . io . OutputStream ;
import java . security . spec . AlgorithmParameterSpec ;
import javax . crypto . Cipher ;
import javax . crypto . CipherInputStream ;
import javax . crypto . CipherOutputStream ;
import javax . crypto . SecretKey ;
import javax . crypto . spec . IvParameterSpec ;
public class DesEncrypter {
Cipher ecipher ;
Cipher dcipher ;
public DesEncrypter ( SecretKey key ) {
byte [ ] iv = new byte [ ] {
( byte ) <num> , <num> , <num> , ( byte ) <num> ,
<num> , <num> , <num> , <num>
} ;
AlgorithmParameterSpec paramSpec = new IvParameterSpec ( iv ) ;
try {
ecipher = Cipher . getInstance ( " ) ;
dcipher = Cipher . getInstance ( " ) ;
ecipher . init ( Cipher . ENCRYPT_MODE , key , paramSpec ) ;
dcipher . init ( Cipher . DECRYPT_MODE , key , paramSpec ) ;
} catch ( java . security . InvalidAlgorithmParameterException e ) {
} catch ( javax . crypto . NoSuchPaddingException e ) {
} catch ( java . security . NoSuchAlgorithmException e ) {
} catch ( java . security . InvalidKeyException e ) {
}
}
byte [ ] buf = new byte [ <num> ] ;
public void encrypt ( InputStream in , OutputStream out ) {
try {
out = new CipherOutputStream ( out , ecipher ) ;
int numRead = <num> ;
while ( ( numRead = in . read ( buf ) ) >= <num> ) {
out . write ( buf , <num> , numRead ) ;
}
out . close ( ) ;
} catch ( java . io . IOException e ) {
}
}
public void decrypt ( InputStream in , OutputStream out ) {
try {
in = new CipherInputStream ( in , dcipher ) ;
int numRead = <num> ;
while ( ( numRead = in . read ( buf ) ) >= <num> ) {
out . write ( buf , <num> , numRead ) ;
}
out . close ( ) ;
} catch ( java . io . IOException e ) {
}
}
package com . lgposse . cards . tests ;
import org . junit . Test ;
import com . lgposse . cards . models . Deck ;
import com . lgposse . cards . models . Hand ;
public class <unk> {
@Test
public void test ( ) {
Deck d = new Deck ( false ) ;
Hand h1 = d . dealNewHand ( <num> ) ;
System . out . println ( h1 ) ;
Hand h2 = d . dealNewHand ( <num> , " ) ;
System . out . println ( h2 ) ;
}
}
package com . lgposse . jumper . views ;
import javax . swing . event . ChangeEvent ;
import javax . swing . event . ChangeListener ;
import acm . graphics . GCompound ;
import acm . graphics . GRect ;
import com . lgposse . game . views . View ;
import com . lgposse . jumper . models . Graveyard ;
import com . lgposse . jumper . models . Peg ;
public class GraveyardView extends GCompound implements View , ChangeListener {
protected Graveyard graveyard ;
private GRect outerRect ;
public GraveyardView ( Graveyard graveyard ) {
this . graveyard = graveyard ;
update ( ) ;
}
@Override
public void stateChanged ( ChangeEvent arg0 ) {
update ( ) ;
}
@Override
public void update ( ) {
this . removeAll ( ) ;
int x = <num> ;
int y = <num> ;
int count = <num> ;
outerRect = new GRect ( <num> , <num> ) ;
this . add ( outerRect ,  <num> ,  <num> ) ;
PegView empty = new PegView ( new Peg (  <num> , Peg . types . EMPTY ) ) ;
for ( Peg p : this . graveyard . getPegs ( ) ) {
this . add ( new PegView ( p ) ) ;
if ( count == <num> ) y += <num> ; x = <num> ;
count  ;
x += <num> ;
}
if ( count > <num> ) {
for ( int i = count ; i > <num> ; i  ) {
this . add ( empty , x , y ) ;
x += <num> ;
}
y += <num> ; x = <num> ;
for ( int i = <num> ; i > <num> ; i  ) {
this . add ( empty , x , y ) ;
x += <num> ;
}
} else {
for ( int i = count ; i > <num> ; i  ) {
this . add ( empty , x , y ) ;
x += <num> ;
}
}
}
}
package com . lgposse . game . models ;
import java . io . ByteArrayInputStream ;
import java . io . ByteArrayOutputStream ;
import java . io . IOException ;
import java . io . ObjectOutputStream ;
import java . io . Serializable ;
import java . util . ArrayList ;
public abstract class Game extends Model implements Serializable {
private static final long serialVersionUID = <num> ;
public int id ;
public String name ;
public String type ;
public ArrayList < Player > players ;
public int maxPlayers ;
public enum states {
JOINABLE , IN_PROGRESS , FINISHED
} ;
public int turn ;
public states state ;
public Game ( String name ) {
this . name = name ;
this . players = new ArrayList < Player > ( ) ;
this . state = states . JOINABLE ;
}
public abstract boolean addPlayer ( Player p ) ;
public abstract void dropPlayer ( Player p ) ;
public abstract void startGame ( ) ;
public abstract void endGame ( ) ;
public boolean endTurn ( ) {
if ( this . state == states . IN_PROGRESS ) {
try {
this . players . get ( turn + <num> ) ;
turn ++ ;
} catch ( IndexOutOfBoundsException e ) {
turn = <num> ;
}
return true ;
} else return false ;
}
public Player playerFromName ( String name ) {
for ( Player p : this . players ) {
if ( p . name == name ) return p ;
}
return null ;
}
public ByteArrayInputStream getInputStream ( ) {
try {
ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ;
ObjectOutputStream oos ;
oos = new ObjectOutputStream ( baos ) ;
oos . writeObject ( this ) ;
oos . close ( ) ;
ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ;
return bais ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
return null ;
}
}
}
package com . lgposse . cards . models ;
import java . util . ArrayList ;
public class Hand extends Deck {
private static final long serialVersionUID =  <num> ;
public String owner ;
public Hand ( ArrayList < Card > cards ) {
this . cards = cards ;
}
public void setOwner ( String owner ) {
this . owner = owner ;
for ( Card c : this . cards ) {
c . owner = this . owner ;
}
}
public void giveCard ( Card c , Hand h ) {
h . receiveCard ( c ) ;
this . cards . remove ( this . cards . indexOf ( c ) ) ;
}
public void receiveCard ( Card c ) {
c . owner = this . owner ;
this . cards . add ( c ) ;
}
public Card cardFromId ( String id ) {
for ( Card c : this . cards ) {
if ( c . id == id ) return c ;
}
return null ;
}
}
package com . lgposse . jumper . net ;
import com . lgposse . game . net . NetControl ;
import com . lgposse . jumper . app . JumperGameApp ;
public class JumperNet extends NetControl {
public JumperNet ( JumperGameApp app , String host , int port ) {
super ( app , host , port ) ;
}
@Override
public void gotObject ( Object o ) {
}
}
package com . lgposse . game . net ;
import java . io . IOException ;
import java . net . Socket ;
import java . util . ArrayList ;
import com . lgposse . game . database . GameList ;
import com . lgposse . game . models . Game ;
import com . lgposse . net . common . TextRequest ;
import com . lgposse . net . server . ServerThread ;
public class GameServerThread extends ServerThread {
protected GameServer parent ;
public GameServerThread ( GameServer parent , Socket socket )
throws IOException {
super ( parent , socket ) ;
this . parent = parent ;
}
@Override
public void gotObject ( Object o ) {
if ( o instanceof Game ) {
Game game = ( Game ) o ;
parent . games . put ( game . name , game ) ;
}
else if ( o instanceof TextRequest ) {
TextRequest req = ( TextRequest ) o ;
switch ( req . channel ) {
case " :
String name = req . text ;
if ( parent . games . get ( name ) != null ) {
this . sendObject ( parent . games . get ( name ) ) ;
}
break ;
case " :
GameList gameList = new GameList ( ) ;
gameList . games = new ArrayList < Game > ( parent . games . values ( ) ) ;
this . sendObject ( gameList ) ;
break ;
}
}
}
}
package com . lgposse . net . server ;
import java . io . IOException ;
import java . io . Serializable ;
import java . net . Socket ;
public class EchoServerThread extends ServerThread {
public EchoServerThread ( MultiServer parent , Socket socket )
throws IOException {
super ( parent , socket ) ;
}
@Override
public void gotObject ( Object o ) {
this . sendObject ( ( Serializable ) o ) ;
}
}
package com . lgposse . game . app ;
import java . applet . Applet ;
public abstract class WebContainer extends Applet implements GameContainer , Runnable {
private static final long serialVersionUID = <num> ;
public GameApp gameApp ;
}
package com . lgposse . tests ;
import java . net . * ;
import java . io . * ;
public class <unk> {
public static void main ( String [ ] args ) throws Exception {
URL oracle = new URL ( " ) ;
URLConnection yc = oracle . openConnection ( ) ;
BufferedReader in = new BufferedReader ( new InputStreamReader (
yc . getInputStream ( ) ) ) ;
String inputLine ;
while ( ( inputLine = in . readLine ( ) ) != null )
System . out . println ( inputLine ) ;
in . close ( ) ;
}
package com . lgposse . cards . tests ;
import javax . swing . JFrame ;
import acm . graphics . GCanvas ;
import com . lgposse . cards . controllers . HandControl ;
import com . lgposse . cards . models . Deck ;
import com . lgposse . cards . models . Hand ;
public class HandControlTest implements Runnable {
public static void main ( String [ ] args ) {
new HandControlTest ( ) . run ( ) ;
}
public void run ( ) {
System . setProperty ( " , " ) ;
System . setProperty ( " , " ) ;
JFrame frame = new JFrame ( " ) ;
Deck d = new Deck ( false ) ;
Hand h2 = d . dealNewHand ( <num> ) ;
HandControl v2 = new HandControl ( h2 , true , true ) ;
GCanvas gc = new GCanvas ( ) ;
gc . add ( v2 , <num> , <num> ) ;
frame . add ( gc ) ;
frame . setSize ( <num> , <num> ) ;
frame . setLocation ( <num> , <num> ) ;
frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
frame . setVisible ( true ) ;
}
}
package com . lgposse . game . views ;
import java . awt . BorderLayout ;
import java . awt . Color ;
import java . awt . Component ;
import java . awt . Dimension ;
import java . net . MalformedURLException ;
import java . net . URL ;
import javax . swing . BoxLayout ;
import javax . swing . ImageIcon ;
import javax . swing . JButton ;
import javax . swing . JLabel ;
import javax . swing . JPanel ;
import javax . swing . border . EmptyBorder ;
import com . lgposse . common . Colors ;
import com . lgposse . common . Fonts ;
import com . lgposse . game . models . Game ;
public class GameInfoView extends JPanel implements View {
private static final long serialVersionUID = <num> ;
protected Game game ;
protected JPanel infoPanel ;
protected JPanel iconPanel ;
protected ImageIcon icon ;
protected JLabel iconLabel ;
protected JLabel lblName ;
protected JLabel lblType ;
protected JLabel lblPlayerCount ;
protected JLabel lblState ;
protected JButton btnJoinGame ;
public GameInfoView ( ) {
this . setLayout ( new BorderLayout ( <num> , <num> ) ) ;
infoPanel = new JPanel ( ) ;
infoPanel . setLayout ( new BoxLayout ( infoPanel , BoxLayout . Y_AXIS ) ) ;
iconPanel = new JPanel ( ) ;
lblName = new JLabel ( ) ;
lblName . setFont ( Fonts . TITLE ) ;
lblType = new JLabel ( ) ;
lblType . setFont ( Fonts . SUBTITLE ) ;
lblPlayerCount = new JLabel ( ) ;
lblPlayerCount . setFont ( Fonts . BODY_BOLD ) ;
lblState = new JLabel ( ) ;
lblState . setFont ( Fonts . BODY_BOLD ) ;
btnJoinGame = new JButton ( " ) ;
btnJoinGame . setFont ( Fonts . LOBBY_BUTTON ) ;
btnJoinGame . setBackground ( Colors . DARK_GREEN ) ;
btnJoinGame . setForeground ( Color . white ) ;
try {
icon = new ImageIcon ( new URL ( " ) ) ;
} catch ( MalformedURLException e ) { e . printStackTrace ( ) ; icon = null ; }
iconLabel = new JLabel ( icon ) ;
iconLabel . setOpaque ( true ) ;
iconLabel . setBorder ( new EmptyBorder ( <num> , <num> , <num> , <num> ) ) ;
iconPanel . add ( iconLabel ) ;
iconPanel . setPreferredSize ( new Dimension ( <num> , <num> ) ) ;
lblName . setAlignmentX ( Component . LEFT_ALIGNMENT ) ;
lblType . setAlignmentX ( Component . LEFT_ALIGNMENT ) ;
lblState . setAlignmentX ( Component . LEFT_ALIGNMENT ) ;
lblPlayerCount . setAlignmentX ( Component . LEFT_ALIGNMENT ) ;
infoPanel . add ( lblName ) ;
infoPanel . add ( lblType ) ;
infoPanel . add ( lblState ) ;
infoPanel . add ( lblPlayerCount ) ;
this . add ( iconPanel , BorderLayout . WEST ) ;
this . add ( infoPanel , BorderLayout . CENTER ) ;
this . add ( btnJoinGame , BorderLayout . SOUTH ) ;
}
public GameInfoView ( Game game ) {
super ( ) ;
this . setGame ( game ) ;
}
@Override
public void update ( ) {
lblName . setText ( game . name ) ;
lblType . setText ( game . type ) ;
lblPlayerCount . setText ( " + Integer . toString ( game . players . size ( ) ) +
" + Integer . toString ( game . maxPlayers ) ) ;
if ( game . players . size ( ) == game . maxPlayers ) {
btnJoinGame . setEnabled ( false ) ;
btnJoinGame . setBackground ( Color . DARK_GRAY ) ;
btnJoinGame . setText ( " ) ;
lblPlayerCount . setForeground ( Color . red ) ;
} else {
btnJoinGame . setEnabled ( true ) ;
btnJoinGame . setBackground ( Colors . DARK_GREEN ) ;
btnJoinGame . setText ( " ) ;
lblPlayerCount . setForeground ( Color . black ) ;
}
lblState . setText ( game . state . toString ( ) ) ;
switch ( game . state ) {
case JOINABLE :
lblState . setForeground ( new Color ( <num> , <num> , <num> ) ) ;
break ;
case IN_PROGRESS :
case FINISHED :
lblState . setForeground ( Color . red ) ;
break ;
}
}
public void setGame ( Game game ) {
this . game = game ;
this . update ( ) ;
}
}
package com . lgposse . cards . app ;
import com . lgposse . cards . controllers . CardGameControl ;
import com . lgposse . cards . controllers . CardGameLobbyControl ;
import com . lgposse . cards . models . CardGame ;
import com . lgposse . cards . tests . CardGameDatabaseTest ;
import com . lgposse . game . app . GameApp ;
import com . lgposse . game . app . GameContainer ;
import com . lgposse . game . models . Game ;
import com . lgposse . game . models . Player ;
public class CardGameApp extends GameApp {
public CardGame game ;
public CardGameControl gameControl ;
public CardGameApp ( GameContainer container ) {
super ( container ) ;
}
@Override
public void gotPlayer ( Player player ) {
this . player = player ;
this . lobbyControl = new CardGameLobbyControl ( this ) ;
this . gameContainer . setActiveComponent ( this . lobbyControl ) ;
}
@Override
public void gotGame ( Game game ) {
this . game = ( CardGame ) game ;
this . gameControl = new CardGameControl ( this ) ;
this . gameContainer . setActiveComponent ( this . gameControl ) ;
}
@Override
public boolean canMove ( ) {
if ( this . game . players . indexOf ( this . player ) == this . game . turn ) return true ;
else return false ;
}
}
package com . lgposse . cards . models ;
import java . io . Serializable ;
public class Card implements Comparable < Card > , Serializable {
private static final long serialVersionUID =  <num> ;
public int suit ;
public int rank ;
public String id ;
public String owner ;
public Card ( int suit , int rank ) {
this . suit = suit ;
this . rank = rank ;
this . id = Integer . toString ( suit ) + " + Integer . toString ( rank ) ;
}
public String toString ( ) {
return " + this . id + " + this . owner + " + decode_rank ( this . rank ) + " + decode_suit ( this . suit ) ;
}
public static String decode_rank ( int rank ) {
switch ( rank ) {
case <num> :
case <num> :
case <num> :
case <num> :
case <num> :
case <num> :
case <num> :
case <num> :
case <num> :
return Integer . toString ( rank ) ;
case <num> :
return " ;
case <num> :
return " ;
case <num> :
return " ;
case <num> :
case <num> :
return " ;
default :
return " ;
}
}
public static String decode_suit ( int suit ) {
switch ( suit ) {
case <num> :
return " ;
case <num> :
return " ;
case <num> :
return " ;
case <num> :
return " ;
default :
return " ;
}
}
public static String decode_rank_symbol ( int rank ) {
switch ( rank ) {
case <num> :
case <num> :
case <num> :
case <num> :
case <num> :
case <num> :
case <num> :
case <num> :
case <num> :
return Integer . toString ( rank ) ;
case <num> :
return " ;
case <num> :
return " ;
case <num> :
return " ;
case <num> :
case <num> :
return " ;
default :
return " ;
}
}
public static String decode_suit_symbol ( int suit ) {
String heart = " ;
String diamond = " ;
String spade = " ;
String club = " ;
switch ( suit ) {
case <num> :
return spade ;
case <num> :
return club ;
case <num> :
return diamond ;
case <num> :
return heart ;
default :
return " ;
}
}
public int compareTo ( Card other ) {
other = ( Card ) other ;
if ( this . rank > other . rank ) return <num> ;
else if ( this . rank < other . rank ) return  <num> ;
else return <num> ;
}
}
package com . lgposse . net . client ;
import java . io . IOException ;
import java . io . ObjectInputStream ;
import java . io . ObjectOutputStream ;
import java . io . Serializable ;
import java . net . Socket ;
import java . net . SocketException ;
import com . lgposse . net . common . ObjectListener ;
public class Client extends Thread {
protected ObjectListener listener ;
protected Socket socket ;
protected ObjectOutputStream out ;
protected ObjectInputStream in ;
public Client ( ObjectListener listener , String host , int port ) {
this . listener = listener ;
try {
socket = new Socket ( host , port ) ;
out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ;
in = new ObjectInputStream ( socket . getInputStream ( ) ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
public void sendObject ( Serializable obj ) {
try {
out . writeObject ( obj ) ;
} catch ( Exception e ) {
e . printStackTrace ( ) ;
}
}
public void run ( ) {
try {
Object input = null ;
while ( true ) {
input = in . readObject ( ) ;
if ( input != null ) {
listener . gotObject ( input ) ;
}
}
} catch ( SocketException e ) {
try {
this . out . close ( ) ;
this . in . close ( ) ;
this . socket . close ( ) ;
} catch ( Exception e2 ) {
e2 . printStackTrace ( ) ;
}
} catch ( ClassNotFoundException e ) {
e . printStackTrace ( ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
public void close ( ) throws IOException {
this . out . close ( ) ;
this . in . close ( ) ;
this . socket . close ( ) ;
}
}
package com . lgposse . jumper . tests ;
import javax . swing . JFrame ;
import acm . graphics . GCanvas ;
import com . lgposse . jumper . models . Board ;
import com . lgposse . jumper . views . BoardView ;
public class BoardViewTest implements Runnable {
public static void main ( String [ ] args ) {
new BoardViewTest ( ) . run ( ) ;
}
public void run ( ) {
System . setProperty ( " , " ) ;
System . setProperty ( " , " ) ;
JFrame frame = new JFrame ( " ) ;
frame . setSize ( <num> , <num> ) ;
frame . setLocation ( <num> , <num> ) ;
frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ;
GCanvas c = new GCanvas ( ) ;
BoardView v = new BoardView ( new Board ( ) ) ;
v . scale ( <num> ) ;
c . add ( v ) ;
frame . add ( c ) ;
frame . setVisible ( true ) ;
}
}
package com . lgposse . game . app ;
import com . lgposse . game . controllers . LobbyControl ;
import com . lgposse . game . controllers . PlayerControl ;
import com . lgposse . game . database . GameDatabase ;
import com . lgposse . game . database . GameList ;
import com . lgposse . game . models . Game ;
import com . lgposse . game . models . Player ;
import com . lgposse . game . net . NetControl ;
import com . lgposse . net . common . ObjectListener ;
public abstract class GameApp implements Runnable , ObjectListener {
public GameContainer gameContainer ;
public Player player ;
public GameDatabase database ;
public PlayerControl playerControl ;
public LobbyControl lobbyControl ;
public NetControl netControl ;
public GameApp ( GameContainer gameContainer ) {
this . gameContainer = gameContainer ;
this . playerControl = new PlayerControl ( this ) ;
this . gameContainer . setActiveComponent ( this . playerControl ) ;
this . netControl = new NetControl ( this , " , <num> ) ;
}
public void run ( ) {
playerControl = new PlayerControl ( this ) ;
}
public abstract void gotPlayer ( Player player ) ;
public abstract void gotGame ( Game game ) ;
public abstract boolean canMove ( ) ;
public void gotObject ( Object o ) {
if ( o instanceof Game ) this . gotGame ( ( Game ) o ) ;
else if ( o instanceof GameList ) {
GameList gameList = ( GameList ) o ;
System . out . println ( " + gameList ) ;
try {
Thread . sleep ( <num> ) ;
} catch ( InterruptedException e ) { }
this . lobbyControl . gotGameList ( gameList ) ;
}
else if ( o instanceof Player ) this . gotPlayer ( ( Player ) o ) ;
}
}
package com . lgposse . game . models ;
import com . lgposse . user . models . User ;
public class Player extends User {
private static final long serialVersionUID = <num> ;
public int coins ;
public Player ( String name ) {
super ( name ) ;
this . coins = <num> ;
}
}
package com . lgposse . cards . controllers ;
import com . lgposse . cards . app . CardGameApp ;
import com . lgposse . cards . views . CardGameView ;
public class CardGameControl extends CardGameView {
private static final long serialVersionUID = <num> ;
public CardGameControl ( CardGameApp gameApp ) {
super ( gameApp . game , gameApp . player ) ;
this . setName ( " ) ;
}
}
package com . lgposse . net . common ;
import java . io . Serializable ;
import java . util . Date ;
public class <unk> implements Serializable {
private static final long serialVersionUID = <num> ;
public String greeting = " ;
public int age = <num> ;
public int <unk> = <num> ;
public long <unk> = <num> ;
public char a = a' ;
public Date date = new Date ( System . currentTimeMillis ( ) ) ;
public String <unk> ( ) {
return " ;
}
package com . lgposse . cards . tests ;
import org . junit . Test ;
import com . lgposse . cards . models . Card ;
public class <unk> {
@Test
public void test ( ) {
Card c = new Card ( <num> , <num> ) ;
System . out . println ( c ) ;
}
}
package com . lgposse . jumper . models ;
import java . io . Serializable ;
import com . lgposse . game . models . Model ;
public class Board extends Model implements Serializable {
private static final long serialVersionUID = <num> ;
public Peg [ ] [ ] pegs ;
public Board ( ) {
int id = <num> ;
pegs = new Peg [ <num> ] [ <num> ] ;
for ( int i = <num> ; i < <num> ; i ++ ) {
for ( int j = <num> ; j < <num> ; j ++ ) {
switch ( i ) {
case <num> :
case <num> :
pegs [ i ] [ j ] = new Peg ( id , Peg . types . PLAYER_TWO ) ;
break ;
case <num> :
case <num> :
pegs [ i ] [ j ] = new Peg ( id , Peg . types . PLAYER_ONE ) ;
break ;
default :
pegs [ i ] [ j ] = new Peg ( id , Peg . types . EMPTY ) ;
}
id ++ ;
}
}
}
public String toString ( ) {
String s = " ;
for ( int i = <num> ; i < <num> ; i ++ ) {
for ( int j = <num> ; j < <num> ; j ++ ) {
s += pegs [ i ] [ j ] ;
}
s += \n' ;
}
return s ;
}
public boolean jump ( Peg jPeg , Peg lPeg ) {
boolean success = false ;
if ( ! jPeg . type . equals ( Peg . types . EMPTY ) && lPeg . type . equals ( Peg . types . EMPTY ) ) {
int jx = getX ( indexOf ( jPeg ) ) ;
int jy = getY ( indexOf ( jPeg ) ) ;
int lx = getX ( indexOf ( lPeg ) ) ;
int ly = getY ( indexOf ( lPeg ) ) ;
if (
( jx + <num> == lx || jx  <num> == lx ) &&
( jy + <num> == ly || jy  <num> == ly )
) {
swap ( jPeg , lPeg , jx , jy , lx , ly ) ;
success = true ;
}
else if (
( ( jx + <num> == lx || jx  <num> == lx ) && jy == ly ) ||
( jx == lx && ( jy + <num> == ly || jy  <num> == ly ) )
) {
swap ( jPeg , lPeg , jx , jy , lx , ly ) ;
success = true ;
}
Peg mPeg = inBetween ( jx , jy , lx , ly ) ;
if ( mPeg != null ) {
boolean remove = false ;
switch ( mPeg . type ) {
case PLAYER_ONE :
if ( jPeg . type . equals ( Peg . types . PLAYER_TWO ) ) {
remove = true ;
}
break ;
case PLAYER_TWO :
if ( jPeg . type . equals ( Peg . types . PLAYER_ONE ) ) {
remove = true ;
}
break ;
}
if ( remove ) {
mPeg . type = Peg . types . EMPTY ;
}
}
}
return success ;
}
public Peg <unk> ( int id ) {
for ( Peg [ ] row : pegs ) {
for ( Peg p : row ) {
if ( p . id == id ) {
return p ;
}
}
}
return null ;
}
public Peg pegByCoordinates ( int x , int y ) {
try {
return pegs [ x ] [ y ] ;
} catch ( ArrayIndexOutOfBoundsException e ) {
return null ;
}
}
public int getX ( Peg p ) {
return getX ( indexOf ( p ) ) ;
}
public int getY ( Peg p ) {
return getY ( indexOf ( p ) ) ;
}
private void swap ( Peg jPeg , Peg lPeg , int jx , int jy , int lx , int ly ) {
pegs [ jx ] [ jy ] = lPeg ;
pegs [ lx ] [ ly ] = jPeg ;
}
private String indexOf ( Peg peg ) {
for ( int i = <num> ; i < <num> ; i ++ ) {
for ( int j = <num> ; j < <num> ; j ++ ) {
if ( pegs [ i ] [ j ] . equals ( peg ) ) {
return Integer . toString ( i ) + " + Integer . toString ( j ) ;
}
}
}
return " ;
}
private int getX ( String indexOf ) {
String [ ] x = indexOf . split ( " ) ;
return Integer . parseInt ( x [ <num> ] ) ;
}
private int getY ( String indexOf ) {
String [ ] y = indexOf . split ( " ) ;
return Integer . parseInt ( y [ <num> ] ) ;
}
private Peg inBetween ( int jx , int jy , int lx , int ly ) {
if ( jx + <num> == lx  <num> ) {
if ( jy + <num> == ly  <num> ) {
return pegs [ jx + <num> ] [ jy + <num> ] ;
}
if ( jy  <num> == ly + <num> ) {
return pegs [ jx + <num> ] [ jy  <num> ] ;
}
if ( jy == ly ) {
return pegs [ jx + <num> ] [ jy ] ;
}
}
if ( jx  <num> == lx + <num> ) {
if ( jy + <num> == ly  <num> ) {
return pegs [ jx  <num> ] [ jy + <num> ] ;
}
if ( jy  <num> == ly + <num> ) {
return pegs [ jx  <num> ] [ jy  <num> ] ;
}
if ( jy == ly ) {
return pegs [ jx  <num> ] [ jy ] ;
}
}
if ( jx == lx ) {
if ( jy + <num> == ly  <num> ) {
return pegs [ jx ] [ jy + <num> ] ;
}
if ( jy  <num> == ly + <num> ) {
return pegs [ jx ] [ jy  <num> ] ;
}
if ( jy == ly ) {
return pegs [ jx ] [ jy ] ;
}
}
return null ;
}
}
package com . lgposse . jumper . models ;
import java . util . Hashtable ;
import com . lgposse . game . models . Game ;
import com . lgposse . game . models . Player ;
public class JumperGame extends Game {
private static final long serialVersionUID =  <num> ;
public Hashtable < Player , Peg . types > playerOrder ;
public Board board ;
public JumperGame ( String name ) {
super ( name ) ;
this . type = " ;
this . maxPlayers = <num> ;
this . turn = <num> ;
this . board = new Board ( ) ;
playerOrder = new Hashtable < Player , Peg . types > ( ) ;
}
@Override
public boolean addPlayer ( Player p ) {
boolean success ;
if ( this . state == Game . states . JOINABLE && this . players . size ( ) < this . maxPlayers ) {
this . players . add ( p ) ;
switch ( this . players . size ( ) ) {
case <num> :
this . playerOrder . put ( p , Peg . types . PLAYER_ONE ) ;
break ;
case <num> :
this . playerOrder . put ( p , Peg . types . PLAYER_TWO ) ;
break ;
}
success = true ;
} else success = false ;
if ( this . players . size ( ) == this . maxPlayers ) startGame ( ) ;
return success ;
}
@Override
public void dropPlayer ( Player p ) {
try {
this . players . remove ( p ) ;
} catch ( Exception e ) { e . printStackTrace ( ) ; }
if ( this . state == Game . states . IN_PROGRESS ) {
if ( this . players . size ( ) < this . maxPlayers ) {
this . endGame ( ) ;
}
}
}
@Override
public void startGame ( ) {
this . state = states . IN_PROGRESS ;
}
@Override
public void endGame ( ) {
this . state = states . FINISHED ;
}
public boolean isTurn ( Player player ) {
if ( this . players . indexOf ( player ) == this . turn ) return true ;
else return false ;
}
public boolean isPiece ( Player player , Peg peg ) {
if ( this . playerOrder . get ( player ) == peg . type ) return true ;
else return false ;
}
}
package com . lgposse . cards . tests ;
import org . junit . Test ;
public class <unk> {
@Test
public void test ( ) {
System . out . printf ( " , " , " , " ) ;
}
}
package com . lgposse . common ;
import java . awt . Font ;
public class Fonts {
public final static Font TITLE = new Font ( " , Font . PLAIN , <num> ) ;
public final static Font SUBTITLE = new Font ( " , Font . ITALIC , <num> ) ;
public final static Font BODY_BOLD = new Font ( " , Font . BOLD , <num> ) ;
public final static Font BODY = new Font ( " , Font . PLAIN , <num> ) ;
public final static Font LOBBY_BUTTON = new Font ( " , Font . BOLD , <num> ) ;
}
package com . lgposse . cards . views ;
import com . lgposse . cards . models . Card ;
import com . lgposse . cards . models . CardGame ;
public class PlayfieldView extends HandView {
private CardGame g ;
public PlayfieldView ( CardGame g , boolean flipped ) {
super ( g . playfield , flipped ) ;
this . g = g ;
this . update ( ) ;
}
@Override
public void update ( ) {
int r = <num> ;
int n = h . cards . size ( ) ;
int i ;
for ( Card c : h . cards ) {
i = g . players . indexOf ( g . playerFromName ( c . owner ) ) ;
CardView cv = new CardView ( c , flipped ) ;
double t = <num> * Math . PI * i / n ;
int x = ( int ) Math . round ( r * Math . cos ( t ) ) ;
int y = ( int ) Math . round ( r * Math . sin ( t ) ) ;
this . add ( cv , x , y ) ;
}
}
}
package com . lgposse . cards . views ;
import java . awt . Color ;
import java . awt . Font ;
import java . awt . geom . AffineTransform ;
import com . lgposse . cards . models . Card ;
import com . lgposse . game . views . View ;
import acm . graphics . GCompound ;
import acm . graphics . GLabel ;
import acm . graphics . GRect ;
import acm . graphics . GRoundRect ;
public class CardView extends GCompound implements View {
private String suit ;
private String rank ;
private final int SUIT_SIZE = <num> ;
private final int RANK_SIZE = <num> ;
public Card card ;
public CardView ( Card c , boolean flipped ) {
this . card = c ;
this . suit = Card . decode_suit_symbol ( c . suit ) ;
this . rank = Card . decode_rank_symbol ( c . rank ) ;
Color cardColor = CardView . decodeColor ( c . suit ) ;
GRoundRect outerRect = new GRoundRect ( <num> , <num> ) ;
GRect innerRect = new GRect ( <num> , <num> ) ;
CenterDesign centerDesign = new CenterDesign ( c ) ;
DoubleLabel upperLabel = new DoubleLabel ( this . rank , this . suit , true , RANK_SIZE , SUIT_SIZE , cardColor ) ;
DoubleLabel lowerLabel = new DoubleLabel ( this . suit , this . rank , false , SUIT_SIZE , RANK_SIZE , cardColor ) ;
if ( flipped ) {
outerRect . setFillColor ( Color . pink ) ;
outerRect . setFilled ( true ) ;
innerRect . setFillColor ( Color . red ) ;
innerRect . setColor ( Color . red ) ;
innerRect . setFilled ( true ) ;
} else {
outerRect . setFillColor ( Color . white ) ;
innerRect . setColor ( Color . white ) ;
outerRect . setFilled ( true ) ;
}
this . add ( outerRect , <num> , <num> ) ;
this . add ( innerRect , <num> , <num> ) ;
if ( ! flipped ) {
this . add ( upperLabel , <num> , <num> ) ;
this . add ( centerDesign , <num> , <num> ) ;
this . add ( lowerLabel , <num> , <num> ) ;
}
}
public static Color decodeColor ( int suit ) {
Color c ;
if ( suit == <num> || suit == <num> ) {
c = Color . black ;
} else {
c = Color . red ;
}
return c ;
}
@Override
public void update ( ) {
}
}
class DoubleLabel extends GCompound {
public DoubleLabel ( String tupper , String tlower , boolean upperLabel , int uSize , int dSize , Color c ) {
GBigLabel upper = new GBigLabel ( tupper , uSize , c ) ;
GBigLabel lower = new GBigLabel ( tlower , dSize , c ) ;
if ( upperLabel ) {
this . add ( upper , <num> , <num> ) ;
this . add ( lower , <num> , <num> ) ;
} else {
this . add ( upper , <num> , <num> ) ;
this . add ( lower , <num> , <num> ) ;
}
}
}
class GBigLabel extends GLabel {
public GBigLabel ( String caption , int size , Color c ) {
super ( caption ) ;
this . setColor ( c ) ;
Font f ;
if ( caption . equals ( " ) ) {
f = new Font ( " , Font . PLAIN , size  <num> ) ;
AffineTransform trans = new AffineTransform ( ) ;
trans . scale ( <num> , <num> ) ;
f = f . deriveFont ( trans ) ;
} else f = new Font ( " , Font . PLAIN , size ) ;
this . setFont ( f ) ;
}
}
class CenterDesign extends GCompound {
public GLabelStack side ;
public GLabelStack side2 ;
public GLabelStack center ;
public CenterDesign ( Card c ) {
int suit = c . suit ;
int rank = c . rank ;
boolean [ ] p21 = { true , false } ;
boolean [ ] p22 = { true , true } ;
boolean [ ] p31 = { false , true , false } ;
boolean [ ] p32 = { true , false , true } ;
boolean [ ] p33 = { true , true , true } ;
boolean [ ] p44 = { true , true , true , true } ;
switch ( rank ) {
case <num> :
case <num> :
center = new ThreeStack ( suit , p31 ) ;
break ;
case <num> :
center = new ThreeStack ( suit , p32 ) ;
break ;
case <num> :
center = new ThreeStack ( suit , p33 ) ;
break ;
case <num> :
side = new ThreeStack ( suit , p32 ) ;
side2 = new ThreeStack ( suit , p32 ) ;
break ;
case <num> :
center = new ThreeStack ( suit , p31 ) ;
side = new ThreeStack ( suit , p32 ) ;
side2 = new ThreeStack ( suit , p32 ) ;
break ;
case <num> :
side = new ThreeStack ( suit , p33 ) ;
side2 = new ThreeStack ( suit , p33 ) ;
break ;
case <num> :
center = new TwoStack ( suit , p21 ) ;
side = new ThreeStack ( suit , p33 ) ;
side2 = new ThreeStack ( suit , p33 ) ;
break ;
case <num> :
center = new TwoStack ( suit , p22 ) ;
side = new ThreeStack ( suit , p33 ) ;
side2 = new ThreeStack ( suit , p33 ) ;
break ;
case <num> :
center = new ThreeStack ( suit , p31 ) ;
side = new FourStack ( suit , p44 ) ;
side2 = new FourStack ( suit , p44 ) ;
break ;
case <num> :
center = new TwoStack ( suit , p22 ) ;
side = new FourStack ( suit , p44 ) ;
side2 = new FourStack ( suit , p44 ) ;
break ;
}
try { this . add ( center , <num> , <num> ) ; } catch ( NullPointerException e ) { }
try {
this . add ( side , <num> , <num> ) ;
this . add ( side2 , <num> , <num> ) ;
} catch ( NullPointerException e ) { }
}
}
abstract class GLabelStack extends GCompound {
private final int SIZE = <num> ;
public GLabel [ ] pos = new GLabel [ <num> ] ;
public GLabelStack ( int suit , boolean [ ] positions , int plusY , int padY ) {
String suitSymbol = Card . decode_suit_symbol ( suit ) ;
Color c = CardView . decodeColor ( suit ) ;
int i = <num> ;
int y = padY ;
Font f = new Font ( " , Font . PLAIN , SIZE ) ;
for ( boolean p : positions ) {
if ( p ) {
pos [ i ] = new GLabel ( suitSymbol ) ;
pos [ i ] . setFont ( f ) ;
pos [ i ] . setColor ( c ) ;
this . add ( pos [ i ] , <num> , y ) ;
i ++ ;
}
y += plusY ;
}
}
public GLabelStack ( ) { }
}
class <unk> extends GLabelStack { }
class TwoStack extends GLabelStack {
public TwoStack ( int suit , boolean [ ] positions ) {
super ( suit , positions , <num> , <num> ) ;
}
}
class ThreeStack extends GLabelStack {
public ThreeStack ( int suit , boolean [ ] positions ) {
super ( suit , positions , <num> , <num> ) ;
}
}
class FourStack extends GLabelStack {
public FourStack ( int suit , boolean [ ] positions ) {
super ( suit , positions , <num> , <num> ) ;
}
package com . lgposse . cards . tests ;
import java . io . IOException ;
import java . io . ObjectOutputStream ;
import java . util . Random ;
import org . junit . Test ;
import com . lgposse . cards . models . CardGame ;
import com . lgposse . game . models . Player ;
public class CardGameTest {
CardGame game ;
Player u1 ;
Player u2 ;
Player u3 ;
Player u4 ;
@Test
public void test ( ) {
game = new CardGame ( " ) ;
u1 = new Player ( " ) ;
u2 = new Player ( " ) ;
u3 = new Player ( " ) ;
u4 = new Player ( " ) ;
game . addPlayer ( u1 ) ;
game . addPlayer ( u2 ) ;
randomExampleCardGameTest ( ) ;
}
private void randomExampleCardGameTest ( ) {
CardGame g = CardGameTest . exampleCardGame ( " ) ;
System . out . println ( g ) ;
}
public void <unk> ( ) {
try {
ObjectOutputStream oos = new ObjectOutputStream ( System . out ) ;
oos . writeObject ( game ) ;
} catch ( IOException e ) {
e . printStackTrace ( ) ;
}
}
public void <unk> ( ) {
game . addPlayer ( u3 ) ;
game . addPlayer ( u4 ) ;
game . addPlayer ( new Player ( " ) ) ;
pgc ( ) ;
}
public void <unk> ( ) {
game . startGame ( ) ;
game . playCard ( u1 , game . hands . get ( u1 ) . cards . get ( <num> ) . id ) ;
game . playCard ( u1 , game . hands . get ( u1 ) . cards . get ( <num> ) . id ) ;
game . playCard ( u2 , game . hands . get ( u2 ) . cards . get ( <num> ) . id ) ;
game . playCard ( u1 , game . hands . get ( u2 ) . cards . get ( <num> ) . id ) ;
pg ( ) ;
}
public void <unk> ( ) {
game . addPlayer ( u3 ) ;
game . addPlayer ( u4 ) ;
game . startGame ( ) ;
for ( int i = <num> ; i < <num> ; i ++ ) {
game . endTurn ( ) ;
System . out . println ( game . turn ) ;
}
game . endGame ( ) ;
pgc ( ) ;
}
public void <unk> ( ) {
game . startGame ( ) ;
game . playCard ( u1 , game . hands . get ( u1 ) . cards . get ( <num> ) . id ) ;
Player u = game . scoreHand ( ) ;
System . out . println ( u ) ;
game . playCard ( u2 , game . hands . get ( u2 ) . cards . get ( <num> ) . id ) ;
pgc ( ) ;
u = game . scoreHand ( ) ;
pgc ( ) ;
System . out . println ( u ) ;
}
public void pg ( ) {
System . out . println ( game ) ;
}
public void pgc ( ) {
System . out . println ( " + game . hands . toString ( ) + "
+ " + Integer . toString ( game . turn ) + "
+ " + game . playfield . toString ( ) ) ;
}
public static CardGame exampleCardGame ( ) {
CardGame g = new CardGame ( " ) ;
Player su1 = new Player ( " ) ;
Player su2 = new Player ( " ) ;
Player su3 = new Player ( " ) ;
Player su4 = new Player ( " ) ;
g . addPlayer ( su1 ) ;
g . addPlayer ( su2 ) ;
g . addPlayer ( su3 ) ;
g . addPlayer ( su4 ) ;
g . startGame ( ) ;
g . playCard ( su1 , g . hands . get ( su1 ) . cards . get ( <num> ) . id ) ;
g . playCard ( su2 , g . hands . get ( su2 ) . cards . get ( <num> ) . id ) ;
g . playCard ( su3 , g . hands . get ( su3 ) . cards . get ( <num> ) . id ) ;
g . playCard ( su4 , g . hands . get ( su4 ) . cards . get ( <num> ) . id ) ;
return g ;
}
public static CardGame exampleCardGame ( String name ) {
Random r = new Random ( ) ;
int players = r . nextInt ( <num> ) + <num> ;
CardGame game = new CardGame ( name ) ;
for ( int i = <num> ; i < players ; i ++ ) {
Player p = new Player ( " + Integer . toString ( i ) ) ;
game . addPlayer ( p ) ;
}
game . startGame ( ) ;
boolean stop = false ;
for ( Player p : game . players ) {
stop = r . nextBoolean ( ) ;
if ( stop != true ) {
game . playCard ( p , game . hands . get ( p ) . cards . get ( <num> ) . id ) ;
} else break ;
}
return game ;
}
}
package com . lgposse . jumper . controllers ;
import java . awt . Color ;
import java . awt . event . MouseEvent ;
import java . awt . event . MouseListener ;
import com . lgposse . jumper . app . JumperGameApp ;
import com . lgposse . jumper . views . BoardView ;
import com . lgposse . jumper . views . PegView ;
public class BoardControl extends BoardView implements MouseListener {
protected JumperGameApp app ;
protected PegView selectedPeg ;
public BoardControl ( JumperGameApp app ) {
super ( app . game . board ) ;
this . app = app ;
for ( PegView [ ] row : this . pegViews ) {
for ( PegView p : row ) {
p . addMouseListener ( this ) ;
}
}
}
@Override
public void mouseClicked ( MouseEvent e ) {
PegView clickedPeg = ( PegView ) e . getSource ( ) ;
if ( app . game . isTurn ( app . player ) ) {
if ( selectedPeg == null ) {
if ( app . game . isPiece ( app . player , clickedPeg . peg ) ) {
selectedPeg = clickedPeg ;
selectedPeg . setFillColor ( Color . GREEN ) ;
}
} else {
PegView destinationPeg = clickedPeg ;
this . app . game . board . jump ( selectedPeg . peg , destinationPeg . peg ) ;
selectedPeg = null ;
this . update ( ) ;
}
}
}
@Override
public void mouseEntered ( MouseEvent e ) {
}
@Override
public void mouseExited ( MouseEvent e ) {
}
@Override
public void mousePressed ( MouseEvent e ) {
}
@Override
public void mouseReleased ( MouseEvent e ) {
}
package com . lgposse . jumper . controllers ;
import com . lgposse . jumper . app . JumperGameApp ;
import com . lgposse . jumper . views . JumperGameView ;
public class JumperGameControl extends JumperGameView {
private static final long serialVersionUID =  <num> ;
protected JumperGameApp app ;
public JumperGameControl ( JumperGameApp jumperGameApp ) {
super ( jumperGameApp . game ) ;
this . app = jumperGameApp ;
this . setName ( " ) ;
this . initComponents ( ) ;
}
@Override
public void initComponents ( ) {
this . boardView = new BoardControl ( this . app ) ;
this . add ( boardView , <num> , <num> ) ;
}
}
package com . imjake9 . server . lib ;
import com . imjake9 . server . lib . Messaging . MessageLevel ;
public interface MessageTemplate {
String getMessage ( ) ;
MessageLevel getLevel ( ) ;
}
package com . imjake9 . server . lib ;
import java . util . ArrayList ;
import java . util . List ;
import java . util . logging . Logger ;
import org . bukkit . Bukkit ;
import org . bukkit . ChatColor ;
import org . bukkit . command . CommandSender ;
import org . bukkit . entity . Player ;
public class Messaging {
private static final Logger log = Logger . getLogger ( " ) ;
public static void info ( String message ) {
log . info ( " + message ) ;
}
public static void info ( MessageTemplate message , String . . . args ) {
info ( fillArgs ( message , args ) ) ;
}
public static void warning ( String message ) {
log . warning ( " + message ) ;
}
public static void warning ( MessageTemplate message , String . . . args ) {
warning ( fillArgs ( message , args ) ) ;
}
public static void severe ( String message ) {
log . severe ( " + message ) ;
}
public static void severe ( MessageTemplate message , String . . . args ) {
severe ( fillArgs ( message , args ) ) ;
}
public static void send ( MessageTemplate message , CommandSender sender , String . . . args ) {
sender . sendMessage ( fillArgs ( message , args ) ) ;
}
public static void broadcast ( MessageTemplate message , String . . . args ) {
Bukkit . broadcastMessage ( fillArgs ( message , args ) ) ;
}
public static void <unk> ( MessageTemplate message , Player sender , String . . . args ) {
sender . chat ( fillArgs ( message , args ) ) ;
}
public static String parseStyling ( String message ) {
List < ChatColor > styles = new ArrayList < ChatColor > ( ) ;
while ( message . contains ( " ) && message . contains ( " ) ) {
String tag = message . substring ( message . indexOf ( " ) + <num> , message . indexOf ( " ) ) ;
boolean closing = false ;
if ( tag . charAt ( <num> ) == /' ) {
closing = true ;
tag = tag . substring ( <num> ) ;
}
ChatColor style = null ;
boolean reset = true ;
if ( tag . equalsIgnoreCase ( " ) ) {
style = ChatColor . BOLD ;
} else if ( tag . equalsIgnoreCase ( " ) ) {
style = ChatColor . ITALIC ;
} else if ( tag . equalsIgnoreCase ( " ) ) {
style = ChatColor . UNDERLINE ;
} else if ( ChatColor . valueOf ( tag . toUpperCase ( ) ) != null ) {
reset = false ;
style = ChatColor . valueOf ( tag . toUpperCase ( ) ) ;
}
if ( style != null ) {
if ( ! closing ) {
styles . add ( style ) ;
message = message . substring ( <num> , message . indexOf ( " ) ) + style + message . substring ( message . indexOf ( " ) + <num> ) ;
} else if ( styles . contains ( style ) ) {
if ( reset ) {
styles . remove ( styles . lastIndexOf ( style ) ) ;
String newStyles = ChatColor . RESET . toString ( ) ;
for ( ChatColor cc : styles ) {
newStyles += cc ;
}
message = message . substring ( <num> , message . indexOf ( " ) ) + newStyles + message . substring ( message . indexOf ( " ) + <num> ) ;
} else {
int chopIndex = <num> ;
for ( int i = styles . size ( )  <num> ; i >= <num> ; i  ) {
ChatColor cc = styles . get ( i ) ;
if ( ! cc . equals ( ChatColor . BOLD ) && ! cc . equals ( ChatColor . ITALIC ) && ! cc . equals ( ChatColor . UNDERLINE ) && ! cc . equals ( ChatColor . STRIKETHROUGH ) ) {
chopIndex = i ;
break ;
}
}
String newStyles = ChatColor . WHITE . toString ( ) ;
while ( styles . size ( ) > chopIndex ) {
if ( styles . size ( )  chopIndex > <num> ) {
newStyles += styles . get ( chopIndex ) ;
}
styles . remove ( chopIndex ) ;
}
message = message . substring ( <num> , message . indexOf ( " ) ) + newStyles + message . substring ( message . indexOf ( " ) + <num> ) ;
}
}
}
}
return message ;
}
public static String fillArgs ( String format , String . . . args ) {
String message = format ;
for ( int i = <num> ; message . indexOf ( " + i ) > <num> ; i ++ ) {
message = message . replaceAll ( " + i , args [ i  <num> ] ) ;
}
return message ;
}
public static String fillArgs ( MessageTemplate format , String . . . args ) {
return fillArgs ( format . getMessage ( ) , args ) ;
}
public static enum JSMessage implements MessageTemplate {
<unk> ( MessageLevel . ERROR , " ) ,
<unk> ( MessageLevel . ERROR , " ) ,
<unk> ( MessageLevel . ERROR , " ) ,
<unk> ( MessageLevel . ERROR , " ) ,
<unk> ( MessageLevel . ERROR , " ) ,
<unk> ( MessageLevel . ERROR , " ) ,
<unk> ( MessageLevel . ERROR , " ) ;
private MessageLevel level ;
private String format ;
JSMessage ( MessageLevel level , String format ) {
this . level = level ;
this . format = parseStyling ( level . getOpeningTag ( ) + format + level . getClosingTag ( ) ) ;
}
JSMessage ( String format ) {
this ( MessageLevel . NORMAL , format ) ;
}
@Override
public String getMessage ( ) {
return this . format ;
}
@Override
public MessageLevel getLevel ( ) {
return this . level ;
}
}
public static enum MessageLevel {
NORMAL ( ChatColor . AQUA ) ,
ERROR ( ChatColor . RED ) ,
SUCCESS ( ChatColor . GREEN ) ,
PLAIN ( ChatColor . WHITE ) ,
PRIVATE ( ChatColor . GRAY ) ,
INIT ( ChatColor . DARK_GREEN ) ,
COMPLETE ( ChatColor . DARK_AQUA ) ;
private ChatColor prefix ;
MessageLevel ( ChatColor prefix ) {
this . prefix = prefix ;
}
public ChatColor getPrefix ( ) {
return this . prefix ;
}
public String getOpeningTag ( ) {
return " + getPrefix ( ) . name ( ) . toLowerCase ( ) + " ;
}
public String getClosingTag ( ) {
return " + getPrefix ( ) . name ( ) . toLowerCase ( ) + " ;
}
}
}
package com . imjake9 . server . lib ;
import net . milkbowl . vault . economy . Economy ;
import org . bukkit . Bukkit ;
import org . bukkit . plugin . Plugin ;
import org . bukkit . plugin . RegisteredServiceProvider ;
public class EconomyManager {
private static boolean usingEconomy = false ;
private static Economy economy = null ;
public static void setupEconomy ( ) {
Plugin vault = Bukkit . getServer ( ) . getPluginManager ( ) . getPlugin ( " ) ;
if ( vault == null ) return ;
RegisteredServiceProvider < Economy > rsp = Bukkit . getServer ( ) . getServicesManager ( ) . getRegistration ( Economy . class ) ;
if ( rsp == null ) return ;
economy = rsp . getProvider ( ) ;
usingEconomy = true ;
}
public static boolean <unk> ( ) {
return usingEconomy ;
}
public static Economy getEconomy ( ) {
return economy ;
}
}
package com . imjake9 . server . lib . plugin ;
import com . imjake9 . server . lib . MessageTemplate ;
import com . imjake9 . server . lib . Messaging ;
import java . util . logging . Logger ;
import org . bukkit . plugin . Plugin ;
public class Messager {
private static final Logger log = Logger . getLogger ( " ) ;
private final Plugin plugin ;
public Messager ( Plugin plugin ) {
this . plugin = plugin ;
}
public void info ( String message ) {
log . info ( " + plugin . getDescription ( ) . getName ( ) + " + message ) ;
}
public void info ( MessageTemplate template , String . . . args ) {
info ( Messaging . fillArgs ( template , args ) ) ;
}
public void warning ( String message ) {
log . warning ( " + plugin . getDescription ( ) . getName ( ) + " + message ) ;
}
public void warning ( MessageTemplate template , String . . . args ) {
warning ( Messaging . fillArgs ( template , args ) ) ;
}
public void severe ( String message ) {
log . severe ( " + plugin . getDescription ( ) . getName ( ) + " + message ) ;
}
public void severe ( MessageTemplate template , String . . . args ) {
severe ( Messaging . fillArgs ( template , args ) ) ;
}
}
package com . imjake9 . server . lib . plugin ;
import org . bukkit . plugin . java . JavaPlugin ;
public abstract class <unk> extends JavaPlugin {
protected Messager messager ;
protected PermissionsManager permissionsManager ;
@Override
public final void onEnable ( ) {
messager = new Messager ( this ) ;
permissionsManager = new PermissionsManager ( this ) ;
onJSEnable ( ) ;
}
@Override
public final void onDisable ( ) {
onJSDisable ( ) ;
}
public Messager <unk> ( ) {
return messager ;
}
public PermissionsManager <unk> ( ) {
return permissionsManager ;
}
public void onJSEnable ( ) { } ;
public void onJSDisable ( ) { } ;
}
package com . imjake9 . server . lib ;
import org . bukkit . plugin . java . JavaPlugin ;
public class Main extends JavaPlugin {
@Override
public void onEnable ( ) {
EconomyManager . setupEconomy ( ) ;
}
}
package com . imjake9 . server . lib . plugin ;
import org . bukkit . command . CommandSender ;
import org . bukkit . entity . Player ;
import org . bukkit . plugin . Plugin ;
public class PermissionsManager {
private final Plugin plugin ;
public PermissionsManager ( Plugin plugin ) {
this . plugin = plugin ;
}
public String getPermission ( String node ) {
return plugin . getDescription ( ) . getName ( ) . toLowerCase ( ) + " + node ;
}
public boolean hasPermission ( CommandSender sender , String node ) {
if ( ! ( sender instanceof Player ) )
return true ;
return sender . hasPermission ( getPermission ( node ) ) ;
}
}
package GeneticAlgorithms ;
import java . util . Arrays ;
import java . util . Comparator ;
public class GeneticAlgorithmDriver < T extends GeneticSolution >
{
private T [ ] population ;
private int eliteCount ;
private double mutationRate , crossoverRate , elitePercentage ;
public GeneticAlgorithmDriver ( T [ ] population )
{
this . population = population ;
mutationRate = <num> ;
crossoverRate = <num> ;
elitePercentage = <num> ;
eliteCount = ( int ) ( elitePercentage * population . length ) ;
rankPopulation ( ) ;
}
public GeneticAlgorithmDriver ( T [ ] population , double mutationRate , double crossoverRate , double elitePercentage )
{
this . population = population ;
this . mutationRate = mutationRate ;
this . crossoverRate = crossoverRate ;
this . elitePercentage = elitePercentage ;
eliteCount = ( int ) ( elitePercentage * population . length ) ;
rankPopulation ( ) ;
}
public T [ ] population ( )
{
return population ;
}
public void nextGeneration ( )
{
fillGeneration ( ) ;
rankPopulation ( ) ;
}
public void <unk> ( int generations )
{
for ( int i = <num> ; i < generations ; i ++ )
nextGeneration ( ) ;
}
private void fillGeneration ( )
{
for ( int i = eliteCount ; i < population . length ; i ++ )
{
if ( Math . random ( ) < crossoverRate )
population [ i ] = ( T ) population [ ( int ) ( Math . random ( ) * eliteCount ) ] . crossover ( ( T ) population [ ( int ) ( Math . random ( ) * eliteCount ) ] ) ;
else
population [ i ] = ( T ) population [ ( int ) ( Math . random ( ) * eliteCount ) ] . copy ( ) ;
if ( Math . random ( ) < mutationRate )
population [ i ] . mutate ( ) ;
}
}
private void rankPopulation ( )
{
Arrays . sort ( population , new SolutionCompare ( ) ) ;
}
private class SolutionCompare implements Comparator < GeneticSolution >
{
@Override
public int compare ( GeneticSolution t , GeneticSolution t1 )
{
return t1 . evaluate ( )  t . evaluate ( ) ;
}
}
}
package GeneticAlgorithms ;
public interface GeneticSolution
{
public GeneticSolution crossover ( GeneticSolution <unk> ) ;
public GeneticSolution copy ( ) ;
public void mutate ( ) ;
public int evaluate ( ) ;
}
package org . wintrisstech . erik . iaroc ;
import android . os . SystemClock ;
import ioio . lib . api . IOIO ;
import ioio . lib . api . exception . ConnectionLostException ;
import java . util . Random ;
import org . wintrisstech . irobot . ioio . IRobotCreateAdapter ;
import org . wintrisstech . irobot . ioio . IRobotCreateInterface ;
public class Lada extends IRobotCreateAdapter
{
private static final String TAG = " ;
private final Dashboard dashboard ;
private int speed = <num> ;
private static enum State
{
STRAIGHT_FORWARD ,
LEFT_BACKWARD ,
RIGHT_BACKWARD ,
STRAIGHT_BACKWARD
}
private static enum Event
{
BACKUP_DONE ,
RIGHT_BUMP ,
LEFT_BUMP ,
FRONT_BUMP ,
}
private State presentState ;
private int heading = <num> ;
private static final int howFarToGoBackWhenBumped = <num> ;
private int howFarBacked = <num> ;
private boolean backingUp = false ;
private Random rand = new Random ( ) ;
public Lada ( IOIO ioio , IRobotCreateInterface create , Dashboard dashboard ) throws ConnectionLostException
{
super ( create ) ;
this . dashboard = dashboard ;
song ( <num> , new int [ ]
{
<unk> , <num>
} ) ;
}
public void initialize ( ) throws ConnectionLostException
{
dashboard . log ( " ) ;
heading = <num> ;
backingUp = false ;
presentState = State . STRAIGHT_FORWARD ;
readSensors ( SENSORS_GROUP_ID6 ) ;
driveDirect ( speed , speed ) ;
}
public void loop ( ) throws ConnectionLostException
{
SystemClock . sleep ( <num> ) ;
readSensors ( SENSORS_GROUP_ID6 ) ;
heading += getAngle ( ) ;
if ( isBumpLeft ( ) && isBumpRight ( ) )
{
dashboard . log ( " ) ;
fireEvent ( Event . FRONT_BUMP ) ;
} else if ( isBumpLeft ( ) )
{
dashboard . log ( " ) ;
fireEvent ( Event . LEFT_BUMP ) ;
} else if ( isBumpRight ( ) )
{
dashboard . log ( " ) ;
fireEvent ( Event . RIGHT_BUMP ) ;
} else if ( backingUp )
{
howFarBacked -= getDistance ( ) ;
if ( howFarBacked > howFarToGoBackWhenBumped )
{
dashboard . log ( " ) ;
fireEvent ( Event . BACKUP_DONE ) ;
}
}
}
private void fireEvent ( Event event ) throws ConnectionLostException
{
presentState = nextState ( presentState , event ) ;
switch ( presentState )
{
case STRAIGHT_FORWARD :
dashboard . log ( " ) ;
dashboard . speak ( " ) ;
dashboard . log ( " + heading ) ;
backingUp = false ;
driveDirect ( speed , speed ) ;
break ;
case LEFT_BACKWARD :
dashboard . log ( " ) ;
dashboard . speak ( " ) ;
backingUp = true ;
howFarBacked = <num> ;
driveDirect (  speed ,  speed / <num> ) ;
break ;
case RIGHT_BACKWARD :
dashboard . log ( " ) ;
dashboard . speak ( " ) ;
backingUp = true ;
howFarBacked = <num> ;
driveDirect (  speed / <num> ,  speed ) ;
break ;
case STRAIGHT_BACKWARD :
dashboard . log ( " ) ;
backingUp = true ;
howFarBacked = <num> ;
if ( rand . nextBoolean ( ) )
{
dashboard . speak ( " ) ;
driveDirect (  speed / <num> ,  speed ) ;
} else
{
dashboard . speak ( " ) ;
driveDirect (  speed ,  speed / <num> ) ;
}
break ;
default :
dashboard . log ( " ) ;
}
}
private State nextState ( State state , Event event )
{
switch ( state )
{
case STRAIGHT_FORWARD :
switch ( event )
{
case BACKUP_DONE :
dashboard . log ( " ) ;
return state ;
case FRONT_BUMP :
return State . STRAIGHT_BACKWARD ;
case LEFT_BUMP :
return State . RIGHT_BACKWARD ;
case RIGHT_BUMP :
return State . LEFT_BACKWARD ;
}
case LEFT_BACKWARD :
switch ( event )
{
case BACKUP_DONE :
return State . STRAIGHT_FORWARD ;
case FRONT_BUMP :
return State . STRAIGHT_BACKWARD ;
case LEFT_BUMP :
return State . RIGHT_BACKWARD ;
case RIGHT_BUMP :
return State . LEFT_BACKWARD ;
}
case RIGHT_BACKWARD :
switch ( event )
{
case BACKUP_DONE :
return State . STRAIGHT_FORWARD ;
case FRONT_BUMP :
return State . STRAIGHT_BACKWARD ;
case LEFT_BUMP :
return State . RIGHT_BACKWARD ;
case RIGHT_BUMP :
return State . LEFT_BACKWARD ;
}
case STRAIGHT_BACKWARD :
switch ( event )
{
case BACKUP_DONE :
return State . STRAIGHT_FORWARD ;
case FRONT_BUMP :
return State . STRAIGHT_BACKWARD ;
case LEFT_BUMP :
return State . RIGHT_BACKWARD ;
case RIGHT_BUMP :
return State . LEFT_BACKWARD ;
}
default :
dashboard . log ( " ) ;
return state ;
}
}
public void stop ( ) throws ConnectionLostException
{
driveDirect ( <num> , <num> ) ;
}
}
package org . wintrisstech . erik . iaroc ;
import android . content . Context ;
import android . text . Editable ;
import android . text . method . MovementMethod ;
import android . text . method . ScrollingMovementMethod ;
import android . util . AttributeSet ;
import android . widget . TextView ;
public class LogTextView extends TextView {
public LogTextView ( Context context ) {
this ( context , null ) ;
}
public LogTextView ( Context context , AttributeSet attrs ) {
this ( context , attrs , android . R . attr . textViewStyle ) ;
}
public LogTextView ( Context context , AttributeSet attrs , int defStyle ) {
super ( context , attrs , defStyle ) ;
}
@Override
protected MovementMethod getDefaultMovementMethod ( ) {
return ScrollingMovementMethod . getInstance ( ) ;
}
@Override
public Editable getText ( ) {
return ( Editable ) super . getText ( ) ;
}
@Override
public void setText ( CharSequence text , BufferType type ) {
super . setText ( text , BufferType . EDITABLE ) ;
}
}
package org . wintrisstech . erik . iaroc ;
import android . content . Intent ;
import android . content . pm . ActivityInfo ;
import android . os . Bundle ;
import android . speech . tts . TextToSpeech ;
import ioio . lib . api . IOIO ;
import ioio . lib . api . exception . ConnectionLostException ;
import ioio . lib . util . IOIOLooper ;
import ioio . lib . util . android . IOIOActivity ;
import java . util . Locale ;
import org . wintrisstech . irobot . ioio . IRobotCreateInterface ;
import org . wintrisstech . irobot . ioio . SimpleIRobotCreate ;
public class Dashboard extends IOIOActivity implements TextToSpeech . OnInitListener
{
private static final String TAG = " ;
private LogTextView mText ;
private Lada kalina ;
protected static final int MY_DATA_CHECK_CODE = <num> ;
private TextToSpeech mTts ;
@Override
public void onCreate ( Bundle savedInstanceState )
{
super . onCreate ( savedInstanceState ) ;
this . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ;
setContentView ( R . layout . main ) ;
Intent checkIntent = new Intent ( ) ;
checkIntent . setAction ( TextToSpeech . Engine . ACTION_CHECK_TTS_DATA ) ;
startActivityForResult ( checkIntent , MY_DATA_CHECK_CODE ) ;
mText = ( LogTextView ) findViewById ( R . id . text ) ;
log ( getString ( R . string . wait_ioio ) ) ;
}
@Override
public void onPause ( )
{
if ( kalina != null )
{
log ( " ) ;
try
{
kalina . stop ( ) ;
} catch ( ConnectionLostException ex )
{
}
}
super . onPause ( ) ;
}
@Override
protected void onActivityResult ( int requestCode , int resultCode , Intent data )
{
if ( requestCode == MY_DATA_CHECK_CODE )
{
if ( resultCode == TextToSpeech . Engine . CHECK_VOICE_DATA_PASS )
{
mTts = new TextToSpeech ( this , this ) ;
} else
{
Intent installIntent = new Intent ( ) ;
installIntent . setAction ( TextToSpeech . Engine . ACTION_INSTALL_TTS_DATA ) ;
startActivity ( installIntent ) ;
}
}
}
public void onInit ( int arg0 )
{
}
public void speak ( String stuffToSay )
{
mTts . setLanguage ( Locale . US ) ;
if ( ! mTts . isSpeaking ( ) )
{
mTts . speak ( stuffToSay , TextToSpeech . QUEUE_FLUSH , null ) ;
}
}
@Override
public IOIOLooper createIOIOLooper ( )
{
return new IOIOLooper ( )
{
public void setup ( IOIO ioio ) throws ConnectionLostException , InterruptedException
{
log ( getString ( R . string . ioio_connected ) ) ;
log ( getString ( R . string . wait_create ) ) ;
IRobotCreateInterface iRobotCreate = new SimpleIRobotCreate ( ioio ) ;
log ( getString ( R . string . create_connected ) ) ;
kalina = new Lada ( ioio , iRobotCreate , Dashboard . this ) ;
kalina . initialize ( ) ;
}
public void loop ( ) throws ConnectionLostException , InterruptedException
{
kalina . loop ( ) ;
}
public void disconnected ( )
{
log ( getString ( R . string . ioio_disconnected ) ) ;
}
public void incompatible ( )
{
}
} ;
}
public void log ( final String msg )
{
runOnUiThread ( new Runnable ( )
{
public void run ( )
{
mText . append ( msg ) ;
mText . append ( " ) ;
}
} ) ;
}
}
package org . wintrisstech . sensors ;
import android . os . SystemClock ;
import ioio . lib . api . DigitalOutput ;
import ioio . lib . api . IOIO ;
import ioio . lib . api . PulseInput ;
import ioio . lib . api . PulseInput . PulseMode ;
import ioio . lib . api . exception . ConnectionLostException ;
import java . util . logging . Level ;
import java . util . logging . Logger ;
import org . wintrisstech . erik . iaroc . Dashboard ;
public class UltraSonicSensors
{
private static final int LEFT_ULTRASONIC_INPUT_PIN = <num> ;
private static final int FRONT_ULTRASONIC_INPUT_PIN = <num> ;
private static final int RIGHT_ULTRASONIC_INPUT_PIN = <num> ;
private static final int STROBE_ULTRASONIC_OUTPUT_PIN = <num> ;
private DigitalOutput strobe ;
private int leftDistance ;
private int frontDistance ;
private int rightDistance ;
private Dashboard dashboard ;
private IOIO ioio ;
float f ;
float r ;
float l ;
public UltraSonicSensors ( IOIO ioio ) throws ConnectionLostException
{
this . ioio = ioio ;
strobe = ioio . openDigitalOutput ( STROBE_ULTRASONIC_OUTPUT_PIN , false ) ;
}
public void readUltrasonicSensors ( )
{
try
{
strobe . write ( true ) ;
long end = System . nanoTime ( ) + <num> ;
while ( System . nanoTime ( ) < end )
{
}
strobe . write ( false ) ;
SystemClock . sleep ( <num> ) ;
dashboard . log ( " + ( int ) ( r * <num> ) + " + ( int ) ( f * <num> ) + " + ( int ) ( l * <num> ) ) ;
}
catch ( ConnectionLostException ex )
{
dashboard . log ( " ) ;
}
}
public void testStrobe ( ) throws ConnectionLostException
{
long end = System . nanoTime ( ) + <num> ;
dashboard . log ( " ) ;
strobe = ioio . openDigitalOutput ( STROBE_ULTRASONIC_OUTPUT_PIN , false ) ;
strobe . write ( true ) ;
dashboard . log ( " ) ;
while ( System . nanoTime ( ) < end )
{
}
dashboard . log ( " ) ;
strobe . write ( false ) ;
strobe . close ( ) ;
dashboard . log ( " ) ;
SystemClock . sleep ( <num> ) ;
dashboard . log ( " ) ;
}
public void <unk> ( Dashboard dashboard )
{
this . dashboard = dashboard ;
}
}
package com . attask . jenkins ;
import hudson . Extension ;
import hudson . Launcher ;
import hudson . model . AbstractBuild ;
import hudson . model . AbstractProject ;
import hudson . model . BuildListener ;
import hudson . tasks . BuildStepDescriptor ;
import hudson . tasks . BuildStepMonitor ;
import hudson . tasks . Publisher ;
import hudson . tasks . Recorder ;
import org . kohsuke . stapler . DataBoundConstructor ;
import java . io . File ;
import java . io . IOException ;
import java . util . Arrays ;
import java . util . Collection ;
public class TestResultRecorder extends Recorder {
private String filePattern ;
@DataBoundConstructor
public TestResultRecorder ( String filePattern ) {
this . filePattern = filePattern ;
}
@Override
public boolean perform ( AbstractBuild < ? , ? > build , Launcher launcher , BuildListener listener ) throws InterruptedException , IOException {
TestResultParser parser = new TestResultParser ( build . <unk> ( ) ) ;
Collection < TestResult > testResults = parser . parseResults ( Arrays . asList ( new File ( filePattern ) ) ) ;
build . addAction ( new TestResultAction ( testResults , build ) ) ;
return true ;
}
public BuildStepMonitor getRequiredMonitorService ( ) {
return BuildStepMonitor . NONE ;
}
public String <unk> ( ) {
return filePattern ;
}
public void <unk> ( String filePattern ) {
this . filePattern = filePattern ;
}
@Extension
public static class <unk> extends BuildStepDescriptor < Publisher > {
@Override
public boolean isApplicable ( Class < ? extends AbstractProject > jobType ) {
return true ;
}
@Override
public String getDisplayName ( ) {
return " ;
}
}
}
package com . attask . jenkins ;
public class TestResult {
private final String packageName ;
private final String className ;
private final String methodName ;
private final String threadName ;
private final String exception ;
private final String time ;
public TestResult ( String fullTestName , String threadName , String time ) {
this ( fullTestName , threadName , time , null ) ;
}
public TestResult ( String fullTestName , String threadName , String time , String exception ) {
int lastDot = fullTestName . lastIndexOf ( " ) ;
this . packageName = fullTestName . substring ( <num> , lastDot ) ;
String [ ] secondPart = fullTestName . substring ( lastDot + <num> ) . split ( " ) ;
this . className = secondPart [ <num> ] ;
this . methodName = secondPart [ <num> ] ;
this . threadName = threadName ;
this . exception = exception ;
this . time = time ;
}
public String getPackageName ( ) {
return packageName ;
}
public String getClassName ( ) {
return className ;
}
public String getMethodName ( ) {
return methodName ;
}
public String getThreadName ( ) {
return threadName ;
}
public String getException ( ) {
return exception ;
}
public boolean <unk> ( ) {
return exception != null ;
}
public boolean <unk> ( ) {
return " . equals ( time ) ;
}
@Override
public String toString ( ) {
return packageName + " + className + " + methodName ;
}
public String getTime ( ) {
return time ;
}
}
package com . attask . jenkins ;
import com . google . common . collect . ArrayListMultimap ;
import com . google . common . collect . Multimap ;
import hudson . model . AbstractBuild ;
import hudson . model . Action ;
import org . kohsuke . stapler . StaplerRequest ;
import org . kohsuke . stapler . StaplerResponse ;
import org . springframework . web . util . <unk> ;
import java . io . IOException ;
import java . io . PrintStream ;
import java . io . UnsupportedEncodingException ;
import java . io . Writer ;
import java . net . URLEncoder ;
import java . util . * ;
public class TestResultAction implements Action {
private Multimap < String , TestResult > testResults ;
private final AbstractBuild < ? , ? > build ;
public TestResultAction ( Collection < TestResult > testResults , AbstractBuild < ? , ? > build ) {
this . build = build ;
this . testResults = ArrayListMultimap . create ( ) ;
for ( TestResult testResult : testResults ) {
this . testResults . put ( testResult . getThreadName ( ) , testResult ) ;
}
}
public Multimap < String , TestResult > getTestResults ( ) {
return testResults ;
}
public void <unk> ( StaplerRequest request , StaplerResponse response ) throws IOException {
String id = request . getParameter ( " ) ;
response . setContentType ( " ) ;
Writer stream = response . <unk> ( request ) ;
stream . write ( " ) ;
for ( TestResult testResult : testResults . get ( id ) ) {
stream . write ( " + testResult . toString ( ) + " ) ;
if ( testResult . getException ( ) != null ) {
stream . write ( testResult . getException ( ) ) ;
} else {
stream . write ( " ) ;
}
}
stream . flush ( ) ;
}
public String <unk> ( String thread ) {
StringBuilder sb = new StringBuilder ( ) ;
sb . append ( " ) . append ( " ) ;
for ( TestResult testResult : testResults . get ( thread ) ) {
sb . append ( " ) . append ( testResult . toString ( ) ) . append ( " ) ;
}
try {
return " + URLEncoder . encode ( sb . toString ( ) , " ) . replace ( " , " ) ;
} catch ( UnsupportedEncodingException e ) {
throw new RuntimeException ( e ) ;
}
}
public String getIconFileName ( ) {
return " ;
}
public String getDisplayName ( ) {
return " ;
}
public String getUrlName ( ) {
return " ;
}
public AbstractBuild < ? , ? > getBuild ( ) {
return build ;
}
}
package com . attask . jenkins ;
import java . io . File ;
import java . io . FileNotFoundException ;
import java . util . * ;
public class TestResultParser {
private final File root ;
public TestResultParser ( File root ) {
this . root = root ;
}
public Collection < TestResult > parseResults ( Collection < File > files ) throws FileNotFoundException {
List < TestResult > testResults = new ArrayList < TestResult > ( ) ;
for ( File file : files ) {
testResults . addAll ( getTestResults ( new File ( root , file . getPath ( ) ) ) ) ;
}
return testResults ;
}
public Collection < ? extends TestResult > getTestResults ( File file ) throws FileNotFoundException {
if ( file == null || ! file . exists ( ) || file . isDirectory ( ) ) {
return Collections . emptyList ( ) ;
}
List < TestResult > testResults = new ArrayList < TestResult > ( ) ;
Scanner scanner = new Scanner ( file ) ;
while ( scanner . hasNextLine ( ) ) {
String line = scanner . nextLine ( ) ;
String [ ] parts = line . split ( " ) ;
TestResult result ;
if ( " . equals ( parts [ <num> ] ) || " . equals ( parts [ <num> ] ) ) {
String fullTestName = parts [ <num> ] ;
String threadName = parts [ <num> ] ;
String time = parts [ <num> ] ;
result = new TestResult ( fullTestName , threadName , time ) ;
} else if ( " . equals ( parts [ <num> ] ) ) {
String fullTestName = parts [ <num> ] ;
String threadName = parts [ <num> ] ;
String time = parts [ <num> ] ;
StringBuilder exception = new StringBuilder ( ) ;
while ( ! line . trim ( ) . isEmpty ( ) && scanner . hasNextLine ( ) ) {
line = scanner . nextLine ( ) ;
exception . append ( line ) . append ( " ) ;
}
result = new TestResult ( fullTestName , threadName , time , exception . toString ( ) ) ;
} else {
continue ;
}
testResults . add ( result ) ;
}
return testResults ;
}
}
package com . bugfullabs . thegame . game ;
import java . io . IOException ;
import javax . microedition . khronos . opengles . GL10 ;
import org . anddev . andengine . engine . Engine ;
import org . anddev . andengine . engine . camera . Camera ;
import org . anddev . andengine . engine . handler . timer . ITimerCallback ;
import org . anddev . andengine . engine . handler . timer . TimerHandler ;
import org . anddev . andengine . engine . options . EngineOptions ;
import org . anddev . andengine . engine . options . EngineOptions . ScreenOrientation ;
import org . anddev . andengine . engine . options . resolutionpolicy . FillResolutionPolicy ;
import org . anddev . andengine . entity . IEntity ;
import org . anddev . andengine . entity . modifier . AlphaModifier ;
import org . anddev . andengine . entity . modifier . IEntityModifier . IEntityModifierListener ;
import org . anddev . andengine . entity . modifier . MoveModifier ;
import org . anddev . andengine . entity . modifier . ScaleModifier ;
import org . anddev . andengine . entity . modifier . SequenceEntityModifier ;
import org . anddev . andengine . entity . scene . Scene ;
import org . anddev . andengine . entity . scene . Scene . IOnSceneTouchListener ;
import org . anddev . andengine . entity . scene . menu . MenuScene ;
import org . anddev . andengine . entity . scene . menu . MenuScene . IOnMenuItemClickListener ;
import org . anddev . andengine . entity . scene . menu . item . IMenuItem ;
import org . anddev . andengine . entity . scene . menu . item . SpriteMenuItem ;
import org . anddev . andengine . entity . sprite . Sprite ;
import org . anddev . andengine . entity . text . ChangeableText ;
import org . anddev . andengine . extension . texturepacker . opengl . texture . util . texturepacker . TexturePack ;
import org . anddev . andengine . extension . texturepacker . opengl . texture . util . texturepacker . TexturePackLoader ;
import org . anddev . andengine . extension . texturepacker . opengl . texture . util . texturepacker . exception . TexturePackParseException ;
import org . anddev . andengine . input . touch . TouchEvent ;
import org . anddev . andengine . opengl . font . Font ;
import org . anddev . andengine . opengl . font . StrokeFont ;
import org . anddev . andengine . opengl . texture . TextureOptions ;
import org . anddev . andengine . opengl . texture . atlas . bitmap . BitmapTextureAtlas ;
import org . anddev . andengine . opengl . texture . atlas . bitmap . BitmapTextureAtlasTextureRegionFactory ;
import org . anddev . andengine . opengl . texture . region . TextureRegion ;
import org . anddev . andengine . ui . activity . BaseGameActivity ;
import org . anddev . andengine . util . modifier . IModifier ;
import org . anddev . andengine . util . modifier . ease . EaseCubicOut ;
import org . anddev . andengine . util . modifier . ease . EaseStrongOut ;
import android . content . Intent ;
import android . content . SharedPreferences ;
import android . graphics . Color ;
import android . graphics . Point ;
import android . graphics . Typeface ;
import android . util . FloatMath ;
import android . util . Log ;
import android . view . KeyEvent ;
import android . view . WindowManager ;
import com . bugfullabs . thegame . R ;
import com . bugfullabs . thegame . TheGameActivity ;
import com . bugfullabs . thegame . level . Level ;
import com . bugfullabs . thegame . level . LevelFileReader ;
import com . bugfullabs . thegame . level . LevelSceneFactory ;
import com . bugfullabs . thegame . util . Button ;
import com . bugfullabs . thegame . util . Hint ;
public class GameActivity extends BaseGameActivity implements
IOnSceneTouchListener , IOnMenuItemClickListener {
public static final float CAMERA_WIDTH = <num> , CAMERA_HEIGHT = <num> ;
private Scene gameScene ;
protected MenuScene mPauseScene ;
public static TexturePack levelTexture ;
public TimerHandler updateTimer ;
static Level level ;
private BitmapTextureAtlas mBitmapTextureAtlas ;
private TextureRegion mPausedTextureRegion ;
private TextureRegion mPausedBackgroundTextureRegion ;
private TextureRegion mRestartTextureRegion ;
private TextureRegion mMenuTextureRegion ;
private TextureRegion mResumeTextureRegion ;
private TextureRegion mNextTextureRegion ;
private TextureRegion mPauseButtonTextureRegion ;
private TextureRegion mRestartButtonTextureRegion ;
private TextureRegion mHintBackgroundTextureRegion ;
private StrokeFont mFont ;
private Font mFontText ;
private BitmapTextureAtlas mFontTexture ;
private BitmapTextureAtlas mFontTextTexture ;
private boolean run = false ;
private boolean toggleStop = false ;
private boolean teleporting = false ;
private boolean toggleBlueTeleport = false ;
private boolean togglePurpleTeleport = false ;
private boolean was_running = false ;
private Camera camera ;
private static int lvl_id ;
private static int lvl_pack_id ;
private static int moves ;
private static int stars ;
private ChangeableText mMoves ;
private Sprite pausedSprite ;
private static boolean reset = false ;
private LevelFileReader mLevelFileReader ;
private float time ;
private boolean toggleRestart = false ;
private float touchX , touchY , offX , offY ;
public static final String SCORES_FILE = " ;
public static final String PREFS_NAME = " ;
private final int MENU_RESET = <num> , MENU_MAIN = <num> , MENU_RESUME = <num> ;
@Override
public Engine onLoadEngine ( ) {
camera = new Camera ( <num> , <num> , CAMERA_WIDTH , CAMERA_HEIGHT ) ;
final EngineOptions engineOptions = new EngineOptions ( true ,
ScreenOrientation . LANDSCAPE , new FillResolutionPolicy ( ) , camera ) ;
engineOptions . getTouchOptions ( ) . setRunOnUpdateThread ( true ) ;
getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_KEEP_SCREEN_ON ) ;
return mEngine = new Engine ( engineOptions ) ;
}
@Override
public void onLoadResources ( ) {
try {
levelTexture = new TexturePackLoader ( this , " ) . <unk> ( this , " ) ;
} catch ( TexturePackParseException e ) {
e . printStackTrace ( ) ;
}
this . mBitmapTextureAtlas = new BitmapTextureAtlas ( <num> , <num> , TextureOptions . BILINEAR_PREMULTIPLYALPHA ) ;
BitmapTextureAtlasTextureRegionFactory . setAssetBasePath ( " ) ;
this . mPausedTextureRegion = BitmapTextureAtlasTextureRegionFactory . createFromAsset ( this . mBitmapTextureAtlas , this , " + getString ( R . string . lang ) + " , <num> , <num> ) ;
this . mPausedBackgroundTextureRegion = BitmapTextureAtlasTextureRegionFactory . createFromAsset ( this . mBitmapTextureAtlas , this , " , <num> , <num> + <num> * <num> ) ;
this . mFontTextTexture = new BitmapTextureAtlas ( <num> , <num> , TextureOptions . BILINEAR ) ;
this . mFontText = new Font ( this . mFontTextTexture , Typeface . create ( Typeface . DEFAULT , Typeface . BOLD ) , <num> , true , Color . WHITE ) ;
this . mRestartTextureRegion = BitmapTextureAtlasTextureRegionFactory . createFromAsset ( this . mBitmapTextureAtlas , this , " , <num> , <num> ) ;
this . mMenuTextureRegion = BitmapTextureAtlasTextureRegionFactory . createFromAsset ( this . mBitmapTextureAtlas , this , " , <num> , <num> + <num> ) ;
this . mResumeTextureRegion = BitmapTextureAtlasTextureRegionFactory . createFromAsset ( this . mBitmapTextureAtlas , this , " , <num> , <num> + <num> * <num> ) ;
this . mNextTextureRegion = BitmapTextureAtlasTextureRegionFactory . createFromAsset ( this . mBitmapTextureAtlas , this , " , <num> + <num> , <num> + <num> * <num> ) ;
this . mHintBackgroundTextureRegion = BitmapTextureAtlasTextureRegionFactory
. createFromAsset ( this . mBitmapTextureAtlas , this ,
" , <num> , <num>  <num> ) ;
this . mPauseButtonTextureRegion = BitmapTextureAtlasTextureRegionFactory
. createFromAsset ( this . mBitmapTextureAtlas , this ,
" , <num> , <num> ) ;
this . mRestartButtonTextureRegion = BitmapTextureAtlasTextureRegionFactory
. createFromAsset ( this . mBitmapTextureAtlas , this ,
" , <num> , <num> + <num> ) ;
this . mFontTexture = new BitmapTextureAtlas ( <num> , <num> ,
TextureOptions . BILINEAR_PREMULTIPLYALPHA ) ;
Typeface typeface = Typeface . createFromAsset ( getAssets ( ) ,
" ) ;
mFont = new StrokeFont ( mFontTexture , typeface , <num> , true , Color . WHITE ,
1.36f , Color . BLACK ) ;
this . mEngine . getFontManager ( ) . loadFonts ( mFont , mFontText ) ;
this . mEngine . getTextureManager ( ) . loadTextures ( levelTexture . getTexture ( ) , this . mBitmapTextureAtlas , this . mFontTexture , this . mFontTextTexture ) ;
}
@Override
public Scene onLoadScene ( ) {
SharedPreferences settings = getSharedPreferences ( PREFS_NAME , <num> ) ;
this . createMenuScene ( ) ;
gameScene = new Scene ( ) ;
gameScene = LevelSceneFactory . createScene ( level , levelTexture , ( settings . getInt ( " , <num> ) == <num> ? true : false ) ) ;
lvl_id = level . getLevelId ( ) ;
lvl_pack_id = level . getLevelpackId ( ) ;
if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
else if ( lvl_pack_id == <num> && lvl_id == <num> )
showHint ( gameScene , R . string . <unk> , <num> , <num> ) ;
mMoves = new ChangeableText ( <num> , <num> , this . mFontText , getString ( R . string . moves ) + " + moves , " . length ( ) ) ;
gameScene . attachChild ( mMoves ) ;
if ( settings . getInt ( " , <num> ) == <num> )
time = <num> ;
else
time = <num> ;
updateTimer = new TimerHandler ( time , true , new ITimerCallback ( ) {
@Override
public void onTimePassed ( TimerHandler arg0 ) {
GameActivity . this . onTimerUpdate ( ) ;
}
} ) ;
@SuppressWarnings("unused")
Button pause = new Button ( gameScene , " ,
this . mPauseButtonTextureRegion , this . mFont , <num>  <num>  <num> ,
48 , <num> , <num> , false , <num> ) {
@Override
